/* automatically generated by rust-bindgen 0.58.1 */
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const NGX_HAVE_UNISTD_H: u32 = 1;
pub const NGX_HAVE_INTTYPES_H: u32 = 1;
pub const NGX_HAVE_LIMITS_H: u32 = 1;
pub const NGX_HAVE_SYS_PARAM_H: u32 = 1;
pub const NGX_HAVE_SYS_MOUNT_H: u32 = 1;
pub const NGX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const NGX_HAVE_CRYPT_H: u32 = 1;
pub const NGX_LINUX: u32 = 1;
pub const NGX_HAVE_SYS_PRCTL_H: u32 = 1;
pub const NGX_HAVE_SYS_VFS_H: u32 = 1;
pub const NGX_CONFIGURE: &'static [u8; 26usize] = b" --with-compat --prefix=r\0";
pub const NGX_COMPILER: &'static [u8; 31usize] = b"gcc 12.2.0 (Debian 12.2.0-14) \0";
pub const NGX_HAVE_GCC_ATOMIC: u32 = 1;
pub const NGX_HAVE_C99_VARIADIC_MACROS: u32 = 1;
pub const NGX_HAVE_GCC_VARIADIC_MACROS: u32 = 1;
pub const NGX_HAVE_GCC_BSWAP64: u32 = 1;
pub const NGX_HAVE_EPOLL: u32 = 1;
pub const NGX_HAVE_CLEAR_EVENT: u32 = 1;
pub const NGX_HAVE_EPOLLRDHUP: u32 = 1;
pub const NGX_HAVE_EPOLLEXCLUSIVE: u32 = 1;
pub const NGX_HAVE_O_PATH: u32 = 1;
pub const NGX_HAVE_SENDFILE: u32 = 1;
pub const NGX_HAVE_SENDFILE64: u32 = 1;
pub const NGX_HAVE_PR_SET_DUMPABLE: u32 = 1;
pub const NGX_HAVE_GNU_CRYPT_R: u32 = 1;
pub const NGX_HAVE_NONALIGNED: u32 = 1;
pub const NGX_CPU_CACHE_LINE: u32 = 64;
pub const NGX_HAVE_POSIX_FADVISE: u32 = 1;
pub const NGX_HAVE_O_DIRECT: u32 = 1;
pub const NGX_HAVE_ALIGNED_DIRECTIO: u32 = 1;
pub const NGX_HAVE_STATFS: u32 = 1;
pub const NGX_HAVE_STATVFS: u32 = 1;
pub const NGX_HAVE_DLOPEN: u32 = 1;
pub const NGX_HAVE_SCHED_YIELD: u32 = 1;
pub const NGX_HAVE_SCHED_SETAFFINITY: u32 = 1;
pub const NGX_HAVE_REUSEPORT: u32 = 1;
pub const NGX_HAVE_IP_BIND_ADDRESS_NO_PORT: u32 = 1;
pub const NGX_HAVE_TRANSPARENT_PROXY: u32 = 1;
pub const NGX_HAVE_IP_PKTINFO: u32 = 1;
pub const NGX_HAVE_IPV6_RECVPKTINFO: u32 = 1;
pub const NGX_HAVE_DEFERRED_ACCEPT: u32 = 1;
pub const NGX_HAVE_KEEPALIVE_TUNABLE: u32 = 1;
pub const NGX_HAVE_TCP_FASTOPEN: u32 = 1;
pub const NGX_HAVE_TCP_INFO: u32 = 1;
pub const NGX_HAVE_ACCEPT4: u32 = 1;
pub const NGX_HAVE_EVENTFD: u32 = 1;
pub const NGX_HAVE_SYS_EVENTFD_H: u32 = 1;
pub const NGX_HAVE_UNIX_DOMAIN: u32 = 1;
pub const NGX_PTR_SIZE: u32 = 8;
pub const NGX_SIG_ATOMIC_T_SIZE: u32 = 4;
pub const NGX_HAVE_LITTLE_ENDIAN: u32 = 1;
pub const NGX_MAX_SIZE_T_VALUE: u64 = 9223372036854775807;
pub const NGX_MAX_OFF_T_VALUE: u64 = 9223372036854775807;
pub const NGX_TIME_T_SIZE: u32 = 8;
pub const NGX_MAX_TIME_T_VALUE: u64 = 9223372036854775807;
pub const NGX_HAVE_INET6: u32 = 1;
pub const NGX_HAVE_PREAD: u32 = 1;
pub const NGX_HAVE_PWRITE: u32 = 1;
pub const NGX_HAVE_PWRITEV: u32 = 1;
pub const NGX_SYS_NERR: u32 = 41;
pub const NGX_HAVE_LOCALTIME_R: u32 = 1;
pub const NGX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const NGX_HAVE_MEMALIGN: u32 = 1;
pub const NGX_HAVE_MAP_ANON: u32 = 1;
pub const NGX_HAVE_MAP_DEVZERO: u32 = 1;
pub const NGX_HAVE_SYSVSHM: u32 = 1;
pub const NGX_HAVE_POSIX_SEM: u32 = 1;
pub const NGX_HAVE_MSGHDR_MSG_CONTROL: u32 = 1;
pub const NGX_HAVE_FIONBIO: u32 = 1;
pub const NGX_HAVE_GMTOFF: u32 = 1;
pub const NGX_HAVE_D_TYPE: u32 = 1;
pub const NGX_HAVE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const NGX_HAVE_OPENAT: u32 = 1;
pub const NGX_HAVE_GETADDRINFO: u32 = 1;
pub const NGX_HAVE_SOCKET_CLOEXEC: u32 = 1;
pub const NGX_HAVE_FD_CLOEXEC: u32 = 1;
pub const NGX_HTTP_CACHE: u32 = 1;
pub const NGX_HTTP_GZIP: u32 = 1;
pub const NGX_HTTP_SSI: u32 = 1;
pub const NGX_CRYPT: u32 = 1;
pub const NGX_HTTP_X_FORWARDED_FOR: u32 = 1;
pub const NGX_HTTP_UPSTREAM_ZONE: u32 = 1;
pub const NGX_COMPAT: u32 = 1;
pub const NGX_HTTP_DAV: u32 = 1;
pub const NGX_HTTP_REALIP: u32 = 1;
pub const NGX_HTTP_HEADERS: u32 = 1;
pub const NGX_STREAM_UPSTREAM_ZONE: u32 = 1;
pub const NGX_PCRE: u32 = 1;
pub const NGX_HAVE_PCRE_JIT: u32 = 1;
pub const NGX_ZLIB: u32 = 1;
pub const NGX_PREFIX: &'static [u8; 3usize] = b"r/\0";
pub const NGX_CONF_PREFIX: &'static [u8; 6usize] = b"conf/\0";
pub const NGX_SBIN_PATH: &'static [u8; 11usize] = b"sbin/nginx\0";
pub const NGX_CONF_PATH: &'static [u8; 16usize] = b"conf/nginx.conf\0";
pub const NGX_PID_PATH: &'static [u8; 15usize] = b"logs/nginx.pid\0";
pub const NGX_LOCK_PATH: &'static [u8; 16usize] = b"logs/nginx.lock\0";
pub const NGX_ERROR_LOG_PATH: &'static [u8; 15usize] = b"logs/error.log\0";
pub const NGX_HTTP_LOG_PATH: &'static [u8; 16usize] = b"logs/access.log\0";
pub const NGX_HTTP_CLIENT_TEMP_PATH: &'static [u8; 17usize] = b"client_body_temp\0";
pub const NGX_HTTP_PROXY_TEMP_PATH: &'static [u8; 11usize] = b"proxy_temp\0";
pub const NGX_HTTP_FASTCGI_TEMP_PATH: &'static [u8; 13usize] = b"fastcgi_temp\0";
pub const NGX_HTTP_UWSGI_TEMP_PATH: &'static [u8; 11usize] = b"uwsgi_temp\0";
pub const NGX_HTTP_SCGI_TEMP_PATH: &'static [u8; 10usize] = b"scgi_temp\0";
pub const NGX_SUPPRESS_WARN: u32 = 1;
pub const NGX_SMP: u32 = 1;
pub const NGX_USER: &'static [u8; 7usize] = b"nobody\0";
pub const NGX_GROUP: &'static [u8; 8usize] = b"nogroup\0";
pub const NGX_LISTEN_BACKLOG: u32 = 511;
pub const NGX_HAVE_SO_SNDLOWAT: u32 = 0;
pub const NGX_HAVE_INHERITED_NONBLOCK: u32 = 0;
pub const NGX_HAVE_OS_SPECIFIC_INIT: u32 = 1;
pub const NGX_MAX_INT_T_VALUE: u64 = 9223372036854775807;
pub const NGX_INVALID_ARRAY_INDEX: u32 = 2147483648;
pub const NGX_MAXHOSTNAMELEN: u32 = 256;
pub const NGX_OK: u32 = 0;
pub const NGX_ERROR: i32 = -1;
pub const NGX_AGAIN: i32 = -2;
pub const NGX_BUSY: i32 = -3;
pub const NGX_DONE: i32 = -4;
pub const NGX_DECLINED: i32 = -5;
pub const NGX_ABORT: i32 = -6;
pub const NGX_EPERM: u32 = 1;
pub const NGX_ENOENT: u32 = 2;
pub const NGX_ENOPATH: u32 = 2;
pub const NGX_ESRCH: u32 = 3;
pub const NGX_EINTR: u32 = 4;
pub const NGX_ECHILD: u32 = 10;
pub const NGX_ENOMEM: u32 = 12;
pub const NGX_EACCES: u32 = 13;
pub const NGX_EBUSY: u32 = 16;
pub const NGX_EEXIST: u32 = 17;
pub const NGX_EEXIST_FILE: u32 = 17;
pub const NGX_EXDEV: u32 = 18;
pub const NGX_ENOTDIR: u32 = 20;
pub const NGX_EISDIR: u32 = 21;
pub const NGX_EINVAL: u32 = 22;
pub const NGX_ENFILE: u32 = 23;
pub const NGX_EMFILE: u32 = 24;
pub const NGX_ENOSPC: u32 = 28;
pub const NGX_EPIPE: u32 = 32;
pub const NGX_EINPROGRESS: u32 = 115;
pub const NGX_ENOPROTOOPT: u32 = 92;
pub const NGX_EOPNOTSUPP: u32 = 95;
pub const NGX_EADDRINUSE: u32 = 98;
pub const NGX_ECONNABORTED: u32 = 103;
pub const NGX_ECONNRESET: u32 = 104;
pub const NGX_ENOTCONN: u32 = 107;
pub const NGX_ETIMEDOUT: u32 = 110;
pub const NGX_ECONNREFUSED: u32 = 111;
pub const NGX_ENAMETOOLONG: u32 = 36;
pub const NGX_ENETDOWN: u32 = 100;
pub const NGX_ENETUNREACH: u32 = 101;
pub const NGX_EHOSTDOWN: u32 = 112;
pub const NGX_EHOSTUNREACH: u32 = 113;
pub const NGX_ENOSYS: u32 = 38;
pub const NGX_ECANCELED: u32 = 125;
pub const NGX_EILSEQ: u32 = 84;
pub const NGX_ENOMOREFILES: u32 = 0;
pub const NGX_ELOOP: u32 = 40;
pub const NGX_EBADF: u32 = 9;
pub const NGX_EMLINK: u32 = 31;
pub const NGX_EAGAIN: u32 = 11;
pub const NGX_HAVE_ATOMIC_OPS: u32 = 1;
pub const ngx_log_tid: u32 = 0;
pub const NGX_TID_T_FMT: &'static [u8; 3usize] = b"%d\0";
pub const ngx_socket_n: &'static [u8; 9usize] = b"socket()\0";
pub const ngx_nonblocking_n: &'static [u8; 15usize] = b"ioctl(FIONBIO)\0";
pub const ngx_blocking_n: &'static [u8; 16usize] = b"ioctl(!FIONBIO)\0";
pub const ngx_cloexec_n: &'static [u8; 18usize] = b"fcntl(FD_CLOEXEC)\0";
pub const ngx_tcp_nopush_n: &'static [u8; 21usize] = b"setsockopt(TCP_CORK)\0";
pub const ngx_tcp_push_n: &'static [u8; 22usize] = b"setsockopt(!TCP_CORK)\0";
pub const ngx_shutdown_socket_n: &'static [u8; 11usize] = b"shutdown()\0";
pub const ngx_close_socket_n: &'static [u8; 15usize] = b"close() socket\0";
pub const NGX_ESCAPE_URI: u32 = 0;
pub const NGX_ESCAPE_ARGS: u32 = 1;
pub const NGX_ESCAPE_URI_COMPONENT: u32 = 2;
pub const NGX_ESCAPE_HTML: u32 = 3;
pub const NGX_ESCAPE_REFRESH: u32 = 4;
pub const NGX_ESCAPE_MEMCACHED: u32 = 5;
pub const NGX_ESCAPE_MAIL_AUTH: u32 = 6;
pub const NGX_UNESCAPE_URI: u32 = 1;
pub const NGX_UNESCAPE_REDIRECT: u32 = 2;
pub const NGX_INVALID_FILE: i32 = -1;
pub const NGX_FILE_ERROR: i32 = -1;
pub const ngx_open_file_n: &'static [u8; 7usize] = b"open()\0";
pub const NGX_FILE_RDONLY: u32 = 0;
pub const NGX_FILE_WRONLY: u32 = 1;
pub const NGX_FILE_RDWR: u32 = 2;
pub const NGX_FILE_CREATE_OR_OPEN: u32 = 64;
pub const NGX_FILE_OPEN: u32 = 0;
pub const NGX_FILE_TRUNCATE: u32 = 576;
pub const NGX_FILE_APPEND: u32 = 1025;
pub const NGX_FILE_NONBLOCK: u32 = 2048;
pub const NGX_FILE_NOFOLLOW: u32 = 131072;
pub const NGX_FILE_DIRECTORY: u32 = 65536;
pub const NGX_FILE_SEARCH: u32 = 2162688;
pub const NGX_FILE_DEFAULT_ACCESS: u32 = 420;
pub const NGX_FILE_OWNER_ACCESS: u32 = 384;
pub const ngx_close_file_n: &'static [u8; 8usize] = b"close()\0";
pub const ngx_delete_file_n: &'static [u8; 9usize] = b"unlink()\0";
pub const ngx_open_tempfile_n: &'static [u8; 7usize] = b"open()\0";
pub const ngx_read_file_n: &'static [u8; 8usize] = b"pread()\0";
pub const ngx_read_fd_n: &'static [u8; 7usize] = b"read()\0";
pub const ngx_write_fd_n: &'static [u8; 8usize] = b"write()\0";
pub const NGX_LINEFEED_SIZE: u32 = 1;
pub const NGX_LINEFEED: &'static [u8; 2usize] = b"\n\0";
pub const ngx_rename_file_n: &'static [u8; 9usize] = b"rename()\0";
pub const ngx_change_file_access_n: &'static [u8; 8usize] = b"chmod()\0";
pub const ngx_set_file_time_n: &'static [u8; 9usize] = b"utimes()\0";
pub const ngx_file_info_n: &'static [u8; 7usize] = b"stat()\0";
pub const ngx_fd_info_n: &'static [u8; 8usize] = b"fstat()\0";
pub const ngx_link_info_n: &'static [u8; 8usize] = b"lstat()\0";
pub const ngx_realpath_n: &'static [u8; 11usize] = b"realpath()\0";
pub const ngx_getcwd_n: &'static [u8; 9usize] = b"getcwd()\0";
pub const NGX_HAVE_MAX_PATH: u32 = 1;
pub const NGX_MAX_PATH: u32 = 4096;
pub const NGX_DIR_MASK_LEN: u32 = 0;
pub const ngx_open_dir_n: &'static [u8; 10usize] = b"opendir()\0";
pub const ngx_close_dir_n: &'static [u8; 11usize] = b"closedir()\0";
pub const ngx_read_dir_n: &'static [u8; 10usize] = b"readdir()\0";
pub const ngx_create_dir_n: &'static [u8; 8usize] = b"mkdir()\0";
pub const ngx_delete_dir_n: &'static [u8; 8usize] = b"rmdir()\0";
pub const ngx_de_info_n: &'static [u8; 7usize] = b"stat()\0";
pub const ngx_de_link_info_n: &'static [u8; 8usize] = b"lstat()\0";
pub const ngx_open_glob_n: &'static [u8; 7usize] = b"glob()\0";
pub const ngx_trylock_fd_n: &'static [u8; 24usize] = b"fcntl(F_SETLK, F_WRLCK)\0";
pub const ngx_lock_fd_n: &'static [u8; 25usize] = b"fcntl(F_SETLKW, F_WRLCK)\0";
pub const ngx_unlock_fd_n: &'static [u8; 24usize] = b"fcntl(F_SETLK, F_UNLCK)\0";
pub const NGX_HAVE_READ_AHEAD: u32 = 1;
pub const ngx_read_ahead_n: &'static [u8; 37usize] = b"posix_fadvise(POSIX_FADV_SEQUENTIAL)\0";
pub const ngx_directio_on_n: &'static [u8; 16usize] = b"fcntl(O_DIRECT)\0";
pub const ngx_directio_off_n: &'static [u8; 17usize] = b"fcntl(!O_DIRECT)\0";
pub const ngx_openat_file_n: &'static [u8; 9usize] = b"openat()\0";
pub const ngx_file_at_info_n: &'static [u8; 10usize] = b"fstatat()\0";
pub const ngx_stdout: u32 = 1;
pub const ngx_stderr: u32 = 2;
pub const ngx_set_stderr_n: &'static [u8; 20usize] = b"dup2(STDERR_FILENO)\0";
pub const NGX_HAVE_CPU_AFFINITY: u32 = 1;
pub const NGX_SETPROCTITLE_USES_ENV: u32 = 1;
pub const NGX_SETPROCTITLE_PAD: u8 = 0u8;
pub const NGX_INVALID_PID: i32 = -1;
pub const NGX_MAX_PROCESSES: u32 = 1024;
pub const NGX_PROCESS_NORESPAWN: i32 = -1;
pub const NGX_PROCESS_JUST_SPAWN: i32 = -2;
pub const NGX_PROCESS_RESPAWN: i32 = -3;
pub const NGX_PROCESS_JUST_RESPAWN: i32 = -4;
pub const NGX_PROCESS_DETACHED: i32 = -5;
pub const ngx_dlopen_n: &'static [u8; 9usize] = b"dlopen()\0";
pub const ngx_dlsym_n: &'static [u8; 8usize] = b"dlsym()\0";
pub const ngx_dlclose_n: &'static [u8; 10usize] = b"dlclose()\0";
pub const NGX_LOG_STDERR: u32 = 0;
pub const NGX_LOG_EMERG: u32 = 1;
pub const NGX_LOG_ALERT: u32 = 2;
pub const NGX_LOG_CRIT: u32 = 3;
pub const NGX_LOG_ERR: u32 = 4;
pub const NGX_LOG_WARN: u32 = 5;
pub const NGX_LOG_NOTICE: u32 = 6;
pub const NGX_LOG_INFO: u32 = 7;
pub const NGX_LOG_DEBUG: u32 = 8;
pub const NGX_LOG_DEBUG_CORE: u32 = 16;
pub const NGX_LOG_DEBUG_ALLOC: u32 = 32;
pub const NGX_LOG_DEBUG_MUTEX: u32 = 64;
pub const NGX_LOG_DEBUG_EVENT: u32 = 128;
pub const NGX_LOG_DEBUG_HTTP: u32 = 256;
pub const NGX_LOG_DEBUG_MAIL: u32 = 512;
pub const NGX_LOG_DEBUG_STREAM: u32 = 1024;
pub const NGX_LOG_DEBUG_FIRST: u32 = 16;
pub const NGX_LOG_DEBUG_LAST: u32 = 1024;
pub const NGX_LOG_DEBUG_CONNECTION: u32 = 2147483648;
pub const NGX_LOG_DEBUG_ALL: u32 = 2147483632;
pub const NGX_MAX_ERROR_STR: u32 = 4096;
pub const NGX_HAVE_VARIADIC_MACROS: u32 = 1;
pub const NGX_DEFAULT_POOL_SIZE: u32 = 16384;
pub const NGX_POOL_ALIGNMENT: u32 = 16;
pub const NGX_HASH_SMALL: u32 = 1;
pub const NGX_HASH_LARGE: u32 = 2;
pub const NGX_HASH_LARGE_ASIZE: u32 = 16384;
pub const NGX_HASH_LARGE_HSIZE: u32 = 10007;
pub const NGX_HASH_WILDCARD_KEY: u32 = 1;
pub const NGX_HASH_READONLY_KEY: u32 = 2;
pub const NGX_MAX_PATH_LEVEL: u32 = 3;
pub const NGX_REGEX_NO_MATCHED: i32 = -1;
pub const NGX_REGEX_CASELESS: u32 = 1;
pub const ngx_regex_exec_n: &'static [u8; 12usize] = b"pcre_exec()\0";
pub const ngx_next_time_n: &'static [u8; 9usize] = b"mktime()\0";
pub const NGX_CYCLE_POOL_SIZE: u32 = 16384;
pub const NGX_DEBUG_POINTS_STOP: u32 = 1;
pub const NGX_DEBUG_POINTS_ABORT: u32 = 2;
pub const NGX_RESOLVE_A: u32 = 1;
pub const NGX_RESOLVE_CNAME: u32 = 5;
pub const NGX_RESOLVE_PTR: u32 = 12;
pub const NGX_RESOLVE_MX: u32 = 15;
pub const NGX_RESOLVE_TXT: u32 = 16;
pub const NGX_RESOLVE_AAAA: u32 = 28;
pub const NGX_RESOLVE_SRV: u32 = 33;
pub const NGX_RESOLVE_DNAME: u32 = 39;
pub const NGX_RESOLVE_FORMERR: u32 = 1;
pub const NGX_RESOLVE_SERVFAIL: u32 = 2;
pub const NGX_RESOLVE_NXDOMAIN: u32 = 3;
pub const NGX_RESOLVE_NOTIMP: u32 = 4;
pub const NGX_RESOLVE_REFUSED: u32 = 5;
pub const NGX_RESOLVE_TIMEDOUT: u32 = 110;
pub const NGX_RESOLVER_MAX_RECURSION: u32 = 50;
pub const NGX_CMD_OPEN_CHANNEL: u32 = 1;
pub const NGX_CMD_CLOSE_CHANNEL: u32 = 2;
pub const NGX_CMD_QUIT: u32 = 3;
pub const NGX_CMD_TERMINATE: u32 = 4;
pub const NGX_CMD_REOPEN: u32 = 5;
pub const NGX_PROCESS_SINGLE: u32 = 0;
pub const NGX_PROCESS_MASTER: u32 = 1;
pub const NGX_PROCESS_SIGNALLER: u32 = 2;
pub const NGX_PROCESS_WORKER: u32 = 3;
pub const NGX_PROCESS_HELPER: u32 = 4;
pub const NGX_CONF_NOARGS: u32 = 1;
pub const NGX_CONF_TAKE1: u32 = 2;
pub const NGX_CONF_TAKE2: u32 = 4;
pub const NGX_CONF_TAKE3: u32 = 8;
pub const NGX_CONF_TAKE4: u32 = 16;
pub const NGX_CONF_TAKE5: u32 = 32;
pub const NGX_CONF_TAKE6: u32 = 64;
pub const NGX_CONF_TAKE7: u32 = 128;
pub const NGX_CONF_MAX_ARGS: u32 = 8;
pub const NGX_CONF_TAKE12: u32 = 6;
pub const NGX_CONF_TAKE13: u32 = 10;
pub const NGX_CONF_TAKE23: u32 = 12;
pub const NGX_CONF_TAKE123: u32 = 14;
pub const NGX_CONF_TAKE1234: u32 = 30;
pub const NGX_CONF_ARGS_NUMBER: u32 = 255;
pub const NGX_CONF_BLOCK: u32 = 256;
pub const NGX_CONF_FLAG: u32 = 512;
pub const NGX_CONF_ANY: u32 = 1024;
pub const NGX_CONF_1MORE: u32 = 2048;
pub const NGX_CONF_2MORE: u32 = 4096;
pub const NGX_DIRECT_CONF: u32 = 65536;
pub const NGX_MAIN_CONF: u32 = 16777216;
pub const NGX_ANY_CONF: u32 = 520093696;
pub const NGX_CONF_UNSET: i32 = -1;
pub const NGX_CONF_BLOCK_START: u32 = 1;
pub const NGX_CONF_BLOCK_DONE: u32 = 2;
pub const NGX_CONF_FILE_DONE: u32 = 3;
pub const NGX_CORE_MODULE: u32 = 1163022147;
pub const NGX_CONF_MODULE: u32 = 1179537219;
pub const NGX_MAX_CONF_ERRSTR: u32 = 1024;
pub const NGX_CONF_BITMASK_SET: u32 = 1;
pub const nginx_version: u32 = 1013006;
pub const NGX_OLDPID_EXT: &'static [u8; 8usize] = b".oldbin\0";
pub const NGX_MODULE_SIGNATURE_1: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_2: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_3: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_4: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_5: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_6: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_7: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_8: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_9: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_10: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_11: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_12: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_13: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_14: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_15: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_16: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_17: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_18: &'static [u8; 2usize] = b"0\0";
pub const NGX_MODULE_SIGNATURE_19: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_20: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_21: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_22: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_23: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_24: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_25: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_26: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_27: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_28: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_29: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_30: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_31: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_32: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_33: &'static [u8; 2usize] = b"1\0";
pub const NGX_MODULE_SIGNATURE_34: &'static [u8; 2usize] = b"1\0";
pub const NGX_OPEN_FILE_DIRECTIO_OFF: u64 = 9223372036854775807;
pub const NGX_IO_SENDFILE: u32 = 1;
pub const NGX_IOVS_PREALLOCATE: u32 = 64;
pub const NGX_LOWLEVEL_BUFFERED: u32 = 15;
pub const NGX_SSL_BUFFERED: u32 = 1;
pub const NGX_HTTP_V2_BUFFERED: u32 = 2;
pub const NGX_PROXY_PROTOCOL_MAX_HEADER: u32 = 107;
pub const NGX_DISABLE_SYMLINKS_OFF: u32 = 0;
pub const NGX_DISABLE_SYMLINKS_ON: u32 = 1;
pub const NGX_DISABLE_SYMLINKS_NOTOWNER: u32 = 2;
pub const NGX_HTTP_VAR_CHANGEABLE: u32 = 1;
pub const NGX_HTTP_VAR_NOCACHEABLE: u32 = 2;
pub const NGX_HTTP_VAR_INDEXED: u32 = 4;
pub const NGX_HTTP_VAR_NOHASH: u32 = 8;
pub const NGX_HTTP_VAR_WEAK: u32 = 16;
pub const NGX_HTTP_VAR_PREFIX: u32 = 32;
pub const NGX_HTTP_MODULE: u32 = 1347703880;
pub const NGX_HTTP_MAIN_CONF: u32 = 33554432;
pub const NGX_HTTP_SRV_CONF: u32 = 67108864;
pub const NGX_HTTP_LOC_CONF: u32 = 134217728;
pub const NGX_HTTP_UPS_CONF: u32 = 268435456;
pub const NGX_HTTP_SIF_CONF: u32 = 536870912;
pub const NGX_HTTP_LIF_CONF: u32 = 1073741824;
pub const NGX_HTTP_LMT_CONF: u32 = 2147483648;
pub const NGX_HTTP_MAX_URI_CHANGES: u32 = 10;
pub const NGX_HTTP_MAX_SUBREQUESTS: u32 = 50;
pub const NGX_HTTP_LC_HEADER_LEN: u32 = 32;
pub const NGX_HTTP_DISCARD_BUFFER_SIZE: u32 = 4096;
pub const NGX_HTTP_LINGERING_BUFFER_SIZE: u32 = 4096;
pub const NGX_HTTP_VERSION_9: u32 = 9;
pub const NGX_HTTP_VERSION_10: u32 = 1000;
pub const NGX_HTTP_VERSION_11: u32 = 1001;
pub const NGX_HTTP_VERSION_20: u32 = 2000;
pub const NGX_HTTP_UNKNOWN: u32 = 1;
pub const NGX_HTTP_GET: u32 = 2;
pub const NGX_HTTP_HEAD: u32 = 4;
pub const NGX_HTTP_POST: u32 = 8;
pub const NGX_HTTP_PUT: u32 = 16;
pub const NGX_HTTP_DELETE: u32 = 32;
pub const NGX_HTTP_MKCOL: u32 = 64;
pub const NGX_HTTP_COPY: u32 = 128;
pub const NGX_HTTP_MOVE: u32 = 256;
pub const NGX_HTTP_OPTIONS: u32 = 512;
pub const NGX_HTTP_PROPFIND: u32 = 1024;
pub const NGX_HTTP_PROPPATCH: u32 = 2048;
pub const NGX_HTTP_LOCK: u32 = 4096;
pub const NGX_HTTP_UNLOCK: u32 = 8192;
pub const NGX_HTTP_PATCH: u32 = 16384;
pub const NGX_HTTP_TRACE: u32 = 32768;
pub const NGX_HTTP_CONNECTION_CLOSE: u32 = 1;
pub const NGX_HTTP_CONNECTION_KEEP_ALIVE: u32 = 2;
pub const NGX_NONE: u32 = 1;
pub const NGX_HTTP_PARSE_HEADER_DONE: u32 = 1;
pub const NGX_HTTP_CLIENT_ERROR: u32 = 10;
pub const NGX_HTTP_PARSE_INVALID_METHOD: u32 = 10;
pub const NGX_HTTP_PARSE_INVALID_REQUEST: u32 = 11;
pub const NGX_HTTP_PARSE_INVALID_VERSION: u32 = 12;
pub const NGX_HTTP_PARSE_INVALID_09_METHOD: u32 = 13;
pub const NGX_HTTP_PARSE_INVALID_HEADER: u32 = 14;
pub const NGX_HTTP_SUBREQUEST_IN_MEMORY: u32 = 2;
pub const NGX_HTTP_SUBREQUEST_WAITED: u32 = 4;
pub const NGX_HTTP_SUBREQUEST_CLONE: u32 = 8;
pub const NGX_HTTP_SUBREQUEST_BACKGROUND: u32 = 16;
pub const NGX_HTTP_LOG_UNSAFE: u32 = 1;
pub const NGX_HTTP_CONTINUE: u32 = 100;
pub const NGX_HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const NGX_HTTP_PROCESSING: u32 = 102;
pub const NGX_HTTP_OK: u32 = 200;
pub const NGX_HTTP_CREATED: u32 = 201;
pub const NGX_HTTP_ACCEPTED: u32 = 202;
pub const NGX_HTTP_NO_CONTENT: u32 = 204;
pub const NGX_HTTP_PARTIAL_CONTENT: u32 = 206;
pub const NGX_HTTP_SPECIAL_RESPONSE: u32 = 300;
pub const NGX_HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const NGX_HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const NGX_HTTP_SEE_OTHER: u32 = 303;
pub const NGX_HTTP_NOT_MODIFIED: u32 = 304;
pub const NGX_HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const NGX_HTTP_PERMANENT_REDIRECT: u32 = 308;
pub const NGX_HTTP_BAD_REQUEST: u32 = 400;
pub const NGX_HTTP_UNAUTHORIZED: u32 = 401;
pub const NGX_HTTP_FORBIDDEN: u32 = 403;
pub const NGX_HTTP_NOT_FOUND: u32 = 404;
pub const NGX_HTTP_NOT_ALLOWED: u32 = 405;
pub const NGX_HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const NGX_HTTP_CONFLICT: u32 = 409;
pub const NGX_HTTP_LENGTH_REQUIRED: u32 = 411;
pub const NGX_HTTP_PRECONDITION_FAILED: u32 = 412;
pub const NGX_HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const NGX_HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const NGX_HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const NGX_HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const NGX_HTTP_MISDIRECTED_REQUEST: u32 = 421;
pub const NGX_HTTP_TOO_MANY_REQUESTS: u32 = 429;
pub const NGX_HTTP_CLOSE: u32 = 444;
pub const NGX_HTTP_NGINX_CODES: u32 = 494;
pub const NGX_HTTP_REQUEST_HEADER_TOO_LARGE: u32 = 494;
pub const NGX_HTTPS_CERT_ERROR: u32 = 495;
pub const NGX_HTTPS_NO_CERT: u32 = 496;
pub const NGX_HTTP_TO_HTTPS: u32 = 497;
pub const NGX_HTTP_CLIENT_CLOSED_REQUEST: u32 = 499;
pub const NGX_HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const NGX_HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const NGX_HTTP_BAD_GATEWAY: u32 = 502;
pub const NGX_HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const NGX_HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const NGX_HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const NGX_HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const NGX_HTTP_LOWLEVEL_BUFFERED: u32 = 240;
pub const NGX_HTTP_WRITE_BUFFERED: u32 = 16;
pub const NGX_HTTP_GZIP_BUFFERED: u32 = 32;
pub const NGX_HTTP_SSI_BUFFERED: u32 = 1;
pub const NGX_HTTP_SUB_BUFFERED: u32 = 2;
pub const NGX_HTTP_COPY_BUFFERED: u32 = 4;
pub const NGX_INVALID_INDEX: u32 = 3503345872;
pub const NGX_USE_LEVEL_EVENT: u32 = 1;
pub const NGX_USE_ONESHOT_EVENT: u32 = 2;
pub const NGX_USE_CLEAR_EVENT: u32 = 4;
pub const NGX_USE_KQUEUE_EVENT: u32 = 8;
pub const NGX_USE_LOWAT_EVENT: u32 = 16;
pub const NGX_USE_GREEDY_EVENT: u32 = 32;
pub const NGX_USE_EPOLL_EVENT: u32 = 64;
pub const NGX_USE_RTSIG_EVENT: u32 = 128;
pub const NGX_USE_AIO_EVENT: u32 = 256;
pub const NGX_USE_IOCP_EVENT: u32 = 512;
pub const NGX_USE_FD_EVENT: u32 = 1024;
pub const NGX_USE_TIMER_EVENT: u32 = 2048;
pub const NGX_USE_EVENTPORT_EVENT: u32 = 4096;
pub const NGX_USE_VNODE_EVENT: u32 = 8192;
pub const NGX_CLOSE_EVENT: u32 = 1;
pub const NGX_DISABLE_EVENT: u32 = 2;
pub const NGX_FLUSH_EVENT: u32 = 4;
pub const NGX_LOWAT_EVENT: u32 = 0;
pub const NGX_VNODE_EVENT: u32 = 0;
pub const NGX_LEVEL_EVENT: u32 = 0;
pub const NGX_ONESHOT_EVENT: u32 = 1879048192;
pub const NGX_EVENT_MODULE: u32 = 1414420037;
pub const NGX_EVENT_CONF: u32 = 33554432;
pub const NGX_UPDATE_TIME: u32 = 1;
pub const NGX_POST_EVENTS: u32 = 2;
pub const NGX_TIMER_LAZY_DELAY: u32 = 300;
pub const NGX_PEER_KEEPALIVE: u32 = 1;
pub const NGX_PEER_NEXT: u32 = 2;
pub const NGX_PEER_FAILED: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FT_ERROR: u32 = 2;
pub const NGX_HTTP_UPSTREAM_FT_TIMEOUT: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FT_INVALID_HEADER: u32 = 8;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_500: u32 = 16;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_502: u32 = 32;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_503: u32 = 64;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_504: u32 = 128;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_403: u32 = 256;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_404: u32 = 512;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_429: u32 = 1024;
pub const NGX_HTTP_UPSTREAM_FT_UPDATING: u32 = 2048;
pub const NGX_HTTP_UPSTREAM_FT_BUSY_LOCK: u32 = 4096;
pub const NGX_HTTP_UPSTREAM_FT_MAX_WAITING: u32 = 8192;
pub const NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT: u32 = 16384;
pub const NGX_HTTP_UPSTREAM_FT_NOLIVE: u32 = 1073741824;
pub const NGX_HTTP_UPSTREAM_FT_OFF: u32 = 2147483648;
pub const NGX_HTTP_UPSTREAM_FT_STATUS: u32 = 2032;
pub const NGX_HTTP_UPSTREAM_INVALID_HEADER: u32 = 40;
pub const NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT: u32 = 2;
pub const NGX_HTTP_UPSTREAM_IGN_XA_EXPIRES: u32 = 4;
pub const NGX_HTTP_UPSTREAM_IGN_EXPIRES: u32 = 8;
pub const NGX_HTTP_UPSTREAM_IGN_CACHE_CONTROL: u32 = 16;
pub const NGX_HTTP_UPSTREAM_IGN_SET_COOKIE: u32 = 32;
pub const NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE: u32 = 64;
pub const NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING: u32 = 128;
pub const NGX_HTTP_UPSTREAM_IGN_XA_CHARSET: u32 = 256;
pub const NGX_HTTP_UPSTREAM_IGN_VARY: u32 = 512;
pub const NGX_HTTP_UPSTREAM_CREATE: u32 = 1;
pub const NGX_HTTP_UPSTREAM_WEIGHT: u32 = 2;
pub const NGX_HTTP_UPSTREAM_MAX_FAILS: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FAIL_TIMEOUT: u32 = 8;
pub const NGX_HTTP_UPSTREAM_DOWN: u32 = 16;
pub const NGX_HTTP_UPSTREAM_BACKUP: u32 = 32;
pub const NGX_HTTP_UPSTREAM_MAX_CONNS: u32 = 256;
pub const NGX_HTTP_GZIP_PROXIED_OFF: u32 = 2;
pub const NGX_HTTP_GZIP_PROXIED_EXPIRED: u32 = 4;
pub const NGX_HTTP_GZIP_PROXIED_NO_CACHE: u32 = 8;
pub const NGX_HTTP_GZIP_PROXIED_NO_STORE: u32 = 16;
pub const NGX_HTTP_GZIP_PROXIED_PRIVATE: u32 = 32;
pub const NGX_HTTP_GZIP_PROXIED_NO_LM: u32 = 64;
pub const NGX_HTTP_GZIP_PROXIED_NO_ETAG: u32 = 128;
pub const NGX_HTTP_GZIP_PROXIED_AUTH: u32 = 256;
pub const NGX_HTTP_GZIP_PROXIED_ANY: u32 = 512;
pub const NGX_HTTP_AIO_OFF: u32 = 0;
pub const NGX_HTTP_AIO_ON: u32 = 1;
pub const NGX_HTTP_AIO_THREADS: u32 = 2;
pub const NGX_HTTP_SATISFY_ALL: u32 = 0;
pub const NGX_HTTP_SATISFY_ANY: u32 = 1;
pub const NGX_HTTP_LINGERING_OFF: u32 = 0;
pub const NGX_HTTP_LINGERING_ON: u32 = 1;
pub const NGX_HTTP_LINGERING_ALWAYS: u32 = 2;
pub const NGX_HTTP_IMS_OFF: u32 = 0;
pub const NGX_HTTP_IMS_EXACT: u32 = 1;
pub const NGX_HTTP_IMS_BEFORE: u32 = 2;
pub const NGX_HTTP_KEEPALIVE_DISABLE_NONE: u32 = 2;
pub const NGX_HTTP_KEEPALIVE_DISABLE_MSIE6: u32 = 4;
pub const NGX_HTTP_KEEPALIVE_DISABLE_SAFARI: u32 = 8;
pub const NGX_HTTP_SERVER_TOKENS_OFF: u32 = 0;
pub const NGX_HTTP_SERVER_TOKENS_ON: u32 = 1;
pub const NGX_HTTP_SERVER_TOKENS_BUILD: u32 = 2;
pub const NGX_HTTP_CACHE_MISS: u32 = 1;
pub const NGX_HTTP_CACHE_BYPASS: u32 = 2;
pub const NGX_HTTP_CACHE_EXPIRED: u32 = 3;
pub const NGX_HTTP_CACHE_STALE: u32 = 4;
pub const NGX_HTTP_CACHE_UPDATING: u32 = 5;
pub const NGX_HTTP_CACHE_REVALIDATED: u32 = 6;
pub const NGX_HTTP_CACHE_HIT: u32 = 7;
pub const NGX_HTTP_CACHE_SCARCE: u32 = 8;
pub const NGX_HTTP_CACHE_KEY_LEN: u32 = 16;
pub const NGX_HTTP_CACHE_ETAG_LEN: u32 = 128;
pub const NGX_HTTP_CACHE_VARY_LEN: u32 = 128;
pub const NGX_HTTP_CACHE_VERSION: u32 = 5;
pub const NGX_HTTP_SSI_MAX_PARAMS: u32 = 16;
pub const NGX_HTTP_SSI_COMMAND_LEN: u32 = 32;
pub const NGX_HTTP_SSI_PARAM_LEN: u32 = 32;
pub const NGX_HTTP_SSI_PARAMS_N: u32 = 4;
pub const NGX_HTTP_SSI_COND_IF: u32 = 1;
pub const NGX_HTTP_SSI_COND_ELSE: u32 = 2;
pub const NGX_HTTP_SSI_NO_ENCODING: u32 = 0;
pub const NGX_HTTP_SSI_URL_ENCODING: u32 = 1;
pub const NGX_HTTP_SSI_ENTITY_ENCODING: u32 = 2;
pub const NGX_HTTP_LAST: u32 = 1;
pub const NGX_HTTP_FLUSH: u32 = 2;
pub type __u_char = ::aya_bpf::cty::c_uchar;
pub type __u_short = ::aya_bpf::cty::c_ushort;
pub type __uint8_t = ::aya_bpf::cty::c_uchar;
pub type __uint16_t = ::aya_bpf::cty::c_ushort;
pub type __uint32_t = ::aya_bpf::cty::c_uint;
pub type __uint64_t = ::aya_bpf::cty::c_ulong;
pub type __dev_t = ::aya_bpf::cty::c_ulong;
pub type __uid_t = ::aya_bpf::cty::c_uint;
pub type __gid_t = ::aya_bpf::cty::c_uint;
pub type __ino_t = ::aya_bpf::cty::c_ulong;
pub type __ino64_t = ::aya_bpf::cty::c_ulong;
pub type __mode_t = ::aya_bpf::cty::c_uint;
pub type __nlink_t = ::aya_bpf::cty::c_ulong;
pub type __off_t = ::aya_bpf::cty::c_long;
pub type __off64_t = ::aya_bpf::cty::c_long;
pub type __pid_t = ::aya_bpf::cty::c_int;
pub type __time_t = ::aya_bpf::cty::c_long;
pub type __blksize_t = ::aya_bpf::cty::c_long;
pub type __blkcnt_t = ::aya_bpf::cty::c_long;
pub type __ssize_t = ::aya_bpf::cty::c_long;
pub type __syscall_slong_t = ::aya_bpf::cty::c_long;
pub type __intptr_t = ::aya_bpf::cty::c_long;
pub type __socklen_t = ::aya_bpf::cty::c_uint;
pub type __sig_atomic_t = ::aya_bpf::cty::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type ino_t = __ino64_t;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off64_t;
pub type pid_t = __pid_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
pub type size_t = ::aya_bpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type socklen_t = __socklen_t;
pub type va_list = __builtin_va_list;
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: ::aya_bpf::cty::c_ushort,
    pub d_type: ::aya_bpf::cty::c_uchar,
    pub d_name: [::aya_bpf::cty::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
pub type __size_t = ::aya_bpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glob_t {
    pub gl_pathc: __size_t,
    pub gl_pathv: *mut *mut ::aya_bpf::cty::c_char,
    pub gl_offs: __size_t,
    pub gl_flags: ::aya_bpf::cty::c_int,
    pub gl_closedir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void)>,
    pub gl_readdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::aya_bpf::cty::c_void) -> *mut dirent,
    >,
    pub gl_opendir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_bpf::cty::c_char) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub gl_lstat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: *mut stat,
        ) -> ::aya_bpf::cty::c_int,
    >,
    pub gl_stat: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::aya_bpf::cty::c_char,
            arg2: *mut stat,
        ) -> ::aya_bpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::aya_bpf::cty::c_void,
    pub iov_len: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::aya_bpf::cty::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
pub type __cpu_mask = ::aya_bpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
pub type sa_family_t = ::aya_bpf::cty::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::aya_bpf::cty::c_char; 14usize],
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::aya_bpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::aya_bpf::cty::c_char; 108usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::aya_bpf::cty::c_int,
    pub tm_min: ::aya_bpf::cty::c_int,
    pub tm_hour: ::aya_bpf::cty::c_int,
    pub tm_mday: ::aya_bpf::cty::c_int,
    pub tm_mon: ::aya_bpf::cty::c_int,
    pub tm_year: ::aya_bpf::cty::c_int,
    pub tm_wday: ::aya_bpf::cty::c_int,
    pub tm_yday: ::aya_bpf::cty::c_int,
    pub tm_isdst: ::aya_bpf::cty::c_int,
    pub tm_gmtoff: ::aya_bpf::cty::c_long,
    pub tm_zone: *const ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::aya_bpf::cty::c_char; 32usize],
    pub __align: ::aya_bpf::cty::c_long,
}
pub type ngx_int_t = isize;
pub type ngx_uint_t = usize;
pub type ngx_flag_t = isize;
pub type ngx_module_t = ngx_module_s;
pub type ngx_conf_t = ngx_conf_s;
pub type ngx_cycle_t = ngx_cycle_s;
pub type ngx_pool_t = ngx_pool_s;
pub type ngx_chain_t = ngx_chain_s;
pub type ngx_log_t = ngx_log_s;
pub type ngx_open_file_t = ngx_open_file_s;
pub type ngx_command_t = ngx_command_s;
pub type ngx_file_t = ngx_file_s;
pub type ngx_event_t = ngx_event_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_aio_s {
    _unused: [u8; 0],
}
pub type ngx_event_aio_t = ngx_event_aio_s;
pub type ngx_connection_t = ngx_connection_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_thread_task_s {
    _unused: [u8; 0],
}
pub type ngx_thread_task_t = ngx_thread_task_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_s {
    _unused: [u8; 0],
}
pub type ngx_ssl_t = ngx_ssl_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_connection_s {
    _unused: [u8; 0],
}
pub type ngx_ssl_connection_t = ngx_ssl_connection_s;
pub type ngx_event_handler_pt = ::core::option::Option<unsafe extern "C" fn(ev: *mut ngx_event_t)>;
pub type ngx_connection_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t)>;
pub type ngx_err_t = ::aya_bpf::cty::c_int;
extern "C" {
    pub fn ngx_strerror(err: ngx_err_t, errstr: *mut u_char, size: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strerror_init() -> ngx_int_t;
}
pub type ngx_atomic_int_t = ::aya_bpf::cty::c_long;
pub type ngx_atomic_uint_t = ::aya_bpf::cty::c_ulong;
pub type ngx_atomic_t = ngx_atomic_uint_t;
extern "C" {
    pub fn ngx_spinlock(lock: *mut ngx_atomic_t, value: ngx_atomic_int_t, spin: ngx_uint_t);
}
pub type ngx_rbtree_key_t = ngx_uint_t;
pub type ngx_rbtree_key_int_t = ngx_int_t;
pub type ngx_rbtree_node_t = ngx_rbtree_node_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_rbtree_node_s {
    pub key: ngx_rbtree_key_t,
    pub left: *mut ngx_rbtree_node_t,
    pub right: *mut ngx_rbtree_node_t,
    pub parent: *mut ngx_rbtree_node_t,
    pub color: u_char,
    pub data: u_char,
}
pub type ngx_rbtree_t = ngx_rbtree_s;
pub type ngx_rbtree_insert_pt = ::core::option::Option<
    unsafe extern "C" fn(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_rbtree_s {
    pub root: *mut ngx_rbtree_node_t,
    pub sentinel: *mut ngx_rbtree_node_t,
    pub insert: ngx_rbtree_insert_pt,
}
extern "C" {
    pub fn ngx_rbtree_insert(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t);
}
extern "C" {
    pub fn ngx_rbtree_delete(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t);
}
extern "C" {
    pub fn ngx_rbtree_insert_value(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_rbtree_insert_timer_value(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_rbtree_next(
        tree: *mut ngx_rbtree_t,
        node: *mut ngx_rbtree_node_t,
    ) -> *mut ngx_rbtree_node_t;
}
pub type ngx_msec_t = ngx_rbtree_key_t;
pub type ngx_msec_int_t = ngx_rbtree_key_int_t;
pub type ngx_tm_t = tm;
extern "C" {
    pub fn ngx_timezone_update();
}
extern "C" {
    pub fn ngx_localtime(s: time_t, tm: *mut ngx_tm_t);
}
extern "C" {
    pub fn ngx_libc_localtime(s: time_t, tm: *mut tm);
}
extern "C" {
    pub fn ngx_libc_gmtime(s: time_t, tm: *mut tm);
}
pub type ngx_socket_t = ::aya_bpf::cty::c_int;
extern "C" {
    pub fn ngx_nonblocking(s: ngx_socket_t) -> ::aya_bpf::cty::c_int;
}
extern "C" {
    pub fn ngx_blocking(s: ngx_socket_t) -> ::aya_bpf::cty::c_int;
}
extern "C" {
    pub fn ngx_tcp_nopush(s: ngx_socket_t) -> ::aya_bpf::cty::c_int;
}
extern "C" {
    pub fn ngx_tcp_push(s: ngx_socket_t) -> ::aya_bpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_str_t {
    pub len: size_t,
    pub data: *mut u_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_keyval_t {
    pub key: ngx_str_t,
    pub value: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_variable_value_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub data: *mut u_char,
}
impl ngx_variable_value_t {
    #[inline]
    pub fn len(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cacheable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cacheable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_found(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_found(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escape(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escape(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        len: ::aya_bpf::cty::c_uint,
        valid: ::aya_bpf::cty::c_uint,
        no_cacheable: ::aya_bpf::cty::c_uint,
        not_found: ::aya_bpf::cty::c_uint,
        escape: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let len: u32 = unsafe { ::core::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let no_cacheable: u32 = unsafe { ::core::mem::transmute(no_cacheable) };
            no_cacheable as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let not_found: u32 = unsafe { ::core::mem::transmute(not_found) };
            not_found as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let escape: u32 = unsafe { ::core::mem::transmute(escape) };
            escape as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_strlow(dst: *mut u_char, src: *mut u_char, n: size_t);
}
extern "C" {
    pub fn ngx_strnlen(p: *mut u_char, n: size_t) -> size_t;
}
extern "C" {
    pub fn ngx_cpystrn(dst: *mut u_char, src: *mut u_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_pstrdup(pool: *mut ngx_pool_t, src: *mut ngx_str_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_sprintf(buf: *mut u_char, fmt: *const ::aya_bpf::cty::c_char, ...) -> *mut u_char;
}
extern "C" {
    pub fn ngx_snprintf(
        buf: *mut u_char,
        max: size_t,
        fmt: *const ::aya_bpf::cty::c_char,
        ...
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_slprintf(
        buf: *mut u_char,
        last: *mut u_char,
        fmt: *const ::aya_bpf::cty::c_char,
        ...
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_vslprintf(
        buf: *mut u_char,
        last: *mut u_char,
        fmt: *const ::aya_bpf::cty::c_char,
        args: *mut __va_list_tag,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strcasecmp(s1: *mut u_char, s2: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_strncasecmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_strnstr(s1: *mut u_char, s2: *mut ::aya_bpf::cty::c_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strstrn(s1: *mut u_char, s2: *mut ::aya_bpf::cty::c_char, n: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strcasestrn(
        s1: *mut u_char,
        s2: *mut ::aya_bpf::cty::c_char,
        n: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strlcasestrn(
        s1: *mut u_char,
        last: *mut u_char,
        s2: *mut u_char,
        n: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_rstrncmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_rstrncasecmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_memn2cmp(s1: *mut u_char, s2: *mut u_char, n1: size_t, n2: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_dns_strcmp(s1: *mut u_char, s2: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_filename_cmp(s1: *mut u_char, s2: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atoi(line: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atofp(line: *mut u_char, n: size_t, point: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atosz(line: *mut u_char, n: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_atoof(line: *mut u_char, n: size_t) -> off_t;
}
extern "C" {
    pub fn ngx_atotm(line: *mut u_char, n: size_t) -> time_t;
}
extern "C" {
    pub fn ngx_hextoi(line: *mut u_char, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hex_dump(dst: *mut u_char, src: *mut u_char, len: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_encode_base64(dst: *mut ngx_str_t, src: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_encode_base64url(dst: *mut ngx_str_t, src: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_decode_base64(dst: *mut ngx_str_t, src: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_decode_base64url(dst: *mut ngx_str_t, src: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_utf8_decode(p: *mut *mut u_char, n: size_t) -> u32;
}
extern "C" {
    pub fn ngx_utf8_length(p: *mut u_char, n: size_t) -> size_t;
}
extern "C" {
    pub fn ngx_utf8_cpystrn(
        dst: *mut u_char,
        src: *mut u_char,
        n: size_t,
        len: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_escape_uri(
        dst: *mut u_char,
        src: *mut u_char,
        size: size_t,
        type_: ngx_uint_t,
    ) -> usize;
}
extern "C" {
    pub fn ngx_unescape_uri(
        dst: *mut *mut u_char,
        src: *mut *mut u_char,
        size: size_t,
        type_: ngx_uint_t,
    );
}
extern "C" {
    pub fn ngx_escape_html(dst: *mut u_char, src: *mut u_char, size: size_t) -> usize;
}
extern "C" {
    pub fn ngx_escape_json(dst: *mut u_char, src: *mut u_char, size: size_t) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_str_node_t {
    pub node: ngx_rbtree_node_t,
    pub str_: ngx_str_t,
}
extern "C" {
    pub fn ngx_str_rbtree_insert_value(
        temp: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_str_rbtree_lookup(
        rbtree: *mut ngx_rbtree_t,
        name: *mut ngx_str_t,
        hash: u32,
    ) -> *mut ngx_str_node_t;
}
extern "C" {
    pub fn ngx_sort(
        base: *mut ::aya_bpf::cty::c_void,
        n: size_t,
        size: size_t,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_bpf::cty::c_void,
                arg2: *const ::aya_bpf::cty::c_void,
            ) -> ngx_int_t,
        >,
    );
}
pub type ngx_fd_t = ::aya_bpf::cty::c_int;
pub type ngx_file_info_t = stat;
pub type ngx_file_uniq_t = ino_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_file_mapping_t {
    pub name: *mut u_char,
    pub size: size_t,
    pub addr: *mut ::aya_bpf::cty::c_void,
    pub fd: ngx_fd_t,
    pub log: *mut ngx_log_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_dir_t {
    pub dir: *mut DIR,
    pub de: *mut dirent,
    pub info: stat,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_dir_t {
    #[inline]
    pub fn type_(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_info(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_info(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::aya_bpf::cty::c_uint,
        valid_info: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let valid_info: u32 = unsafe { ::core::mem::transmute(valid_info) };
            valid_info as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_glob_t {
    pub n: size_t,
    pub pglob: glob_t,
    pub pattern: *mut u_char,
    pub log: *mut ngx_log_t,
    pub test: ngx_uint_t,
}
extern "C" {
    pub fn ngx_open_tempfile(
        name: *mut u_char,
        persistent: ngx_uint_t,
        access: ngx_uint_t,
    ) -> ngx_fd_t;
}
extern "C" {
    pub fn ngx_read_file(
        file: *mut ngx_file_t,
        buf: *mut u_char,
        size: size_t,
        offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_write_file(
        file: *mut ngx_file_t,
        buf: *mut u_char,
        size: size_t,
        offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_write_chain_to_file(
        file: *mut ngx_file_t,
        ce: *mut ngx_chain_t,
        offset: off_t,
        pool: *mut ngx_pool_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_set_file_time(name: *mut u_char, fd: ngx_fd_t, s: time_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_file_mapping(fm: *mut ngx_file_mapping_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_close_file_mapping(fm: *mut ngx_file_mapping_t);
}
extern "C" {
    pub fn ngx_open_dir(name: *mut ngx_str_t, dir: *mut ngx_dir_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_read_dir(dir: *mut ngx_dir_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_open_glob(gl: *mut ngx_glob_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_read_glob(gl: *mut ngx_glob_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_close_glob(gl: *mut ngx_glob_t);
}
extern "C" {
    pub fn ngx_trylock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_lock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_unlock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_read_ahead(fd: ngx_fd_t, n: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_directio_on(fd: ngx_fd_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_directio_off(fd: ngx_fd_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_fs_bsize(name: *mut u_char) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_shm_t {
    pub addr: *mut u_char,
    pub size: size_t,
    pub name: ngx_str_t,
    pub log: *mut ngx_log_t,
    pub exists: ngx_uint_t,
}
extern "C" {
    pub fn ngx_shm_alloc(shm: *mut ngx_shm_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_shm_free(shm: *mut ngx_shm_t);
}
pub type ngx_cpuset_t = cpu_set_t;
extern "C" {
    pub fn ngx_setaffinity(cpu_affinity: *mut ngx_cpuset_t, log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_init_setproctitle(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_setproctitle(title: *mut ::aya_bpf::cty::c_char);
}
pub type ngx_pid_t = pid_t;
pub type ngx_spawn_proc_pt = ::core::option::Option<
    unsafe extern "C" fn(cycle: *mut ngx_cycle_t, data: *mut ::aya_bpf::cty::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_process_t {
    pub pid: ngx_pid_t,
    pub status: ::aya_bpf::cty::c_int,
    pub channel: [ngx_socket_t; 2usize],
    pub proc_: ngx_spawn_proc_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_process_t {
    #[inline]
    pub fn respawn(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_respawn(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn just_spawn(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_just_spawn(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn detached(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_detached(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exiting(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exiting(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exited(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exited(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        respawn: ::aya_bpf::cty::c_uint,
        just_spawn: ::aya_bpf::cty::c_uint,
        detached: ::aya_bpf::cty::c_uint,
        exiting: ::aya_bpf::cty::c_uint,
        exited: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let respawn: u32 = unsafe { ::core::mem::transmute(respawn) };
            respawn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let just_spawn: u32 = unsafe { ::core::mem::transmute(just_spawn) };
            just_spawn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let detached: u32 = unsafe { ::core::mem::transmute(detached) };
            detached as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exiting: u32 = unsafe { ::core::mem::transmute(exiting) };
            exiting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exited: u32 = unsafe { ::core::mem::transmute(exited) };
            exited as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_exec_ctx_t {
    pub path: *mut ::aya_bpf::cty::c_char,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub argv: *const *mut ::aya_bpf::cty::c_char,
    pub envp: *const *mut ::aya_bpf::cty::c_char,
}
extern "C" {
    pub fn ngx_spawn_process(
        cycle: *mut ngx_cycle_t,
        proc_: ngx_spawn_proc_pt,
        data: *mut ::aya_bpf::cty::c_void,
        name: *mut ::aya_bpf::cty::c_char,
        respawn: ngx_int_t,
    ) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_execute(cycle: *mut ngx_cycle_t, ctx: *mut ngx_exec_ctx_t) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_init_signals(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_debug_point();
}
extern "C" {
    pub static mut ngx_argc: ::aya_bpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_argv: *mut *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_os_argv: *mut *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_pid: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_channel: ngx_socket_t;
}
extern "C" {
    pub static mut ngx_process_slot: ngx_int_t;
}
extern "C" {
    pub static mut ngx_last_process: ngx_int_t;
}
extern "C" {
    pub static mut ngx_processes: [ngx_process_t; 1024usize];
}
pub type ngx_uid_t = uid_t;
pub type ngx_gid_t = gid_t;
extern "C" {
    pub fn ngx_libc_crypt(
        pool: *mut ngx_pool_t,
        key: *mut u_char,
        salt: *mut u_char,
        encrypted: *mut *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_dlerror() -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_parse_size(line: *mut ngx_str_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_parse_offset(line: *mut ngx_str_t) -> off_t;
}
extern "C" {
    pub fn ngx_parse_time(line: *mut ngx_str_t, is_sec: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_http_time(value: *mut u_char, len: size_t) -> time_t;
}
pub type ngx_log_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(log: *mut ngx_log_t, buf: *mut u_char, len: size_t) -> *mut u_char,
>;
pub type ngx_log_writer_pt = ::core::option::Option<
    unsafe extern "C" fn(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: size_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_log_s {
    pub log_level: ngx_uint_t,
    pub file: *mut ngx_open_file_t,
    pub connection: ngx_atomic_uint_t,
    pub disk_full_time: time_t,
    pub handler: ngx_log_handler_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub writer: ngx_log_writer_pt,
    pub wdata: *mut ::aya_bpf::cty::c_void,
    pub action: *mut ::aya_bpf::cty::c_char,
    pub next: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_log_error_core(
        level: ngx_uint_t,
        log: *mut ngx_log_t,
        err: ngx_err_t,
        fmt: *const ::aya_bpf::cty::c_char,
        ...
    );
}
extern "C" {
    pub fn ngx_log_init(prefix: *mut u_char) -> *mut ngx_log_t;
}
extern "C" {
    pub fn ngx_log_abort(err: ngx_err_t, fmt: *const ::aya_bpf::cty::c_char, ...);
}
extern "C" {
    pub fn ngx_log_stderr(err: ngx_err_t, fmt: *const ::aya_bpf::cty::c_char, ...);
}
extern "C" {
    pub fn ngx_log_errno(buf: *mut u_char, last: *mut u_char, err: ngx_err_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_log_open_default(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_log_redirect_stderr(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_log_get_file_log(head: *mut ngx_log_t) -> *mut ngx_log_t;
}
extern "C" {
    pub fn ngx_log_set_log(
        cf: *mut ngx_conf_t,
        head: *mut *mut ngx_log_t,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_errlog_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_use_stderr: ngx_uint_t;
}
extern "C" {
    pub fn ngx_alloc(size: size_t, log: *mut ngx_log_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_calloc(size: size_t, log: *mut ngx_log_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_memalign(
        alignment: size_t,
        size: size_t,
        log: *mut ngx_log_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub static mut ngx_pagesize: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_pagesize_shift: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_cacheline_size: ngx_uint_t;
}
pub type ngx_pool_cleanup_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void)>;
pub type ngx_pool_cleanup_t = ngx_pool_cleanup_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_cleanup_s {
    pub handler: ngx_pool_cleanup_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub next: *mut ngx_pool_cleanup_t,
}
pub type ngx_pool_large_t = ngx_pool_large_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_large_s {
    pub next: *mut ngx_pool_large_t,
    pub alloc: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_data_t {
    pub last: *mut u_char,
    pub end: *mut u_char,
    pub next: *mut ngx_pool_t,
    pub failed: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_s {
    pub d: ngx_pool_data_t,
    pub max: size_t,
    pub current: *mut ngx_pool_t,
    pub chain: *mut ngx_chain_t,
    pub large: *mut ngx_pool_large_t,
    pub cleanup: *mut ngx_pool_cleanup_t,
    pub log: *mut ngx_log_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_cleanup_file_t {
    pub fd: ngx_fd_t,
    pub name: *mut u_char,
    pub log: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_create_pool(size: size_t, log: *mut ngx_log_t) -> *mut ngx_pool_t;
}
extern "C" {
    pub fn ngx_destroy_pool(pool: *mut ngx_pool_t);
}
extern "C" {
    pub fn ngx_reset_pool(pool: *mut ngx_pool_t);
}
extern "C" {
    pub fn ngx_palloc(pool: *mut ngx_pool_t, size: size_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pnalloc(pool: *mut ngx_pool_t, size: size_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pcalloc(pool: *mut ngx_pool_t, size: size_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pmemalign(
        pool: *mut ngx_pool_t,
        size: size_t,
        alignment: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pfree(pool: *mut ngx_pool_t, p: *mut ::aya_bpf::cty::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_pool_cleanup_add(p: *mut ngx_pool_t, size: size_t) -> *mut ngx_pool_cleanup_t;
}
extern "C" {
    pub fn ngx_pool_run_cleanup_file(p: *mut ngx_pool_t, fd: ngx_fd_t);
}
extern "C" {
    pub fn ngx_pool_cleanup_file(data: *mut ::aya_bpf::cty::c_void);
}
extern "C" {
    pub fn ngx_pool_delete_file(data: *mut ::aya_bpf::cty::c_void);
}
pub type ngx_buf_tag_t = *mut ::aya_bpf::cty::c_void;
pub type ngx_buf_t = ngx_buf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_buf_s {
    pub pos: *mut u_char,
    pub last: *mut u_char,
    pub file_pos: off_t,
    pub file_last: off_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
    pub tag: ngx_buf_tag_t,
    pub file: *mut ngx_file_t,
    pub shadow: *mut ngx_buf_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub num: ::aya_bpf::cty::c_int,
}
impl ngx_buf_s {
    #[inline]
    pub fn temporary(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporary(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memory(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memory(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recycled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_recycled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sync(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_buf(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_buf(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_in_chain(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_in_chain(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_shadow(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_shadow(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temp_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        temporary: ::aya_bpf::cty::c_uint,
        memory: ::aya_bpf::cty::c_uint,
        mmap: ::aya_bpf::cty::c_uint,
        recycled: ::aya_bpf::cty::c_uint,
        in_file: ::aya_bpf::cty::c_uint,
        flush: ::aya_bpf::cty::c_uint,
        sync: ::aya_bpf::cty::c_uint,
        last_buf: ::aya_bpf::cty::c_uint,
        last_in_chain: ::aya_bpf::cty::c_uint,
        last_shadow: ::aya_bpf::cty::c_uint,
        temp_file: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let temporary: u32 = unsafe { ::core::mem::transmute(temporary) };
            temporary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let memory: u32 = unsafe { ::core::mem::transmute(memory) };
            memory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mmap: u32 = unsafe { ::core::mem::transmute(mmap) };
            mmap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let recycled: u32 = unsafe { ::core::mem::transmute(recycled) };
            recycled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_file: u32 = unsafe { ::core::mem::transmute(in_file) };
            in_file as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flush: u32 = unsafe { ::core::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sync: u32 = unsafe { ::core::mem::transmute(sync) };
            sync as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let last_buf: u32 = unsafe { ::core::mem::transmute(last_buf) };
            last_buf as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let last_in_chain: u32 = unsafe { ::core::mem::transmute(last_in_chain) };
            last_in_chain as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let last_shadow: u32 = unsafe { ::core::mem::transmute(last_shadow) };
            last_shadow as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let temp_file: u32 = unsafe { ::core::mem::transmute(temp_file) };
            temp_file as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_chain_s {
    pub buf: *mut ngx_buf_t,
    pub next: *mut ngx_chain_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_bufs_t {
    pub num: ngx_int_t,
    pub size: size_t,
}
pub type ngx_output_chain_ctx_t = ngx_output_chain_ctx_s;
pub type ngx_output_chain_filter_pt = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_bpf::cty::c_void, in_: *mut ngx_chain_t) -> ngx_int_t,
>;
pub type ngx_output_chain_aio_pt = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ngx_output_chain_ctx_t, file: *mut ngx_file_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_output_chain_ctx_s {
    pub buf: *mut ngx_buf_t,
    pub in_: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub aio_handler: ngx_output_chain_aio_pt,
    pub aio_preload: ::core::option::Option<unsafe extern "C" fn(file: *mut ngx_buf_t) -> ssize_t>,
    pub thread_handler: ::core::option::Option<
        unsafe extern "C" fn(task: *mut ngx_thread_task_t, file: *mut ngx_file_t) -> ngx_int_t,
    >,
    pub thread_task: *mut ngx_thread_task_t,
    pub alignment: off_t,
    pub pool: *mut ngx_pool_t,
    pub allocated: ngx_int_t,
    pub bufs: ngx_bufs_t,
    pub tag: ngx_buf_tag_t,
    pub output_filter: ngx_output_chain_filter_pt,
    pub filter_ctx: *mut ::aya_bpf::cty::c_void,
}
impl ngx_output_chain_ctx_s {
    #[inline]
    pub fn sendfile(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unaligned(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unaligned(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_in_memory(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_in_memory(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_in_temp(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_in_temp(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sendfile: ::aya_bpf::cty::c_uint,
        directio: ::aya_bpf::cty::c_uint,
        unaligned: ::aya_bpf::cty::c_uint,
        need_in_memory: ::aya_bpf::cty::c_uint,
        need_in_temp: ::aya_bpf::cty::c_uint,
        aio: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sendfile: u32 = unsafe { ::core::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let directio: u32 = unsafe { ::core::mem::transmute(directio) };
            directio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let unaligned: u32 = unsafe { ::core::mem::transmute(unaligned) };
            unaligned as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let need_in_memory: u32 = unsafe { ::core::mem::transmute(need_in_memory) };
            need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let need_in_temp: u32 = unsafe { ::core::mem::transmute(need_in_temp) };
            need_in_temp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let aio: u32 = unsafe { ::core::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_chain_writer_ctx_t {
    pub out: *mut ngx_chain_t,
    pub last: *mut *mut ngx_chain_t,
    pub connection: *mut ngx_connection_t,
    pub pool: *mut ngx_pool_t,
    pub limit: off_t,
}
extern "C" {
    pub fn ngx_create_temp_buf(pool: *mut ngx_pool_t, size: size_t) -> *mut ngx_buf_t;
}
extern "C" {
    pub fn ngx_create_chain_of_bufs(
        pool: *mut ngx_pool_t,
        bufs: *mut ngx_bufs_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_alloc_chain_link(pool: *mut ngx_pool_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_output_chain(ctx: *mut ngx_output_chain_ctx_t, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_writer(ctx: *mut ::aya_bpf::cty::c_void, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_add_copy(
        pool: *mut ngx_pool_t,
        chain: *mut *mut ngx_chain_t,
        in_: *mut ngx_chain_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_get_free_buf(
        p: *mut ngx_pool_t,
        free: *mut *mut ngx_chain_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_chain_update_chains(
        p: *mut ngx_pool_t,
        free: *mut *mut ngx_chain_t,
        busy: *mut *mut ngx_chain_t,
        out: *mut *mut ngx_chain_t,
        tag: ngx_buf_tag_t,
    );
}
extern "C" {
    pub fn ngx_chain_coalesce_file(in_: *mut *mut ngx_chain_t, limit: off_t) -> off_t;
}
extern "C" {
    pub fn ngx_chain_update_sent(in_: *mut ngx_chain_t, sent: off_t) -> *mut ngx_chain_t;
}
pub type ngx_queue_t = ngx_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_queue_s {
    pub prev: *mut ngx_queue_t,
    pub next: *mut ngx_queue_t,
}
extern "C" {
    pub fn ngx_queue_middle(queue: *mut ngx_queue_t) -> *mut ngx_queue_t;
}
extern "C" {
    pub fn ngx_queue_sort(
        queue: *mut ngx_queue_t,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ngx_queue_t, arg2: *const ngx_queue_t) -> ngx_int_t,
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_array_t {
    pub elts: *mut ::aya_bpf::cty::c_void,
    pub nelts: ngx_uint_t,
    pub size: size_t,
    pub nalloc: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
}
extern "C" {
    pub fn ngx_array_create(p: *mut ngx_pool_t, n: ngx_uint_t, size: size_t) -> *mut ngx_array_t;
}
extern "C" {
    pub fn ngx_array_destroy(a: *mut ngx_array_t);
}
extern "C" {
    pub fn ngx_array_push(a: *mut ngx_array_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_array_push_n(a: *mut ngx_array_t, n: ngx_uint_t) -> *mut ::aya_bpf::cty::c_void;
}
pub type ngx_list_part_t = ngx_list_part_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_list_part_s {
    pub elts: *mut ::aya_bpf::cty::c_void,
    pub nelts: ngx_uint_t,
    pub next: *mut ngx_list_part_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_list_t {
    pub last: *mut ngx_list_part_t,
    pub part: ngx_list_part_t,
    pub size: size_t,
    pub nalloc: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
}
extern "C" {
    pub fn ngx_list_create(pool: *mut ngx_pool_t, n: ngx_uint_t, size: size_t) -> *mut ngx_list_t;
}
extern "C" {
    pub fn ngx_list_push(list: *mut ngx_list_t) -> *mut ::aya_bpf::cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_elt_t {
    pub value: *mut ::aya_bpf::cty::c_void,
    pub len: u_short,
    pub name: [u_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_t {
    pub buckets: *mut *mut ngx_hash_elt_t,
    pub size: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_wildcard_t {
    pub hash: ngx_hash_t,
    pub value: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_key_t {
    pub key: ngx_str_t,
    pub key_hash: ngx_uint_t,
    pub value: *mut ::aya_bpf::cty::c_void,
}
pub type ngx_hash_key_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut u_char, len: size_t) -> ngx_uint_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_combined_t {
    pub hash: ngx_hash_t,
    pub wc_head: *mut ngx_hash_wildcard_t,
    pub wc_tail: *mut ngx_hash_wildcard_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_init_t {
    pub hash: *mut ngx_hash_t,
    pub key: ngx_hash_key_pt,
    pub max_size: ngx_uint_t,
    pub bucket_size: ngx_uint_t,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_keys_arrays_t {
    pub hsize: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
    pub keys: ngx_array_t,
    pub keys_hash: *mut ngx_array_t,
    pub dns_wc_head: ngx_array_t,
    pub dns_wc_head_hash: *mut ngx_array_t,
    pub dns_wc_tail: ngx_array_t,
    pub dns_wc_tail_hash: *mut ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_table_elt_t {
    pub hash: ngx_uint_t,
    pub key: ngx_str_t,
    pub value: ngx_str_t,
    pub lowcase_key: *mut u_char,
}
extern "C" {
    pub fn ngx_hash_find(
        hash: *mut ngx_hash_t,
        key: ngx_uint_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_find_wc_head(
        hwc: *mut ngx_hash_wildcard_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_find_wc_tail(
        hwc: *mut ngx_hash_wildcard_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_find_combined(
        hash: *mut ngx_hash_combined_t,
        key: ngx_uint_t,
        name: *mut u_char,
        len: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_init(
        hinit: *mut ngx_hash_init_t,
        names: *mut ngx_hash_key_t,
        nelts: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_wildcard_init(
        hinit: *mut ngx_hash_init_t,
        names: *mut ngx_hash_key_t,
        nelts: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_key(data: *mut u_char, len: size_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_key_lc(data: *mut u_char, len: size_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_strlow(dst: *mut u_char, src: *mut u_char, n: size_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_keys_array_init(
        ha: *mut ngx_hash_keys_arrays_t,
        type_: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_add_key(
        ha: *mut ngx_hash_keys_arrays_t,
        key: *mut ngx_str_t,
        value: *mut ::aya_bpf::cty::c_void,
        flags: ngx_uint_t,
    ) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_file_s {
    pub fd: ngx_fd_t,
    pub name: ngx_str_t,
    pub info: ngx_file_info_t,
    pub offset: off_t,
    pub sys_offset: off_t,
    pub log: *mut ngx_log_t,
    pub thread_handler: ::core::option::Option<
        unsafe extern "C" fn(task: *mut ngx_thread_task_t, file: *mut ngx_file_t) -> ngx_int_t,
    >,
    pub thread_ctx: *mut ::aya_bpf::cty::c_void,
    pub thread_task: *mut ngx_thread_task_t,
    pub aio: *mut ngx_event_aio_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_file_s {
    #[inline]
    pub fn valid_info(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_info(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid_info: ::aya_bpf::cty::c_uint,
        directio: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid_info: u32 = unsafe { ::core::mem::transmute(valid_info) };
            valid_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let directio: u32 = unsafe { ::core::mem::transmute(directio) };
            directio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_path_manager_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void) -> ngx_msec_t>;
pub type ngx_path_purger_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void) -> ngx_msec_t>;
pub type ngx_path_loader_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_path_t {
    pub name: ngx_str_t,
    pub len: size_t,
    pub level: [size_t; 3usize],
    pub manager: ngx_path_manager_pt,
    pub purger: ngx_path_purger_pt,
    pub loader: ngx_path_loader_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub conf_file: *mut u_char,
    pub line: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_path_init_t {
    pub name: ngx_str_t,
    pub level: [size_t; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_temp_file_t {
    pub file: ngx_file_t,
    pub offset: off_t,
    pub path: *mut ngx_path_t,
    pub pool: *mut ngx_pool_t,
    pub warn: *mut ::aya_bpf::cty::c_char,
    pub access: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_temp_file_t {
    #[inline]
    pub fn log_level(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_level(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn persistent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_persistent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clean(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clean(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thread_write(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thread_write(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log_level: ::aya_bpf::cty::c_uint,
        persistent: ::aya_bpf::cty::c_uint,
        clean: ::aya_bpf::cty::c_uint,
        thread_write: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log_level: u32 = unsafe { ::core::mem::transmute(log_level) };
            log_level as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let persistent: u32 = unsafe { ::core::mem::transmute(persistent) };
            persistent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let clean: u32 = unsafe { ::core::mem::transmute(clean) };
            clean as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let thread_write: u32 = unsafe { ::core::mem::transmute(thread_write) };
            thread_write as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ext_rename_file_t {
    pub access: ngx_uint_t,
    pub path_access: ngx_uint_t,
    pub time: time_t,
    pub fd: ngx_fd_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log: *mut ngx_log_t,
}
impl ngx_ext_rename_file_t {
    #[inline]
    pub fn create_path(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_create_path(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delete_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delete_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        create_path: ::aya_bpf::cty::c_uint,
        delete_file: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let create_path: u32 = unsafe { ::core::mem::transmute(create_path) };
            create_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let delete_file: u32 = unsafe { ::core::mem::transmute(delete_file) };
            delete_file as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_copy_file_t {
    pub size: off_t,
    pub buf_size: size_t,
    pub access: ngx_uint_t,
    pub time: time_t,
    pub log: *mut ngx_log_t,
}
pub type ngx_tree_ctx_t = ngx_tree_ctx_s;
pub type ngx_tree_init_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_bpf::cty::c_void,
        prev: *mut ::aya_bpf::cty::c_void,
    ) -> ngx_int_t,
>;
pub type ngx_tree_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ngx_tree_ctx_t, name: *mut ngx_str_t) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_tree_ctx_s {
    pub size: off_t,
    pub fs_size: off_t,
    pub access: ngx_uint_t,
    pub mtime: time_t,
    pub init_handler: ngx_tree_init_handler_pt,
    pub file_handler: ngx_tree_handler_pt,
    pub pre_tree_handler: ngx_tree_handler_pt,
    pub post_tree_handler: ngx_tree_handler_pt,
    pub spec_handler: ngx_tree_handler_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub alloc: size_t,
    pub log: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_get_full_name(
        pool: *mut ngx_pool_t,
        prefix: *mut ngx_str_t,
        name: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_write_chain_to_temp_file(
        tf: *mut ngx_temp_file_t,
        chain: *mut ngx_chain_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_create_temp_file(
        file: *mut ngx_file_t,
        path: *mut ngx_path_t,
        pool: *mut ngx_pool_t,
        persistent: ngx_uint_t,
        clean: ngx_uint_t,
        access: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_hashed_filename(path: *mut ngx_path_t, file: *mut u_char, len: size_t);
}
extern "C" {
    pub fn ngx_create_path(file: *mut ngx_file_t, path: *mut ngx_path_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_full_path(dir: *mut u_char, access: ngx_uint_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_add_path(cf: *mut ngx_conf_t, slot: *mut *mut ngx_path_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_paths(cycle: *mut ngx_cycle_t, user: ngx_uid_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ext_rename_file(
        src: *mut ngx_str_t,
        to: *mut ngx_str_t,
        ext: *mut ngx_ext_rename_file_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_copy_file(from: *mut u_char, to: *mut u_char, cf: *mut ngx_copy_file_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_walk_tree(ctx: *mut ngx_tree_ctx_t, tree: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_next_temp_number(collision: ngx_uint_t) -> ngx_atomic_uint_t;
}
extern "C" {
    pub fn ngx_conf_set_path_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_merge_path_value(
        cf: *mut ngx_conf_t,
        path: *mut *mut ngx_path_t,
        prev: *mut ngx_path_t,
        init: *mut ngx_path_init_t,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_access_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_temp_number: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_random_number: ngx_atomic_int_t;
}
extern "C" {
    pub static mut ngx_crc32_table_short: *mut u32;
}
extern "C" {
    pub static mut ngx_crc32_table256: [u32; 0usize];
}
extern "C" {
    pub fn ngx_crc32_table_init() -> ngx_int_t;
}
extern "C" {
    pub fn ngx_murmur_hash2(data: *mut u_char, len: size_t) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre {
    _unused: [u8; 0],
}
pub type pcre = real_pcre;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre_extra {
    pub flags: ::aya_bpf::cty::c_ulong,
    pub study_data: *mut ::aya_bpf::cty::c_void,
    pub match_limit: ::aya_bpf::cty::c_ulong,
    pub callout_data: *mut ::aya_bpf::cty::c_void,
    pub tables: *const ::aya_bpf::cty::c_uchar,
    pub match_limit_recursion: ::aya_bpf::cty::c_ulong,
    pub mark: *mut *mut ::aya_bpf::cty::c_uchar,
    pub executable_jit: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_t {
    pub code: *mut pcre,
    pub extra: *mut pcre_extra,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_compile_t {
    pub pattern: ngx_str_t,
    pub pool: *mut ngx_pool_t,
    pub options: ngx_int_t,
    pub regex: *mut ngx_regex_t,
    pub captures: ::aya_bpf::cty::c_int,
    pub named_captures: ::aya_bpf::cty::c_int,
    pub name_size: ::aya_bpf::cty::c_int,
    pub names: *mut u_char,
    pub err: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_elt_t {
    pub regex: *mut ngx_regex_t,
    pub name: *mut u_char,
}
extern "C" {
    pub fn ngx_regex_init();
}
extern "C" {
    pub fn ngx_regex_compile(rc: *mut ngx_regex_compile_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_regex_exec_array(
        a: *mut ngx_array_t,
        s: *mut ngx_str_t,
        log: *mut ngx_log_t,
    ) -> ngx_int_t;
}
pub type ngx_radix_node_t = ngx_radix_node_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_radix_node_s {
    pub right: *mut ngx_radix_node_t,
    pub left: *mut ngx_radix_node_t,
    pub parent: *mut ngx_radix_node_t,
    pub value: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_radix_tree_t {
    pub root: *mut ngx_radix_node_t,
    pub pool: *mut ngx_pool_t,
    pub free: *mut ngx_radix_node_t,
    pub start: *mut ::aya_bpf::cty::c_char,
    pub size: size_t,
}
extern "C" {
    pub fn ngx_radix_tree_create(
        pool: *mut ngx_pool_t,
        preallocate: ngx_int_t,
    ) -> *mut ngx_radix_tree_t;
}
extern "C" {
    pub fn ngx_radix32tree_insert(
        tree: *mut ngx_radix_tree_t,
        key: u32,
        mask: u32,
        value: usize,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix32tree_delete(tree: *mut ngx_radix_tree_t, key: u32, mask: u32) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix32tree_find(tree: *mut ngx_radix_tree_t, key: u32) -> usize;
}
extern "C" {
    pub fn ngx_radix128tree_insert(
        tree: *mut ngx_radix_tree_t,
        key: *mut u_char,
        mask: *mut u_char,
        value: usize,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix128tree_delete(
        tree: *mut ngx_radix_tree_t,
        key: *mut u_char,
        mask: *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix128tree_find(tree: *mut ngx_radix_tree_t, key: *mut u_char) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_time_t {
    pub sec: time_t,
    pub msec: ngx_uint_t,
    pub gmtoff: ngx_int_t,
}
extern "C" {
    pub fn ngx_time_init();
}
extern "C" {
    pub fn ngx_time_update();
}
extern "C" {
    pub fn ngx_time_sigsafe_update();
}
extern "C" {
    pub fn ngx_http_time(buf: *mut u_char, t: time_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_cookie_time(buf: *mut u_char, t: time_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_gmtime(t: time_t, tp: *mut ngx_tm_t);
}
extern "C" {
    pub fn ngx_next_time(when: time_t) -> time_t;
}
extern "C" {
    pub static mut ngx_cached_time: *mut ngx_time_t;
}
extern "C" {
    pub static mut ngx_cached_err_log_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_log_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_log_iso8601: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_syslog_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_current_msec: ngx_msec_t;
}
extern "C" {
    pub fn ngx_rwlock_wlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_rlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_unlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_downgrade(lock: *mut ngx_atomic_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_shmtx_sh_t {
    pub lock: ngx_atomic_t,
    pub wait: ngx_atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_shmtx_t {
    pub lock: *mut ngx_atomic_t,
    pub wait: *mut ngx_atomic_t,
    pub semaphore: ngx_uint_t,
    pub sem: sem_t,
    pub spin: ngx_uint_t,
}
extern "C" {
    pub fn ngx_shmtx_create(
        mtx: *mut ngx_shmtx_t,
        addr: *mut ngx_shmtx_sh_t,
        name: *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_shmtx_destroy(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_trylock(mtx: *mut ngx_shmtx_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_shmtx_lock(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_unlock(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_force_unlock(mtx: *mut ngx_shmtx_t, pid: ngx_pid_t) -> ngx_uint_t;
}
pub type ngx_slab_page_t = ngx_slab_page_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_slab_page_s {
    pub slab: usize,
    pub next: *mut ngx_slab_page_t,
    pub prev: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_slab_stat_t {
    pub total: ngx_uint_t,
    pub used: ngx_uint_t,
    pub reqs: ngx_uint_t,
    pub fails: ngx_uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_slab_pool_t {
    pub lock: ngx_shmtx_sh_t,
    pub min_size: size_t,
    pub min_shift: size_t,
    pub pages: *mut ngx_slab_page_t,
    pub last: *mut ngx_slab_page_t,
    pub free: ngx_slab_page_t,
    pub stats: *mut ngx_slab_stat_t,
    pub pfree: ngx_uint_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
    pub mutex: ngx_shmtx_t,
    pub log_ctx: *mut u_char,
    pub zero: u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub addr: *mut ::aya_bpf::cty::c_void,
}
impl ngx_slab_pool_t {
    #[inline]
    pub fn log_nomem(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log_nomem(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log_nomem: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let log_nomem: u32 = unsafe { ::core::mem::transmute(log_nomem) };
            log_nomem as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_slab_sizes_init();
}
extern "C" {
    pub fn ngx_slab_init(pool: *mut ngx_slab_pool_t);
}
extern "C" {
    pub fn ngx_slab_alloc(pool: *mut ngx_slab_pool_t, size: size_t) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_alloc_locked(
        pool: *mut ngx_slab_pool_t,
        size: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_calloc(pool: *mut ngx_slab_pool_t, size: size_t)
        -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_calloc_locked(
        pool: *mut ngx_slab_pool_t,
        size: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_free(pool: *mut ngx_slab_pool_t, p: *mut ::aya_bpf::cty::c_void);
}
extern "C" {
    pub fn ngx_slab_free_locked(pool: *mut ngx_slab_pool_t, p: *mut ::aya_bpf::cty::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_sockaddr_t {
    pub sockaddr: sockaddr,
    pub sockaddr_in: sockaddr_in,
    pub sockaddr_in6: sockaddr_in6,
    pub sockaddr_un: sockaddr_un,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_in_cidr_t {
    pub addr: in_addr_t,
    pub mask: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_in6_cidr_t {
    pub addr: in6_addr,
    pub mask: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_cidr_t {
    pub family: ngx_uint_t,
    pub u: ngx_cidr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_cidr_t__bindgen_ty_1 {
    pub in_: ngx_in_cidr_t,
    pub in6: ngx_in6_cidr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_addr_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_url_t {
    pub url: ngx_str_t,
    pub host: ngx_str_t,
    pub port_text: ngx_str_t,
    pub uri: ngx_str_t,
    pub port: in_port_t,
    pub default_port: in_port_t,
    pub family: ::aya_bpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub socklen: socklen_t,
    pub sockaddr: ngx_sockaddr_t,
    pub addrs: *mut ngx_addr_t,
    pub naddrs: ngx_uint_t,
    pub err: *mut ::aya_bpf::cty::c_char,
}
impl ngx_url_t {
    #[inline]
    pub fn listen(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_part(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri_part(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_resolve(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_resolve(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_port(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_port(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        listen: ::aya_bpf::cty::c_uint,
        uri_part: ::aya_bpf::cty::c_uint,
        no_resolve: ::aya_bpf::cty::c_uint,
        no_port: ::aya_bpf::cty::c_uint,
        wildcard: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let listen: u32 = unsafe { ::core::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uri_part: u32 = unsafe { ::core::mem::transmute(uri_part) };
            uri_part as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_resolve: u32 = unsafe { ::core::mem::transmute(no_resolve) };
            no_resolve as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_port: u32 = unsafe { ::core::mem::transmute(no_port) };
            no_port as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wildcard: u32 = unsafe { ::core::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_inet_addr(text: *mut u_char, len: size_t) -> in_addr_t;
}
extern "C" {
    pub fn ngx_inet6_addr(p: *mut u_char, len: size_t, addr: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet6_ntop(p: *mut u_char, text: *mut u_char, len: size_t) -> size_t;
}
extern "C" {
    pub fn ngx_sock_ntop(
        sa: *mut sockaddr,
        socklen: socklen_t,
        text: *mut u_char,
        len: size_t,
        port: ngx_uint_t,
    ) -> size_t;
}
extern "C" {
    pub fn ngx_inet_ntop(
        family: ::aya_bpf::cty::c_int,
        addr: *mut ::aya_bpf::cty::c_void,
        text: *mut u_char,
        len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn ngx_ptocidr(text: *mut ngx_str_t, cidr: *mut ngx_cidr_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cidr_match(sa: *mut sockaddr, cidrs: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_addr(
        pool: *mut ngx_pool_t,
        addr: *mut ngx_addr_t,
        text: *mut u_char,
        len: size_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_addr_port(
        pool: *mut ngx_pool_t,
        addr: *mut ngx_addr_t,
        text: *mut u_char,
        len: size_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_url(pool: *mut ngx_pool_t, u: *mut ngx_url_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet_resolve_host(pool: *mut ngx_pool_t, u: *mut ngx_url_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cmp_sockaddr(
        sa1: *mut sockaddr,
        slen1: socklen_t,
        sa2: *mut sockaddr,
        slen2: socklen_t,
        cmp_port: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet_get_port(sa: *mut sockaddr) -> in_port_t;
}
extern "C" {
    pub fn ngx_inet_set_port(sa: *mut sockaddr, port: in_port_t);
}
pub type ngx_shm_zone_t = ngx_shm_zone_s;
pub type ngx_shm_zone_init_pt = ::core::option::Option<
    unsafe extern "C" fn(zone: *mut ngx_shm_zone_t, data: *mut ::aya_bpf::cty::c_void) -> ngx_int_t,
>;
pub type ngx_log_intercept_pt = ::core::option::Option<
    unsafe extern "C" fn(
        log: *mut ngx_log_t,
        level: ngx_uint_t,
        buf: *mut u_char,
        len: size_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_shm_zone_s {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub shm: ngx_shm_t,
    pub init: ngx_shm_zone_init_pt,
    pub tag: *mut ::aya_bpf::cty::c_void,
    pub noreuse: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_cycle_s {
    pub conf_ctx: *mut *mut *mut *mut ::aya_bpf::cty::c_void,
    pub pool: *mut ngx_pool_t,
    pub log: *mut ngx_log_t,
    pub new_log: ngx_log_t,
    pub log_use_stderr: ngx_uint_t,
    pub files: *mut *mut ngx_connection_t,
    pub free_connections: *mut ngx_connection_t,
    pub free_connection_n: ngx_uint_t,
    pub modules: *mut *mut ngx_module_t,
    pub modules_n: ngx_uint_t,
    pub modules_used: ngx_uint_t,
    pub reusable_connections_queue: ngx_queue_t,
    pub reusable_connections_n: ngx_uint_t,
    pub listening: ngx_array_t,
    pub paths: ngx_array_t,
    pub config_dump: ngx_array_t,
    pub config_dump_rbtree: ngx_rbtree_t,
    pub config_dump_sentinel: ngx_rbtree_node_t,
    pub open_files: ngx_list_t,
    pub shared_memory: ngx_list_t,
    pub connection_n: ngx_uint_t,
    pub files_n: ngx_uint_t,
    pub connections: *mut ngx_connection_t,
    pub read_events: *mut ngx_event_t,
    pub write_events: *mut ngx_event_t,
    pub old_cycle: *mut ngx_cycle_t,
    pub conf_file: ngx_str_t,
    pub conf_param: ngx_str_t,
    pub conf_prefix: ngx_str_t,
    pub prefix: ngx_str_t,
    pub lock_file: ngx_str_t,
    pub hostname: ngx_str_t,
    pub intercept_error_log_handler: ngx_log_intercept_pt,
    pub intercept_error_log_data: *mut ::aya_bpf::cty::c_void,
    pub entered_logger: ::aya_bpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_core_conf_t {
    pub daemon: ngx_flag_t,
    pub master: ngx_flag_t,
    pub privileged_agent: ngx_flag_t,
    pub timer_resolution: ngx_msec_t,
    pub shutdown_timeout: ngx_msec_t,
    pub worker_processes: ngx_int_t,
    pub debug_points: ngx_int_t,
    pub rlimit_nofile: ngx_int_t,
    pub rlimit_core: off_t,
    pub priority: ::aya_bpf::cty::c_int,
    pub cpu_affinity_auto: ngx_uint_t,
    pub cpu_affinity_n: ngx_uint_t,
    pub cpu_affinity: *mut ngx_cpuset_t,
    pub username: *mut ::aya_bpf::cty::c_char,
    pub user: ngx_uid_t,
    pub group: ngx_gid_t,
    pub working_directory: ngx_str_t,
    pub lock_file: ngx_str_t,
    pub pid: ngx_str_t,
    pub oldpid: ngx_str_t,
    pub env: ngx_array_t,
    pub environment: *mut *mut ::aya_bpf::cty::c_char,
}
extern "C" {
    pub fn ngx_init_cycle(old_cycle: *mut ngx_cycle_t) -> *mut ngx_cycle_t;
}
extern "C" {
    pub fn ngx_create_pidfile(name: *mut ngx_str_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_delete_pidfile(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_signal_process(
        cycle: *mut ngx_cycle_t,
        sig: *mut ::aya_bpf::cty::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_reopen_files(cycle: *mut ngx_cycle_t, user: ngx_uid_t);
}
extern "C" {
    pub fn ngx_set_environment(
        cycle: *mut ngx_cycle_t,
        last: *mut ngx_uint_t,
    ) -> *mut *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_exec_new_binary(
        cycle: *mut ngx_cycle_t,
        argv: *const *mut ::aya_bpf::cty::c_char,
    ) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_get_cpu_affinity(n: ngx_uint_t) -> *mut ngx_cpuset_t;
}
extern "C" {
    pub fn ngx_shared_memory_add(
        cf: *mut ngx_conf_t,
        name: *mut ngx_str_t,
        size: size_t,
        tag: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ngx_shm_zone_t;
}
extern "C" {
    pub fn ngx_set_shutdown_timer(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_cycle: *mut ngx_cycle_t;
}
extern "C" {
    pub static mut ngx_old_cycles: ngx_array_t;
}
extern "C" {
    pub static mut ngx_core_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_test_config: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_dump_config: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_quiet_mode: ngx_uint_t;
}
pub type ngx_resolver_t = ngx_resolver_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_connection_t {
    pub udp: *mut ngx_connection_t,
    pub tcp: *mut ngx_connection_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub server: ngx_str_t,
    pub log: ngx_log_t,
    pub read_buf: *mut ngx_buf_t,
    pub write_buf: *mut ngx_buf_t,
    pub resolver: *mut ngx_resolver_t,
}
pub type ngx_resolver_ctx_t = ngx_resolver_ctx_s;
pub type ngx_resolver_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ngx_resolver_ctx_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_addr_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_srv_t {
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
    pub port: u_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_srv_name_t {
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
    pub port: u_short,
    pub ctx: *mut ngx_resolver_ctx_t,
    pub state: ngx_int_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_resolver_node_t {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub name: *mut u_char,
    pub addr6: in6_addr,
    pub nlen: u_short,
    pub qlen: u_short,
    pub query: *mut u_char,
    pub query6: *mut u_char,
    pub u: ngx_resolver_node_t__bindgen_ty_1,
    pub code: u_char,
    pub naddrs: u_short,
    pub nsrvs: u_short,
    pub cnlen: u_short,
    pub u6: ngx_resolver_node_t__bindgen_ty_2,
    pub naddrs6: u_short,
    pub expire: time_t,
    pub valid: time_t,
    pub ttl: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub last_connection: ngx_uint_t,
    pub waiting: *mut ngx_resolver_ctx_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_resolver_node_t__bindgen_ty_1 {
    pub addr: in_addr_t,
    pub addrs: *mut in_addr_t,
    pub cname: *mut u_char,
    pub srvs: *mut ngx_resolver_srv_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_resolver_node_t__bindgen_ty_2 {
    pub addr6: in6_addr,
    pub addrs6: *mut in6_addr,
}
impl ngx_resolver_node_t {
    #[inline]
    pub fn tcp(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp6(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp6(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcp: ::aya_bpf::cty::c_uint,
        tcp6: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tcp: u32 = unsafe { ::core::mem::transmute(tcp) };
            tcp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tcp6: u32 = unsafe { ::core::mem::transmute(tcp6) };
            tcp6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_s {
    pub event: *mut ngx_event_t,
    pub dummy: *mut ::aya_bpf::cty::c_void,
    pub log: *mut ngx_log_t,
    pub ident: ngx_int_t,
    pub connections: ngx_array_t,
    pub last_connection: ngx_uint_t,
    pub name_rbtree: ngx_rbtree_t,
    pub name_sentinel: ngx_rbtree_node_t,
    pub srv_rbtree: ngx_rbtree_t,
    pub srv_sentinel: ngx_rbtree_node_t,
    pub addr_rbtree: ngx_rbtree_t,
    pub addr_sentinel: ngx_rbtree_node_t,
    pub name_resend_queue: ngx_queue_t,
    pub srv_resend_queue: ngx_queue_t,
    pub addr_resend_queue: ngx_queue_t,
    pub name_expire_queue: ngx_queue_t,
    pub srv_expire_queue: ngx_queue_t,
    pub addr_expire_queue: ngx_queue_t,
    pub ipv6: ngx_uint_t,
    pub addr6_rbtree: ngx_rbtree_t,
    pub addr6_sentinel: ngx_rbtree_node_t,
    pub addr6_resend_queue: ngx_queue_t,
    pub addr6_expire_queue: ngx_queue_t,
    pub resend_timeout: time_t,
    pub tcp_timeout: time_t,
    pub expire: time_t,
    pub valid: time_t,
    pub log_level: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_ctx_s {
    pub next: *mut ngx_resolver_ctx_t,
    pub resolver: *mut ngx_resolver_t,
    pub node: *mut ngx_resolver_node_t,
    pub ident: ngx_int_t,
    pub state: ngx_int_t,
    pub name: ngx_str_t,
    pub service: ngx_str_t,
    pub valid: time_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_resolver_addr_t,
    pub addr: ngx_resolver_addr_t,
    pub sin: sockaddr_in,
    pub count: ngx_uint_t,
    pub nsrvs: ngx_uint_t,
    pub srvs: *mut ngx_resolver_srv_name_t,
    pub handler: ngx_resolver_handler_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub timeout: ngx_msec_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub recursion: ngx_uint_t,
    pub event: *mut ngx_event_t,
}
impl ngx_resolver_ctx_s {
    #[inline]
    pub fn quick(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quick(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancelable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancelable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        quick: ::aya_bpf::cty::c_uint,
        async_: ::aya_bpf::cty::c_uint,
        cancelable: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let quick: u32 = unsafe { ::core::mem::transmute(quick) };
            quick as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_: u32 = unsafe { ::core::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cancelable: u32 = unsafe { ::core::mem::transmute(cancelable) };
            cancelable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_resolver_create(
        cf: *mut ngx_conf_t,
        names: *mut ngx_str_t,
        n: ngx_uint_t,
    ) -> *mut ngx_resolver_t;
}
extern "C" {
    pub fn ngx_resolve_start(
        r: *mut ngx_resolver_t,
        temp: *mut ngx_resolver_ctx_t,
    ) -> *mut ngx_resolver_ctx_t;
}
extern "C" {
    pub fn ngx_resolve_name(ctx: *mut ngx_resolver_ctx_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_resolve_name_done(ctx: *mut ngx_resolver_ctx_t);
}
extern "C" {
    pub fn ngx_resolve_addr(ctx: *mut ngx_resolver_ctx_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_resolve_addr_done(ctx: *mut ngx_resolver_ctx_t);
}
extern "C" {
    pub fn ngx_resolver_strerror(err: ngx_int_t) -> *mut ::aya_bpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_cache_manager_ctx_t {
    pub handler: ngx_event_handler_pt,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub delay: ngx_msec_t,
}
extern "C" {
    pub fn ngx_master_process_cycle(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_single_process_cycle(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_process: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_worker: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_new_binary: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_inherited: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_daemonized: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_exiting: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_is_privileged_agent: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_reap: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_sigio: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_sigalrm: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_quit: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_debug_quit: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_terminate: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_noaccept: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_reconfigure: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_reopen: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_change_binary: sig_atomic_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_command_s {
    pub name: ngx_str_t,
    pub type_: ngx_uint_t,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            cmd: *mut ngx_command_t,
            conf: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub conf: ngx_uint_t,
    pub offset: ngx_uint_t,
    pub post: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_s {
    pub fd: ngx_fd_t,
    pub name: ngx_str_t,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(file: *mut ngx_open_file_t, log: *mut ngx_log_t),
    >,
    pub data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_file_t {
    pub file: ngx_file_t,
    pub buffer: *mut ngx_buf_t,
    pub dump: *mut ngx_buf_t,
    pub line: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_dump_t {
    pub name: ngx_str_t,
    pub buffer: *mut ngx_buf_t,
}
pub type ngx_conf_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        cf: *mut ngx_conf_t,
        dummy: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_s {
    pub name: *mut ::aya_bpf::cty::c_char,
    pub args: *mut ngx_array_t,
    pub cycle: *mut ngx_cycle_t,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
    pub conf_file: *mut ngx_conf_file_t,
    pub log: *mut ngx_log_t,
    pub ctx: *mut ::aya_bpf::cty::c_void,
    pub module_type: ngx_uint_t,
    pub cmd_type: ngx_uint_t,
    pub handler: ngx_conf_handler_pt,
    pub handler_conf: *mut ::aya_bpf::cty::c_char,
}
pub type ngx_conf_post_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        cf: *mut ngx_conf_t,
        data: *mut ::aya_bpf::cty::c_void,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_post_t {
    pub post_handler: ngx_conf_post_handler_pt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_deprecated_t {
    pub post_handler: ngx_conf_post_handler_pt,
    pub old_name: *mut ::aya_bpf::cty::c_char,
    pub new_name: *mut ::aya_bpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_num_bounds_t {
    pub post_handler: ngx_conf_post_handler_pt,
    pub low: ngx_int_t,
    pub high: ngx_int_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_enum_t {
    pub name: ngx_str_t,
    pub value: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_bitmask_t {
    pub name: ngx_str_t,
    pub mask: ngx_uint_t,
}
extern "C" {
    pub fn ngx_conf_deprecated(
        cf: *mut ngx_conf_t,
        post: *mut ::aya_bpf::cty::c_void,
        data: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_check_num_bounds(
        cf: *mut ngx_conf_t,
        post: *mut ::aya_bpf::cty::c_void,
        data: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_param(cf: *mut ngx_conf_t) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_parse(
        cf: *mut ngx_conf_t,
        filename: *mut ngx_str_t,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_include(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_full_name(
        cycle: *mut ngx_cycle_t,
        name: *mut ngx_str_t,
        conf_prefix: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_conf_open_file(
        cycle: *mut ngx_cycle_t,
        name: *mut ngx_str_t,
    ) -> *mut ngx_open_file_t;
}
extern "C" {
    pub fn ngx_conf_log_error(
        level: ngx_uint_t,
        cf: *mut ngx_conf_t,
        err: ngx_err_t,
        fmt: *const ::aya_bpf::cty::c_char,
        ...
    );
}
extern "C" {
    pub fn ngx_conf_set_flag_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_str_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_str_array_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_keyval_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_num_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_size_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_off_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_msec_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_sec_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_bufs_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_enum_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_bitmask_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_module_s {
    pub ctx_index: ngx_uint_t,
    pub index: ngx_uint_t,
    pub name: *mut ::aya_bpf::cty::c_char,
    pub spare0: ngx_uint_t,
    pub spare1: ngx_uint_t,
    pub version: ngx_uint_t,
    pub signature: *const ::aya_bpf::cty::c_char,
    pub ctx: *mut ::aya_bpf::cty::c_void,
    pub commands: *mut ngx_command_t,
    pub type_: ngx_uint_t,
    pub init_master: ::core::option::Option<unsafe extern "C" fn(log: *mut ngx_log_t) -> ngx_int_t>,
    pub init_module:
        ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub init_process:
        ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub init_thread:
        ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub exit_thread: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub exit_process: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub exit_master: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub spare_hook0: usize,
    pub spare_hook1: usize,
    pub spare_hook2: usize,
    pub spare_hook3: usize,
    pub spare_hook4: usize,
    pub spare_hook5: usize,
    pub spare_hook6: usize,
    pub spare_hook7: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_core_module_t {
    pub name: ngx_str_t,
    pub create_conf: ::core::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub init_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cycle: *mut ngx_cycle_t,
            conf: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
}
extern "C" {
    pub fn ngx_preinit_modules() -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cycle_modules(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_init_modules(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_count_modules(cycle: *mut ngx_cycle_t, type_: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_add_module(
        cf: *mut ngx_conf_t,
        file: *mut ngx_str_t,
        module: *mut ngx_module_t,
        order: *mut *mut ::aya_bpf::cty::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_modules: [*mut ngx_module_t; 0usize];
}
extern "C" {
    pub static mut ngx_max_module: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_module_names: [*mut ::aya_bpf::cty::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_info_t {
    pub fd: ngx_fd_t,
    pub uniq: ngx_file_uniq_t,
    pub mtime: time_t,
    pub size: off_t,
    pub fs_size: off_t,
    pub directio: off_t,
    pub read_ahead: size_t,
    pub err: ngx_err_t,
    pub failed: *mut ::aya_bpf::cty::c_char,
    pub valid: time_t,
    pub min_uses: ngx_uint_t,
    pub disable_symlinks_from: size_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_open_file_info_t {
    #[inline]
    pub fn disable_symlinks(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_disable_symlinks(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn test_dir(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test_dir(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test_only(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test_only(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errors(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errors(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn events(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_events(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dir(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dir(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_link(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_link(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_exec(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_exec(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_directio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_directio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_symlinks: ::aya_bpf::cty::c_uint,
        test_dir: ::aya_bpf::cty::c_uint,
        test_only: ::aya_bpf::cty::c_uint,
        log: ::aya_bpf::cty::c_uint,
        errors: ::aya_bpf::cty::c_uint,
        events: ::aya_bpf::cty::c_uint,
        is_dir: ::aya_bpf::cty::c_uint,
        is_file: ::aya_bpf::cty::c_uint,
        is_link: ::aya_bpf::cty::c_uint,
        is_exec: ::aya_bpf::cty::c_uint,
        is_directio: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let disable_symlinks: u32 = unsafe { ::core::mem::transmute(disable_symlinks) };
            disable_symlinks as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test_dir: u32 = unsafe { ::core::mem::transmute(test_dir) };
            test_dir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let test_only: u32 = unsafe { ::core::mem::transmute(test_only) };
            test_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let log: u32 = unsafe { ::core::mem::transmute(log) };
            log as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let errors: u32 = unsafe { ::core::mem::transmute(errors) };
            errors as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let events: u32 = unsafe { ::core::mem::transmute(events) };
            events as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_dir: u32 = unsafe { ::core::mem::transmute(is_dir) };
            is_dir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_file: u32 = unsafe { ::core::mem::transmute(is_file) };
            is_file as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_link: u32 = unsafe { ::core::mem::transmute(is_link) };
            is_link as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_exec: u32 = unsafe { ::core::mem::transmute(is_exec) };
            is_exec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_directio: u32 = unsafe { ::core::mem::transmute(is_directio) };
            is_directio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_cached_open_file_t = ngx_cached_open_file_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_cached_open_file_s {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub name: *mut u_char,
    pub created: time_t,
    pub accessed: time_t,
    pub fd: ngx_fd_t,
    pub uniq: ngx_file_uniq_t,
    pub mtime: time_t,
    pub size: off_t,
    pub err: ngx_err_t,
    pub uses: u32,
    pub disable_symlinks_from: size_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub event: *mut ngx_event_t,
}
impl ngx_cached_open_file_s {
    #[inline]
    pub fn disable_symlinks(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_disable_symlinks(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn close(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_event(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_event(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dir(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dir(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_link(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_link(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_exec(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_exec(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_directio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_directio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_symlinks: ::aya_bpf::cty::c_uint,
        count: ::aya_bpf::cty::c_uint,
        close: ::aya_bpf::cty::c_uint,
        use_event: ::aya_bpf::cty::c_uint,
        is_dir: ::aya_bpf::cty::c_uint,
        is_file: ::aya_bpf::cty::c_uint,
        is_link: ::aya_bpf::cty::c_uint,
        is_exec: ::aya_bpf::cty::c_uint,
        is_directio: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let disable_symlinks: u32 = unsafe { ::core::mem::transmute(disable_symlinks) };
            disable_symlinks as u64
        });
        __bindgen_bitfield_unit.set(2usize, 24u8, {
            let count: u32 = unsafe { ::core::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let close: u32 = unsafe { ::core::mem::transmute(close) };
            close as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let use_event: u32 = unsafe { ::core::mem::transmute(use_event) };
            use_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let is_dir: u32 = unsafe { ::core::mem::transmute(is_dir) };
            is_dir as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let is_file: u32 = unsafe { ::core::mem::transmute(is_file) };
            is_file as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_link: u32 = unsafe { ::core::mem::transmute(is_link) };
            is_link as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_exec: u32 = unsafe { ::core::mem::transmute(is_exec) };
            is_exec as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let is_directio: u32 = unsafe { ::core::mem::transmute(is_directio) };
            is_directio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_t {
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub expire_queue: ngx_queue_t,
    pub current: ngx_uint_t,
    pub max: ngx_uint_t,
    pub inactive: time_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_cleanup_t {
    pub cache: *mut ngx_open_file_cache_t,
    pub file: *mut ngx_cached_open_file_t,
    pub min_uses: ngx_uint_t,
    pub log: *mut ngx_log_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_event_t {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub read: *mut ngx_event_t,
    pub write: *mut ngx_event_t,
    pub fd: ngx_fd_t,
    pub file: *mut ngx_cached_open_file_t,
    pub cache: *mut ngx_open_file_cache_t,
}
extern "C" {
    pub fn ngx_open_file_cache_init(
        pool: *mut ngx_pool_t,
        max: ngx_uint_t,
        inactive: time_t,
    ) -> *mut ngx_open_file_cache_t;
}
extern "C" {
    pub fn ngx_open_cached_file(
        cache: *mut ngx_open_file_cache_t,
        name: *mut ngx_str_t,
        of: *mut ngx_open_file_info_t,
        pool: *mut ngx_pool_t,
    ) -> ngx_int_t;
}
pub type ngx_recv_pt = ::core::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t,
>;
pub type ngx_recv_chain_pt = ::core::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> ssize_t,
>;
pub type ngx_send_pt = ::core::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t,
>;
pub type ngx_send_chain_pt = ::core::option::Option<
    unsafe extern "C" fn(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_os_io_t {
    pub recv: ngx_recv_pt,
    pub recv_chain: ngx_recv_chain_pt,
    pub udp_recv: ngx_recv_pt,
    pub send: ngx_send_pt,
    pub udp_send: ngx_send_pt,
    pub udp_send_chain: ngx_send_chain_pt,
    pub send_chain: ngx_send_chain_pt,
    pub flags: ngx_uint_t,
}
extern "C" {
    pub fn ngx_os_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_status(log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_os_specific_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_specific_status(log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_daemon(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_signal_process(
        cycle: *mut ngx_cycle_t,
        sig: *mut ::aya_bpf::cty::c_char,
        pid: ngx_pid_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_unix_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_readv_chain(
        c: *mut ngx_connection_t,
        entry: *mut ngx_chain_t,
        limit: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ngx_udp_unix_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_unix_send(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_writev_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_udp_unix_send(c: *mut ngx_connection_t, buf: *mut u_char, size: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_udp_unix_sendmsg_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_iovec_t {
    pub iovs: *mut iovec,
    pub count: ngx_uint_t,
    pub size: size_t,
    pub nalloc: ngx_uint_t,
}
extern "C" {
    pub fn ngx_output_chain_to_iovec(
        vec: *mut ngx_iovec_t,
        in_: *mut ngx_chain_t,
        limit: size_t,
        log: *mut ngx_log_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_writev(c: *mut ngx_connection_t, vec: *mut ngx_iovec_t) -> ssize_t;
}
extern "C" {
    pub static mut ngx_os_io: ngx_os_io_t;
}
extern "C" {
    pub static mut ngx_ncpu: ngx_int_t;
}
extern "C" {
    pub static mut ngx_max_sockets: ngx_int_t;
}
extern "C" {
    pub static mut ngx_inherited_nonblocking: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_tcp_nodelay_and_tcp_nopush: ngx_uint_t;
}
extern "C" {
    pub fn ngx_linux_sendfile_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
pub type ngx_listening_t = ngx_listening_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_listening_s {
    pub fd: ngx_socket_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text_max_len: size_t,
    pub addr_text: ngx_str_t,
    pub type_: ::aya_bpf::cty::c_int,
    pub backlog: ::aya_bpf::cty::c_int,
    pub rcvbuf: ::aya_bpf::cty::c_int,
    pub sndbuf: ::aya_bpf::cty::c_int,
    pub keepidle: ::aya_bpf::cty::c_int,
    pub keepintvl: ::aya_bpf::cty::c_int,
    pub keepcnt: ::aya_bpf::cty::c_int,
    pub handler: ngx_connection_handler_pt,
    pub servers: *mut ::aya_bpf::cty::c_void,
    pub log: ngx_log_t,
    pub logp: *mut ngx_log_t,
    pub pool_size: size_t,
    pub post_accept_buffer_size: size_t,
    pub post_accept_timeout: ngx_msec_t,
    pub previous: *mut ngx_listening_t,
    pub connection: *mut ngx_connection_t,
    pub worker: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub fastopen: ::aya_bpf::cty::c_int,
}
impl ngx_listening_s {
    #[inline]
    pub fn open(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_open(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remain(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remain(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bound(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bound(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherited(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inherited(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonblocking_accept(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonblocking_accept(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn listen(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonblocking(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonblocking(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr_ntop(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_addr_ntop(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6only(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6only(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_reuseport(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_reuseport(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delete_deferred(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delete_deferred(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_deferred(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_deferred(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        open: ::aya_bpf::cty::c_uint,
        remain: ::aya_bpf::cty::c_uint,
        ignore: ::aya_bpf::cty::c_uint,
        bound: ::aya_bpf::cty::c_uint,
        inherited: ::aya_bpf::cty::c_uint,
        nonblocking_accept: ::aya_bpf::cty::c_uint,
        listen: ::aya_bpf::cty::c_uint,
        nonblocking: ::aya_bpf::cty::c_uint,
        shared: ::aya_bpf::cty::c_uint,
        addr_ntop: ::aya_bpf::cty::c_uint,
        wildcard: ::aya_bpf::cty::c_uint,
        ipv6only: ::aya_bpf::cty::c_uint,
        reuseport: ::aya_bpf::cty::c_uint,
        add_reuseport: ::aya_bpf::cty::c_uint,
        keepalive: ::aya_bpf::cty::c_uint,
        deferred_accept: ::aya_bpf::cty::c_uint,
        delete_deferred: ::aya_bpf::cty::c_uint,
        add_deferred: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let open: u32 = unsafe { ::core::mem::transmute(open) };
            open as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let remain: u32 = unsafe { ::core::mem::transmute(remain) };
            remain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ignore: u32 = unsafe { ::core::mem::transmute(ignore) };
            ignore as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bound: u32 = unsafe { ::core::mem::transmute(bound) };
            bound as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let inherited: u32 = unsafe { ::core::mem::transmute(inherited) };
            inherited as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nonblocking_accept: u32 = unsafe { ::core::mem::transmute(nonblocking_accept) };
            nonblocking_accept as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let listen: u32 = unsafe { ::core::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nonblocking: u32 = unsafe { ::core::mem::transmute(nonblocking) };
            nonblocking as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let shared: u32 = unsafe { ::core::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let addr_ntop: u32 = unsafe { ::core::mem::transmute(addr_ntop) };
            addr_ntop as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wildcard: u32 = unsafe { ::core::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ipv6only: u32 = unsafe { ::core::mem::transmute(ipv6only) };
            ipv6only as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reuseport: u32 = unsafe { ::core::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let add_reuseport: u32 = unsafe { ::core::mem::transmute(add_reuseport) };
            add_reuseport as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let keepalive: u32 = unsafe { ::core::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::core::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let delete_deferred: u32 = unsafe { ::core::mem::transmute(delete_deferred) };
            delete_deferred as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let add_deferred: u32 = unsafe { ::core::mem::transmute(add_deferred) };
            add_deferred as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ngx_connection_log_error_e_NGX_ERROR_ALERT: ngx_connection_log_error_e = 0;
pub const ngx_connection_log_error_e_NGX_ERROR_ERR: ngx_connection_log_error_e = 1;
pub const ngx_connection_log_error_e_NGX_ERROR_INFO: ngx_connection_log_error_e = 2;
pub const ngx_connection_log_error_e_NGX_ERROR_IGNORE_ECONNRESET: ngx_connection_log_error_e = 3;
pub const ngx_connection_log_error_e_NGX_ERROR_IGNORE_EINVAL: ngx_connection_log_error_e = 4;
pub type ngx_connection_log_error_e = ::aya_bpf::cty::c_uint;
pub const ngx_connection_tcp_nodelay_e_NGX_TCP_NODELAY_UNSET: ngx_connection_tcp_nodelay_e = 0;
pub const ngx_connection_tcp_nodelay_e_NGX_TCP_NODELAY_SET: ngx_connection_tcp_nodelay_e = 1;
pub const ngx_connection_tcp_nodelay_e_NGX_TCP_NODELAY_DISABLED: ngx_connection_tcp_nodelay_e = 2;
pub type ngx_connection_tcp_nodelay_e = ::aya_bpf::cty::c_uint;
pub const ngx_connection_tcp_nopush_e_NGX_TCP_NOPUSH_UNSET: ngx_connection_tcp_nopush_e = 0;
pub const ngx_connection_tcp_nopush_e_NGX_TCP_NOPUSH_SET: ngx_connection_tcp_nopush_e = 1;
pub const ngx_connection_tcp_nopush_e_NGX_TCP_NOPUSH_DISABLED: ngx_connection_tcp_nopush_e = 2;
pub type ngx_connection_tcp_nopush_e = ::aya_bpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_connection_s {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub read: *mut ngx_event_t,
    pub write: *mut ngx_event_t,
    pub fd: ngx_socket_t,
    pub recv: ngx_recv_pt,
    pub send: ngx_send_pt,
    pub recv_chain: ngx_recv_chain_pt,
    pub send_chain: ngx_send_chain_pt,
    pub listening: *mut ngx_listening_t,
    pub sent: off_t,
    pub log: *mut ngx_log_t,
    pub pool: *mut ngx_pool_t,
    pub type_: ::aya_bpf::cty::c_int,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text: ngx_str_t,
    pub proxy_protocol_addr: ngx_str_t,
    pub proxy_protocol_port: in_port_t,
    pub ssl: *mut ngx_ssl_connection_t,
    pub local_sockaddr: *mut sockaddr,
    pub local_socklen: socklen_t,
    pub buffer: *mut ngx_buf_t,
    pub queue: ngx_queue_t,
    pub number: ngx_atomic_uint_t,
    pub requests: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sendfile_task: *mut ngx_thread_task_t,
}
impl ngx_connection_s {
    #[inline]
    pub fn buffered(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_buffered(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn log_error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_log_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn timedout(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timedout(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn destroyed(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_destroyed(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idle(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reusable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reusable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sendfile(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sndlowat(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sndlowat(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp_nodelay(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_nodelay(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp_nopush(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_nopush(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn need_last_buf(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_last_buf(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn busy_count(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_busy_count(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        buffered: ::aya_bpf::cty::c_uint,
        log_error: ::aya_bpf::cty::c_uint,
        timedout: ::aya_bpf::cty::c_uint,
        error: ::aya_bpf::cty::c_uint,
        destroyed: ::aya_bpf::cty::c_uint,
        idle: ::aya_bpf::cty::c_uint,
        reusable: ::aya_bpf::cty::c_uint,
        close: ::aya_bpf::cty::c_uint,
        shared: ::aya_bpf::cty::c_uint,
        sendfile: ::aya_bpf::cty::c_uint,
        sndlowat: ::aya_bpf::cty::c_uint,
        tcp_nodelay: ::aya_bpf::cty::c_uint,
        tcp_nopush: ::aya_bpf::cty::c_uint,
        need_last_buf: ::aya_bpf::cty::c_uint,
        busy_count: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let buffered: u32 = unsafe { ::core::mem::transmute(buffered) };
            buffered as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let log_error: u32 = unsafe { ::core::mem::transmute(log_error) };
            log_error as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timedout: u32 = unsafe { ::core::mem::transmute(timedout) };
            timedout as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let destroyed: u32 = unsafe { ::core::mem::transmute(destroyed) };
            destroyed as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let idle: u32 = unsafe { ::core::mem::transmute(idle) };
            idle as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reusable: u32 = unsafe { ::core::mem::transmute(reusable) };
            reusable as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let close: u32 = unsafe { ::core::mem::transmute(close) };
            close as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let shared: u32 = unsafe { ::core::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sendfile: u32 = unsafe { ::core::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sndlowat: u32 = unsafe { ::core::mem::transmute(sndlowat) };
            sndlowat as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let tcp_nodelay: u32 = unsafe { ::core::mem::transmute(tcp_nodelay) };
            tcp_nodelay as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let tcp_nopush: u32 = unsafe { ::core::mem::transmute(tcp_nopush) };
            tcp_nopush as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let need_last_buf: u32 = unsafe { ::core::mem::transmute(need_last_buf) };
            need_last_buf as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let busy_count: u32 = unsafe { ::core::mem::transmute(busy_count) };
            busy_count as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_create_listening(
        cf: *mut ngx_conf_t,
        sockaddr: *mut sockaddr,
        socklen: socklen_t,
    ) -> *mut ngx_listening_t;
}
extern "C" {
    pub fn ngx_clone_listening(cf: *mut ngx_conf_t, ls: *mut ngx_listening_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_set_inherited_sockets(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_open_listening_sockets(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_configure_listening_sockets(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_close_listening_sockets(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_close_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_close_idle_connections(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_connection_local_sockaddr(
        c: *mut ngx_connection_t,
        s: *mut ngx_str_t,
        port: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_tcp_nodelay(c: *mut ngx_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_connection_error(
        c: *mut ngx_connection_t,
        err: ngx_err_t,
        text: *mut ::aya_bpf::cty::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_get_connection(s: ngx_socket_t, log: *mut ngx_log_t) -> *mut ngx_connection_t;
}
extern "C" {
    pub fn ngx_free_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_reusable_connection(c: *mut ngx_connection_t, reusable: ngx_uint_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_syslog_peer_t {
    pub pool: *mut ngx_pool_t,
    pub facility: ngx_uint_t,
    pub severity: ngx_uint_t,
    pub tag: ngx_str_t,
    pub server: ngx_addr_t,
    pub conn: ngx_connection_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_syslog_peer_t {
    #[inline]
    pub fn busy(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohostname(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nohostname(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        busy: ::aya_bpf::cty::c_uint,
        nohostname: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let busy: u32 = unsafe { ::core::mem::transmute(busy) };
            busy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohostname: u32 = unsafe { ::core::mem::transmute(nohostname) };
            nohostname as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_syslog_process_conf(
        cf: *mut ngx_conf_t,
        peer: *mut ngx_syslog_peer_t,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_syslog_add_header(peer: *mut ngx_syslog_peer_t, buf: *mut u_char) -> *mut u_char;
}
extern "C" {
    pub fn ngx_syslog_writer(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: size_t);
}
extern "C" {
    pub fn ngx_syslog_send(peer: *mut ngx_syslog_peer_t, buf: *mut u_char, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn ngx_proxy_protocol_read(
        c: *mut ngx_connection_t,
        buf: *mut u_char,
        last: *mut u_char,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_proxy_protocol_write(
        c: *mut ngx_connection_t,
        buf: *mut u_char,
        last: *mut u_char,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_cpuinfo();
}
pub type ngx_http_request_t = ngx_http_request_s;
pub type ngx_http_upstream_t = ngx_http_upstream_s;
pub type ngx_http_cache_t = ngx_http_cache_s;
pub type ngx_http_file_cache_t = ngx_http_file_cache_s;
pub type ngx_http_log_ctx_t = ngx_http_log_ctx_s;
pub type ngx_http_chunked_t = ngx_http_chunked_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_stream_s {
    _unused: [u8; 0],
}
pub type ngx_http_v2_stream_t = ngx_http_v2_stream_s;
pub type ngx_http_header_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        h: *mut ngx_table_elt_t,
        offset: ngx_uint_t,
    ) -> ngx_int_t,
>;
pub type ngx_http_log_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        sr: *mut ngx_http_request_t,
        buf: *mut u_char,
        len: size_t,
    ) -> *mut u_char,
>;
pub type ngx_http_variable_value_t = ngx_variable_value_t;
pub type ngx_http_variable_t = ngx_http_variable_s;
pub type ngx_http_set_variable_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        v: *mut ngx_http_variable_value_t,
        data: usize,
    ),
>;
pub type ngx_http_get_variable_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        v: *mut ngx_http_variable_value_t,
        data: usize,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_variable_s {
    pub name: ngx_str_t,
    pub set_handler: ngx_http_set_variable_pt,
    pub get_handler: ngx_http_get_variable_pt,
    pub data: usize,
    pub flags: ngx_uint_t,
    pub index: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_add_variable(
        cf: *mut ngx_conf_t,
        name: *mut ngx_str_t,
        flags: ngx_uint_t,
    ) -> *mut ngx_http_variable_t;
}
extern "C" {
    pub fn ngx_http_get_variable_index(cf: *mut ngx_conf_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_get_indexed_variable(
        r: *mut ngx_http_request_t,
        index: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_get_flushed_variable(
        r: *mut ngx_http_request_t,
        index: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_get_variable(
        r: *mut ngx_http_request_t,
        name: *mut ngx_str_t,
        key: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_variable_unknown_header(
        v: *mut ngx_http_variable_value_t,
        var: *mut ngx_str_t,
        part: *mut ngx_list_part_t,
        prefix: size_t,
    ) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_regex_variable_t {
    pub capture: ngx_uint_t,
    pub index: ngx_int_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_regex_t {
    pub regex: *mut ngx_regex_t,
    pub ncaptures: ngx_uint_t,
    pub variables: *mut ngx_http_regex_variable_t,
    pub nvariables: ngx_uint_t,
    pub name: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_map_regex_t {
    pub regex: *mut ngx_http_regex_t,
    pub value: *mut ::aya_bpf::cty::c_void,
}
extern "C" {
    pub fn ngx_http_regex_compile(
        cf: *mut ngx_conf_t,
        rc: *mut ngx_regex_compile_t,
    ) -> *mut ngx_http_regex_t;
}
extern "C" {
    pub fn ngx_http_regex_exec(
        r: *mut ngx_http_request_t,
        re: *mut ngx_http_regex_t,
        s: *mut ngx_str_t,
    ) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_map_t {
    pub hash: ngx_hash_combined_t,
    pub regex: *mut ngx_http_map_regex_t,
    pub nregex: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_map_find(
        r: *mut ngx_http_request_t,
        map: *mut ngx_http_map_t,
        match_: *mut ngx_str_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_variables_add_core_vars(cf: *mut ngx_conf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_variables_init_vars(cf: *mut ngx_conf_t) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_variable_null_value: ngx_http_variable_value_t;
}
extern "C" {
    pub static mut ngx_http_variable_true_value: ngx_http_variable_value_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_conf_ctx_t {
    pub main_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub srv_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub loc_conf: *mut *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_module_t {
    pub preconfiguration:
        ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> ngx_int_t>,
    pub postconfiguration:
        ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> ngx_int_t>,
    pub create_main_conf: ::core::option::Option<
        unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub init_main_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            conf: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub create_srv_conf: ::core::option::Option<
        unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub merge_srv_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            prev: *mut ::aya_bpf::cty::c_void,
            conf: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub create_loc_conf: ::core::option::Option<
        unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub merge_loc_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            prev: *mut ::aya_bpf::cty::c_void,
            conf: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
}
pub const ngx_http_state_e_NGX_HTTP_INITING_REQUEST_STATE: ngx_http_state_e = 0;
pub const ngx_http_state_e_NGX_HTTP_READING_REQUEST_STATE: ngx_http_state_e = 1;
pub const ngx_http_state_e_NGX_HTTP_PROCESS_REQUEST_STATE: ngx_http_state_e = 2;
pub const ngx_http_state_e_NGX_HTTP_CONNECT_UPSTREAM_STATE: ngx_http_state_e = 3;
pub const ngx_http_state_e_NGX_HTTP_WRITING_UPSTREAM_STATE: ngx_http_state_e = 4;
pub const ngx_http_state_e_NGX_HTTP_READING_UPSTREAM_STATE: ngx_http_state_e = 5;
pub const ngx_http_state_e_NGX_HTTP_WRITING_REQUEST_STATE: ngx_http_state_e = 6;
pub const ngx_http_state_e_NGX_HTTP_LINGERING_CLOSE_STATE: ngx_http_state_e = 7;
pub const ngx_http_state_e_NGX_HTTP_KEEPALIVE_STATE: ngx_http_state_e = 8;
pub type ngx_http_state_e = ::aya_bpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_header_t {
    pub name: ngx_str_t,
    pub offset: ngx_uint_t,
    pub handler: ngx_http_header_handler_pt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_header_out_t {
    pub name: ngx_str_t,
    pub offset: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_headers_in_t {
    pub headers: ngx_list_t,
    pub host: *mut ngx_table_elt_t,
    pub connection: *mut ngx_table_elt_t,
    pub if_modified_since: *mut ngx_table_elt_t,
    pub if_unmodified_since: *mut ngx_table_elt_t,
    pub if_match: *mut ngx_table_elt_t,
    pub if_none_match: *mut ngx_table_elt_t,
    pub user_agent: *mut ngx_table_elt_t,
    pub referer: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub content_range: *mut ngx_table_elt_t,
    pub content_type: *mut ngx_table_elt_t,
    pub range: *mut ngx_table_elt_t,
    pub if_range: *mut ngx_table_elt_t,
    pub transfer_encoding: *mut ngx_table_elt_t,
    pub expect: *mut ngx_table_elt_t,
    pub upgrade: *mut ngx_table_elt_t,
    pub accept_encoding: *mut ngx_table_elt_t,
    pub via: *mut ngx_table_elt_t,
    pub authorization: *mut ngx_table_elt_t,
    pub keep_alive: *mut ngx_table_elt_t,
    pub x_forwarded_for: ngx_array_t,
    pub x_real_ip: *mut ngx_table_elt_t,
    pub accept: *mut ngx_table_elt_t,
    pub accept_language: *mut ngx_table_elt_t,
    pub depth: *mut ngx_table_elt_t,
    pub destination: *mut ngx_table_elt_t,
    pub overwrite: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub user: ngx_str_t,
    pub passwd: ngx_str_t,
    pub cookies: ngx_array_t,
    pub server: ngx_str_t,
    pub content_length_n: off_t,
    pub keep_alive_n: time_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_headers_in_t {
    #[inline]
    pub fn connection_type(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_connection_type(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msie(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msie6(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie6(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opera(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_opera(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gecko(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gecko(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chrome(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chrome(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn safari(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_safari(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn konqueror(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_konqueror(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connection_type: ::aya_bpf::cty::c_uint,
        chunked: ::aya_bpf::cty::c_uint,
        msie: ::aya_bpf::cty::c_uint,
        msie6: ::aya_bpf::cty::c_uint,
        opera: ::aya_bpf::cty::c_uint,
        gecko: ::aya_bpf::cty::c_uint,
        chrome: ::aya_bpf::cty::c_uint,
        safari: ::aya_bpf::cty::c_uint,
        konqueror: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let connection_type: u32 = unsafe { ::core::mem::transmute(connection_type) };
            connection_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let chunked: u32 = unsafe { ::core::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let msie: u32 = unsafe { ::core::mem::transmute(msie) };
            msie as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let msie6: u32 = unsafe { ::core::mem::transmute(msie6) };
            msie6 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let opera: u32 = unsafe { ::core::mem::transmute(opera) };
            opera as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let gecko: u32 = unsafe { ::core::mem::transmute(gecko) };
            gecko as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let chrome: u32 = unsafe { ::core::mem::transmute(chrome) };
            chrome as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let safari: u32 = unsafe { ::core::mem::transmute(safari) };
            safari as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let konqueror: u32 = unsafe { ::core::mem::transmute(konqueror) };
            konqueror as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_headers_out_t {
    pub headers: ngx_list_t,
    pub trailers: ngx_list_t,
    pub status: ngx_uint_t,
    pub status_line: ngx_str_t,
    pub server: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub content_encoding: *mut ngx_table_elt_t,
    pub location: *mut ngx_table_elt_t,
    pub refresh: *mut ngx_table_elt_t,
    pub last_modified: *mut ngx_table_elt_t,
    pub content_range: *mut ngx_table_elt_t,
    pub accept_ranges: *mut ngx_table_elt_t,
    pub www_authenticate: *mut ngx_table_elt_t,
    pub expires: *mut ngx_table_elt_t,
    pub etag: *mut ngx_table_elt_t,
    pub override_charset: *mut ngx_str_t,
    pub content_type_len: size_t,
    pub content_type: ngx_str_t,
    pub charset: ngx_str_t,
    pub content_type_lowcase: *mut u_char,
    pub content_type_hash: ngx_uint_t,
    pub cache_control: ngx_array_t,
    pub content_length_n: off_t,
    pub content_offset: off_t,
    pub date_time: time_t,
    pub last_modified_time: time_t,
}
pub type ngx_http_client_body_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_request_body_t {
    pub temp_file: *mut ngx_temp_file_t,
    pub bufs: *mut ngx_chain_t,
    pub buf: *mut ngx_buf_t,
    pub rest: off_t,
    pub received: off_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub chunked: *mut ngx_http_chunked_t,
    pub post_handler: ngx_http_client_body_handler_pt,
}
pub type ngx_http_addr_conf_t = ngx_http_addr_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_connection_t {
    pub addr_conf: *mut ngx_http_addr_conf_t,
    pub conf_ctx: *mut ngx_http_conf_ctx_t,
    pub ssl_servername: *mut ngx_str_t,
    pub ssl_servername_regex: *mut ngx_http_regex_t,
    pub busy: *mut ngx_chain_t,
    pub nbusy: ngx_int_t,
    pub free: *mut ngx_chain_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_connection_t {
    #[inline]
    pub fn ssl(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssl: ::aya_bpf::cty::c_uint,
        proxy_protocol: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::core::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_cleanup_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void)>;
pub type ngx_http_cleanup_t = ngx_http_cleanup_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cleanup_s {
    pub handler: ngx_http_cleanup_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub next: *mut ngx_http_cleanup_t,
}
pub type ngx_http_post_subrequest_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        data: *mut ::aya_bpf::cty::c_void,
        rc: ngx_int_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_post_subrequest_t {
    pub handler: ngx_http_post_subrequest_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
}
pub type ngx_http_postponed_request_t = ngx_http_postponed_request_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_postponed_request_s {
    pub request: *mut ngx_http_request_t,
    pub out: *mut ngx_chain_t,
    pub next: *mut ngx_http_postponed_request_t,
}
pub type ngx_http_posted_request_t = ngx_http_posted_request_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_posted_request_s {
    pub request: *mut ngx_http_request_t,
    pub next: *mut ngx_http_posted_request_t,
}
pub type ngx_http_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>;
pub type ngx_http_event_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_request_s {
    pub signature: u32,
    pub connection: *mut ngx_connection_t,
    pub ctx: *mut *mut ::aya_bpf::cty::c_void,
    pub main_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub srv_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub loc_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub read_event_handler: ngx_http_event_handler_pt,
    pub write_event_handler: ngx_http_event_handler_pt,
    pub cache: *mut ngx_http_cache_t,
    pub upstream: *mut ngx_http_upstream_t,
    pub upstream_states: *mut ngx_array_t,
    pub pool: *mut ngx_pool_t,
    pub header_in: *mut ngx_buf_t,
    pub headers_in: ngx_http_headers_in_t,
    pub headers_out: ngx_http_headers_out_t,
    pub request_body: *mut ngx_http_request_body_t,
    pub lingering_time: time_t,
    pub start_sec: time_t,
    pub start_msec: ngx_msec_t,
    pub method: ngx_uint_t,
    pub http_version: ngx_uint_t,
    pub request_line: ngx_str_t,
    pub uri: ngx_str_t,
    pub args: ngx_str_t,
    pub exten: ngx_str_t,
    pub unparsed_uri: ngx_str_t,
    pub method_name: ngx_str_t,
    pub http_protocol: ngx_str_t,
    pub out: *mut ngx_chain_t,
    pub main: *mut ngx_http_request_t,
    pub parent: *mut ngx_http_request_t,
    pub postponed: *mut ngx_http_postponed_request_t,
    pub post_subrequest: *mut ngx_http_post_subrequest_t,
    pub posted_requests: *mut ngx_http_posted_request_t,
    pub phase_handler: ngx_int_t,
    pub content_handler: ngx_http_handler_pt,
    pub access_code: ngx_uint_t,
    pub variables: *mut ngx_http_variable_value_t,
    pub ncaptures: ngx_uint_t,
    pub captures: *mut ::aya_bpf::cty::c_int,
    pub captures_data: *mut u_char,
    pub limit_rate: size_t,
    pub limit_rate_after: size_t,
    pub header_size: size_t,
    pub request_length: off_t,
    pub err_status: ngx_uint_t,
    pub http_connection: *mut ngx_http_connection_t,
    pub stream: *mut ngx_http_v2_stream_t,
    pub log_handler: ngx_http_log_handler_pt,
    pub cleanup: *mut ngx_http_cleanup_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 14usize]>,
    pub state: ngx_uint_t,
    pub header_hash: ngx_uint_t,
    pub lowcase_index: ngx_uint_t,
    pub lowcase_header: [u_char; 32usize],
    pub header_name_start: *mut u_char,
    pub header_name_end: *mut u_char,
    pub header_start: *mut u_char,
    pub header_end: *mut u_char,
    pub uri_start: *mut u_char,
    pub uri_end: *mut u_char,
    pub uri_ext: *mut u_char,
    pub args_start: *mut u_char,
    pub request_start: *mut u_char,
    pub request_end: *mut u_char,
    pub method_end: *mut u_char,
    pub schema_start: *mut u_char,
    pub schema_end: *mut u_char,
    pub host_start: *mut u_char,
    pub host_end: *mut u_char,
    pub port_start: *mut u_char,
    pub port_end: *mut u_char,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl ngx_http_request_s {
    #[inline]
    pub fn count(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequests(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_subrequests(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn blocked(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http_state(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_http_state(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn complex_uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complex_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quoted_uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quoted_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plus_in_uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plus_in_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn space_in_uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_space_in_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid_header(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid_header(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_uri_to_alias(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_uri_to_alias(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_location(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_location(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_unparsed_uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_unparsed_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_changed(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri_changed(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_changes(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_uri_changes(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_single_buf(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_single_buf(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_file_only(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_file_only(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_persistent_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_persistent_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_clean_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_clean_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_file_group_access(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_file_group_access(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_file_log_level(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_file_log_level(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_no_buffering(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_no_buffering(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequest_in_memory(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subrequest_in_memory(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waited(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waited(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cached(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_tested(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_tested(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_ok(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_ok(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_vary(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_vary(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bypass_cache(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bypass_cache(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cache(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cache(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_conn_set(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_conn_set(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_req_set(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(69usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_req_set(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(69usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pipeline(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(70usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pipeline(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(70usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_only(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_only(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expect_trailers(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(73usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expect_trailers(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(73usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lingering_close(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lingering_close(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn discard_body(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discard_body(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reading_body(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reading_body(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn internal(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_internal(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_page(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_page(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_finalize(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_finalize(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn post_action(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_post_action(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_complete(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_complete(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_output(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_output(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_sent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_sent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expect_tested(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expect_tested(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_tested(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_tested(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn done(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_done(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn logged(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logged(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn buffered(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(89usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_buffered(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(89usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn main_filter_need_in_memory(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(93usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_filter_need_in_memory(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(93usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_need_in_memory(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(94usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_in_memory(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(94usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_need_temporary(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(95usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_temporary(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(95usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserve_body(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_preserve_body(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_ranges(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(97usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_ranges(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(97usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequest_ranges(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(98usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subrequest_ranges(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(98usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_range(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(99usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single_range(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(99usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_not_modified(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(100usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_not_modified(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(100usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_reading(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(101usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_reading(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(101usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_writing(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(102usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_writing(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(102usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_processing(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(103usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_processing(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(103usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(104usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(104usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn health_check(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(105usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_health_check(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(105usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: ::aya_bpf::cty::c_uint,
        subrequests: ::aya_bpf::cty::c_uint,
        blocked: ::aya_bpf::cty::c_uint,
        aio: ::aya_bpf::cty::c_uint,
        http_state: ::aya_bpf::cty::c_uint,
        complex_uri: ::aya_bpf::cty::c_uint,
        quoted_uri: ::aya_bpf::cty::c_uint,
        plus_in_uri: ::aya_bpf::cty::c_uint,
        space_in_uri: ::aya_bpf::cty::c_uint,
        invalid_header: ::aya_bpf::cty::c_uint,
        add_uri_to_alias: ::aya_bpf::cty::c_uint,
        valid_location: ::aya_bpf::cty::c_uint,
        valid_unparsed_uri: ::aya_bpf::cty::c_uint,
        uri_changed: ::aya_bpf::cty::c_uint,
        uri_changes: ::aya_bpf::cty::c_uint,
        request_body_in_single_buf: ::aya_bpf::cty::c_uint,
        request_body_in_file_only: ::aya_bpf::cty::c_uint,
        request_body_in_persistent_file: ::aya_bpf::cty::c_uint,
        request_body_in_clean_file: ::aya_bpf::cty::c_uint,
        request_body_file_group_access: ::aya_bpf::cty::c_uint,
        request_body_file_log_level: ::aya_bpf::cty::c_uint,
        request_body_no_buffering: ::aya_bpf::cty::c_uint,
        subrequest_in_memory: ::aya_bpf::cty::c_uint,
        waited: ::aya_bpf::cty::c_uint,
        cached: ::aya_bpf::cty::c_uint,
        gzip_tested: ::aya_bpf::cty::c_uint,
        gzip_ok: ::aya_bpf::cty::c_uint,
        gzip_vary: ::aya_bpf::cty::c_uint,
        proxy: ::aya_bpf::cty::c_uint,
        bypass_cache: ::aya_bpf::cty::c_uint,
        no_cache: ::aya_bpf::cty::c_uint,
        limit_conn_set: ::aya_bpf::cty::c_uint,
        limit_req_set: ::aya_bpf::cty::c_uint,
        pipeline: ::aya_bpf::cty::c_uint,
        chunked: ::aya_bpf::cty::c_uint,
        header_only: ::aya_bpf::cty::c_uint,
        expect_trailers: ::aya_bpf::cty::c_uint,
        keepalive: ::aya_bpf::cty::c_uint,
        lingering_close: ::aya_bpf::cty::c_uint,
        discard_body: ::aya_bpf::cty::c_uint,
        reading_body: ::aya_bpf::cty::c_uint,
        internal: ::aya_bpf::cty::c_uint,
        error_page: ::aya_bpf::cty::c_uint,
        filter_finalize: ::aya_bpf::cty::c_uint,
        post_action: ::aya_bpf::cty::c_uint,
        request_complete: ::aya_bpf::cty::c_uint,
        request_output: ::aya_bpf::cty::c_uint,
        header_sent: ::aya_bpf::cty::c_uint,
        expect_tested: ::aya_bpf::cty::c_uint,
        root_tested: ::aya_bpf::cty::c_uint,
        done: ::aya_bpf::cty::c_uint,
        logged: ::aya_bpf::cty::c_uint,
        buffered: ::aya_bpf::cty::c_uint,
        main_filter_need_in_memory: ::aya_bpf::cty::c_uint,
        filter_need_in_memory: ::aya_bpf::cty::c_uint,
        filter_need_temporary: ::aya_bpf::cty::c_uint,
        preserve_body: ::aya_bpf::cty::c_uint,
        allow_ranges: ::aya_bpf::cty::c_uint,
        subrequest_ranges: ::aya_bpf::cty::c_uint,
        single_range: ::aya_bpf::cty::c_uint,
        disable_not_modified: ::aya_bpf::cty::c_uint,
        stat_reading: ::aya_bpf::cty::c_uint,
        stat_writing: ::aya_bpf::cty::c_uint,
        stat_processing: ::aya_bpf::cty::c_uint,
        background: ::aya_bpf::cty::c_uint,
        health_check: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 14usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 14usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let count: u32 = unsafe { ::core::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let subrequests: u32 = unsafe { ::core::mem::transmute(subrequests) };
            subrequests as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let blocked: u32 = unsafe { ::core::mem::transmute(blocked) };
            blocked as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let aio: u32 = unsafe { ::core::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit.set(33usize, 4u8, {
            let http_state: u32 = unsafe { ::core::mem::transmute(http_state) };
            http_state as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let complex_uri: u32 = unsafe { ::core::mem::transmute(complex_uri) };
            complex_uri as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let quoted_uri: u32 = unsafe { ::core::mem::transmute(quoted_uri) };
            quoted_uri as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let plus_in_uri: u32 = unsafe { ::core::mem::transmute(plus_in_uri) };
            plus_in_uri as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let space_in_uri: u32 = unsafe { ::core::mem::transmute(space_in_uri) };
            space_in_uri as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let invalid_header: u32 = unsafe { ::core::mem::transmute(invalid_header) };
            invalid_header as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let add_uri_to_alias: u32 = unsafe { ::core::mem::transmute(add_uri_to_alias) };
            add_uri_to_alias as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let valid_location: u32 = unsafe { ::core::mem::transmute(valid_location) };
            valid_location as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let valid_unparsed_uri: u32 = unsafe { ::core::mem::transmute(valid_unparsed_uri) };
            valid_unparsed_uri as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let uri_changed: u32 = unsafe { ::core::mem::transmute(uri_changed) };
            uri_changed as u64
        });
        __bindgen_bitfield_unit.set(46usize, 4u8, {
            let uri_changes: u32 = unsafe { ::core::mem::transmute(uri_changes) };
            uri_changes as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let request_body_in_single_buf: u32 =
                unsafe { ::core::mem::transmute(request_body_in_single_buf) };
            request_body_in_single_buf as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let request_body_in_file_only: u32 =
                unsafe { ::core::mem::transmute(request_body_in_file_only) };
            request_body_in_file_only as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let request_body_in_persistent_file: u32 =
                unsafe { ::core::mem::transmute(request_body_in_persistent_file) };
            request_body_in_persistent_file as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let request_body_in_clean_file: u32 =
                unsafe { ::core::mem::transmute(request_body_in_clean_file) };
            request_body_in_clean_file as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let request_body_file_group_access: u32 =
                unsafe { ::core::mem::transmute(request_body_file_group_access) };
            request_body_file_group_access as u64
        });
        __bindgen_bitfield_unit.set(55usize, 3u8, {
            let request_body_file_log_level: u32 =
                unsafe { ::core::mem::transmute(request_body_file_log_level) };
            request_body_file_log_level as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let request_body_no_buffering: u32 =
                unsafe { ::core::mem::transmute(request_body_no_buffering) };
            request_body_no_buffering as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let subrequest_in_memory: u32 = unsafe { ::core::mem::transmute(subrequest_in_memory) };
            subrequest_in_memory as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let waited: u32 = unsafe { ::core::mem::transmute(waited) };
            waited as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let cached: u32 = unsafe { ::core::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let gzip_tested: u32 = unsafe { ::core::mem::transmute(gzip_tested) };
            gzip_tested as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let gzip_ok: u32 = unsafe { ::core::mem::transmute(gzip_ok) };
            gzip_ok as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let gzip_vary: u32 = unsafe { ::core::mem::transmute(gzip_vary) };
            gzip_vary as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let proxy: u32 = unsafe { ::core::mem::transmute(proxy) };
            proxy as u64
        });
        __bindgen_bitfield_unit.set(66usize, 1u8, {
            let bypass_cache: u32 = unsafe { ::core::mem::transmute(bypass_cache) };
            bypass_cache as u64
        });
        __bindgen_bitfield_unit.set(67usize, 1u8, {
            let no_cache: u32 = unsafe { ::core::mem::transmute(no_cache) };
            no_cache as u64
        });
        __bindgen_bitfield_unit.set(68usize, 1u8, {
            let limit_conn_set: u32 = unsafe { ::core::mem::transmute(limit_conn_set) };
            limit_conn_set as u64
        });
        __bindgen_bitfield_unit.set(69usize, 1u8, {
            let limit_req_set: u32 = unsafe { ::core::mem::transmute(limit_req_set) };
            limit_req_set as u64
        });
        __bindgen_bitfield_unit.set(70usize, 1u8, {
            let pipeline: u32 = unsafe { ::core::mem::transmute(pipeline) };
            pipeline as u64
        });
        __bindgen_bitfield_unit.set(71usize, 1u8, {
            let chunked: u32 = unsafe { ::core::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit.set(72usize, 1u8, {
            let header_only: u32 = unsafe { ::core::mem::transmute(header_only) };
            header_only as u64
        });
        __bindgen_bitfield_unit.set(73usize, 1u8, {
            let expect_trailers: u32 = unsafe { ::core::mem::transmute(expect_trailers) };
            expect_trailers as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let keepalive: u32 = unsafe { ::core::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(75usize, 1u8, {
            let lingering_close: u32 = unsafe { ::core::mem::transmute(lingering_close) };
            lingering_close as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let discard_body: u32 = unsafe { ::core::mem::transmute(discard_body) };
            discard_body as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let reading_body: u32 = unsafe { ::core::mem::transmute(reading_body) };
            reading_body as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let internal: u32 = unsafe { ::core::mem::transmute(internal) };
            internal as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let error_page: u32 = unsafe { ::core::mem::transmute(error_page) };
            error_page as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let filter_finalize: u32 = unsafe { ::core::mem::transmute(filter_finalize) };
            filter_finalize as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let post_action: u32 = unsafe { ::core::mem::transmute(post_action) };
            post_action as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let request_complete: u32 = unsafe { ::core::mem::transmute(request_complete) };
            request_complete as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let request_output: u32 = unsafe { ::core::mem::transmute(request_output) };
            request_output as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let header_sent: u32 = unsafe { ::core::mem::transmute(header_sent) };
            header_sent as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let expect_tested: u32 = unsafe { ::core::mem::transmute(expect_tested) };
            expect_tested as u64
        });
        __bindgen_bitfield_unit.set(86usize, 1u8, {
            let root_tested: u32 = unsafe { ::core::mem::transmute(root_tested) };
            root_tested as u64
        });
        __bindgen_bitfield_unit.set(87usize, 1u8, {
            let done: u32 = unsafe { ::core::mem::transmute(done) };
            done as u64
        });
        __bindgen_bitfield_unit.set(88usize, 1u8, {
            let logged: u32 = unsafe { ::core::mem::transmute(logged) };
            logged as u64
        });
        __bindgen_bitfield_unit.set(89usize, 4u8, {
            let buffered: u32 = unsafe { ::core::mem::transmute(buffered) };
            buffered as u64
        });
        __bindgen_bitfield_unit.set(93usize, 1u8, {
            let main_filter_need_in_memory: u32 =
                unsafe { ::core::mem::transmute(main_filter_need_in_memory) };
            main_filter_need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(94usize, 1u8, {
            let filter_need_in_memory: u32 =
                unsafe { ::core::mem::transmute(filter_need_in_memory) };
            filter_need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(95usize, 1u8, {
            let filter_need_temporary: u32 =
                unsafe { ::core::mem::transmute(filter_need_temporary) };
            filter_need_temporary as u64
        });
        __bindgen_bitfield_unit.set(96usize, 1u8, {
            let preserve_body: u32 = unsafe { ::core::mem::transmute(preserve_body) };
            preserve_body as u64
        });
        __bindgen_bitfield_unit.set(97usize, 1u8, {
            let allow_ranges: u32 = unsafe { ::core::mem::transmute(allow_ranges) };
            allow_ranges as u64
        });
        __bindgen_bitfield_unit.set(98usize, 1u8, {
            let subrequest_ranges: u32 = unsafe { ::core::mem::transmute(subrequest_ranges) };
            subrequest_ranges as u64
        });
        __bindgen_bitfield_unit.set(99usize, 1u8, {
            let single_range: u32 = unsafe { ::core::mem::transmute(single_range) };
            single_range as u64
        });
        __bindgen_bitfield_unit.set(100usize, 1u8, {
            let disable_not_modified: u32 = unsafe { ::core::mem::transmute(disable_not_modified) };
            disable_not_modified as u64
        });
        __bindgen_bitfield_unit.set(101usize, 1u8, {
            let stat_reading: u32 = unsafe { ::core::mem::transmute(stat_reading) };
            stat_reading as u64
        });
        __bindgen_bitfield_unit.set(102usize, 1u8, {
            let stat_writing: u32 = unsafe { ::core::mem::transmute(stat_writing) };
            stat_writing as u64
        });
        __bindgen_bitfield_unit.set(103usize, 1u8, {
            let stat_processing: u32 = unsafe { ::core::mem::transmute(stat_processing) };
            stat_processing as u64
        });
        __bindgen_bitfield_unit.set(104usize, 1u8, {
            let background: u32 = unsafe { ::core::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(105usize, 1u8, {
            let health_check: u32 = unsafe { ::core::mem::transmute(health_check) };
            health_check as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn http_minor(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_http_minor(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn http_major(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_http_major(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        http_minor: ::aya_bpf::cty::c_uint,
        http_major: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let http_minor: u32 = unsafe { ::core::mem::transmute(http_minor) };
            http_minor as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let http_major: u32 = unsafe { ::core::mem::transmute(http_major) };
            http_major as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ephemeral_t {
    pub terminal_posted_request: ngx_http_posted_request_t,
}
extern "C" {
    pub static mut ngx_http_headers_in: [ngx_http_header_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_headers_out: [ngx_http_header_out_t; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_engine_t {
    pub ip: *mut u_char,
    pub pos: *mut u_char,
    pub sp: *mut ngx_http_variable_value_t,
    pub buf: ngx_str_t,
    pub line: ngx_str_t,
    pub args: *mut u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub status: ngx_int_t,
    pub request: *mut ngx_http_request_t,
}
impl ngx_http_script_engine_t {
    #[inline]
    pub fn flushed(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flushed(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quote(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quote(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flushed: ::aya_bpf::cty::c_uint,
        skip: ::aya_bpf::cty::c_uint,
        quote: ::aya_bpf::cty::c_uint,
        is_args: ::aya_bpf::cty::c_uint,
        log: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flushed: u32 = unsafe { ::core::mem::transmute(flushed) };
            flushed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip: u32 = unsafe { ::core::mem::transmute(skip) };
            skip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let quote: u32 = unsafe { ::core::mem::transmute(quote) };
            quote as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_args: u32 = unsafe { ::core::mem::transmute(is_args) };
            is_args as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let log: u32 = unsafe { ::core::mem::transmute(log) };
            log as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_compile_t {
    pub cf: *mut ngx_conf_t,
    pub source: *mut ngx_str_t,
    pub flushes: *mut *mut ngx_array_t,
    pub lengths: *mut *mut ngx_array_t,
    pub values: *mut *mut ngx_array_t,
    pub variables: ngx_uint_t,
    pub ncaptures: ngx_uint_t,
    pub captures_mask: ngx_uint_t,
    pub size: ngx_uint_t,
    pub main: *mut ::aya_bpf::cty::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_script_compile_t {
    #[inline]
    pub fn compile_args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compile_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_lengths(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete_lengths(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_values(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete_values(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conf_prefix(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_conf_prefix(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_prefix(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_prefix(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dup_capture(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dup_capture(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compile_args: ::aya_bpf::cty::c_uint,
        complete_lengths: ::aya_bpf::cty::c_uint,
        complete_values: ::aya_bpf::cty::c_uint,
        zero: ::aya_bpf::cty::c_uint,
        conf_prefix: ::aya_bpf::cty::c_uint,
        root_prefix: ::aya_bpf::cty::c_uint,
        dup_capture: ::aya_bpf::cty::c_uint,
        args: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compile_args: u32 = unsafe { ::core::mem::transmute(compile_args) };
            compile_args as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let complete_lengths: u32 = unsafe { ::core::mem::transmute(complete_lengths) };
            complete_lengths as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let complete_values: u32 = unsafe { ::core::mem::transmute(complete_values) };
            complete_values as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let zero: u32 = unsafe { ::core::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let conf_prefix: u32 = unsafe { ::core::mem::transmute(conf_prefix) };
            conf_prefix as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let root_prefix: u32 = unsafe { ::core::mem::transmute(root_prefix) };
            root_prefix as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dup_capture: u32 = unsafe { ::core::mem::transmute(dup_capture) };
            dup_capture as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let args: u32 = unsafe { ::core::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_complex_value_t {
    pub value: ngx_str_t,
    pub flushes: *mut ngx_uint_t,
    pub lengths: *mut ::aya_bpf::cty::c_void,
    pub values: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_compile_complex_value_t {
    pub cf: *mut ngx_conf_t,
    pub value: *mut ngx_str_t,
    pub complex_value: *mut ngx_http_complex_value_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_compile_complex_value_t {
    #[inline]
    pub fn zero(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conf_prefix(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_conf_prefix(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_prefix(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_prefix(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        zero: ::aya_bpf::cty::c_uint,
        conf_prefix: ::aya_bpf::cty::c_uint,
        root_prefix: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zero: u32 = unsafe { ::core::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let conf_prefix: u32 = unsafe { ::core::mem::transmute(conf_prefix) };
            conf_prefix as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let root_prefix: u32 = unsafe { ::core::mem::transmute(root_prefix) };
            root_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_script_code_pt =
    ::core::option::Option<unsafe extern "C" fn(e: *mut ngx_http_script_engine_t)>;
pub type ngx_http_script_len_code_pt =
    ::core::option::Option<unsafe extern "C" fn(e: *mut ngx_http_script_engine_t) -> size_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_copy_code_t {
    pub code: ngx_http_script_code_pt,
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_var_code_t {
    pub code: ngx_http_script_code_pt,
    pub index: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_var_handler_code_t {
    pub code: ngx_http_script_code_pt,
    pub handler: ngx_http_set_variable_pt,
    pub data: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_copy_capture_code_t {
    pub code: ngx_http_script_code_pt,
    pub n: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_regex_code_t {
    pub code: ngx_http_script_code_pt,
    pub regex: *mut ngx_http_regex_t,
    pub lengths: *mut ngx_array_t,
    pub size: usize,
    pub status: usize,
    pub next: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub name: ngx_str_t,
}
impl ngx_http_script_regex_code_t {
    #[inline]
    pub fn test(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn negative_test(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_negative_test(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn break_cycle(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_break_cycle(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        test: ::aya_bpf::cty::c_uint,
        negative_test: ::aya_bpf::cty::c_uint,
        uri: ::aya_bpf::cty::c_uint,
        args: ::aya_bpf::cty::c_uint,
        add_args: ::aya_bpf::cty::c_uint,
        redirect: ::aya_bpf::cty::c_uint,
        break_cycle: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let test: u32 = unsafe { ::core::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let negative_test: u32 = unsafe { ::core::mem::transmute(negative_test) };
            negative_test as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let uri: u32 = unsafe { ::core::mem::transmute(uri) };
            uri as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let args: u32 = unsafe { ::core::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let add_args: u32 = unsafe { ::core::mem::transmute(add_args) };
            add_args as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let redirect: u32 = unsafe { ::core::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let break_cycle: u32 = unsafe { ::core::mem::transmute(break_cycle) };
            break_cycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_regex_end_code_t {
    pub code: ngx_http_script_code_pt,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_script_regex_end_code_t {
    #[inline]
    pub fn uri(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_args(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_args(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uri: ::aya_bpf::cty::c_uint,
        args: ::aya_bpf::cty::c_uint,
        add_args: ::aya_bpf::cty::c_uint,
        redirect: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uri: u32 = unsafe { ::core::mem::transmute(uri) };
            uri as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let args: u32 = unsafe { ::core::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let add_args: u32 = unsafe { ::core::mem::transmute(add_args) };
            add_args as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let redirect: u32 = unsafe { ::core::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_full_name_code_t {
    pub code: ngx_http_script_code_pt,
    pub conf_prefix: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_return_code_t {
    pub code: ngx_http_script_code_pt,
    pub status: usize,
    pub text: ngx_http_complex_value_t,
}
pub const ngx_http_script_file_op_e_ngx_http_script_file_plain: ngx_http_script_file_op_e = 0;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_plain: ngx_http_script_file_op_e = 1;
pub const ngx_http_script_file_op_e_ngx_http_script_file_dir: ngx_http_script_file_op_e = 2;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_dir: ngx_http_script_file_op_e = 3;
pub const ngx_http_script_file_op_e_ngx_http_script_file_exists: ngx_http_script_file_op_e = 4;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_exists: ngx_http_script_file_op_e = 5;
pub const ngx_http_script_file_op_e_ngx_http_script_file_exec: ngx_http_script_file_op_e = 6;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_exec: ngx_http_script_file_op_e = 7;
pub type ngx_http_script_file_op_e = ::aya_bpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_file_code_t {
    pub code: ngx_http_script_code_pt,
    pub op: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_if_code_t {
    pub code: ngx_http_script_code_pt,
    pub next: usize,
    pub loc_conf: *mut *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_complex_value_code_t {
    pub code: ngx_http_script_code_pt,
    pub lengths: *mut ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_value_code_t {
    pub code: ngx_http_script_code_pt,
    pub value: usize,
    pub text_len: usize,
    pub text_data: usize,
}
extern "C" {
    pub fn ngx_http_script_flush_complex_value(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
    );
}
extern "C" {
    pub fn ngx_http_complex_value(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_compile_complex_value(ccv: *mut ngx_http_compile_complex_value_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_complex_value_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_test_predicates(
        r: *mut ngx_http_request_t,
        predicates: *mut ngx_array_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_predicate_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_script_variables_count(value: *mut ngx_str_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_http_script_compile(sc: *mut ngx_http_script_compile_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_script_run(
        r: *mut ngx_http_request_t,
        value: *mut ngx_str_t,
        code_lengths: *mut ::aya_bpf::cty::c_void,
        reserved: size_t,
        code_values: *mut ::aya_bpf::cty::c_void,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_script_flush_no_cacheable_variables(
        r: *mut ngx_http_request_t,
        indices: *mut ngx_array_t,
    );
}
extern "C" {
    pub fn ngx_http_script_start_code(
        pool: *mut ngx_pool_t,
        codes: *mut *mut ngx_array_t,
        size: size_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_script_add_code(
        codes: *mut ngx_array_t,
        size: size_t,
        code: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_script_copy_len_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_copy_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_copy_var_len_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_copy_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_copy_capture_len_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_copy_capture_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_mark_args_code(e: *mut ngx_http_script_engine_t) -> size_t;
}
extern "C" {
    pub fn ngx_http_script_start_args_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_regex_start_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_regex_end_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_return_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_break_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_if_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_equal_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_not_equal_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_file_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_complex_value_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_value_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_set_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_var_set_handler_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_nop_code(e: *mut ngx_http_script_engine_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_s {
    pub data: *mut ::aya_bpf::cty::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub handler: ngx_event_handler_pt,
    pub index: ngx_uint_t,
    pub log: *mut ngx_log_t,
    pub timer: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
}
impl ngx_event_s {
    #[inline]
    pub fn write(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accept(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instance(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_instance(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ready(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ready(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oneshot(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oneshot(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eof(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eof(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timedout(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timedout(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_set(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_set(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delayed(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delayed(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_eof(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pending_eof(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn posted(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_posted(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn closed(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_closed(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resolver(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resolver(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancelable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancelable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn available(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_available(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        write: ::aya_bpf::cty::c_uint,
        accept: ::aya_bpf::cty::c_uint,
        instance: ::aya_bpf::cty::c_uint,
        active: ::aya_bpf::cty::c_uint,
        disabled: ::aya_bpf::cty::c_uint,
        ready: ::aya_bpf::cty::c_uint,
        oneshot: ::aya_bpf::cty::c_uint,
        complete: ::aya_bpf::cty::c_uint,
        eof: ::aya_bpf::cty::c_uint,
        error: ::aya_bpf::cty::c_uint,
        timedout: ::aya_bpf::cty::c_uint,
        timer_set: ::aya_bpf::cty::c_uint,
        delayed: ::aya_bpf::cty::c_uint,
        deferred_accept: ::aya_bpf::cty::c_uint,
        pending_eof: ::aya_bpf::cty::c_uint,
        posted: ::aya_bpf::cty::c_uint,
        closed: ::aya_bpf::cty::c_uint,
        channel: ::aya_bpf::cty::c_uint,
        resolver: ::aya_bpf::cty::c_uint,
        cancelable: ::aya_bpf::cty::c_uint,
        available: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let write: u32 = unsafe { ::core::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let accept: u32 = unsafe { ::core::mem::transmute(accept) };
            accept as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let instance: u32 = unsafe { ::core::mem::transmute(instance) };
            instance as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let active: u32 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disabled: u32 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ready: u32 = unsafe { ::core::mem::transmute(ready) };
            ready as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let oneshot: u32 = unsafe { ::core::mem::transmute(oneshot) };
            oneshot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let complete: u32 = unsafe { ::core::mem::transmute(complete) };
            complete as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let eof: u32 = unsafe { ::core::mem::transmute(eof) };
            eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let timedout: u32 = unsafe { ::core::mem::transmute(timedout) };
            timedout as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timer_set: u32 = unsafe { ::core::mem::transmute(timer_set) };
            timer_set as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delayed: u32 = unsafe { ::core::mem::transmute(delayed) };
            delayed as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::core::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let pending_eof: u32 = unsafe { ::core::mem::transmute(pending_eof) };
            pending_eof as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let posted: u32 = unsafe { ::core::mem::transmute(posted) };
            posted as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let closed: u32 = unsafe { ::core::mem::transmute(closed) };
            closed as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let resolver: u32 = unsafe { ::core::mem::transmute(resolver) };
            resolver as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let cancelable: u32 = unsafe { ::core::mem::transmute(cancelable) };
            cancelable as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let available: u32 = unsafe { ::core::mem::transmute(available) };
            available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_actions_t {
    pub add: ::core::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub del: ::core::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub enable: ::core::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub disable: ::core::option::Option<
        unsafe extern "C" fn(
            ev: *mut ngx_event_t,
            event: ngx_int_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub add_conn:
        ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t) -> ngx_int_t>,
    pub del_conn: ::core::option::Option<
        unsafe extern "C" fn(c: *mut ngx_connection_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub notify:
        ::core::option::Option<unsafe extern "C" fn(handler: ngx_event_handler_pt) -> ngx_int_t>,
    pub process_events: ::core::option::Option<
        unsafe extern "C" fn(
            cycle: *mut ngx_cycle_t,
            timer: ngx_msec_t,
            flags: ngx_uint_t,
        ) -> ngx_int_t,
    >,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, timer: ngx_msec_t) -> ngx_int_t,
    >,
    pub done: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
}
extern "C" {
    pub static mut ngx_event_actions: ngx_event_actions_t;
}
extern "C" {
    pub static mut ngx_use_epoll_rdhup: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_io: ngx_os_io_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_conf_t {
    pub connections: ngx_uint_t,
    pub use_: ngx_uint_t,
    pub multi_accept: ngx_flag_t,
    pub accept_mutex: ngx_flag_t,
    pub accept_mutex_delay: ngx_msec_t,
    pub name: *mut u_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_module_t {
    pub name: *mut ngx_str_t,
    pub create_conf: ::core::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> *mut ::aya_bpf::cty::c_void,
    >,
    pub init_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cycle: *mut ngx_cycle_t,
            conf: *mut ::aya_bpf::cty::c_void,
        ) -> *mut ::aya_bpf::cty::c_char,
    >,
    pub actions: ngx_event_actions_t,
}
extern "C" {
    pub static mut ngx_connection_counter: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_ptr: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_accept_mutex: ngx_shmtx_t;
}
extern "C" {
    pub static mut ngx_use_accept_mutex: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_events: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_held: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_delay: ngx_msec_t;
}
extern "C" {
    pub static mut ngx_accept_disabled: ngx_int_t;
}
extern "C" {
    pub static mut ngx_event_timer_alarm: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_event_flags: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_events_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_event_core_module: ngx_module_t;
}
extern "C" {
    pub fn ngx_event_accept(ev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_event_recvmsg(ev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_trylock_accept_mutex(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_accept_log_error(log: *mut ngx_log_t, buf: *mut u_char, len: size_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_process_events_and_timers(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_handle_read_event(rev: *mut ngx_event_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_handle_write_event(wev: *mut ngx_event_t, lowat: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_send_lowat(c: *mut ngx_connection_t, lowat: size_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_timer_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_find_timer() -> ngx_msec_t;
}
extern "C" {
    pub fn ngx_event_expire_timers();
}
extern "C" {
    pub fn ngx_event_no_timers_left() -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_event_timer_rbtree: ngx_rbtree_t;
}
extern "C" {
    pub fn ngx_event_process_posted(cycle: *mut ngx_cycle_t, posted: *mut ngx_queue_t);
}
extern "C" {
    pub static mut ngx_posted_accept_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_delayed_events: ngx_queue_t;
}
pub type ngx_peer_connection_t = ngx_peer_connection_s;
pub type ngx_event_get_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
    ) -> ngx_int_t,
>;
pub type ngx_event_free_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
        state: ngx_uint_t,
    ),
>;
pub type ngx_event_notify_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
        type_: ngx_uint_t,
    ),
>;
pub type ngx_event_set_peer_session_pt = ::core::option::Option<
    unsafe extern "C" fn(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
    ) -> ngx_int_t,
>;
pub type ngx_event_save_peer_session_pt = ::core::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut ::aya_bpf::cty::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_peer_connection_s {
    pub connection: *mut ngx_connection_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: *mut ngx_str_t,
    pub tries: ngx_uint_t,
    pub start_time: ngx_msec_t,
    pub get: ngx_event_get_peer_pt,
    pub free: ngx_event_free_peer_pt,
    pub notify: ngx_event_notify_peer_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
    pub set_session: ngx_event_set_peer_session_pt,
    pub save_session: ngx_event_save_peer_session_pt,
    pub local: *mut ngx_addr_t,
    pub type_: ::aya_bpf::cty::c_int,
    pub rcvbuf: ::aya_bpf::cty::c_int,
    pub log: *mut ngx_log_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub spare: [u64; 2usize],
}
impl ngx_peer_connection_s {
    #[inline]
    pub fn cached(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transparent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transparent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log_error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cached: ::aya_bpf::cty::c_uint,
        transparent: ::aya_bpf::cty::c_uint,
        log_error: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cached: u32 = unsafe { ::core::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transparent: u32 = unsafe { ::core::mem::transmute(transparent) };
            transparent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let log_error: u32 = unsafe { ::core::mem::transmute(log_error) };
            log_error as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_event_connect_peer(pc: *mut ngx_peer_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_get_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
    ) -> ngx_int_t;
}
pub type ngx_event_pipe_t = ngx_event_pipe_s;
pub type ngx_event_pipe_input_filter_pt = ::core::option::Option<
    unsafe extern "C" fn(p: *mut ngx_event_pipe_t, buf: *mut ngx_buf_t) -> ngx_int_t,
>;
pub type ngx_event_pipe_output_filter_pt = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_pipe_s {
    pub upstream: *mut ngx_connection_t,
    pub downstream: *mut ngx_connection_t,
    pub free_raw_bufs: *mut ngx_chain_t,
    pub in_: *mut ngx_chain_t,
    pub last_in: *mut *mut ngx_chain_t,
    pub writing: *mut ngx_chain_t,
    pub out: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub input_filter: ngx_event_pipe_input_filter_pt,
    pub input_ctx: *mut ::aya_bpf::cty::c_void,
    pub output_filter: ngx_event_pipe_output_filter_pt,
    pub output_ctx: *mut ::aya_bpf::cty::c_void,
    pub thread_handler: ::core::option::Option<
        unsafe extern "C" fn(task: *mut ngx_thread_task_t, file: *mut ngx_file_t) -> ngx_int_t,
    >,
    pub thread_ctx: *mut ::aya_bpf::cty::c_void,
    pub thread_task: *mut ngx_thread_task_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub allocated: ngx_int_t,
    pub bufs: ngx_bufs_t,
    pub tag: ngx_buf_tag_t,
    pub busy_size: ssize_t,
    pub read_length: off_t,
    pub length: off_t,
    pub max_temp_file_size: off_t,
    pub temp_file_write_size: ssize_t,
    pub read_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub send_lowat: ssize_t,
    pub pool: *mut ngx_pool_t,
    pub log: *mut ngx_log_t,
    pub preread_bufs: *mut ngx_chain_t,
    pub preread_size: size_t,
    pub buf_to_file: *mut ngx_buf_t,
    pub limit_rate: size_t,
    pub start_sec: time_t,
    pub temp_file: *mut ngx_temp_file_t,
    pub num: ::aya_bpf::cty::c_int,
}
impl ngx_event_pipe_s {
    #[inline]
    pub fn read(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cacheable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cacheable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_buf(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single_buf(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn free_bufs(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_free_bufs(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_done(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_done(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_eof(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_eof(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_blocked(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_blocked(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downstream_done(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downstream_done(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downstream_error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downstream_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyclic_temp_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyclic_temp_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read: ::aya_bpf::cty::c_uint,
        cacheable: ::aya_bpf::cty::c_uint,
        single_buf: ::aya_bpf::cty::c_uint,
        free_bufs: ::aya_bpf::cty::c_uint,
        upstream_done: ::aya_bpf::cty::c_uint,
        upstream_error: ::aya_bpf::cty::c_uint,
        upstream_eof: ::aya_bpf::cty::c_uint,
        upstream_blocked: ::aya_bpf::cty::c_uint,
        downstream_done: ::aya_bpf::cty::c_uint,
        downstream_error: ::aya_bpf::cty::c_uint,
        cyclic_temp_file: ::aya_bpf::cty::c_uint,
        aio: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read: u32 = unsafe { ::core::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cacheable: u32 = unsafe { ::core::mem::transmute(cacheable) };
            cacheable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let single_buf: u32 = unsafe { ::core::mem::transmute(single_buf) };
            single_buf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let free_bufs: u32 = unsafe { ::core::mem::transmute(free_bufs) };
            free_bufs as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let upstream_done: u32 = unsafe { ::core::mem::transmute(upstream_done) };
            upstream_done as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let upstream_error: u32 = unsafe { ::core::mem::transmute(upstream_error) };
            upstream_error as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let upstream_eof: u32 = unsafe { ::core::mem::transmute(upstream_eof) };
            upstream_eof as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let upstream_blocked: u32 = unsafe { ::core::mem::transmute(upstream_blocked) };
            upstream_blocked as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let downstream_done: u32 = unsafe { ::core::mem::transmute(downstream_done) };
            downstream_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downstream_error: u32 = unsafe { ::core::mem::transmute(downstream_error) };
            downstream_error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cyclic_temp_file: u32 = unsafe { ::core::mem::transmute(cyclic_temp_file) };
            cyclic_temp_file as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let aio: u32 = unsafe { ::core::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_event_pipe(p: *mut ngx_event_pipe_t, do_write: ngx_int_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_pipe_copy_input_filter(
        p: *mut ngx_event_pipe_t,
        buf: *mut ngx_buf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_pipe_add_free_buf(p: *mut ngx_event_pipe_t, b: *mut ngx_buf_t) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_state_t {
    pub status: ngx_uint_t,
    pub response_time: ngx_msec_t,
    pub connect_time: ngx_msec_t,
    pub header_time: ngx_msec_t,
    pub response_length: off_t,
    pub bytes_received: off_t,
    pub peer: *mut ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_main_conf_t {
    pub headers_in_hash: ngx_hash_t,
    pub upstreams: ngx_array_t,
}
pub type ngx_http_upstream_srv_conf_t = ngx_http_upstream_srv_conf_s;
pub type ngx_http_upstream_init_pt = ::core::option::Option<
    unsafe extern "C" fn(cf: *mut ngx_conf_t, us: *mut ngx_http_upstream_srv_conf_t) -> ngx_int_t,
>;
pub type ngx_http_upstream_init_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_peer_t {
    pub init_upstream: ngx_http_upstream_init_pt,
    pub init: ngx_http_upstream_init_peer_pt,
    pub data: *mut ::aya_bpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_server_t {
    pub name: ngx_str_t,
    pub addrs: *mut ngx_addr_t,
    pub naddrs: ngx_uint_t,
    pub weight: ngx_uint_t,
    pub max_conns: ngx_uint_t,
    pub max_fails: ngx_uint_t,
    pub fail_timeout: time_t,
    pub slow_start: ngx_msec_t,
    pub down: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub spare: [u64; 6usize],
}
impl ngx_http_upstream_server_t {
    #[inline]
    pub fn backup(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backup(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(backup: ::aya_bpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let backup: u32 = unsafe { ::core::mem::transmute(backup) };
            backup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_srv_conf_s {
    pub peer: ngx_http_upstream_peer_t,
    pub srv_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub servers: *mut ngx_array_t,
    pub flags: ngx_uint_t,
    pub host: ngx_str_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub port: in_port_t,
    pub no_port: ngx_uint_t,
    pub shm_zone: *mut ngx_shm_zone_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_local_t {
    pub addr: *mut ngx_addr_t,
    pub value: *mut ngx_http_complex_value_t,
    pub transparent: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_conf_t {
    pub upstream: *mut ngx_http_upstream_srv_conf_t,
    pub connect_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub read_timeout: ngx_msec_t,
    pub next_upstream_timeout: ngx_msec_t,
    pub send_lowat: size_t,
    pub buffer_size: size_t,
    pub limit_rate: size_t,
    pub busy_buffers_size: size_t,
    pub max_temp_file_size: size_t,
    pub temp_file_write_size: size_t,
    pub busy_buffers_size_conf: size_t,
    pub max_temp_file_size_conf: size_t,
    pub temp_file_write_size_conf: size_t,
    pub bufs: ngx_bufs_t,
    pub ignore_headers: ngx_uint_t,
    pub next_upstream: ngx_uint_t,
    pub store_access: ngx_uint_t,
    pub next_upstream_tries: ngx_uint_t,
    pub buffering: ngx_flag_t,
    pub request_buffering: ngx_flag_t,
    pub pass_request_headers: ngx_flag_t,
    pub pass_request_body: ngx_flag_t,
    pub ignore_client_abort: ngx_flag_t,
    pub intercept_errors: ngx_flag_t,
    pub cyclic_temp_file: ngx_flag_t,
    pub force_ranges: ngx_flag_t,
    pub temp_path: *mut ngx_path_t,
    pub hide_headers_hash: ngx_hash_t,
    pub hide_headers: *mut ngx_array_t,
    pub pass_headers: *mut ngx_array_t,
    pub local: *mut ngx_http_upstream_local_t,
    pub cache_zone: *mut ngx_shm_zone_t,
    pub cache_value: *mut ngx_http_complex_value_t,
    pub cache_min_uses: ngx_uint_t,
    pub cache_use_stale: ngx_uint_t,
    pub cache_methods: ngx_uint_t,
    pub cache_max_range_offset: off_t,
    pub cache_lock: ngx_flag_t,
    pub cache_lock_timeout: ngx_msec_t,
    pub cache_lock_age: ngx_msec_t,
    pub cache_revalidate: ngx_flag_t,
    pub cache_convert_head: ngx_flag_t,
    pub cache_background_update: ngx_flag_t,
    pub cache_valid: *mut ngx_array_t,
    pub cache_bypass: *mut ngx_array_t,
    pub cache_purge: *mut ngx_array_t,
    pub no_cache: *mut ngx_array_t,
    pub store_lengths: *mut ngx_array_t,
    pub store_values: *mut ngx_array_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ssl: *mut ngx_ssl_t,
    pub ssl_session_reuse: ngx_flag_t,
    pub ssl_name: *mut ngx_http_complex_value_t,
    pub ssl_server_name: ngx_flag_t,
    pub ssl_verify: ngx_flag_t,
    pub module: ngx_str_t,
    pub spare: [u64; 2usize],
}
impl ngx_http_upstream_conf_t {
    #[inline]
    pub fn cache(&self) -> ::aya_bpf::cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cache(&mut self, val: ::aya_bpf::cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> ::aya_bpf::cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: ::aya_bpf::cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_404(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intercept_404(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn change_buffering(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_change_buffering(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache: ::aya_bpf::cty::c_int,
        store: ::aya_bpf::cty::c_int,
        intercept_404: ::aya_bpf::cty::c_uint,
        change_buffering: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cache: u32 = unsafe { ::core::mem::transmute(cache) };
            cache as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let store: u32 = unsafe { ::core::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let intercept_404: u32 = unsafe { ::core::mem::transmute(intercept_404) };
            intercept_404 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let change_buffering: u32 = unsafe { ::core::mem::transmute(change_buffering) };
            change_buffering as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_header_t {
    pub name: ngx_str_t,
    pub handler: ngx_http_header_handler_pt,
    pub offset: ngx_uint_t,
    pub copy_handler: ngx_http_header_handler_pt,
    pub conf: ngx_uint_t,
    pub redirect: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_headers_in_t {
    pub headers: ngx_list_t,
    pub status_n: ngx_uint_t,
    pub status_line: ngx_str_t,
    pub status: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub server: *mut ngx_table_elt_t,
    pub connection: *mut ngx_table_elt_t,
    pub expires: *mut ngx_table_elt_t,
    pub etag: *mut ngx_table_elt_t,
    pub x_accel_expires: *mut ngx_table_elt_t,
    pub x_accel_redirect: *mut ngx_table_elt_t,
    pub x_accel_limit_rate: *mut ngx_table_elt_t,
    pub content_type: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub last_modified: *mut ngx_table_elt_t,
    pub location: *mut ngx_table_elt_t,
    pub accept_ranges: *mut ngx_table_elt_t,
    pub www_authenticate: *mut ngx_table_elt_t,
    pub transfer_encoding: *mut ngx_table_elt_t,
    pub vary: *mut ngx_table_elt_t,
    pub content_encoding: *mut ngx_table_elt_t,
    pub cache_control: ngx_array_t,
    pub cookies: ngx_array_t,
    pub content_length_n: off_t,
    pub last_modified_time: time_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_upstream_headers_in_t {
    #[inline]
    pub fn connection_close(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_connection_close(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connection_close: ::aya_bpf::cty::c_uint,
        chunked: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connection_close: u32 = unsafe { ::core::mem::transmute(connection_close) };
            connection_close as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chunked: u32 = unsafe { ::core::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_resolved_t {
    pub host: ngx_str_t,
    pub port: in_port_t,
    pub no_port: ngx_uint_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_resolver_addr_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub ctx: *mut ngx_resolver_ctx_t,
}
pub type ngx_http_upstream_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, u: *mut ngx_http_upstream_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_s {
    pub read_event_handler: ngx_http_upstream_handler_pt,
    pub write_event_handler: ngx_http_upstream_handler_pt,
    pub peer: ngx_peer_connection_t,
    pub pipe: *mut ngx_event_pipe_t,
    pub request_bufs: *mut ngx_chain_t,
    pub output: ngx_output_chain_ctx_t,
    pub writer: ngx_chain_writer_ctx_t,
    pub conf: *mut ngx_http_upstream_conf_t,
    pub upstream: *mut ngx_http_upstream_srv_conf_t,
    pub caches: *mut ngx_array_t,
    pub connect_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub read_timeout: ngx_msec_t,
    pub headers_in: ngx_http_upstream_headers_in_t,
    pub resolved: *mut ngx_http_upstream_resolved_t,
    pub from_client: ngx_buf_t,
    pub buffer: ngx_buf_t,
    pub length: off_t,
    pub out_bufs: *mut ngx_chain_t,
    pub busy_bufs: *mut ngx_chain_t,
    pub free_bufs: *mut ngx_chain_t,
    pub input_filter_init:
        ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void) -> ngx_int_t>,
    pub input_filter: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::aya_bpf::cty::c_void, bytes: ssize_t) -> ngx_int_t,
    >,
    pub input_filter_ctx: *mut ::aya_bpf::cty::c_void,
    pub create_key:
        ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub create_request:
        ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub reinit_request:
        ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub process_header:
        ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub abort_request: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>,
    pub finalize_request:
        ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, rc: ngx_int_t)>,
    pub rewrite_redirect: ::core::option::Option<
        unsafe extern "C" fn(
            r: *mut ngx_http_request_t,
            h: *mut ngx_table_elt_t,
            prefix: size_t,
        ) -> ngx_int_t,
    >,
    pub rewrite_cookie: ::core::option::Option<
        unsafe extern "C" fn(r: *mut ngx_http_request_t, h: *mut ngx_table_elt_t) -> ngx_int_t,
    >,
    pub timeout: ngx_msec_t,
    pub state: *mut ngx_http_upstream_state_t,
    pub method: ngx_str_t,
    pub schema: ngx_str_t,
    pub uri: ngx_str_t,
    pub ssl_name: ngx_str_t,
    pub cleanup: *mut ngx_http_cleanup_pt,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_upstream_s {
    #[inline]
    pub fn store(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cacheable(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cacheable(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accel(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accel(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssl(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_status(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cache_status(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn buffering(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_buffering(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upgrade(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upgrade(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_sent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_sent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_sent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_sent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_sent(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_sent(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        store: ::aya_bpf::cty::c_uint,
        cacheable: ::aya_bpf::cty::c_uint,
        accel: ::aya_bpf::cty::c_uint,
        ssl: ::aya_bpf::cty::c_uint,
        cache_status: ::aya_bpf::cty::c_uint,
        buffering: ::aya_bpf::cty::c_uint,
        keepalive: ::aya_bpf::cty::c_uint,
        upgrade: ::aya_bpf::cty::c_uint,
        request_sent: ::aya_bpf::cty::c_uint,
        request_body_sent: ::aya_bpf::cty::c_uint,
        header_sent: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let store: u32 = unsafe { ::core::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cacheable: u32 = unsafe { ::core::mem::transmute(cacheable) };
            cacheable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let accel: u32 = unsafe { ::core::mem::transmute(accel) };
            accel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let cache_status: u32 = unsafe { ::core::mem::transmute(cache_status) };
            cache_status as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let buffering: u32 = unsafe { ::core::mem::transmute(buffering) };
            buffering as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let keepalive: u32 = unsafe { ::core::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let upgrade: u32 = unsafe { ::core::mem::transmute(upgrade) };
            upgrade as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let request_sent: u32 = unsafe { ::core::mem::transmute(request_sent) };
            request_sent as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let request_body_sent: u32 = unsafe { ::core::mem::transmute(request_body_sent) };
            request_body_sent as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let header_sent: u32 = unsafe { ::core::mem::transmute(header_sent) };
            header_sent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_next_t {
    pub status: ngx_uint_t,
    pub mask: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_param_t {
    pub key: ngx_str_t,
    pub value: ngx_str_t,
    pub skip_empty: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_upstream_create(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_init(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_upstream_add(
        cf: *mut ngx_conf_t,
        u: *mut ngx_url_t,
        flags: ngx_uint_t,
    ) -> *mut ngx_http_upstream_srv_conf_t;
}
extern "C" {
    pub fn ngx_http_upstream_bind_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_upstream_param_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_upstream_hide_headers_hash(
        cf: *mut ngx_conf_t,
        conf: *mut ngx_http_upstream_conf_t,
        prev: *mut ngx_http_upstream_conf_t,
        default_hide_headers: *mut ngx_str_t,
        hash: *mut ngx_hash_init_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_upstream_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_upstream_cache_method_mask: [ngx_conf_bitmask_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_upstream_ignore_headers_masks: [ngx_conf_bitmask_t; 0usize];
}
pub type ngx_http_upstream_rr_peer_t = ngx_http_upstream_rr_peer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_rr_peer_s {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub server: ngx_str_t,
    pub current_weight: ngx_int_t,
    pub effective_weight: ngx_int_t,
    pub weight: ngx_int_t,
    pub conns: ngx_uint_t,
    pub max_conns: ngx_uint_t,
    pub fails: ngx_uint_t,
    pub accessed: time_t,
    pub checked: time_t,
    pub max_fails: ngx_uint_t,
    pub fail_timeout: time_t,
    pub slow_start: ngx_msec_t,
    pub start_time: ngx_msec_t,
    pub down: ngx_uint_t,
    pub ssl_session: *mut ::aya_bpf::cty::c_void,
    pub ssl_session_len: ::aya_bpf::cty::c_int,
    pub lock: ngx_atomic_t,
    pub next: *mut ngx_http_upstream_rr_peer_t,
    pub spare: [u64; 32usize],
}
pub type ngx_http_upstream_rr_peers_t = ngx_http_upstream_rr_peers_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_rr_peers_s {
    pub number: ngx_uint_t,
    pub shpool: *mut ngx_slab_pool_t,
    pub rwlock: ngx_atomic_t,
    pub zone_next: *mut ngx_http_upstream_rr_peers_t,
    pub total_weight: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub name: *mut ngx_str_t,
    pub next: *mut ngx_http_upstream_rr_peers_t,
    pub peer: *mut ngx_http_upstream_rr_peer_t,
}
impl ngx_http_upstream_rr_peers_s {
    #[inline]
    pub fn single(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single: ::aya_bpf::cty::c_uint,
        weighted: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single: u32 = unsafe { ::core::mem::transmute(single) };
            single as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let weighted: u32 = unsafe { ::core::mem::transmute(weighted) };
            weighted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_rr_peer_data_t {
    pub config: ngx_uint_t,
    pub peers: *mut ngx_http_upstream_rr_peers_t,
    pub current: *mut ngx_http_upstream_rr_peer_t,
    pub tried: *mut usize,
    pub data: usize,
}
extern "C" {
    pub fn ngx_http_upstream_init_round_robin(
        cf: *mut ngx_conf_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_init_round_robin_peer(
        r: *mut ngx_http_request_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_create_round_robin_peer(
        r: *mut ngx_http_request_t,
        ur: *mut ngx_http_upstream_resolved_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_get_round_robin_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_free_round_robin_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_bpf::cty::c_void,
        state: ngx_uint_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_thread_pool_s {
    _unused: [u8; 0],
}
pub type ngx_thread_pool_t = ngx_thread_pool_s;
pub type ngx_http_location_tree_node_t = ngx_http_location_tree_node_s;
pub type ngx_http_core_loc_conf_t = ngx_http_core_loc_conf_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_listen_opt_t {
    pub sockaddr: ngx_sockaddr_t,
    pub socklen: socklen_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub backlog: ::aya_bpf::cty::c_int,
    pub rcvbuf: ::aya_bpf::cty::c_int,
    pub sndbuf: ::aya_bpf::cty::c_int,
    pub fastopen: ::aya_bpf::cty::c_int,
    pub tcp_keepidle: ::aya_bpf::cty::c_int,
    pub tcp_keepintvl: ::aya_bpf::cty::c_int,
    pub tcp_keepcnt: ::aya_bpf::cty::c_int,
    pub addr: [u_char; 114usize],
}
impl ngx_http_listen_opt_t {
    #[inline]
    pub fn set(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_set(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_server(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_default_server(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bind(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bind(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssl(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http2(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http2(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6only(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6only(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn so_keepalive(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_so_keepalive(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        set: ::aya_bpf::cty::c_uint,
        default_server: ::aya_bpf::cty::c_uint,
        bind: ::aya_bpf::cty::c_uint,
        wildcard: ::aya_bpf::cty::c_uint,
        ssl: ::aya_bpf::cty::c_uint,
        http2: ::aya_bpf::cty::c_uint,
        ipv6only: ::aya_bpf::cty::c_uint,
        deferred_accept: ::aya_bpf::cty::c_uint,
        reuseport: ::aya_bpf::cty::c_uint,
        so_keepalive: ::aya_bpf::cty::c_uint,
        proxy_protocol: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let set: u32 = unsafe { ::core::mem::transmute(set) };
            set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let default_server: u32 = unsafe { ::core::mem::transmute(default_server) };
            default_server as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bind: u32 = unsafe { ::core::mem::transmute(bind) };
            bind as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wildcard: u32 = unsafe { ::core::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let http2: u32 = unsafe { ::core::mem::transmute(http2) };
            http2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ipv6only: u32 = unsafe { ::core::mem::transmute(ipv6only) };
            ipv6only as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::core::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reuseport: u32 = unsafe { ::core::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let so_keepalive: u32 = unsafe { ::core::mem::transmute(so_keepalive) };
            so_keepalive as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::core::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ngx_http_phases_NGX_HTTP_POST_READ_PHASE: ngx_http_phases = 0;
pub const ngx_http_phases_NGX_HTTP_SERVER_REWRITE_PHASE: ngx_http_phases = 1;
pub const ngx_http_phases_NGX_HTTP_FIND_CONFIG_PHASE: ngx_http_phases = 2;
pub const ngx_http_phases_NGX_HTTP_REWRITE_PHASE: ngx_http_phases = 3;
pub const ngx_http_phases_NGX_HTTP_POST_REWRITE_PHASE: ngx_http_phases = 4;
pub const ngx_http_phases_NGX_HTTP_PREACCESS_PHASE: ngx_http_phases = 5;
pub const ngx_http_phases_NGX_HTTP_ACCESS_PHASE: ngx_http_phases = 6;
pub const ngx_http_phases_NGX_HTTP_POST_ACCESS_PHASE: ngx_http_phases = 7;
pub const ngx_http_phases_NGX_HTTP_PRECONTENT_PHASE: ngx_http_phases = 8;
pub const ngx_http_phases_NGX_HTTP_CONTENT_PHASE: ngx_http_phases = 9;
pub const ngx_http_phases_NGX_HTTP_LOG_PHASE: ngx_http_phases = 10;
pub type ngx_http_phases = ::aya_bpf::cty::c_uint;
pub type ngx_http_phase_handler_t = ngx_http_phase_handler_s;
pub type ngx_http_phase_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_phase_handler_s {
    pub checker: ngx_http_phase_handler_pt,
    pub handler: ngx_http_handler_pt,
    pub next: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_phase_engine_t {
    pub handlers: *mut ngx_http_phase_handler_t,
    pub server_rewrite_index: ngx_uint_t,
    pub location_rewrite_index: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_phase_t {
    pub handlers: ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_core_main_conf_t {
    pub servers: ngx_array_t,
    pub phase_engine: ngx_http_phase_engine_t,
    pub headers_in_hash: ngx_hash_t,
    pub variables_hash: ngx_hash_t,
    pub variables: ngx_array_t,
    pub prefix_variables: ngx_array_t,
    pub ncaptures: ngx_uint_t,
    pub server_names_hash_max_size: ngx_uint_t,
    pub server_names_hash_bucket_size: ngx_uint_t,
    pub variables_hash_max_size: ngx_uint_t,
    pub variables_hash_bucket_size: ngx_uint_t,
    pub variables_keys: *mut ngx_hash_keys_arrays_t,
    pub ports: *mut ngx_array_t,
    pub phases: [ngx_http_phase_t; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_core_srv_conf_t {
    pub server_names: ngx_array_t,
    pub ctx: *mut ngx_http_conf_ctx_t,
    pub server_name: ngx_str_t,
    pub connection_pool_size: size_t,
    pub request_pool_size: size_t,
    pub client_header_buffer_size: size_t,
    pub large_client_header_buffers: ngx_bufs_t,
    pub client_header_timeout: ngx_msec_t,
    pub ignore_invalid_headers: ngx_flag_t,
    pub merge_slashes: ngx_flag_t,
    pub underscores_in_headers: ngx_flag_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub named_locations: *mut *mut ngx_http_core_loc_conf_t,
}
impl ngx_http_core_srv_conf_t {
    #[inline]
    pub fn listen(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn captures(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_captures(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        listen: ::aya_bpf::cty::c_uint,
        captures: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let listen: u32 = unsafe { ::core::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let captures: u32 = unsafe { ::core::mem::transmute(captures) };
            captures as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_server_name_t {
    pub regex: *mut ngx_http_regex_t,
    pub server: *mut ngx_http_core_srv_conf_t,
    pub name: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_virtual_names_t {
    pub names: ngx_hash_combined_t,
    pub nregex: ngx_uint_t,
    pub regex: *mut ngx_http_server_name_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_addr_conf_s {
    pub default_server: *mut ngx_http_core_srv_conf_t,
    pub virtual_names: *mut ngx_http_virtual_names_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_addr_conf_s {
    #[inline]
    pub fn ssl(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http2(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http2(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssl: ::aya_bpf::cty::c_uint,
        http2: ::aya_bpf::cty::c_uint,
        proxy_protocol: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let http2: u32 = unsafe { ::core::mem::transmute(http2) };
            http2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::core::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_in_addr_t {
    pub addr: in_addr_t,
    pub conf: ngx_http_addr_conf_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_in6_addr_t {
    pub addr6: in6_addr,
    pub conf: ngx_http_addr_conf_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_port_t {
    pub addrs: *mut ::aya_bpf::cty::c_void,
    pub naddrs: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_conf_port_t {
    pub family: ngx_int_t,
    pub port: in_port_t,
    pub addrs: ngx_array_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_conf_addr_t {
    pub opt: ngx_http_listen_opt_t,
    pub hash: ngx_hash_t,
    pub wc_head: *mut ngx_hash_wildcard_t,
    pub wc_tail: *mut ngx_hash_wildcard_t,
    pub nregex: ngx_uint_t,
    pub regex: *mut ngx_http_server_name_t,
    pub default_server: *mut ngx_http_core_srv_conf_t,
    pub servers: ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_err_page_t {
    pub status: ngx_int_t,
    pub overwrite: ngx_int_t,
    pub value: ngx_http_complex_value_t,
    pub args: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_core_loc_conf_s {
    pub name: ngx_str_t,
    pub regex: *mut ngx_http_regex_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub static_locations: *mut ngx_http_location_tree_node_t,
    pub regex_locations: *mut *mut ngx_http_core_loc_conf_t,
    pub loc_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub limit_except: u32,
    pub limit_except_loc_conf: *mut *mut ::aya_bpf::cty::c_void,
    pub handler: ngx_http_handler_pt,
    pub alias: size_t,
    pub root: ngx_str_t,
    pub post_action: ngx_str_t,
    pub root_lengths: *mut ngx_array_t,
    pub root_values: *mut ngx_array_t,
    pub types: *mut ngx_array_t,
    pub types_hash: ngx_hash_t,
    pub default_type: ngx_str_t,
    pub client_max_body_size: off_t,
    pub directio: off_t,
    pub directio_alignment: off_t,
    pub client_body_buffer_size: size_t,
    pub send_lowat: size_t,
    pub postpone_output: size_t,
    pub limit_rate: size_t,
    pub limit_rate_after: size_t,
    pub sendfile_max_chunk: size_t,
    pub read_ahead: size_t,
    pub client_body_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub keepalive_timeout: ngx_msec_t,
    pub lingering_time: ngx_msec_t,
    pub lingering_timeout: ngx_msec_t,
    pub resolver_timeout: ngx_msec_t,
    pub resolver: *mut ngx_resolver_t,
    pub keepalive_header: time_t,
    pub keepalive_requests: ngx_uint_t,
    pub keepalive_disable: ngx_uint_t,
    pub satisfy: ngx_uint_t,
    pub lingering_close: ngx_uint_t,
    pub if_modified_since: ngx_uint_t,
    pub max_ranges: ngx_uint_t,
    pub client_body_in_file_only: ngx_uint_t,
    pub client_body_in_single_buffer: ngx_flag_t,
    pub internal: ngx_flag_t,
    pub sendfile: ngx_flag_t,
    pub aio: ngx_flag_t,
    pub aio_write: ngx_flag_t,
    pub tcp_nopush: ngx_flag_t,
    pub tcp_nodelay: ngx_flag_t,
    pub reset_timedout_connection: ngx_flag_t,
    pub absolute_redirect: ngx_flag_t,
    pub server_name_in_redirect: ngx_flag_t,
    pub port_in_redirect: ngx_flag_t,
    pub msie_padding: ngx_flag_t,
    pub msie_refresh: ngx_flag_t,
    pub log_not_found: ngx_flag_t,
    pub log_subrequest: ngx_flag_t,
    pub recursive_error_pages: ngx_flag_t,
    pub server_tokens: ngx_uint_t,
    pub chunked_transfer_encoding: ngx_flag_t,
    pub etag: ngx_flag_t,
    pub gzip_vary: ngx_flag_t,
    pub gzip_http_version: ngx_uint_t,
    pub gzip_proxied: ngx_uint_t,
    pub gzip_disable: *mut ngx_array_t,
    pub thread_pool: *mut ngx_thread_pool_t,
    pub thread_pool_value: *mut ngx_http_complex_value_t,
    pub disable_symlinks: ngx_uint_t,
    pub disable_symlinks_from: *mut ngx_http_complex_value_t,
    pub error_pages: *mut ngx_array_t,
    pub client_body_temp_path: *mut ngx_path_t,
    pub open_file_cache: *mut ngx_open_file_cache_t,
    pub open_file_cache_valid: time_t,
    pub open_file_cache_min_uses: ngx_uint_t,
    pub open_file_cache_errors: ngx_flag_t,
    pub open_file_cache_events: ngx_flag_t,
    pub error_log: *mut ngx_log_t,
    pub types_hash_max_size: ngx_uint_t,
    pub types_hash_bucket_size: ngx_uint_t,
    pub locations: *mut ngx_queue_t,
}
impl ngx_http_core_loc_conf_s {
    #[inline]
    pub fn noname(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noname(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lmt_excpt(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lmt_excpt(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn named(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_named(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exact_match(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noregex(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noregex(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_redirect(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_redirect(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_disable_msie6(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_disable_msie6(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_disable_degradation(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_disable_degradation(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        noname: ::aya_bpf::cty::c_uint,
        lmt_excpt: ::aya_bpf::cty::c_uint,
        named: ::aya_bpf::cty::c_uint,
        exact_match: ::aya_bpf::cty::c_uint,
        noregex: ::aya_bpf::cty::c_uint,
        auto_redirect: ::aya_bpf::cty::c_uint,
        gzip_disable_msie6: ::aya_bpf::cty::c_uint,
        gzip_disable_degradation: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let noname: u32 = unsafe { ::core::mem::transmute(noname) };
            noname as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lmt_excpt: u32 = unsafe { ::core::mem::transmute(lmt_excpt) };
            lmt_excpt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let named: u32 = unsafe { ::core::mem::transmute(named) };
            named as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exact_match: u32 = unsafe { ::core::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let noregex: u32 = unsafe { ::core::mem::transmute(noregex) };
            noregex as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let auto_redirect: u32 = unsafe { ::core::mem::transmute(auto_redirect) };
            auto_redirect as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let gzip_disable_msie6: u32 = unsafe { ::core::mem::transmute(gzip_disable_msie6) };
            gzip_disable_msie6 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let gzip_disable_degradation: u32 =
                unsafe { ::core::mem::transmute(gzip_disable_degradation) };
            gzip_disable_degradation as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_location_queue_t {
    pub queue: ngx_queue_t,
    pub exact: *mut ngx_http_core_loc_conf_t,
    pub inclusive: *mut ngx_http_core_loc_conf_t,
    pub name: *mut ngx_str_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub list: ngx_queue_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_location_tree_node_s {
    pub left: *mut ngx_http_location_tree_node_t,
    pub right: *mut ngx_http_location_tree_node_t,
    pub tree: *mut ngx_http_location_tree_node_t,
    pub exact: *mut ngx_http_core_loc_conf_t,
    pub inclusive: *mut ngx_http_core_loc_conf_t,
    pub auto_redirect: u_char,
    pub len: u_char,
    pub name: [u_char; 1usize],
}
extern "C" {
    pub fn ngx_http_core_run_phases(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_core_generic_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_rewrite_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_find_config_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_post_rewrite_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_access_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_post_access_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_content_phase(
        r: *mut ngx_http_request_t,
        ph: *mut ngx_http_phase_handler_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_test_content_type(
        r: *mut ngx_http_request_t,
        types_hash: *mut ngx_hash_t,
    ) -> *mut ::aya_bpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_set_content_type(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_exten(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_set_etag(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_weak_etag(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_send_response(
        r: *mut ngx_http_request_t,
        status: ngx_uint_t,
        ct: *mut ngx_str_t,
        cv: *mut ngx_http_complex_value_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_map_uri_to_path(
        r: *mut ngx_http_request_t,
        name: *mut ngx_str_t,
        root_length: *mut size_t,
        reserved: size_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_auth_basic_user(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_gzip_ok(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_subrequest(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
        sr: *mut *mut ngx_http_request_t,
        psr: *mut ngx_http_post_subrequest_t,
        flags: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_internal_redirect(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_named_location(r: *mut ngx_http_request_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_cleanup_add(
        r: *mut ngx_http_request_t,
        size: size_t,
    ) -> *mut ngx_http_cleanup_t;
}
pub type ngx_http_output_header_filter_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>;
pub type ngx_http_output_body_filter_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
pub type ngx_http_request_body_filter_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
extern "C" {
    pub fn ngx_http_output_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_write_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_request_body_save_filter(
        r: *mut ngx_http_request_t,
        chain: *mut ngx_chain_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_disable_symlinks(
        r: *mut ngx_http_request_t,
        clcf: *mut ngx_http_core_loc_conf_t,
        path: *mut ngx_str_t,
        of: *mut ngx_open_file_info_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_get_forwarded_addr(
        r: *mut ngx_http_request_t,
        addr: *mut ngx_addr_t,
        headers: *mut ngx_array_t,
        value: *mut ngx_str_t,
        proxies: *mut ngx_array_t,
        recursive: ::aya_bpf::cty::c_int,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_core_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_max_module: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_http_core_get_method: ngx_str_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cache_valid_t {
    pub status: ngx_uint_t,
    pub valid: time_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_node_t {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub key: [u_char; 8usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub uniq: ngx_file_uniq_t,
    pub expire: time_t,
    pub valid_sec: time_t,
    pub body_start: size_t,
    pub fs_size: off_t,
    pub lock_time: ngx_msec_t,
}
impl ngx_http_file_cache_node_t {
    #[inline]
    pub fn count(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn uses(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_uses(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_msec(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_valid_msec(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn exists(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updating(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updating(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deleting(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deleting(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn purged(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_purged(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: ::aya_bpf::cty::c_uint,
        uses: ::aya_bpf::cty::c_uint,
        valid_msec: ::aya_bpf::cty::c_uint,
        error: ::aya_bpf::cty::c_uint,
        exists: ::aya_bpf::cty::c_uint,
        updating: ::aya_bpf::cty::c_uint,
        deleting: ::aya_bpf::cty::c_uint,
        purged: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let count: u32 = unsafe { ::core::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let uses: u32 = unsafe { ::core::mem::transmute(uses) };
            uses as u64
        });
        __bindgen_bitfield_unit.set(32usize, 10u8, {
            let valid_msec: u32 = unsafe { ::core::mem::transmute(valid_msec) };
            valid_msec as u64
        });
        __bindgen_bitfield_unit.set(42usize, 10u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let exists: u32 = unsafe { ::core::mem::transmute(exists) };
            exists as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let updating: u32 = unsafe { ::core::mem::transmute(updating) };
            updating as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let deleting: u32 = unsafe { ::core::mem::transmute(deleting) };
            deleting as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let purged: u32 = unsafe { ::core::mem::transmute(purged) };
            purged as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cache_s {
    pub file: ngx_file_t,
    pub keys: ngx_array_t,
    pub crc32: u32,
    pub key: [u_char; 16usize],
    pub main: [u_char; 16usize],
    pub uniq: ngx_file_uniq_t,
    pub valid_sec: time_t,
    pub updating_sec: time_t,
    pub error_sec: time_t,
    pub last_modified: time_t,
    pub date: time_t,
    pub etag: ngx_str_t,
    pub vary: ngx_str_t,
    pub variant: [u_char; 16usize],
    pub header_start: size_t,
    pub body_start: size_t,
    pub length: off_t,
    pub fs_size: off_t,
    pub min_uses: ngx_uint_t,
    pub error: ngx_uint_t,
    pub valid_msec: ngx_uint_t,
    pub vary_tag: ngx_uint_t,
    pub buf: *mut ngx_buf_t,
    pub file_cache: *mut ngx_http_file_cache_t,
    pub node: *mut ngx_http_file_cache_node_t,
    pub thread_task: *mut ngx_thread_task_t,
    pub lock_timeout: ngx_msec_t,
    pub lock_age: ngx_msec_t,
    pub lock_time: ngx_msec_t,
    pub wait_time: ngx_msec_t,
    pub wait_event: ngx_event_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_cache_s {
    #[inline]
    pub fn lock(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lock(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waiting(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waiting(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updated(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updating(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updating(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exists(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temp_file(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_file(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn purged(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_purged(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reading(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reading(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secondary(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stale_updating(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stale_updating(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stale_error(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stale_error(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lock: ::aya_bpf::cty::c_uint,
        waiting: ::aya_bpf::cty::c_uint,
        updated: ::aya_bpf::cty::c_uint,
        updating: ::aya_bpf::cty::c_uint,
        exists: ::aya_bpf::cty::c_uint,
        temp_file: ::aya_bpf::cty::c_uint,
        purged: ::aya_bpf::cty::c_uint,
        reading: ::aya_bpf::cty::c_uint,
        secondary: ::aya_bpf::cty::c_uint,
        background: ::aya_bpf::cty::c_uint,
        stale_updating: ::aya_bpf::cty::c_uint,
        stale_error: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lock: u32 = unsafe { ::core::mem::transmute(lock) };
            lock as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let waiting: u32 = unsafe { ::core::mem::transmute(waiting) };
            waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let updated: u32 = unsafe { ::core::mem::transmute(updated) };
            updated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let updating: u32 = unsafe { ::core::mem::transmute(updating) };
            updating as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exists: u32 = unsafe { ::core::mem::transmute(exists) };
            exists as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let temp_file: u32 = unsafe { ::core::mem::transmute(temp_file) };
            temp_file as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let purged: u32 = unsafe { ::core::mem::transmute(purged) };
            purged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reading: u32 = unsafe { ::core::mem::transmute(reading) };
            reading as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let secondary: u32 = unsafe { ::core::mem::transmute(secondary) };
            secondary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let background: u32 = unsafe { ::core::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let stale_updating: u32 = unsafe { ::core::mem::transmute(stale_updating) };
            stale_updating as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let stale_error: u32 = unsafe { ::core::mem::transmute(stale_error) };
            stale_error as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_file_cache_header_t {
    pub version: ngx_uint_t,
    pub valid_sec: time_t,
    pub updating_sec: time_t,
    pub error_sec: time_t,
    pub last_modified: time_t,
    pub date: time_t,
    pub crc32: u32,
    pub valid_msec: u_short,
    pub header_start: u_short,
    pub body_start: u_short,
    pub etag_len: u_char,
    pub etag: [u_char; 128usize],
    pub vary_len: u_char,
    pub vary: [u_char; 128usize],
    pub variant: [u_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_sh_t {
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub cold: ngx_atomic_t,
    pub loading: ngx_atomic_t,
    pub size: off_t,
    pub count: ngx_uint_t,
    pub watermark: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_s {
    pub sh: *mut ngx_http_file_cache_sh_t,
    pub shpool: *mut ngx_slab_pool_t,
    pub path: *mut ngx_path_t,
    pub max_size: off_t,
    pub bsize: size_t,
    pub inactive: time_t,
    pub fail_time: time_t,
    pub files: ngx_uint_t,
    pub loader_files: ngx_uint_t,
    pub last: ngx_msec_t,
    pub loader_sleep: ngx_msec_t,
    pub loader_threshold: ngx_msec_t,
    pub manager_files: ngx_uint_t,
    pub manager_sleep: ngx_msec_t,
    pub manager_threshold: ngx_msec_t,
    pub shm_zone: *mut ngx_shm_zone_t,
    pub use_temp_path: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_file_cache_new(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_create(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_create_key(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_file_cache_open(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_set_header(
        r: *mut ngx_http_request_t,
        buf: *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_update(r: *mut ngx_http_request_t, tf: *mut ngx_temp_file_t);
}
extern "C" {
    pub fn ngx_http_file_cache_update_header(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_cache_send(arg1: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_free(c: *mut ngx_http_cache_t, tf: *mut ngx_temp_file_t);
}
extern "C" {
    pub fn ngx_http_file_cache_valid(cache_valid: *mut ngx_array_t, status: ngx_uint_t) -> time_t;
}
extern "C" {
    pub fn ngx_http_file_cache_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_file_cache_valid_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_http_cache_status: [ngx_str_t; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_main_conf_t {
    pub hash: ngx_hash_t,
    pub commands: ngx_hash_keys_arrays_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_ctx_t {
    pub buf: *mut ngx_buf_t,
    pub pos: *mut u_char,
    pub copy_start: *mut u_char,
    pub copy_end: *mut u_char,
    pub key: ngx_uint_t,
    pub command: ngx_str_t,
    pub params: ngx_array_t,
    pub param: *mut ngx_table_elt_t,
    pub params_array: [ngx_table_elt_t; 4usize],
    pub in_: *mut ngx_chain_t,
    pub out: *mut ngx_chain_t,
    pub last_out: *mut *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub state: ngx_uint_t,
    pub saved_state: ngx_uint_t,
    pub saved: size_t,
    pub looked: size_t,
    pub value_len: size_t,
    pub variables: *mut ngx_list_t,
    pub blocks: *mut ngx_array_t,
    pub ncaptures: ngx_uint_t,
    pub captures: *mut ::aya_bpf::cty::c_int,
    pub captures_data: *mut u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub wait: *mut ngx_http_request_t,
    pub value_buf: *mut ::aya_bpf::cty::c_void,
    pub timefmt: ngx_str_t,
    pub errmsg: ngx_str_t,
}
impl ngx_http_ssi_ctx_t {
    #[inline]
    pub fn conditional(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_conditional(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn encoding(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_encoding(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output_chosen(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output_chosen(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conditional: ::aya_bpf::cty::c_uint,
        encoding: ::aya_bpf::cty::c_uint,
        block: ::aya_bpf::cty::c_uint,
        output: ::aya_bpf::cty::c_uint,
        output_chosen: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let conditional: u32 = unsafe { ::core::mem::transmute(conditional) };
            conditional as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let encoding: u32 = unsafe { ::core::mem::transmute(encoding) };
            encoding as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let block: u32 = unsafe { ::core::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let output: u32 = unsafe { ::core::mem::transmute(output) };
            output as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let output_chosen: u32 = unsafe { ::core::mem::transmute(output_chosen) };
            output_chosen as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_ssi_command_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        ctx: *mut ngx_http_ssi_ctx_t,
        arg1: *mut *mut ngx_str_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_param_t {
    pub name: ngx_str_t,
    pub index: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_ssi_param_t {
    #[inline]
    pub fn mandatory(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mandatory(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multiple(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multiple(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mandatory: ::aya_bpf::cty::c_uint,
        multiple: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mandatory: u32 = unsafe { ::core::mem::transmute(mandatory) };
            mandatory as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let multiple: u32 = unsafe { ::core::mem::transmute(multiple) };
            multiple as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_command_t {
    pub name: ngx_str_t,
    pub handler: ngx_http_ssi_command_pt,
    pub params: *mut ngx_http_ssi_param_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_ssi_command_t {
    #[inline]
    pub fn conditional(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_conditional(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> ::aya_bpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: ::aya_bpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conditional: ::aya_bpf::cty::c_uint,
        block: ::aya_bpf::cty::c_uint,
        flush: ::aya_bpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let conditional: u32 = unsafe { ::core::mem::transmute(conditional) };
            conditional as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let block: u32 = unsafe { ::core::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flush: u32 = unsafe { ::core::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut ngx_http_ssi_filter_module: ngx_module_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_log_ctx_s {
    pub connection: *mut ngx_connection_t,
    pub request: *mut ngx_http_request_t,
    pub current_request: *mut ngx_http_request_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_chunked_s {
    pub state: ngx_uint_t,
    pub size: off_t,
    pub length: off_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_status_t {
    pub http_version: ngx_uint_t,
    pub code: ngx_uint_t,
    pub count: ngx_uint_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
}
extern "C" {
    pub fn ngx_http_add_location(
        cf: *mut ngx_conf_t,
        locations: *mut *mut ngx_queue_t,
        clcf: *mut ngx_http_core_loc_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_add_listen(
        cf: *mut ngx_conf_t,
        cscf: *mut ngx_http_core_srv_conf_t,
        lsopt: *mut ngx_http_listen_opt_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_init_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_close_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_parse_request_line(r: *mut ngx_http_request_t, b: *mut ngx_buf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_uri(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_complex_uri(
        r: *mut ngx_http_request_t,
        merge_slashes: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_status_line(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        status: *mut ngx_http_status_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_unsafe_uri(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
        flags: *mut ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_header_line(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        allow_underscores: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_multi_header_lines(
        headers: *mut ngx_array_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_set_cookie_lines(
        headers: *mut ngx_array_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_arg(
        r: *mut ngx_http_request_t,
        name: *mut u_char,
        len: size_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_split_args(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
    );
}
extern "C" {
    pub fn ngx_http_parse_chunked(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        ctx: *mut ngx_http_chunked_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_create_request(c: *mut ngx_connection_t) -> *mut ngx_http_request_t;
}
extern "C" {
    pub fn ngx_http_process_request_uri(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_process_request_header(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_process_request(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_update_location_config(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_run_posted_requests(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_post_request(
        r: *mut ngx_http_request_t,
        pr: *mut ngx_http_posted_request_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_finalize_request(r: *mut ngx_http_request_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_free_request(r: *mut ngx_http_request_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_empty_handler(wev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_http_request_empty_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_send_special(r: *mut ngx_http_request_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_read_client_request_body(
        r: *mut ngx_http_request_t,
        post_handler: ngx_http_client_body_handler_pt,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_read_unbuffered_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_send_header(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_special_response_handler(
        r: *mut ngx_http_request_t,
        error: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_filter_finalize_request(
        r: *mut ngx_http_request_t,
        m: *mut ngx_module_t,
        error: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_clean_header(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_discard_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_discarded_request_body_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_block_reading(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_test_reading(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_types_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_bpf::cty::c_void,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_merge_types(
        cf: *mut ngx_conf_t,
        keys: *mut *mut ngx_array_t,
        types_hash: *mut ngx_hash_t,
        prev_keys: *mut *mut ngx_array_t,
        prev_types_hash: *mut ngx_hash_t,
        default_types: *mut ngx_str_t,
    ) -> *mut ::aya_bpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_set_default_types(
        cf: *mut ngx_conf_t,
        types: *mut *mut ngx_array_t,
        default_type: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_html_default_types: [ngx_str_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_top_header_filter: ngx_http_output_header_filter_pt;
}
extern "C" {
    pub static mut ngx_http_top_body_filter: ngx_http_output_body_filter_pt;
}
extern "C" {
    pub static mut ngx_http_top_request_body_filter: ngx_http_request_body_filter_pt;
}
pub const NGX_RS_HTTP_MAIN_CONF_OFFSET: size_t = 0;
pub const NGX_RS_HTTP_SRV_CONF_OFFSET: size_t = 8;
pub const NGX_RS_HTTP_LOC_CONF_OFFSET: size_t = 16;
pub const NGX_RS_MODULE_SIGNATURE: &'static [u8; 41usize] =
    b"8,4,8,0011111111010111001111111111111111\0";
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::aya_bpf::cty::c_uint,
    pub fp_offset: ::aya_bpf::cty::c_uint,
    pub overflow_arg_area: *mut ::aya_bpf::cty::c_void,
    pub reg_save_area: *mut ::aya_bpf::cty::c_void,
}
