/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const NGX_HAVE_UNISTD_H: u32 = 1;
pub const NGX_HAVE_INTTYPES_H: u32 = 1;
pub const NGX_HAVE_LIMITS_H: u32 = 1;
pub const NGX_HAVE_SYS_PARAM_H: u32 = 1;
pub const NGX_HAVE_SYS_MOUNT_H: u32 = 1;
pub const NGX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const NGX_HAVE_CRYPT_H: u32 = 1;
pub const NGX_LINUX: u32 = 1;
pub const NGX_HAVE_SYS_PRCTL_H: u32 = 1;
pub const NGX_HAVE_SYS_VFS_H: u32 = 1;
pub const _FILE_OFFSET_BITS: u32 = 64;
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_FILE_OFFSET64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const CLOSE_RANGE_UNSHARE: u32 = 2;
pub const CLOSE_RANGE_CLOEXEC: u32 = 4;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _PRINTF_NAN_LEN_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const __error_t_defined: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_ARCH_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _PWD_H: u32 = 1;
pub const NSS_BUFLEN_PASSWD: u32 = 1024;
pub const _GRP_H: u32 = 1;
pub const NSS_BUFLEN_GROUP: u32 = 1024;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const __SC_THREAD_STACK_MIN_VALUE: u32 = 75;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const MAXNAMLEN: u32 = 255;
pub const _GLOB_H: u32 = 1;
pub const GLOB_ERR: u32 = 1;
pub const GLOB_MARK: u32 = 2;
pub const GLOB_NOSORT: u32 = 4;
pub const GLOB_DOOFFS: u32 = 8;
pub const GLOB_NOCHECK: u32 = 16;
pub const GLOB_APPEND: u32 = 32;
pub const GLOB_NOESCAPE: u32 = 64;
pub const GLOB_PERIOD: u32 = 128;
pub const GLOB_MAGCHAR: u32 = 256;
pub const GLOB_ALTDIRFUNC: u32 = 512;
pub const GLOB_BRACE: u32 = 1024;
pub const GLOB_NOMAGIC: u32 = 2048;
pub const GLOB_TILDE: u32 = 4096;
pub const GLOB_ONLYDIR: u32 = 8192;
pub const GLOB_TILDE_CHECK: u32 = 16384;
pub const __GLOB_FLAGS: u32 = 32511;
pub const GLOB_NOSPACE: u32 = 1;
pub const GLOB_ABORTED: u32 = 2;
pub const GLOB_NOMATCH: u32 = 3;
pub const GLOB_NOSYS: u32 = 4;
pub const GLOB_ABEND: u32 = 2;
pub const _SYS_STATFS_H: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _BITS_UIO_EXT_H: u32 = 1;
pub const RWF_HIPRI: u32 = 1;
pub const RWF_DSYNC: u32 = 2;
pub const RWF_SYNC: u32 = 4;
pub const RWF_NOWAIT: u32 = 8;
pub const RWF_APPEND: u32 = 16;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const __BITS_PER_LONG: u32 = 64;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ALL: u32 = 4095;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const __statx_timestamp_defined: u32 = 1;
pub const __statx_defined: u32 = 1;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const O_LARGEFILE: u32 = 0;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DIRECT: u32 = 16384;
pub const O_NOATIME: u32 = 262144;
pub const O_PATH: u32 = 2097152;
pub const O_TMPFILE: u32 = 4259840;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const SPLICE_F_MOVE: u32 = 1;
pub const SPLICE_F_NONBLOCK: u32 = 2;
pub const SPLICE_F_MORE: u32 = 4;
pub const SPLICE_F_GIFT: u32 = 8;
pub const FALLOC_FL_KEEP_SIZE: u32 = 1;
pub const FALLOC_FL_PUNCH_HOLE: u32 = 2;
pub const FALLOC_FL_NO_HIDE_STALE: u32 = 4;
pub const FALLOC_FL_COLLAPSE_RANGE: u32 = 8;
pub const FALLOC_FL_ZERO_RANGE: u32 = 16;
pub const FALLOC_FL_INSERT_RANGE: u32 = 32;
pub const FALLOC_FL_UNSHARE_RANGE: u32 = 64;
pub const MAX_HANDLE_SZ: u32 = 128;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_EACCESS: u32 = 512;
pub const _SYS_WAIT_H: u32 = 1;
pub const WCOREFLAG: u32 = 128;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _SYS_MMAN_H: u32 = 1;
pub const MAP_32BIT: u32 = 64;
pub const MAP_GROWSDOWN: u32 = 256;
pub const MAP_DENYWRITE: u32 = 2048;
pub const MAP_EXECUTABLE: u32 = 4096;
pub const MAP_LOCKED: u32 = 8192;
pub const MAP_NORESERVE: u32 = 16384;
pub const MAP_POPULATE: u32 = 32768;
pub const MAP_NONBLOCK: u32 = 65536;
pub const MAP_STACK: u32 = 131072;
pub const MAP_HUGETLB: u32 = 262144;
pub const MAP_SYNC: u32 = 524288;
pub const MAP_FIXED_NOREPLACE: u32 = 1048576;
pub const PROT_READ: u32 = 1;
pub const PROT_WRITE: u32 = 2;
pub const PROT_EXEC: u32 = 4;
pub const PROT_NONE: u32 = 0;
pub const PROT_GROWSDOWN: u32 = 16777216;
pub const PROT_GROWSUP: u32 = 33554432;
pub const MAP_SHARED: u32 = 1;
pub const MAP_PRIVATE: u32 = 2;
pub const MAP_SHARED_VALIDATE: u32 = 3;
pub const MAP_TYPE: u32 = 15;
pub const MAP_FIXED: u32 = 16;
pub const MAP_FILE: u32 = 0;
pub const MAP_ANONYMOUS: u32 = 32;
pub const MAP_ANON: u32 = 32;
pub const MAP_HUGE_SHIFT: u32 = 26;
pub const MAP_HUGE_MASK: u32 = 63;
pub const MS_ASYNC: u32 = 1;
pub const MS_SYNC: u32 = 4;
pub const MS_INVALIDATE: u32 = 2;
pub const MADV_NORMAL: u32 = 0;
pub const MADV_RANDOM: u32 = 1;
pub const MADV_SEQUENTIAL: u32 = 2;
pub const MADV_WILLNEED: u32 = 3;
pub const MADV_DONTNEED: u32 = 4;
pub const MADV_FREE: u32 = 8;
pub const MADV_REMOVE: u32 = 9;
pub const MADV_DONTFORK: u32 = 10;
pub const MADV_DOFORK: u32 = 11;
pub const MADV_MERGEABLE: u32 = 12;
pub const MADV_UNMERGEABLE: u32 = 13;
pub const MADV_HUGEPAGE: u32 = 14;
pub const MADV_NOHUGEPAGE: u32 = 15;
pub const MADV_DONTDUMP: u32 = 16;
pub const MADV_DODUMP: u32 = 17;
pub const MADV_WIPEONFORK: u32 = 18;
pub const MADV_KEEPONFORK: u32 = 19;
pub const MADV_COLD: u32 = 20;
pub const MADV_PAGEOUT: u32 = 21;
pub const MADV_POPULATE_READ: u32 = 22;
pub const MADV_POPULATE_WRITE: u32 = 23;
pub const MADV_DONTNEED_LOCKED: u32 = 24;
pub const MADV_COLLAPSE: u32 = 25;
pub const MADV_HWPOISON: u32 = 100;
pub const POSIX_MADV_NORMAL: u32 = 0;
pub const POSIX_MADV_RANDOM: u32 = 1;
pub const POSIX_MADV_SEQUENTIAL: u32 = 2;
pub const POSIX_MADV_WILLNEED: u32 = 3;
pub const POSIX_MADV_DONTNEED: u32 = 4;
pub const MCL_CURRENT: u32 = 1;
pub const MCL_FUTURE: u32 = 2;
pub const MCL_ONFAULT: u32 = 4;
pub const MREMAP_MAYMOVE: u32 = 1;
pub const MREMAP_FIXED: u32 = 2;
pub const MREMAP_DONTUNMAP: u32 = 4;
pub const MFD_CLOEXEC: u32 = 1;
pub const MFD_ALLOW_SEALING: u32 = 2;
pub const MFD_HUGETLB: u32 = 4;
pub const MLOCK_ONFAULT: u32 = 1;
pub const PKEY_DISABLE_ACCESS: u32 = 1;
pub const PKEY_DISABLE_WRITE: u32 = 2;
pub const _SYS_RESOURCE_H: u32 = 1;
pub const RLIM_INFINITY: i32 = -1;
pub const RLIM64_INFINITY: i32 = -1;
pub const RLIM_SAVED_MAX: i32 = -1;
pub const RLIM_SAVED_CUR: i32 = -1;
pub const __rusage_defined: u32 = 1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_NEWTIME: u32 = 128;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const _SYS_SOCKET_H: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _ARPA_INET_H: u32 = 1;
pub const _NETDB_H: u32 = 1;
pub const _RPC_NETDB_H: u32 = 1;
pub const _PATH_HEQUIV: &[u8; 17] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14] = b"/etc/networks\0";
pub const _PATH_NSSWITCH_CONF: &[u8; 19] = b"/etc/nsswitch.conf\0";
pub const _PATH_PROTOCOLS: &[u8; 15] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14] = b"/etc/services\0";
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const GAI_WAIT: u32 = 0;
pub const GAI_NOWAIT: u32 = 1;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_IDN: u32 = 64;
pub const AI_CANONIDN: u32 = 128;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const EAI_NODATA: i32 = -5;
pub const EAI_ADDRFAMILY: i32 = -9;
pub const EAI_INPROGRESS: i32 = -100;
pub const EAI_CANCELED: i32 = -101;
pub const EAI_NOTCANCELED: i32 = -102;
pub const EAI_ALLDONE: i32 = -103;
pub const EAI_INTR: i32 = -104;
pub const EAI_IDN_ENCODE: i32 = -105;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_IDN: u32 = 32;
pub const _SYS_UN_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _MALLOC_H: u32 = 1;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
pub const M_CHECK_ACTION: i32 = -5;
pub const M_PERTURB: i32 = -6;
pub const M_ARENA_TEST: i32 = -7;
pub const M_ARENA_MAX: i32 = -8;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const BOOL_MAX: u32 = 1;
pub const BOOL_WIDTH: u32 = 1;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _SYS_IOCTL_H: u32 = 1;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const TCGETS: u32 = 21505;
pub const TCSETS: u32 = 21506;
pub const TCSETSW: u32 = 21507;
pub const TCSETSF: u32 = 21508;
pub const TCGETA: u32 = 21509;
pub const TCSETA: u32 = 21510;
pub const TCSETAW: u32 = 21511;
pub const TCSETAF: u32 = 21512;
pub const TCSBRK: u32 = 21513;
pub const TCXONC: u32 = 21514;
pub const TCFLSH: u32 = 21515;
pub const TIOCEXCL: u32 = 21516;
pub const TIOCNXCL: u32 = 21517;
pub const TIOCSCTTY: u32 = 21518;
pub const TIOCGPGRP: u32 = 21519;
pub const TIOCSPGRP: u32 = 21520;
pub const TIOCOUTQ: u32 = 21521;
pub const TIOCSTI: u32 = 21522;
pub const TIOCGWINSZ: u32 = 21523;
pub const TIOCSWINSZ: u32 = 21524;
pub const TIOCMGET: u32 = 21525;
pub const TIOCMBIS: u32 = 21526;
pub const TIOCMBIC: u32 = 21527;
pub const TIOCMSET: u32 = 21528;
pub const TIOCGSOFTCAR: u32 = 21529;
pub const TIOCSSOFTCAR: u32 = 21530;
pub const FIONREAD: u32 = 21531;
pub const TIOCINQ: u32 = 21531;
pub const TIOCLINUX: u32 = 21532;
pub const TIOCCONS: u32 = 21533;
pub const TIOCGSERIAL: u32 = 21534;
pub const TIOCSSERIAL: u32 = 21535;
pub const TIOCPKT: u32 = 21536;
pub const FIONBIO: u32 = 21537;
pub const TIOCNOTTY: u32 = 21538;
pub const TIOCSETD: u32 = 21539;
pub const TIOCGETD: u32 = 21540;
pub const TCSBRKP: u32 = 21541;
pub const TIOCSBRK: u32 = 21543;
pub const TIOCCBRK: u32 = 21544;
pub const TIOCGSID: u32 = 21545;
pub const TIOCGRS485: u32 = 21550;
pub const TIOCSRS485: u32 = 21551;
pub const TCGETX: u32 = 21554;
pub const TCSETX: u32 = 21555;
pub const TCSETXF: u32 = 21556;
pub const TCSETXW: u32 = 21557;
pub const TIOCVHANGUP: u32 = 21559;
pub const FIONCLEX: u32 = 21584;
pub const FIOCLEX: u32 = 21585;
pub const FIOASYNC: u32 = 21586;
pub const TIOCSERCONFIG: u32 = 21587;
pub const TIOCSERGWILD: u32 = 21588;
pub const TIOCSERSWILD: u32 = 21589;
pub const TIOCGLCKTRMIOS: u32 = 21590;
pub const TIOCSLCKTRMIOS: u32 = 21591;
pub const TIOCSERGSTRUCT: u32 = 21592;
pub const TIOCSERGETLSR: u32 = 21593;
pub const TIOCSERGETMULTI: u32 = 21594;
pub const TIOCSERSETMULTI: u32 = 21595;
pub const TIOCMIWAIT: u32 = 21596;
pub const TIOCGICOUNT: u32 = 21597;
pub const FIOQSIZE: u32 = 21600;
pub const TIOCPKT_DATA: u32 = 0;
pub const TIOCPKT_FLUSHREAD: u32 = 1;
pub const TIOCPKT_FLUSHWRITE: u32 = 2;
pub const TIOCPKT_STOP: u32 = 4;
pub const TIOCPKT_START: u32 = 8;
pub const TIOCPKT_NOSTOP: u32 = 16;
pub const TIOCPKT_DOSTOP: u32 = 32;
pub const TIOCPKT_IOCTL: u32 = 64;
pub const TIOCSER_TEMT: u32 = 1;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const NCC: u32 = 8;
pub const TIOCM_LE: u32 = 1;
pub const TIOCM_DTR: u32 = 2;
pub const TIOCM_RTS: u32 = 4;
pub const TIOCM_ST: u32 = 8;
pub const TIOCM_SR: u32 = 16;
pub const TIOCM_CTS: u32 = 32;
pub const TIOCM_CAR: u32 = 64;
pub const TIOCM_RNG: u32 = 128;
pub const TIOCM_DSR: u32 = 256;
pub const TIOCM_CD: u32 = 64;
pub const TIOCM_RI: u32 = 128;
pub const N_TTY: u32 = 0;
pub const N_SLIP: u32 = 1;
pub const N_MOUSE: u32 = 2;
pub const N_PPP: u32 = 3;
pub const N_STRIP: u32 = 4;
pub const N_AX25: u32 = 5;
pub const N_X25: u32 = 6;
pub const N_6PACK: u32 = 7;
pub const N_MASC: u32 = 8;
pub const N_R3964: u32 = 9;
pub const N_PROFIBUS_FDL: u32 = 10;
pub const N_IRDA: u32 = 11;
pub const N_SMSBLOCK: u32 = 12;
pub const N_HDLC: u32 = 13;
pub const N_SYNC_PPP: u32 = 14;
pub const N_HCI: u32 = 15;
pub const CEOL: u8 = 0u8;
pub const CERASE: u32 = 127;
pub const CSTATUS: u8 = 0u8;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u8 = 0u8;
pub const _CRYPT_H: u32 = 1;
pub const CRYPT_OUTPUT_SIZE: u32 = 384;
pub const CRYPT_MAX_PASSPHRASE_SIZE: u32 = 512;
pub const CRYPT_GENSALT_OUTPUT_SIZE: u32 = 192;
pub const CRYPT_DATA_RESERVED_SIZE: u32 = 767;
pub const CRYPT_DATA_INTERNAL_SIZE: u32 = 30720;
pub const CRYPT_SALT_OK: u32 = 0;
pub const CRYPT_SALT_INVALID: u32 = 1;
pub const CRYPT_SALT_METHOD_DISABLED: u32 = 2;
pub const CRYPT_SALT_METHOD_LEGACY: u32 = 3;
pub const CRYPT_SALT_TOO_CHEAP: u32 = 4;
pub const CRYPT_GENSALT_IMPLEMENTS_DEFAULT_PREFIX: u32 = 1;
pub const CRYPT_GENSALT_IMPLEMENTS_AUTO_ENTROPY: u32 = 1;
pub const CRYPT_CHECKSALT_AVAILABLE: u32 = 1;
pub const CRYPT_PREFERRED_METHOD_AVAILABLE: u32 = 1;
pub const XCRYPT_VERSION_MAJOR: u32 = 4;
pub const XCRYPT_VERSION_MINOR: u32 = 4;
pub const XCRYPT_VERSION_NUM: u32 = 262148;
pub const XCRYPT_VERSION_STR: &[u8; 7] = b"4.4.36\0";
pub const _SYS_UTSNAME_H: u32 = 1;
pub const _UTSNAME_LENGTH: u32 = 65;
pub const _UTSNAME_DOMAIN_LENGTH: u32 = 65;
pub const _UTSNAME_SYSNAME_LENGTH: u32 = 65;
pub const _UTSNAME_NODENAME_LENGTH: u32 = 65;
pub const _UTSNAME_RELEASE_LENGTH: u32 = 65;
pub const _UTSNAME_VERSION_LENGTH: u32 = 65;
pub const _UTSNAME_MACHINE_LENGTH: u32 = 65;
pub const SYS_NMLN: u32 = 65;
pub const _DLFCN_H: u32 = 1;
pub const RTLD_LAZY: u32 = 1;
pub const RTLD_NOW: u32 = 2;
pub const RTLD_BINDING_MASK: u32 = 3;
pub const RTLD_NOLOAD: u32 = 4;
pub const RTLD_DEEPBIND: u32 = 8;
pub const RTLD_GLOBAL: u32 = 256;
pub const RTLD_LOCAL: u32 = 0;
pub const RTLD_NODELETE: u32 = 4096;
pub const DLFO_STRUCT_HAS_EH_DBASE: u32 = 0;
pub const DLFO_STRUCT_HAS_EH_COUNT: u32 = 0;
pub const LM_ID_BASE: u32 = 0;
pub const LM_ID_NEWLM: i32 = -1;
pub const NGX_CONFIGURE : & [u8 ; 4515] = b" --prefix=/home/honghaier/Workspaces/Sources/rust/ngx-rust/.cache/nginx/1.21.4/x86_64-unknown-linux-gnu --with-debug --with-file-aio --with-compat --with-http_addition_module --with-http_auth_request_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-stream --with-threads --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/ngx_devel_kit-0.3.1 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/iconv-nginx-module-0.14 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/echo-nginx-module-0.62 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/xss-nginx-module-0.06 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/ngx_coolkit-0.2 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/set-misc-nginx-module-0.33 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/form-input-nginx-module-0.12 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/encrypted-session-nginx-module-0.09 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/srcache-nginx-module-0.32 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/ngx_lua-0.10.21 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/ngx_lua_upstream-0.07 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/headers-more-nginx-module-0.33 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/array-var-nginx-module-0.05 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/memc-nginx-module-0.19 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/redis2-nginx-module-0.15 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/redis-nginx-module-0.3.9 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/rds-json-nginx-module-0.15 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/rds-csv-nginx-module-0.09 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/ngx_stream_lua-0.0.11 --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-module-vts --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-module-sts --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-module-stream-sts --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-sticky-module-ng --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-module-cookie-flag --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-module-stream-lua-upstream --add-module=/home/honghaier/Workspaces/Sources/Nginx/docker-openresty/openresty/src/openresty/bundle/nginx-module-http-upstream-fair --with-stream_realip_module --with-cc-opt='-DKOAL_SSL_WITHOUT_LICENSE -g -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC -DNGX_LUA_USE_ASSERT -DNGX_LUA_ABORT_AT_PANIC -O2 -I/usr/local/kssl/1.1/include -Wall -Werror -DKOAL_SSL_EXTENSION -fno-omit-frame-pointer -DKOAL_SSL_NAME=trpd -DKOAL_SSL_VERSION=1.21.4.1 -DKOAL_SSL_REVISION=bc6c1809:2119:bc6c1809:2119:20240424' --with-ld-opt='-Wl,-Bsymbolic-functions -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie -Wl,-rpath,/kssl/TRP/luajit/lib -L/usr/local/kssl/1.1/lib -lssl -lcrypto -llicense -lKLCRL'\0" ;
pub const NGX_DEBUG: u32 = 1;
pub const NGX_COMPILER: &[u8; 31] = b"gcc 13.2.0 (Debian 13.2.0-13) \0";
pub const NGX_HAVE_GCC_ATOMIC: u32 = 1;
pub const NGX_HAVE_C99_VARIADIC_MACROS: u32 = 1;
pub const NGX_HAVE_GCC_VARIADIC_MACROS: u32 = 1;
pub const NGX_HAVE_GCC_BSWAP64: u32 = 1;
pub const NGX_HAVE_EPOLL: u32 = 1;
pub const NGX_HAVE_CLEAR_EVENT: u32 = 1;
pub const NGX_HAVE_EPOLLRDHUP: u32 = 1;
pub const NGX_HAVE_EPOLLEXCLUSIVE: u32 = 1;
pub const NGX_HAVE_EVENTFD: u32 = 1;
pub const NGX_HAVE_SYS_EVENTFD_H: u32 = 1;
pub const NGX_HAVE_O_PATH: u32 = 1;
pub const NGX_HAVE_SENDFILE: u32 = 1;
pub const NGX_HAVE_SENDFILE64: u32 = 1;
pub const NGX_HAVE_PR_SET_DUMPABLE: u32 = 1;
pub const NGX_HAVE_PR_SET_KEEPCAPS: u32 = 1;
pub const NGX_HAVE_CAPABILITIES: u32 = 1;
pub const NGX_HAVE_GNU_CRYPT_R: u32 = 1;
pub const NGX_HAVE_NONALIGNED: u32 = 1;
pub const NGX_CPU_CACHE_LINE: u32 = 64;
pub const NGX_HAVE_POSIX_FADVISE: u32 = 1;
pub const NGX_HAVE_O_DIRECT: u32 = 1;
pub const NGX_HAVE_ALIGNED_DIRECTIO: u32 = 1;
pub const NGX_HAVE_STATFS: u32 = 1;
pub const NGX_HAVE_STATVFS: u32 = 1;
pub const NGX_HAVE_DLOPEN: u32 = 1;
pub const NGX_HAVE_SCHED_YIELD: u32 = 1;
pub const NGX_HAVE_SCHED_SETAFFINITY: u32 = 1;
pub const NGX_HAVE_REUSEPORT: u32 = 1;
pub const NGX_HAVE_TRANSPARENT_PROXY: u32 = 1;
pub const NGX_HAVE_IP_BIND_ADDRESS_NO_PORT: u32 = 1;
pub const NGX_HAVE_IP_PKTINFO: u32 = 1;
pub const NGX_HAVE_IPV6_RECVPKTINFO: u32 = 1;
pub const NGX_HAVE_DEFERRED_ACCEPT: u32 = 1;
pub const NGX_HAVE_KEEPALIVE_TUNABLE: u32 = 1;
pub const NGX_HAVE_TCP_FASTOPEN: u32 = 1;
pub const NGX_HAVE_TCP_INFO: u32 = 1;
pub const NGX_HAVE_ACCEPT4: u32 = 1;
pub const NGX_HAVE_FILE_AIO: u32 = 1;
pub const NGX_HAVE_UNIX_DOMAIN: u32 = 1;
pub const NGX_PTR_SIZE: u32 = 8;
pub const NGX_SIG_ATOMIC_T_SIZE: u32 = 4;
pub const NGX_HAVE_LITTLE_ENDIAN: u32 = 1;
pub const NGX_MAX_SIZE_T_VALUE: u64 = 9223372036854775807;
pub const NGX_MAX_OFF_T_VALUE: u64 = 9223372036854775807;
pub const NGX_TIME_T_SIZE: u32 = 8;
pub const NGX_MAX_TIME_T_VALUE: u64 = 9223372036854775807;
pub const NGX_HAVE_INET6: u32 = 1;
pub const NGX_HAVE_PREAD: u32 = 1;
pub const NGX_HAVE_PWRITEV: u32 = 1;
pub const NGX_HAVE_LOCALTIME_R: u32 = 1;
pub const NGX_HAVE_CLOCK_MONOTONIC: u32 = 1;
pub const NGX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const NGX_HAVE_MEMALIGN: u32 = 1;
pub const NGX_HAVE_MAP_ANON: u32 = 1;
pub const NGX_HAVE_MAP_DEVZERO: u32 = 1;
pub const NGX_HAVE_SYSVSHM: u32 = 1;
pub const NGX_HAVE_POSIX_SEM: u32 = 1;
pub const NGX_HAVE_MSGHDR_MSG_CONTROL: u32 = 1;
pub const NGX_HAVE_FIONBIO: u32 = 1;
pub const NGX_HAVE_FIONREAD: u32 = 1;
pub const NGX_HAVE_GMTOFF: u32 = 1;
pub const NGX_HAVE_D_TYPE: u32 = 1;
pub const NGX_HAVE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const NGX_HAVE_LEVEL1_DCACHE_LINESIZE: u32 = 1;
pub const NGX_HAVE_OPENAT: u32 = 1;
pub const NGX_HAVE_GETADDRINFO: u32 = 1;
pub const NGX_HAVE_FD_CLOEXEC: u32 = 1;
pub const NGX_THREADS: u32 = 1;
pub const NGX_HTTP_CACHE: u32 = 1;
pub const NGX_HTTP_GZIP: u32 = 1;
pub const NGX_HTTP_SSI: u32 = 1;
pub const NGX_HTTP_V2: u32 = 1;
pub const NGX_HTTP_HEADERS: u32 = 1;
pub const NGX_CRYPT: u32 = 1;
pub const NGX_HTTP_REALIP: u32 = 1;
pub const NGX_HTTP_X_FORWARDED_FOR: u32 = 1;
pub const NGX_HTTP_SSL: u32 = 1;
pub const NGX_HTTP_UPSTREAM_ZONE: u32 = 1;
pub const NGX_STAT_STUB: u32 = 1;
pub const NGX_STREAM_SSL: u32 = 1;
pub const NGX_STREAM_UPSTREAM_ZONE: u32 = 1;
pub const NDK: u32 = 1;
pub const NGX_COOLKIT_MODULE: u32 = 1;
pub const NGX_HTTP_LUA_HAVE_SO_PASSCRED: u32 = 1;
pub const NGX_HTTP_LUA_HAVE_MALLOC_TRIM: u32 = 1;
pub const NGX_HTTP_LUA_HAVE_EXECVPE: u32 = 1;
pub const NGX_STREAM_LUA_HAVE_SO_PASSCRED: u32 = 1;
pub const NGX_VTS_MODULE: u32 = 1;
pub const NGX_STS_MODULE: u32 = 1;
pub const NGX_COMPAT: u32 = 1;
pub const NGX_HTTP_DAV: u32 = 1;
pub const NGX_PCRE: u32 = 1;
pub const NGX_HAVE_PCRE_JIT: u32 = 1;
pub const NGX_OPENSSL: u32 = 1;
pub const NGX_SSL: u32 = 1;
pub const NGX_ZLIB: u32 = 1;
pub const NGX_PREFIX: &[u8; 95] =
    b"/home/honghaier/Workspaces/Sources/rust/ngx-rust/.cache/nginx/1.21.4/x86_64-unknown-linux-gnu/\0";
pub const NGX_CONF_PREFIX: &[u8; 6] = b"conf/\0";
pub const NGX_SBIN_PATH: &[u8; 11] = b"sbin/nginx\0";
pub const NGX_CONF_PATH: &[u8; 16] = b"conf/nginx.conf\0";
pub const NGX_PID_PATH: &[u8; 15] = b"logs/nginx.pid\0";
pub const NGX_LOCK_PATH: &[u8; 16] = b"logs/nginx.lock\0";
pub const NGX_ERROR_LOG_PATH: &[u8; 15] = b"logs/error.log\0";
pub const NGX_HTTP_LOG_PATH: &[u8; 16] = b"logs/access.log\0";
pub const NGX_HTTP_CLIENT_TEMP_PATH: &[u8; 17] = b"client_body_temp\0";
pub const NGX_HTTP_PROXY_TEMP_PATH: &[u8; 11] = b"proxy_temp\0";
pub const NGX_HTTP_FASTCGI_TEMP_PATH: &[u8; 13] = b"fastcgi_temp\0";
pub const NGX_HTTP_UWSGI_TEMP_PATH: &[u8; 11] = b"uwsgi_temp\0";
pub const NGX_HTTP_SCGI_TEMP_PATH: &[u8; 10] = b"scgi_temp\0";
pub const NGX_SUPPRESS_WARN: u32 = 1;
pub const NGX_SMP: u32 = 1;
pub const NGX_USER: &[u8; 7] = b"nobody\0";
pub const NGX_GROUP: &[u8; 8] = b"nogroup\0";
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const _SYS_PRCTL_H: u32 = 1;
pub const PR_SET_PDEATHSIG: u32 = 1;
pub const PR_GET_PDEATHSIG: u32 = 2;
pub const PR_GET_DUMPABLE: u32 = 3;
pub const PR_SET_DUMPABLE: u32 = 4;
pub const PR_GET_UNALIGN: u32 = 5;
pub const PR_SET_UNALIGN: u32 = 6;
pub const PR_UNALIGN_NOPRINT: u32 = 1;
pub const PR_UNALIGN_SIGBUS: u32 = 2;
pub const PR_GET_KEEPCAPS: u32 = 7;
pub const PR_SET_KEEPCAPS: u32 = 8;
pub const PR_GET_FPEMU: u32 = 9;
pub const PR_SET_FPEMU: u32 = 10;
pub const PR_FPEMU_NOPRINT: u32 = 1;
pub const PR_FPEMU_SIGFPE: u32 = 2;
pub const PR_GET_FPEXC: u32 = 11;
pub const PR_SET_FPEXC: u32 = 12;
pub const PR_FP_EXC_SW_ENABLE: u32 = 128;
pub const PR_FP_EXC_DIV: u32 = 65536;
pub const PR_FP_EXC_OVF: u32 = 131072;
pub const PR_FP_EXC_UND: u32 = 262144;
pub const PR_FP_EXC_RES: u32 = 524288;
pub const PR_FP_EXC_INV: u32 = 1048576;
pub const PR_FP_EXC_DISABLED: u32 = 0;
pub const PR_FP_EXC_NONRECOV: u32 = 1;
pub const PR_FP_EXC_ASYNC: u32 = 2;
pub const PR_FP_EXC_PRECISE: u32 = 3;
pub const PR_GET_TIMING: u32 = 13;
pub const PR_SET_TIMING: u32 = 14;
pub const PR_TIMING_STATISTICAL: u32 = 0;
pub const PR_TIMING_TIMESTAMP: u32 = 1;
pub const PR_SET_NAME: u32 = 15;
pub const PR_GET_NAME: u32 = 16;
pub const PR_GET_ENDIAN: u32 = 19;
pub const PR_SET_ENDIAN: u32 = 20;
pub const PR_ENDIAN_BIG: u32 = 0;
pub const PR_ENDIAN_LITTLE: u32 = 1;
pub const PR_ENDIAN_PPC_LITTLE: u32 = 2;
pub const PR_GET_SECCOMP: u32 = 21;
pub const PR_SET_SECCOMP: u32 = 22;
pub const PR_CAPBSET_READ: u32 = 23;
pub const PR_CAPBSET_DROP: u32 = 24;
pub const PR_GET_TSC: u32 = 25;
pub const PR_SET_TSC: u32 = 26;
pub const PR_TSC_ENABLE: u32 = 1;
pub const PR_TSC_SIGSEGV: u32 = 2;
pub const PR_GET_SECUREBITS: u32 = 27;
pub const PR_SET_SECUREBITS: u32 = 28;
pub const PR_SET_TIMERSLACK: u32 = 29;
pub const PR_GET_TIMERSLACK: u32 = 30;
pub const PR_TASK_PERF_EVENTS_DISABLE: u32 = 31;
pub const PR_TASK_PERF_EVENTS_ENABLE: u32 = 32;
pub const PR_MCE_KILL: u32 = 33;
pub const PR_MCE_KILL_CLEAR: u32 = 0;
pub const PR_MCE_KILL_SET: u32 = 1;
pub const PR_MCE_KILL_LATE: u32 = 0;
pub const PR_MCE_KILL_EARLY: u32 = 1;
pub const PR_MCE_KILL_DEFAULT: u32 = 2;
pub const PR_MCE_KILL_GET: u32 = 34;
pub const PR_SET_MM: u32 = 35;
pub const PR_SET_MM_START_CODE: u32 = 1;
pub const PR_SET_MM_END_CODE: u32 = 2;
pub const PR_SET_MM_START_DATA: u32 = 3;
pub const PR_SET_MM_END_DATA: u32 = 4;
pub const PR_SET_MM_START_STACK: u32 = 5;
pub const PR_SET_MM_START_BRK: u32 = 6;
pub const PR_SET_MM_BRK: u32 = 7;
pub const PR_SET_MM_ARG_START: u32 = 8;
pub const PR_SET_MM_ARG_END: u32 = 9;
pub const PR_SET_MM_ENV_START: u32 = 10;
pub const PR_SET_MM_ENV_END: u32 = 11;
pub const PR_SET_MM_AUXV: u32 = 12;
pub const PR_SET_MM_EXE_FILE: u32 = 13;
pub const PR_SET_MM_MAP: u32 = 14;
pub const PR_SET_MM_MAP_SIZE: u32 = 15;
pub const PR_SET_PTRACER: u32 = 1499557217;
pub const PR_SET_CHILD_SUBREAPER: u32 = 36;
pub const PR_GET_CHILD_SUBREAPER: u32 = 37;
pub const PR_SET_NO_NEW_PRIVS: u32 = 38;
pub const PR_GET_NO_NEW_PRIVS: u32 = 39;
pub const PR_GET_TID_ADDRESS: u32 = 40;
pub const PR_SET_THP_DISABLE: u32 = 41;
pub const PR_GET_THP_DISABLE: u32 = 42;
pub const PR_MPX_ENABLE_MANAGEMENT: u32 = 43;
pub const PR_MPX_DISABLE_MANAGEMENT: u32 = 44;
pub const PR_SET_FP_MODE: u32 = 45;
pub const PR_GET_FP_MODE: u32 = 46;
pub const PR_FP_MODE_FR: u32 = 1;
pub const PR_FP_MODE_FRE: u32 = 2;
pub const PR_CAP_AMBIENT: u32 = 47;
pub const PR_CAP_AMBIENT_IS_SET: u32 = 1;
pub const PR_CAP_AMBIENT_RAISE: u32 = 2;
pub const PR_CAP_AMBIENT_LOWER: u32 = 3;
pub const PR_CAP_AMBIENT_CLEAR_ALL: u32 = 4;
pub const PR_SVE_SET_VL: u32 = 50;
pub const PR_SVE_SET_VL_ONEXEC: u32 = 262144;
pub const PR_SVE_GET_VL: u32 = 51;
pub const PR_SVE_VL_LEN_MASK: u32 = 65535;
pub const PR_SVE_VL_INHERIT: u32 = 131072;
pub const PR_GET_SPECULATION_CTRL: u32 = 52;
pub const PR_SET_SPECULATION_CTRL: u32 = 53;
pub const PR_SPEC_STORE_BYPASS: u32 = 0;
pub const PR_SPEC_INDIRECT_BRANCH: u32 = 1;
pub const PR_SPEC_L1D_FLUSH: u32 = 2;
pub const PR_SPEC_NOT_AFFECTED: u32 = 0;
pub const PR_SPEC_PRCTL: u32 = 1;
pub const PR_SPEC_ENABLE: u32 = 2;
pub const PR_SPEC_DISABLE: u32 = 4;
pub const PR_SPEC_FORCE_DISABLE: u32 = 8;
pub const PR_SPEC_DISABLE_NOEXEC: u32 = 16;
pub const PR_PAC_RESET_KEYS: u32 = 54;
pub const PR_PAC_APIAKEY: u32 = 1;
pub const PR_PAC_APIBKEY: u32 = 2;
pub const PR_PAC_APDAKEY: u32 = 4;
pub const PR_PAC_APDBKEY: u32 = 8;
pub const PR_PAC_APGAKEY: u32 = 16;
pub const PR_SET_TAGGED_ADDR_CTRL: u32 = 55;
pub const PR_GET_TAGGED_ADDR_CTRL: u32 = 56;
pub const PR_TAGGED_ADDR_ENABLE: u32 = 1;
pub const PR_MTE_TCF_NONE: u32 = 0;
pub const PR_MTE_TCF_SYNC: u32 = 2;
pub const PR_MTE_TCF_ASYNC: u32 = 4;
pub const PR_MTE_TCF_MASK: u32 = 6;
pub const PR_MTE_TAG_SHIFT: u32 = 3;
pub const PR_MTE_TAG_MASK: u32 = 524280;
pub const PR_MTE_TCF_SHIFT: u32 = 1;
pub const PR_SET_IO_FLUSHER: u32 = 57;
pub const PR_GET_IO_FLUSHER: u32 = 58;
pub const PR_SET_SYSCALL_USER_DISPATCH: u32 = 59;
pub const PR_SYS_DISPATCH_OFF: u32 = 0;
pub const PR_SYS_DISPATCH_ON: u32 = 1;
pub const SYSCALL_DISPATCH_FILTER_ALLOW: u32 = 0;
pub const SYSCALL_DISPATCH_FILTER_BLOCK: u32 = 1;
pub const PR_PAC_SET_ENABLED_KEYS: u32 = 60;
pub const PR_PAC_GET_ENABLED_KEYS: u32 = 61;
pub const PR_SCHED_CORE: u32 = 62;
pub const PR_SCHED_CORE_GET: u32 = 0;
pub const PR_SCHED_CORE_CREATE: u32 = 1;
pub const PR_SCHED_CORE_SHARE_TO: u32 = 2;
pub const PR_SCHED_CORE_SHARE_FROM: u32 = 3;
pub const PR_SCHED_CORE_MAX: u32 = 4;
pub const PR_SCHED_CORE_SCOPE_THREAD: u32 = 0;
pub const PR_SCHED_CORE_SCOPE_THREAD_GROUP: u32 = 1;
pub const PR_SCHED_CORE_SCOPE_PROCESS_GROUP: u32 = 2;
pub const PR_SME_SET_VL: u32 = 63;
pub const PR_SME_SET_VL_ONEXEC: u32 = 262144;
pub const PR_SME_GET_VL: u32 = 64;
pub const PR_SME_VL_LEN_MASK: u32 = 65535;
pub const PR_SME_VL_INHERIT: u32 = 131072;
pub const PR_SET_MDWE: u32 = 65;
pub const PR_MDWE_REFUSE_EXEC_GAIN: u32 = 1;
pub const PR_MDWE_NO_INHERIT: u32 = 2;
pub const PR_GET_MDWE: u32 = 66;
pub const PR_SET_VMA: u32 = 1398164801;
pub const PR_SET_VMA_ANON_NAME: u32 = 0;
pub const PR_GET_AUXV: u32 = 1096112214;
pub const PR_SET_MEMORY_MERGE: u32 = 67;
pub const PR_GET_MEMORY_MERGE: u32 = 68;
pub const PR_RISCV_V_SET_CONTROL: u32 = 69;
pub const PR_RISCV_V_GET_CONTROL: u32 = 70;
pub const PR_RISCV_V_VSTATE_CTRL_DEFAULT: u32 = 0;
pub const PR_RISCV_V_VSTATE_CTRL_OFF: u32 = 1;
pub const PR_RISCV_V_VSTATE_CTRL_ON: u32 = 2;
pub const PR_RISCV_V_VSTATE_CTRL_INHERIT: u32 = 16;
pub const PR_RISCV_V_VSTATE_CTRL_CUR_MASK: u32 = 3;
pub const PR_RISCV_V_VSTATE_CTRL_NEXT_MASK: u32 = 12;
pub const PR_RISCV_V_VSTATE_CTRL_MASK: u32 = 31;
pub const _SYS_SENDFILE_H: u32 = 1;
pub const _SYS_EPOLL_H: u32 = 1;
pub const EPOLL_CTL_ADD: u32 = 1;
pub const EPOLL_CTL_DEL: u32 = 2;
pub const EPOLL_CTL_MOD: u32 = 3;
pub const _SYS_EVENTFD_H: u32 = 1;
pub const _SYSCALL_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __NR_io_pgetevents: u32 = 333;
pub const __NR_rseq: u32 = 334;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __NR_cachestat: u32 = 451;
pub const __NR_fchmodat2: u32 = 452;
pub const __NR_map_shadow_stack: u32 = 453;
pub const __GLIBC_LINUX_VERSION_CODE: u32 = 393472;
pub const SYS__sysctl: u32 = 156;
pub const SYS_accept: u32 = 43;
pub const SYS_accept4: u32 = 288;
pub const SYS_access: u32 = 21;
pub const SYS_acct: u32 = 163;
pub const SYS_add_key: u32 = 248;
pub const SYS_adjtimex: u32 = 159;
pub const SYS_afs_syscall: u32 = 183;
pub const SYS_alarm: u32 = 37;
pub const SYS_arch_prctl: u32 = 158;
pub const SYS_bind: u32 = 49;
pub const SYS_bpf: u32 = 321;
pub const SYS_brk: u32 = 12;
pub const SYS_capget: u32 = 125;
pub const SYS_capset: u32 = 126;
pub const SYS_chdir: u32 = 80;
pub const SYS_chmod: u32 = 90;
pub const SYS_chown: u32 = 92;
pub const SYS_chroot: u32 = 161;
pub const SYS_clock_adjtime: u32 = 305;
pub const SYS_clock_getres: u32 = 229;
pub const SYS_clock_gettime: u32 = 228;
pub const SYS_clock_nanosleep: u32 = 230;
pub const SYS_clock_settime: u32 = 227;
pub const SYS_clone: u32 = 56;
pub const SYS_clone3: u32 = 435;
pub const SYS_close: u32 = 3;
pub const SYS_close_range: u32 = 436;
pub const SYS_connect: u32 = 42;
pub const SYS_copy_file_range: u32 = 326;
pub const SYS_creat: u32 = 85;
pub const SYS_create_module: u32 = 174;
pub const SYS_delete_module: u32 = 176;
pub const SYS_dup: u32 = 32;
pub const SYS_dup2: u32 = 33;
pub const SYS_dup3: u32 = 292;
pub const SYS_epoll_create: u32 = 213;
pub const SYS_epoll_create1: u32 = 291;
pub const SYS_epoll_ctl: u32 = 233;
pub const SYS_epoll_ctl_old: u32 = 214;
pub const SYS_epoll_pwait: u32 = 281;
pub const SYS_epoll_pwait2: u32 = 441;
pub const SYS_epoll_wait: u32 = 232;
pub const SYS_epoll_wait_old: u32 = 215;
pub const SYS_eventfd: u32 = 284;
pub const SYS_eventfd2: u32 = 290;
pub const SYS_execve: u32 = 59;
pub const SYS_execveat: u32 = 322;
pub const SYS_exit: u32 = 60;
pub const SYS_exit_group: u32 = 231;
pub const SYS_faccessat: u32 = 269;
pub const SYS_faccessat2: u32 = 439;
pub const SYS_fadvise64: u32 = 221;
pub const SYS_fallocate: u32 = 285;
pub const SYS_fanotify_init: u32 = 300;
pub const SYS_fanotify_mark: u32 = 301;
pub const SYS_fchdir: u32 = 81;
pub const SYS_fchmod: u32 = 91;
pub const SYS_fchmodat: u32 = 268;
pub const SYS_fchown: u32 = 93;
pub const SYS_fchownat: u32 = 260;
pub const SYS_fcntl: u32 = 72;
pub const SYS_fdatasync: u32 = 75;
pub const SYS_fgetxattr: u32 = 193;
pub const SYS_finit_module: u32 = 313;
pub const SYS_flistxattr: u32 = 196;
pub const SYS_flock: u32 = 73;
pub const SYS_fork: u32 = 57;
pub const SYS_fremovexattr: u32 = 199;
pub const SYS_fsconfig: u32 = 431;
pub const SYS_fsetxattr: u32 = 190;
pub const SYS_fsmount: u32 = 432;
pub const SYS_fsopen: u32 = 430;
pub const SYS_fspick: u32 = 433;
pub const SYS_fstat: u32 = 5;
pub const SYS_fstatfs: u32 = 138;
pub const SYS_fsync: u32 = 74;
pub const SYS_ftruncate: u32 = 77;
pub const SYS_futex: u32 = 202;
pub const SYS_futex_waitv: u32 = 449;
pub const SYS_futimesat: u32 = 261;
pub const SYS_get_kernel_syms: u32 = 177;
pub const SYS_get_mempolicy: u32 = 239;
pub const SYS_get_robust_list: u32 = 274;
pub const SYS_get_thread_area: u32 = 211;
pub const SYS_getcpu: u32 = 309;
pub const SYS_getcwd: u32 = 79;
pub const SYS_getdents: u32 = 78;
pub const SYS_getdents64: u32 = 217;
pub const SYS_getegid: u32 = 108;
pub const SYS_geteuid: u32 = 107;
pub const SYS_getgid: u32 = 104;
pub const SYS_getgroups: u32 = 115;
pub const SYS_getitimer: u32 = 36;
pub const SYS_getpeername: u32 = 52;
pub const SYS_getpgid: u32 = 121;
pub const SYS_getpgrp: u32 = 111;
pub const SYS_getpid: u32 = 39;
pub const SYS_getpmsg: u32 = 181;
pub const SYS_getppid: u32 = 110;
pub const SYS_getpriority: u32 = 140;
pub const SYS_getrandom: u32 = 318;
pub const SYS_getresgid: u32 = 120;
pub const SYS_getresuid: u32 = 118;
pub const SYS_getrlimit: u32 = 97;
pub const SYS_getrusage: u32 = 98;
pub const SYS_getsid: u32 = 124;
pub const SYS_getsockname: u32 = 51;
pub const SYS_getsockopt: u32 = 55;
pub const SYS_gettid: u32 = 186;
pub const SYS_gettimeofday: u32 = 96;
pub const SYS_getuid: u32 = 102;
pub const SYS_getxattr: u32 = 191;
pub const SYS_init_module: u32 = 175;
pub const SYS_inotify_add_watch: u32 = 254;
pub const SYS_inotify_init: u32 = 253;
pub const SYS_inotify_init1: u32 = 294;
pub const SYS_inotify_rm_watch: u32 = 255;
pub const SYS_io_cancel: u32 = 210;
pub const SYS_io_destroy: u32 = 207;
pub const SYS_io_getevents: u32 = 208;
pub const SYS_io_pgetevents: u32 = 333;
pub const SYS_io_setup: u32 = 206;
pub const SYS_io_submit: u32 = 209;
pub const SYS_io_uring_enter: u32 = 426;
pub const SYS_io_uring_register: u32 = 427;
pub const SYS_io_uring_setup: u32 = 425;
pub const SYS_ioctl: u32 = 16;
pub const SYS_ioperm: u32 = 173;
pub const SYS_iopl: u32 = 172;
pub const SYS_ioprio_get: u32 = 252;
pub const SYS_ioprio_set: u32 = 251;
pub const SYS_kcmp: u32 = 312;
pub const SYS_kexec_file_load: u32 = 320;
pub const SYS_kexec_load: u32 = 246;
pub const SYS_keyctl: u32 = 250;
pub const SYS_kill: u32 = 62;
pub const SYS_landlock_add_rule: u32 = 445;
pub const SYS_landlock_create_ruleset: u32 = 444;
pub const SYS_landlock_restrict_self: u32 = 446;
pub const SYS_lchown: u32 = 94;
pub const SYS_lgetxattr: u32 = 192;
pub const SYS_link: u32 = 86;
pub const SYS_linkat: u32 = 265;
pub const SYS_listen: u32 = 50;
pub const SYS_listxattr: u32 = 194;
pub const SYS_llistxattr: u32 = 195;
pub const SYS_lookup_dcookie: u32 = 212;
pub const SYS_lremovexattr: u32 = 198;
pub const SYS_lseek: u32 = 8;
pub const SYS_lsetxattr: u32 = 189;
pub const SYS_lstat: u32 = 6;
pub const SYS_madvise: u32 = 28;
pub const SYS_mbind: u32 = 237;
pub const SYS_membarrier: u32 = 324;
pub const SYS_memfd_create: u32 = 319;
pub const SYS_memfd_secret: u32 = 447;
pub const SYS_migrate_pages: u32 = 256;
pub const SYS_mincore: u32 = 27;
pub const SYS_mkdir: u32 = 83;
pub const SYS_mkdirat: u32 = 258;
pub const SYS_mknod: u32 = 133;
pub const SYS_mknodat: u32 = 259;
pub const SYS_mlock: u32 = 149;
pub const SYS_mlock2: u32 = 325;
pub const SYS_mlockall: u32 = 151;
pub const SYS_mmap: u32 = 9;
pub const SYS_modify_ldt: u32 = 154;
pub const SYS_mount: u32 = 165;
pub const SYS_mount_setattr: u32 = 442;
pub const SYS_move_mount: u32 = 429;
pub const SYS_move_pages: u32 = 279;
pub const SYS_mprotect: u32 = 10;
pub const SYS_mq_getsetattr: u32 = 245;
pub const SYS_mq_notify: u32 = 244;
pub const SYS_mq_open: u32 = 240;
pub const SYS_mq_timedreceive: u32 = 243;
pub const SYS_mq_timedsend: u32 = 242;
pub const SYS_mq_unlink: u32 = 241;
pub const SYS_mremap: u32 = 25;
pub const SYS_msgctl: u32 = 71;
pub const SYS_msgget: u32 = 68;
pub const SYS_msgrcv: u32 = 70;
pub const SYS_msgsnd: u32 = 69;
pub const SYS_msync: u32 = 26;
pub const SYS_munlock: u32 = 150;
pub const SYS_munlockall: u32 = 152;
pub const SYS_munmap: u32 = 11;
pub const SYS_name_to_handle_at: u32 = 303;
pub const SYS_nanosleep: u32 = 35;
pub const SYS_newfstatat: u32 = 262;
pub const SYS_nfsservctl: u32 = 180;
pub const SYS_open: u32 = 2;
pub const SYS_open_by_handle_at: u32 = 304;
pub const SYS_open_tree: u32 = 428;
pub const SYS_openat: u32 = 257;
pub const SYS_openat2: u32 = 437;
pub const SYS_pause: u32 = 34;
pub const SYS_perf_event_open: u32 = 298;
pub const SYS_personality: u32 = 135;
pub const SYS_pidfd_getfd: u32 = 438;
pub const SYS_pidfd_open: u32 = 434;
pub const SYS_pidfd_send_signal: u32 = 424;
pub const SYS_pipe: u32 = 22;
pub const SYS_pipe2: u32 = 293;
pub const SYS_pivot_root: u32 = 155;
pub const SYS_pkey_alloc: u32 = 330;
pub const SYS_pkey_free: u32 = 331;
pub const SYS_pkey_mprotect: u32 = 329;
pub const SYS_poll: u32 = 7;
pub const SYS_ppoll: u32 = 271;
pub const SYS_prctl: u32 = 157;
pub const SYS_pread64: u32 = 17;
pub const SYS_preadv: u32 = 295;
pub const SYS_preadv2: u32 = 327;
pub const SYS_prlimit64: u32 = 302;
pub const SYS_process_madvise: u32 = 440;
pub const SYS_process_mrelease: u32 = 448;
pub const SYS_process_vm_readv: u32 = 310;
pub const SYS_process_vm_writev: u32 = 311;
pub const SYS_pselect6: u32 = 270;
pub const SYS_ptrace: u32 = 101;
pub const SYS_putpmsg: u32 = 182;
pub const SYS_pwrite64: u32 = 18;
pub const SYS_pwritev: u32 = 296;
pub const SYS_pwritev2: u32 = 328;
pub const SYS_query_module: u32 = 178;
pub const SYS_quotactl: u32 = 179;
pub const SYS_quotactl_fd: u32 = 443;
pub const SYS_read: u32 = 0;
pub const SYS_readahead: u32 = 187;
pub const SYS_readlink: u32 = 89;
pub const SYS_readlinkat: u32 = 267;
pub const SYS_readv: u32 = 19;
pub const SYS_reboot: u32 = 169;
pub const SYS_recvfrom: u32 = 45;
pub const SYS_recvmmsg: u32 = 299;
pub const SYS_recvmsg: u32 = 47;
pub const SYS_remap_file_pages: u32 = 216;
pub const SYS_removexattr: u32 = 197;
pub const SYS_rename: u32 = 82;
pub const SYS_renameat: u32 = 264;
pub const SYS_renameat2: u32 = 316;
pub const SYS_request_key: u32 = 249;
pub const SYS_restart_syscall: u32 = 219;
pub const SYS_rmdir: u32 = 84;
pub const SYS_rseq: u32 = 334;
pub const SYS_rt_sigaction: u32 = 13;
pub const SYS_rt_sigpending: u32 = 127;
pub const SYS_rt_sigprocmask: u32 = 14;
pub const SYS_rt_sigqueueinfo: u32 = 129;
pub const SYS_rt_sigreturn: u32 = 15;
pub const SYS_rt_sigsuspend: u32 = 130;
pub const SYS_rt_sigtimedwait: u32 = 128;
pub const SYS_rt_tgsigqueueinfo: u32 = 297;
pub const SYS_sched_get_priority_max: u32 = 146;
pub const SYS_sched_get_priority_min: u32 = 147;
pub const SYS_sched_getaffinity: u32 = 204;
pub const SYS_sched_getattr: u32 = 315;
pub const SYS_sched_getparam: u32 = 143;
pub const SYS_sched_getscheduler: u32 = 145;
pub const SYS_sched_rr_get_interval: u32 = 148;
pub const SYS_sched_setaffinity: u32 = 203;
pub const SYS_sched_setattr: u32 = 314;
pub const SYS_sched_setparam: u32 = 142;
pub const SYS_sched_setscheduler: u32 = 144;
pub const SYS_sched_yield: u32 = 24;
pub const SYS_seccomp: u32 = 317;
pub const SYS_security: u32 = 185;
pub const SYS_select: u32 = 23;
pub const SYS_semctl: u32 = 66;
pub const SYS_semget: u32 = 64;
pub const SYS_semop: u32 = 65;
pub const SYS_semtimedop: u32 = 220;
pub const SYS_sendfile: u32 = 40;
pub const SYS_sendmmsg: u32 = 307;
pub const SYS_sendmsg: u32 = 46;
pub const SYS_sendto: u32 = 44;
pub const SYS_set_mempolicy: u32 = 238;
pub const SYS_set_mempolicy_home_node: u32 = 450;
pub const SYS_set_robust_list: u32 = 273;
pub const SYS_set_thread_area: u32 = 205;
pub const SYS_set_tid_address: u32 = 218;
pub const SYS_setdomainname: u32 = 171;
pub const SYS_setfsgid: u32 = 123;
pub const SYS_setfsuid: u32 = 122;
pub const SYS_setgid: u32 = 106;
pub const SYS_setgroups: u32 = 116;
pub const SYS_sethostname: u32 = 170;
pub const SYS_setitimer: u32 = 38;
pub const SYS_setns: u32 = 308;
pub const SYS_setpgid: u32 = 109;
pub const SYS_setpriority: u32 = 141;
pub const SYS_setregid: u32 = 114;
pub const SYS_setresgid: u32 = 119;
pub const SYS_setresuid: u32 = 117;
pub const SYS_setreuid: u32 = 113;
pub const SYS_setrlimit: u32 = 160;
pub const SYS_setsid: u32 = 112;
pub const SYS_setsockopt: u32 = 54;
pub const SYS_settimeofday: u32 = 164;
pub const SYS_setuid: u32 = 105;
pub const SYS_setxattr: u32 = 188;
pub const SYS_shmat: u32 = 30;
pub const SYS_shmctl: u32 = 31;
pub const SYS_shmdt: u32 = 67;
pub const SYS_shmget: u32 = 29;
pub const SYS_shutdown: u32 = 48;
pub const SYS_sigaltstack: u32 = 131;
pub const SYS_signalfd: u32 = 282;
pub const SYS_signalfd4: u32 = 289;
pub const SYS_socket: u32 = 41;
pub const SYS_socketpair: u32 = 53;
pub const SYS_splice: u32 = 275;
pub const SYS_stat: u32 = 4;
pub const SYS_statfs: u32 = 137;
pub const SYS_statx: u32 = 332;
pub const SYS_swapoff: u32 = 168;
pub const SYS_swapon: u32 = 167;
pub const SYS_symlink: u32 = 88;
pub const SYS_symlinkat: u32 = 266;
pub const SYS_sync: u32 = 162;
pub const SYS_sync_file_range: u32 = 277;
pub const SYS_syncfs: u32 = 306;
pub const SYS_sysfs: u32 = 139;
pub const SYS_sysinfo: u32 = 99;
pub const SYS_syslog: u32 = 103;
pub const SYS_tee: u32 = 276;
pub const SYS_tgkill: u32 = 234;
pub const SYS_time: u32 = 201;
pub const SYS_timer_create: u32 = 222;
pub const SYS_timer_delete: u32 = 226;
pub const SYS_timer_getoverrun: u32 = 225;
pub const SYS_timer_gettime: u32 = 224;
pub const SYS_timer_settime: u32 = 223;
pub const SYS_timerfd_create: u32 = 283;
pub const SYS_timerfd_gettime: u32 = 287;
pub const SYS_timerfd_settime: u32 = 286;
pub const SYS_times: u32 = 100;
pub const SYS_tkill: u32 = 200;
pub const SYS_truncate: u32 = 76;
pub const SYS_tuxcall: u32 = 184;
pub const SYS_umask: u32 = 95;
pub const SYS_umount2: u32 = 166;
pub const SYS_uname: u32 = 63;
pub const SYS_unlink: u32 = 87;
pub const SYS_unlinkat: u32 = 263;
pub const SYS_unshare: u32 = 272;
pub const SYS_uselib: u32 = 134;
pub const SYS_userfaultfd: u32 = 323;
pub const SYS_ustat: u32 = 136;
pub const SYS_utime: u32 = 132;
pub const SYS_utimensat: u32 = 280;
pub const SYS_utimes: u32 = 235;
pub const SYS_vfork: u32 = 58;
pub const SYS_vhangup: u32 = 153;
pub const SYS_vmsplice: u32 = 278;
pub const SYS_vserver: u32 = 236;
pub const SYS_wait4: u32 = 61;
pub const SYS_waitid: u32 = 247;
pub const SYS_write: u32 = 1;
pub const SYS_writev: u32 = 20;
pub const FSCRYPT_POLICY_FLAGS_PAD_4: u32 = 0;
pub const FSCRYPT_POLICY_FLAGS_PAD_8: u32 = 1;
pub const FSCRYPT_POLICY_FLAGS_PAD_16: u32 = 2;
pub const FSCRYPT_POLICY_FLAGS_PAD_32: u32 = 3;
pub const FSCRYPT_POLICY_FLAGS_PAD_MASK: u32 = 3;
pub const FSCRYPT_POLICY_FLAG_DIRECT_KEY: u32 = 4;
pub const FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64: u32 = 8;
pub const FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32: u32 = 16;
pub const FSCRYPT_MODE_AES_256_XTS: u32 = 1;
pub const FSCRYPT_MODE_AES_256_CTS: u32 = 4;
pub const FSCRYPT_MODE_AES_128_CBC: u32 = 5;
pub const FSCRYPT_MODE_AES_128_CTS: u32 = 6;
pub const FSCRYPT_MODE_SM4_XTS: u32 = 7;
pub const FSCRYPT_MODE_SM4_CTS: u32 = 8;
pub const FSCRYPT_MODE_ADIANTUM: u32 = 9;
pub const FSCRYPT_MODE_AES_256_HCTR2: u32 = 10;
pub const FSCRYPT_POLICY_V1: u32 = 0;
pub const FSCRYPT_KEY_DESCRIPTOR_SIZE: u32 = 8;
pub const FSCRYPT_KEY_DESC_PREFIX: &[u8; 9] = b"fscrypt:\0";
pub const FSCRYPT_KEY_DESC_PREFIX_SIZE: u32 = 8;
pub const FSCRYPT_MAX_KEY_SIZE: u32 = 64;
pub const FSCRYPT_POLICY_V2: u32 = 2;
pub const FSCRYPT_KEY_IDENTIFIER_SIZE: u32 = 16;
pub const FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR: u32 = 1;
pub const FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER: u32 = 2;
pub const FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY: u32 = 1;
pub const FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS: u32 = 2;
pub const FSCRYPT_KEY_STATUS_ABSENT: u32 = 1;
pub const FSCRYPT_KEY_STATUS_PRESENT: u32 = 2;
pub const FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED: u32 = 3;
pub const FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF: u32 = 1;
pub const FS_KEY_DESCRIPTOR_SIZE: u32 = 8;
pub const FS_POLICY_FLAGS_PAD_4: u32 = 0;
pub const FS_POLICY_FLAGS_PAD_8: u32 = 1;
pub const FS_POLICY_FLAGS_PAD_16: u32 = 2;
pub const FS_POLICY_FLAGS_PAD_32: u32 = 3;
pub const FS_POLICY_FLAGS_PAD_MASK: u32 = 3;
pub const FS_POLICY_FLAG_DIRECT_KEY: u32 = 4;
pub const FS_POLICY_FLAGS_VALID: u32 = 7;
pub const FS_ENCRYPTION_MODE_INVALID: u32 = 0;
pub const FS_ENCRYPTION_MODE_AES_256_XTS: u32 = 1;
pub const FS_ENCRYPTION_MODE_AES_256_GCM: u32 = 2;
pub const FS_ENCRYPTION_MODE_AES_256_CBC: u32 = 3;
pub const FS_ENCRYPTION_MODE_AES_256_CTS: u32 = 4;
pub const FS_ENCRYPTION_MODE_AES_128_CBC: u32 = 5;
pub const FS_ENCRYPTION_MODE_AES_128_CTS: u32 = 6;
pub const FS_ENCRYPTION_MODE_ADIANTUM: u32 = 9;
pub const FS_KEY_DESC_PREFIX: &[u8; 9] = b"fscrypt:\0";
pub const FS_KEY_DESC_PREFIX_SIZE: u32 = 8;
pub const FS_MAX_KEY_SIZE: u32 = 64;
pub const MS_RDONLY: u32 = 1;
pub const MS_NOSUID: u32 = 2;
pub const MS_NODEV: u32 = 4;
pub const MS_NOEXEC: u32 = 8;
pub const MS_SYNCHRONOUS: u32 = 16;
pub const MS_REMOUNT: u32 = 32;
pub const MS_MANDLOCK: u32 = 64;
pub const MS_DIRSYNC: u32 = 128;
pub const MS_NOSYMFOLLOW: u32 = 256;
pub const MS_NOATIME: u32 = 1024;
pub const MS_NODIRATIME: u32 = 2048;
pub const MS_BIND: u32 = 4096;
pub const MS_MOVE: u32 = 8192;
pub const MS_REC: u32 = 16384;
pub const MS_VERBOSE: u32 = 32768;
pub const MS_SILENT: u32 = 32768;
pub const MS_POSIXACL: u32 = 65536;
pub const MS_UNBINDABLE: u32 = 131072;
pub const MS_PRIVATE: u32 = 262144;
pub const MS_SLAVE: u32 = 524288;
pub const MS_SHARED: u32 = 1048576;
pub const MS_RELATIME: u32 = 2097152;
pub const MS_KERNMOUNT: u32 = 4194304;
pub const MS_I_VERSION: u32 = 8388608;
pub const MS_STRICTATIME: u32 = 16777216;
pub const MS_LAZYTIME: u32 = 33554432;
pub const MS_SUBMOUNT: u32 = 67108864;
pub const MS_NOREMOTELOCK: u32 = 134217728;
pub const MS_NOSEC: u32 = 268435456;
pub const MS_BORN: u32 = 536870912;
pub const MS_ACTIVE: u32 = 1073741824;
pub const MS_NOUSER: u32 = 2147483648;
pub const MS_RMT_MASK: u32 = 41943121;
pub const MS_MGC_VAL: u32 = 3236757504;
pub const MS_MGC_MSK: u32 = 4294901760;
pub const OPEN_TREE_CLONE: u32 = 1;
pub const OPEN_TREE_CLOEXEC: u32 = 524288;
pub const MOVE_MOUNT_F_SYMLINKS: u32 = 1;
pub const MOVE_MOUNT_F_AUTOMOUNTS: u32 = 2;
pub const MOVE_MOUNT_F_EMPTY_PATH: u32 = 4;
pub const MOVE_MOUNT_T_SYMLINKS: u32 = 16;
pub const MOVE_MOUNT_T_AUTOMOUNTS: u32 = 32;
pub const MOVE_MOUNT_T_EMPTY_PATH: u32 = 64;
pub const MOVE_MOUNT_SET_GROUP: u32 = 256;
pub const MOVE_MOUNT_BENEATH: u32 = 512;
pub const MOVE_MOUNT__MASK: u32 = 887;
pub const FSOPEN_CLOEXEC: u32 = 1;
pub const FSPICK_CLOEXEC: u32 = 1;
pub const FSPICK_SYMLINK_NOFOLLOW: u32 = 2;
pub const FSPICK_NO_AUTOMOUNT: u32 = 4;
pub const FSPICK_EMPTY_PATH: u32 = 8;
pub const FSMOUNT_CLOEXEC: u32 = 1;
pub const MOUNT_ATTR_RDONLY: u32 = 1;
pub const MOUNT_ATTR_NOSUID: u32 = 2;
pub const MOUNT_ATTR_NODEV: u32 = 4;
pub const MOUNT_ATTR_NOEXEC: u32 = 8;
pub const MOUNT_ATTR__ATIME: u32 = 112;
pub const MOUNT_ATTR_RELATIME: u32 = 0;
pub const MOUNT_ATTR_NOATIME: u32 = 16;
pub const MOUNT_ATTR_STRICTATIME: u32 = 32;
pub const MOUNT_ATTR_NODIRATIME: u32 = 128;
pub const MOUNT_ATTR_IDMAP: u32 = 1048576;
pub const MOUNT_ATTR_NOSYMFOLLOW: u32 = 2097152;
pub const MOUNT_ATTR_SIZE_VER0: u32 = 32;
pub const INR_OPEN_CUR: u32 = 1024;
pub const INR_OPEN_MAX: u32 = 4096;
pub const BLOCK_SIZE_BITS: u32 = 10;
pub const BLOCK_SIZE: u32 = 1024;
pub const SEEK_MAX: u32 = 4;
pub const FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const NR_FILE: u32 = 8192;
pub const FS_XFLAG_REALTIME: u32 = 1;
pub const FS_XFLAG_PREALLOC: u32 = 2;
pub const FS_XFLAG_IMMUTABLE: u32 = 8;
pub const FS_XFLAG_APPEND: u32 = 16;
pub const FS_XFLAG_SYNC: u32 = 32;
pub const FS_XFLAG_NOATIME: u32 = 64;
pub const FS_XFLAG_NODUMP: u32 = 128;
pub const FS_XFLAG_RTINHERIT: u32 = 256;
pub const FS_XFLAG_PROJINHERIT: u32 = 512;
pub const FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const FS_XFLAG_EXTSIZE: u32 = 2048;
pub const FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const FS_XFLAG_NODEFRAG: u32 = 8192;
pub const FS_XFLAG_FILESTREAM: u32 = 16384;
pub const FS_XFLAG_DAX: u32 = 32768;
pub const FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const FS_XFLAG_HASATTR: u32 = 2147483648;
pub const BMAP_IOCTL: u32 = 1;
pub const FSLABEL_MAX: u32 = 256;
pub const FS_SECRM_FL: u32 = 1;
pub const FS_UNRM_FL: u32 = 2;
pub const FS_COMPR_FL: u32 = 4;
pub const FS_SYNC_FL: u32 = 8;
pub const FS_IMMUTABLE_FL: u32 = 16;
pub const FS_APPEND_FL: u32 = 32;
pub const FS_NODUMP_FL: u32 = 64;
pub const FS_NOATIME_FL: u32 = 128;
pub const FS_DIRTY_FL: u32 = 256;
pub const FS_COMPRBLK_FL: u32 = 512;
pub const FS_NOCOMP_FL: u32 = 1024;
pub const FS_ENCRYPT_FL: u32 = 2048;
pub const FS_BTREE_FL: u32 = 4096;
pub const FS_INDEX_FL: u32 = 4096;
pub const FS_IMAGIC_FL: u32 = 8192;
pub const FS_JOURNAL_DATA_FL: u32 = 16384;
pub const FS_NOTAIL_FL: u32 = 32768;
pub const FS_DIRSYNC_FL: u32 = 65536;
pub const FS_TOPDIR_FL: u32 = 131072;
pub const FS_HUGE_FILE_FL: u32 = 262144;
pub const FS_EXTENT_FL: u32 = 524288;
pub const FS_VERITY_FL: u32 = 1048576;
pub const FS_EA_INODE_FL: u32 = 2097152;
pub const FS_EOFBLOCKS_FL: u32 = 4194304;
pub const FS_NOCOW_FL: u32 = 8388608;
pub const FS_DAX_FL: u32 = 33554432;
pub const FS_INLINE_DATA_FL: u32 = 268435456;
pub const FS_PROJINHERIT_FL: u32 = 536870912;
pub const FS_CASEFOLD_FL: u32 = 1073741824;
pub const FS_RESERVED_FL: u32 = 2147483648;
pub const FS_FL_USER_VISIBLE: u32 = 253951;
pub const FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const RWF_SUPPORTED: u32 = 31;
pub const IOCB_FLAG_RESFD: u32 = 1;
pub const IOCB_FLAG_IOPRIO: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const VFS_CAP_REVISION_1: u32 = 16777216;
pub const VFS_CAP_U32_1: u32 = 1;
pub const VFS_CAP_REVISION_2: u32 = 33554432;
pub const VFS_CAP_U32_2: u32 = 2;
pub const VFS_CAP_REVISION_3: u32 = 50331648;
pub const VFS_CAP_U32_3: u32 = 2;
pub const VFS_CAP_U32: u32 = 2;
pub const VFS_CAP_REVISION: u32 = 50331648;
pub const _LINUX_CAPABILITY_VERSION: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S: u32 = 1;
pub const CAP_CHOWN: u32 = 0;
pub const CAP_DAC_OVERRIDE: u32 = 1;
pub const CAP_DAC_READ_SEARCH: u32 = 2;
pub const CAP_FOWNER: u32 = 3;
pub const CAP_FSETID: u32 = 4;
pub const CAP_KILL: u32 = 5;
pub const CAP_SETGID: u32 = 6;
pub const CAP_SETUID: u32 = 7;
pub const CAP_SETPCAP: u32 = 8;
pub const CAP_LINUX_IMMUTABLE: u32 = 9;
pub const CAP_NET_BIND_SERVICE: u32 = 10;
pub const CAP_NET_BROADCAST: u32 = 11;
pub const CAP_NET_ADMIN: u32 = 12;
pub const CAP_NET_RAW: u32 = 13;
pub const CAP_IPC_LOCK: u32 = 14;
pub const CAP_IPC_OWNER: u32 = 15;
pub const CAP_SYS_MODULE: u32 = 16;
pub const CAP_SYS_RAWIO: u32 = 17;
pub const CAP_SYS_CHROOT: u32 = 18;
pub const CAP_SYS_PTRACE: u32 = 19;
pub const CAP_SYS_PACCT: u32 = 20;
pub const CAP_SYS_ADMIN: u32 = 21;
pub const CAP_SYS_BOOT: u32 = 22;
pub const CAP_SYS_NICE: u32 = 23;
pub const CAP_SYS_RESOURCE: u32 = 24;
pub const CAP_SYS_TIME: u32 = 25;
pub const CAP_SYS_TTY_CONFIG: u32 = 26;
pub const CAP_MKNOD: u32 = 27;
pub const CAP_LEASE: u32 = 28;
pub const CAP_AUDIT_WRITE: u32 = 29;
pub const CAP_AUDIT_CONTROL: u32 = 30;
pub const CAP_SETFCAP: u32 = 31;
pub const CAP_MAC_OVERRIDE: u32 = 32;
pub const CAP_MAC_ADMIN: u32 = 33;
pub const CAP_SYSLOG: u32 = 34;
pub const CAP_WAKE_ALARM: u32 = 35;
pub const CAP_BLOCK_SUSPEND: u32 = 36;
pub const CAP_AUDIT_READ: u32 = 37;
pub const CAP_PERFMON: u32 = 38;
pub const CAP_BPF: u32 = 39;
pub const CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const CAP_LAST_CAP: u32 = 40;
pub const NGX_LISTEN_BACKLOG: u32 = 511;
pub const NGX_HAVE_SO_SNDLOWAT: u32 = 0;
pub const NGX_HAVE_INHERITED_NONBLOCK: u32 = 0;
pub const NGX_HAVE_OS_SPECIFIC_INIT: u32 = 1;
pub const NGX_MAX_INT_T_VALUE: u64 = 9223372036854775807;
pub const NGX_INVALID_ARRAY_INDEX: u32 = 2147483648;
pub const NGX_MAXHOSTNAMELEN: u32 = 256;
pub const NGX_OK: u32 = 0;
pub const NGX_ERROR: i32 = -1;
pub const NGX_AGAIN: i32 = -2;
pub const NGX_BUSY: i32 = -3;
pub const NGX_DONE: i32 = -4;
pub const NGX_DECLINED: i32 = -5;
pub const NGX_ABORT: i32 = -6;
pub const NGX_EPERM: u32 = 1;
pub const NGX_ENOENT: u32 = 2;
pub const NGX_ENOPATH: u32 = 2;
pub const NGX_ESRCH: u32 = 3;
pub const NGX_EINTR: u32 = 4;
pub const NGX_ECHILD: u32 = 10;
pub const NGX_ENOMEM: u32 = 12;
pub const NGX_EACCES: u32 = 13;
pub const NGX_EBUSY: u32 = 16;
pub const NGX_EEXIST: u32 = 17;
pub const NGX_EEXIST_FILE: u32 = 17;
pub const NGX_EXDEV: u32 = 18;
pub const NGX_ENOTDIR: u32 = 20;
pub const NGX_EISDIR: u32 = 21;
pub const NGX_EINVAL: u32 = 22;
pub const NGX_ENFILE: u32 = 23;
pub const NGX_EMFILE: u32 = 24;
pub const NGX_ENOSPC: u32 = 28;
pub const NGX_EPIPE: u32 = 32;
pub const NGX_EINPROGRESS: u32 = 115;
pub const NGX_ENOPROTOOPT: u32 = 92;
pub const NGX_EOPNOTSUPP: u32 = 95;
pub const NGX_EADDRINUSE: u32 = 98;
pub const NGX_ECONNABORTED: u32 = 103;
pub const NGX_ECONNRESET: u32 = 104;
pub const NGX_ENOTCONN: u32 = 107;
pub const NGX_ETIMEDOUT: u32 = 110;
pub const NGX_ECONNREFUSED: u32 = 111;
pub const NGX_ENAMETOOLONG: u32 = 36;
pub const NGX_ENETDOWN: u32 = 100;
pub const NGX_ENETUNREACH: u32 = 101;
pub const NGX_EHOSTDOWN: u32 = 112;
pub const NGX_EHOSTUNREACH: u32 = 113;
pub const NGX_ENOSYS: u32 = 38;
pub const NGX_ECANCELED: u32 = 125;
pub const NGX_EILSEQ: u32 = 84;
pub const NGX_ENOMOREFILES: u32 = 0;
pub const NGX_ELOOP: u32 = 40;
pub const NGX_EBADF: u32 = 9;
pub const NGX_EMLINK: u32 = 31;
pub const NGX_EAGAIN: u32 = 11;
pub const NGX_HAVE_ATOMIC_OPS: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const NGX_TID_T_FMT: &[u8; 3] = b"%P\0";
pub const ngx_socket_n: &[u8; 9] = b"socket()\0";
pub const ngx_nonblocking_n: &[u8; 15] = b"ioctl(FIONBIO)\0";
pub const ngx_blocking_n: &[u8; 16] = b"ioctl(!FIONBIO)\0";
pub const ngx_socket_nread_n: &[u8; 16] = b"ioctl(FIONREAD)\0";
pub const ngx_cloexec_n: &[u8; 18] = b"fcntl(FD_CLOEXEC)\0";
pub const HAVE_SOCKET_CLOEXEC_PATCH: u32 = 1;
pub const ngx_tcp_nopush_n: &[u8; 21] = b"setsockopt(TCP_CORK)\0";
pub const ngx_tcp_push_n: &[u8; 22] = b"setsockopt(!TCP_CORK)\0";
pub const ngx_shutdown_socket_n: &[u8; 11] = b"shutdown()\0";
pub const ngx_close_socket_n: &[u8; 15] = b"close() socket\0";
pub const NGX_ESCAPE_URI: u32 = 0;
pub const NGX_ESCAPE_ARGS: u32 = 1;
pub const NGX_ESCAPE_URI_COMPONENT: u32 = 2;
pub const NGX_ESCAPE_HTML: u32 = 3;
pub const NGX_ESCAPE_REFRESH: u32 = 4;
pub const NGX_ESCAPE_MEMCACHED: u32 = 5;
pub const NGX_ESCAPE_MAIL_AUTH: u32 = 6;
pub const NGX_UNESCAPE_URI: u32 = 1;
pub const NGX_UNESCAPE_REDIRECT: u32 = 2;
pub const NGX_INVALID_FILE: i32 = -1;
pub const NGX_FILE_ERROR: i32 = -1;
pub const ngx_open_file_n: &[u8; 7] = b"open()\0";
pub const NGX_FILE_RDONLY: u32 = 0;
pub const NGX_FILE_WRONLY: u32 = 1;
pub const NGX_FILE_RDWR: u32 = 2;
pub const NGX_FILE_CREATE_OR_OPEN: u32 = 64;
pub const NGX_FILE_OPEN: u32 = 0;
pub const NGX_FILE_TRUNCATE: u32 = 576;
pub const NGX_FILE_APPEND: u32 = 1025;
pub const NGX_FILE_NONBLOCK: u32 = 2048;
pub const NGX_FILE_NOFOLLOW: u32 = 131072;
pub const NGX_FILE_DIRECTORY: u32 = 65536;
pub const NGX_FILE_SEARCH: u32 = 2162688;
pub const NGX_FILE_DEFAULT_ACCESS: u32 = 420;
pub const NGX_FILE_OWNER_ACCESS: u32 = 384;
pub const ngx_close_file_n: &[u8; 8] = b"close()\0";
pub const ngx_delete_file_n: &[u8; 9] = b"unlink()\0";
pub const ngx_open_tempfile_n: &[u8; 7] = b"open()\0";
pub const ngx_read_file_n: &[u8; 8] = b"pread()\0";
pub const ngx_read_fd_n: &[u8; 7] = b"read()\0";
pub const ngx_write_fd_n: &[u8; 8] = b"write()\0";
pub const NGX_LINEFEED_SIZE: u32 = 1;
pub const NGX_LINEFEED: &[u8; 2] = b"\n\0";
pub const ngx_rename_file_n: &[u8; 9] = b"rename()\0";
pub const ngx_change_file_access_n: &[u8; 8] = b"chmod()\0";
pub const ngx_set_file_time_n: &[u8; 9] = b"utimes()\0";
pub const ngx_file_info_n: &[u8; 7] = b"stat()\0";
pub const ngx_fd_info_n: &[u8; 8] = b"fstat()\0";
pub const ngx_link_info_n: &[u8; 8] = b"lstat()\0";
pub const ngx_realpath_n: &[u8; 11] = b"realpath()\0";
pub const ngx_getcwd_n: &[u8; 9] = b"getcwd()\0";
pub const NGX_HAVE_MAX_PATH: u32 = 1;
pub const NGX_MAX_PATH: u32 = 4096;
pub const ngx_open_dir_n: &[u8; 10] = b"opendir()\0";
pub const ngx_close_dir_n: &[u8; 11] = b"closedir()\0";
pub const ngx_read_dir_n: &[u8; 10] = b"readdir()\0";
pub const ngx_create_dir_n: &[u8; 8] = b"mkdir()\0";
pub const ngx_delete_dir_n: &[u8; 8] = b"rmdir()\0";
pub const ngx_de_info_n: &[u8; 7] = b"stat()\0";
pub const ngx_de_link_info_n: &[u8; 8] = b"lstat()\0";
pub const ngx_open_glob_n: &[u8; 7] = b"glob()\0";
pub const ngx_trylock_fd_n: &[u8; 24] = b"fcntl(F_SETLK, F_WRLCK)\0";
pub const ngx_lock_fd_n: &[u8; 25] = b"fcntl(F_SETLKW, F_WRLCK)\0";
pub const ngx_unlock_fd_n: &[u8; 24] = b"fcntl(F_SETLK, F_UNLCK)\0";
pub const NGX_HAVE_READ_AHEAD: u32 = 1;
pub const ngx_read_ahead_n: &[u8; 37] = b"posix_fadvise(POSIX_FADV_SEQUENTIAL)\0";
pub const ngx_directio_on_n: &[u8; 16] = b"fcntl(O_DIRECT)\0";
pub const ngx_directio_off_n: &[u8; 17] = b"fcntl(!O_DIRECT)\0";
pub const ngx_openat_file_n: &[u8; 9] = b"openat()\0";
pub const ngx_file_at_info_n: &[u8; 10] = b"fstatat()\0";
pub const ngx_stdout: u32 = 1;
pub const ngx_stderr: u32 = 2;
pub const ngx_set_stderr_n: &[u8; 20] = b"dup2(STDERR_FILENO)\0";
pub const NGX_HAVE_CPU_AFFINITY: u32 = 1;
pub const NGX_SETPROCTITLE_USES_ENV: u32 = 1;
pub const NGX_SETPROCTITLE_PAD: u8 = 0u8;
pub const NGX_INVALID_PID: i32 = -1;
pub const NGX_MAX_PROCESSES: u32 = 1024;
pub const NGX_PROCESS_NORESPAWN: i32 = -1;
pub const NGX_PROCESS_JUST_SPAWN: i32 = -2;
pub const NGX_PROCESS_RESPAWN: i32 = -3;
pub const NGX_PROCESS_JUST_RESPAWN: i32 = -4;
pub const NGX_PROCESS_DETACHED: i32 = -5;
pub const ngx_dlopen_n: &[u8; 9] = b"dlopen()\0";
pub const ngx_dlsym_n: &[u8; 8] = b"dlsym()\0";
pub const ngx_dlclose_n: &[u8; 10] = b"dlclose()\0";
pub const NGX_LOG_STDERR: u32 = 0;
pub const NGX_LOG_EMERG: u32 = 1;
pub const NGX_LOG_ALERT: u32 = 2;
pub const NGX_LOG_CRIT: u32 = 3;
pub const NGX_LOG_ERR: u32 = 4;
pub const NGX_LOG_WARN: u32 = 5;
pub const NGX_LOG_NOTICE: u32 = 6;
pub const NGX_LOG_INFO: u32 = 7;
pub const NGX_LOG_DEBUG: u32 = 8;
pub const NGX_LOG_DEBUG_CORE: u32 = 16;
pub const NGX_LOG_DEBUG_ALLOC: u32 = 32;
pub const NGX_LOG_DEBUG_MUTEX: u32 = 64;
pub const NGX_LOG_DEBUG_EVENT: u32 = 128;
pub const NGX_LOG_DEBUG_HTTP: u32 = 256;
pub const NGX_LOG_DEBUG_MAIL: u32 = 512;
pub const NGX_LOG_DEBUG_STREAM: u32 = 1024;
pub const NGX_LOG_DEBUG_FIRST: u32 = 16;
pub const NGX_LOG_DEBUG_LAST: u32 = 1024;
pub const NGX_LOG_DEBUG_CONNECTION: u32 = 2147483648;
pub const NGX_LOG_DEBUG_ALL: u32 = 2147483632;
pub const NGX_MAX_ERROR_STR: u32 = 4096;
pub const NGX_HAVE_VARIADIC_MACROS: u32 = 1;
pub const NGX_DEFAULT_POOL_SIZE: u32 = 16384;
pub const NGX_POOL_ALIGNMENT: u32 = 16;
pub const NGX_HASH_SMALL: u32 = 1;
pub const NGX_HASH_LARGE: u32 = 2;
pub const NGX_HASH_LARGE_ASIZE: u32 = 16384;
pub const NGX_HASH_LARGE_HSIZE: u32 = 10007;
pub const NGX_HASH_WILDCARD_KEY: u32 = 1;
pub const NGX_HASH_READONLY_KEY: u32 = 2;
pub const NGX_MAX_PATH_LEVEL: u32 = 3;
pub const PCRE_MAJOR: u32 = 8;
pub const PCRE_MINOR: u32 = 39;
pub const PCRE_DATE: u32 = 1996;
pub const PCRE_CASELESS: u32 = 1;
pub const PCRE_MULTILINE: u32 = 2;
pub const PCRE_DOTALL: u32 = 4;
pub const PCRE_EXTENDED: u32 = 8;
pub const PCRE_ANCHORED: u32 = 16;
pub const PCRE_DOLLAR_ENDONLY: u32 = 32;
pub const PCRE_EXTRA: u32 = 64;
pub const PCRE_NOTBOL: u32 = 128;
pub const PCRE_NOTEOL: u32 = 256;
pub const PCRE_UNGREEDY: u32 = 512;
pub const PCRE_NOTEMPTY: u32 = 1024;
pub const PCRE_UTF8: u32 = 2048;
pub const PCRE_UTF16: u32 = 2048;
pub const PCRE_UTF32: u32 = 2048;
pub const PCRE_NO_AUTO_CAPTURE: u32 = 4096;
pub const PCRE_NO_UTF8_CHECK: u32 = 8192;
pub const PCRE_NO_UTF16_CHECK: u32 = 8192;
pub const PCRE_NO_UTF32_CHECK: u32 = 8192;
pub const PCRE_AUTO_CALLOUT: u32 = 16384;
pub const PCRE_PARTIAL_SOFT: u32 = 32768;
pub const PCRE_PARTIAL: u32 = 32768;
pub const PCRE_NEVER_UTF: u32 = 65536;
pub const PCRE_DFA_SHORTEST: u32 = 65536;
pub const PCRE_NO_AUTO_POSSESS: u32 = 131072;
pub const PCRE_DFA_RESTART: u32 = 131072;
pub const PCRE_FIRSTLINE: u32 = 262144;
pub const PCRE_DUPNAMES: u32 = 524288;
pub const PCRE_NEWLINE_CR: u32 = 1048576;
pub const PCRE_NEWLINE_LF: u32 = 2097152;
pub const PCRE_NEWLINE_CRLF: u32 = 3145728;
pub const PCRE_NEWLINE_ANY: u32 = 4194304;
pub const PCRE_NEWLINE_ANYCRLF: u32 = 5242880;
pub const PCRE_BSR_ANYCRLF: u32 = 8388608;
pub const PCRE_BSR_UNICODE: u32 = 16777216;
pub const PCRE_JAVASCRIPT_COMPAT: u32 = 33554432;
pub const PCRE_NO_START_OPTIMIZE: u32 = 67108864;
pub const PCRE_NO_START_OPTIMISE: u32 = 67108864;
pub const PCRE_PARTIAL_HARD: u32 = 134217728;
pub const PCRE_NOTEMPTY_ATSTART: u32 = 268435456;
pub const PCRE_UCP: u32 = 536870912;
pub const PCRE_ERROR_NOMATCH: i32 = -1;
pub const PCRE_ERROR_NULL: i32 = -2;
pub const PCRE_ERROR_BADOPTION: i32 = -3;
pub const PCRE_ERROR_BADMAGIC: i32 = -4;
pub const PCRE_ERROR_UNKNOWN_OPCODE: i32 = -5;
pub const PCRE_ERROR_UNKNOWN_NODE: i32 = -5;
pub const PCRE_ERROR_NOMEMORY: i32 = -6;
pub const PCRE_ERROR_NOSUBSTRING: i32 = -7;
pub const PCRE_ERROR_MATCHLIMIT: i32 = -8;
pub const PCRE_ERROR_CALLOUT: i32 = -9;
pub const PCRE_ERROR_BADUTF8: i32 = -10;
pub const PCRE_ERROR_BADUTF16: i32 = -10;
pub const PCRE_ERROR_BADUTF32: i32 = -10;
pub const PCRE_ERROR_BADUTF8_OFFSET: i32 = -11;
pub const PCRE_ERROR_BADUTF16_OFFSET: i32 = -11;
pub const PCRE_ERROR_PARTIAL: i32 = -12;
pub const PCRE_ERROR_BADPARTIAL: i32 = -13;
pub const PCRE_ERROR_INTERNAL: i32 = -14;
pub const PCRE_ERROR_BADCOUNT: i32 = -15;
pub const PCRE_ERROR_DFA_UITEM: i32 = -16;
pub const PCRE_ERROR_DFA_UCOND: i32 = -17;
pub const PCRE_ERROR_DFA_UMLIMIT: i32 = -18;
pub const PCRE_ERROR_DFA_WSSIZE: i32 = -19;
pub const PCRE_ERROR_DFA_RECURSE: i32 = -20;
pub const PCRE_ERROR_RECURSIONLIMIT: i32 = -21;
pub const PCRE_ERROR_NULLWSLIMIT: i32 = -22;
pub const PCRE_ERROR_BADNEWLINE: i32 = -23;
pub const PCRE_ERROR_BADOFFSET: i32 = -24;
pub const PCRE_ERROR_SHORTUTF8: i32 = -25;
pub const PCRE_ERROR_SHORTUTF16: i32 = -25;
pub const PCRE_ERROR_RECURSELOOP: i32 = -26;
pub const PCRE_ERROR_JIT_STACKLIMIT: i32 = -27;
pub const PCRE_ERROR_BADMODE: i32 = -28;
pub const PCRE_ERROR_BADENDIANNESS: i32 = -29;
pub const PCRE_ERROR_DFA_BADRESTART: i32 = -30;
pub const PCRE_ERROR_JIT_BADOPTION: i32 = -31;
pub const PCRE_ERROR_BADLENGTH: i32 = -32;
pub const PCRE_ERROR_UNSET: i32 = -33;
pub const PCRE_UTF8_ERR0: u32 = 0;
pub const PCRE_UTF8_ERR1: u32 = 1;
pub const PCRE_UTF8_ERR2: u32 = 2;
pub const PCRE_UTF8_ERR3: u32 = 3;
pub const PCRE_UTF8_ERR4: u32 = 4;
pub const PCRE_UTF8_ERR5: u32 = 5;
pub const PCRE_UTF8_ERR6: u32 = 6;
pub const PCRE_UTF8_ERR7: u32 = 7;
pub const PCRE_UTF8_ERR8: u32 = 8;
pub const PCRE_UTF8_ERR9: u32 = 9;
pub const PCRE_UTF8_ERR10: u32 = 10;
pub const PCRE_UTF8_ERR11: u32 = 11;
pub const PCRE_UTF8_ERR12: u32 = 12;
pub const PCRE_UTF8_ERR13: u32 = 13;
pub const PCRE_UTF8_ERR14: u32 = 14;
pub const PCRE_UTF8_ERR15: u32 = 15;
pub const PCRE_UTF8_ERR16: u32 = 16;
pub const PCRE_UTF8_ERR17: u32 = 17;
pub const PCRE_UTF8_ERR18: u32 = 18;
pub const PCRE_UTF8_ERR19: u32 = 19;
pub const PCRE_UTF8_ERR20: u32 = 20;
pub const PCRE_UTF8_ERR21: u32 = 21;
pub const PCRE_UTF8_ERR22: u32 = 22;
pub const PCRE_UTF16_ERR0: u32 = 0;
pub const PCRE_UTF16_ERR1: u32 = 1;
pub const PCRE_UTF16_ERR2: u32 = 2;
pub const PCRE_UTF16_ERR3: u32 = 3;
pub const PCRE_UTF16_ERR4: u32 = 4;
pub const PCRE_UTF32_ERR0: u32 = 0;
pub const PCRE_UTF32_ERR1: u32 = 1;
pub const PCRE_UTF32_ERR2: u32 = 2;
pub const PCRE_UTF32_ERR3: u32 = 3;
pub const PCRE_INFO_OPTIONS: u32 = 0;
pub const PCRE_INFO_SIZE: u32 = 1;
pub const PCRE_INFO_CAPTURECOUNT: u32 = 2;
pub const PCRE_INFO_BACKREFMAX: u32 = 3;
pub const PCRE_INFO_FIRSTBYTE: u32 = 4;
pub const PCRE_INFO_FIRSTCHAR: u32 = 4;
pub const PCRE_INFO_FIRSTTABLE: u32 = 5;
pub const PCRE_INFO_LASTLITERAL: u32 = 6;
pub const PCRE_INFO_NAMEENTRYSIZE: u32 = 7;
pub const PCRE_INFO_NAMECOUNT: u32 = 8;
pub const PCRE_INFO_NAMETABLE: u32 = 9;
pub const PCRE_INFO_STUDYSIZE: u32 = 10;
pub const PCRE_INFO_DEFAULT_TABLES: u32 = 11;
pub const PCRE_INFO_OKPARTIAL: u32 = 12;
pub const PCRE_INFO_JCHANGED: u32 = 13;
pub const PCRE_INFO_HASCRORLF: u32 = 14;
pub const PCRE_INFO_MINLENGTH: u32 = 15;
pub const PCRE_INFO_JIT: u32 = 16;
pub const PCRE_INFO_JITSIZE: u32 = 17;
pub const PCRE_INFO_MAXLOOKBEHIND: u32 = 18;
pub const PCRE_INFO_FIRSTCHARACTER: u32 = 19;
pub const PCRE_INFO_FIRSTCHARACTERFLAGS: u32 = 20;
pub const PCRE_INFO_REQUIREDCHAR: u32 = 21;
pub const PCRE_INFO_REQUIREDCHARFLAGS: u32 = 22;
pub const PCRE_INFO_MATCHLIMIT: u32 = 23;
pub const PCRE_INFO_RECURSIONLIMIT: u32 = 24;
pub const PCRE_INFO_MATCH_EMPTY: u32 = 25;
pub const PCRE_CONFIG_UTF8: u32 = 0;
pub const PCRE_CONFIG_NEWLINE: u32 = 1;
pub const PCRE_CONFIG_LINK_SIZE: u32 = 2;
pub const PCRE_CONFIG_POSIX_MALLOC_THRESHOLD: u32 = 3;
pub const PCRE_CONFIG_MATCH_LIMIT: u32 = 4;
pub const PCRE_CONFIG_STACKRECURSE: u32 = 5;
pub const PCRE_CONFIG_UNICODE_PROPERTIES: u32 = 6;
pub const PCRE_CONFIG_MATCH_LIMIT_RECURSION: u32 = 7;
pub const PCRE_CONFIG_BSR: u32 = 8;
pub const PCRE_CONFIG_JIT: u32 = 9;
pub const PCRE_CONFIG_UTF16: u32 = 10;
pub const PCRE_CONFIG_JITTARGET: u32 = 11;
pub const PCRE_CONFIG_UTF32: u32 = 12;
pub const PCRE_CONFIG_PARENS_LIMIT: u32 = 13;
pub const PCRE_STUDY_JIT_COMPILE: u32 = 1;
pub const PCRE_STUDY_JIT_PARTIAL_SOFT_COMPILE: u32 = 2;
pub const PCRE_STUDY_JIT_PARTIAL_HARD_COMPILE: u32 = 4;
pub const PCRE_STUDY_EXTRA_NEEDED: u32 = 8;
pub const PCRE_EXTRA_STUDY_DATA: u32 = 1;
pub const PCRE_EXTRA_MATCH_LIMIT: u32 = 2;
pub const PCRE_EXTRA_CALLOUT_DATA: u32 = 4;
pub const PCRE_EXTRA_TABLES: u32 = 8;
pub const PCRE_EXTRA_MATCH_LIMIT_RECURSION: u32 = 16;
pub const PCRE_EXTRA_MARK: u32 = 32;
pub const PCRE_EXTRA_EXECUTABLE_JIT: u32 = 64;
pub const NGX_REGEX_NO_MATCHED: i32 = -1;
pub const NGX_REGEX_CASELESS: u32 = 1;
pub const ngx_regex_exec_n: &[u8; 12] = b"pcre_exec()\0";
pub const ngx_next_time_n: &[u8; 9] = b"mktime()\0";
pub const NGX_CYCLE_POOL_SIZE: u32 = 16384;
pub const NGX_DEBUG_POINTS_STOP: u32 = 1;
pub const NGX_DEBUG_POINTS_ABORT: u32 = 2;
pub const HAVE_PRIVILEGED_PROCESS_PATCH: u32 = 1;
pub const NGX_RESOLVE_A: u32 = 1;
pub const NGX_RESOLVE_CNAME: u32 = 5;
pub const NGX_RESOLVE_PTR: u32 = 12;
pub const NGX_RESOLVE_MX: u32 = 15;
pub const NGX_RESOLVE_TXT: u32 = 16;
pub const NGX_RESOLVE_AAAA: u32 = 28;
pub const NGX_RESOLVE_SRV: u32 = 33;
pub const NGX_RESOLVE_DNAME: u32 = 39;
pub const NGX_RESOLVE_FORMERR: u32 = 1;
pub const NGX_RESOLVE_SERVFAIL: u32 = 2;
pub const NGX_RESOLVE_NXDOMAIN: u32 = 3;
pub const NGX_RESOLVE_NOTIMP: u32 = 4;
pub const NGX_RESOLVE_REFUSED: u32 = 5;
pub const NGX_RESOLVE_TIMEDOUT: u32 = 110;
pub const NGX_RESOLVER_MAX_RECURSION: u32 = 50;
pub const OPENSSL_CONFIGURED_API: u32 = 30100;
pub const OPENSSL_VERSION_MAJOR: u32 = 3;
pub const OPENSSL_VERSION_MINOR: u32 = 1;
pub const OPENSSL_VERSION_PATCH: u32 = 5;
pub const OPENSSL_VERSION_PRE_RELEASE: &[u8; 1] = b"\0";
pub const OPENSSL_VERSION_BUILD_METADATA: &[u8; 1] = b"\0";
pub const OPENSSL_SHLIB_VERSION: u32 = 3;
pub const OPENSSL_VERSION_STR: &[u8; 6] = b"3.1.5\0";
pub const OPENSSL_FULL_VERSION_STR: &[u8; 6] = b"3.1.5\0";
pub const OPENSSL_RELEASE_DATE: &[u8; 12] = b"30 Jan 2024\0";
pub const OPENSSL_VERSION_TEXT: &[u8; 26] = b"OpenSSL 3.1.5 30 Jan 2024\0";
pub const _OPENSSL_VERSION_PRE_RELEASE: u32 = 0;
pub const OPENSSL_VERSION_NUMBER: u32 = 806355024;
pub const OPENSSL_API_LEVEL: u32 = 30100;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const ASN1_F_A2D_ASN1_OBJECT: u32 = 0;
pub const ASN1_F_A2I_ASN1_INTEGER: u32 = 0;
pub const ASN1_F_A2I_ASN1_STRING: u32 = 0;
pub const ASN1_F_APPEND_EXP: u32 = 0;
pub const ASN1_F_ASN1_BIO_INIT: u32 = 0;
pub const ASN1_F_ASN1_BIT_STRING_SET_BIT: u32 = 0;
pub const ASN1_F_ASN1_CB: u32 = 0;
pub const ASN1_F_ASN1_CHECK_TLEN: u32 = 0;
pub const ASN1_F_ASN1_COLLECT: u32 = 0;
pub const ASN1_F_ASN1_D2I_EX_PRIMITIVE: u32 = 0;
pub const ASN1_F_ASN1_D2I_FP: u32 = 0;
pub const ASN1_F_ASN1_D2I_READ_BIO: u32 = 0;
pub const ASN1_F_ASN1_DIGEST: u32 = 0;
pub const ASN1_F_ASN1_DO_ADB: u32 = 0;
pub const ASN1_F_ASN1_DO_LOCK: u32 = 0;
pub const ASN1_F_ASN1_DUP: u32 = 0;
pub const ASN1_F_ASN1_ENC_SAVE: u32 = 0;
pub const ASN1_F_ASN1_EX_C2I: u32 = 0;
pub const ASN1_F_ASN1_FIND_END: u32 = 0;
pub const ASN1_F_ASN1_GENERALIZEDTIME_ADJ: u32 = 0;
pub const ASN1_F_ASN1_GENERATE_V3: u32 = 0;
pub const ASN1_F_ASN1_GET_INT64: u32 = 0;
pub const ASN1_F_ASN1_GET_OBJECT: u32 = 0;
pub const ASN1_F_ASN1_GET_UINT64: u32 = 0;
pub const ASN1_F_ASN1_I2D_BIO: u32 = 0;
pub const ASN1_F_ASN1_I2D_FP: u32 = 0;
pub const ASN1_F_ASN1_ITEM_D2I_FP: u32 = 0;
pub const ASN1_F_ASN1_ITEM_DUP: u32 = 0;
pub const ASN1_F_ASN1_ITEM_EMBED_D2I: u32 = 0;
pub const ASN1_F_ASN1_ITEM_EMBED_NEW: u32 = 0;
pub const ASN1_F_ASN1_ITEM_FLAGS_I2D: u32 = 0;
pub const ASN1_F_ASN1_ITEM_I2D_BIO: u32 = 0;
pub const ASN1_F_ASN1_ITEM_I2D_FP: u32 = 0;
pub const ASN1_F_ASN1_ITEM_PACK: u32 = 0;
pub const ASN1_F_ASN1_ITEM_SIGN: u32 = 0;
pub const ASN1_F_ASN1_ITEM_SIGN_CTX: u32 = 0;
pub const ASN1_F_ASN1_ITEM_UNPACK: u32 = 0;
pub const ASN1_F_ASN1_ITEM_VERIFY: u32 = 0;
pub const ASN1_F_ASN1_MBSTRING_NCOPY: u32 = 0;
pub const ASN1_F_ASN1_OBJECT_NEW: u32 = 0;
pub const ASN1_F_ASN1_OUTPUT_DATA: u32 = 0;
pub const ASN1_F_ASN1_PCTX_NEW: u32 = 0;
pub const ASN1_F_ASN1_PRIMITIVE_NEW: u32 = 0;
pub const ASN1_F_ASN1_SCTX_NEW: u32 = 0;
pub const ASN1_F_ASN1_SIGN: u32 = 0;
pub const ASN1_F_ASN1_STR2TYPE: u32 = 0;
pub const ASN1_F_ASN1_STRING_GET_INT64: u32 = 0;
pub const ASN1_F_ASN1_STRING_GET_UINT64: u32 = 0;
pub const ASN1_F_ASN1_STRING_SET: u32 = 0;
pub const ASN1_F_ASN1_STRING_TABLE_ADD: u32 = 0;
pub const ASN1_F_ASN1_STRING_TO_BN: u32 = 0;
pub const ASN1_F_ASN1_STRING_TYPE_NEW: u32 = 0;
pub const ASN1_F_ASN1_TEMPLATE_EX_D2I: u32 = 0;
pub const ASN1_F_ASN1_TEMPLATE_NEW: u32 = 0;
pub const ASN1_F_ASN1_TEMPLATE_NOEXP_D2I: u32 = 0;
pub const ASN1_F_ASN1_TIME_ADJ: u32 = 0;
pub const ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING: u32 = 0;
pub const ASN1_F_ASN1_TYPE_GET_OCTETSTRING: u32 = 0;
pub const ASN1_F_ASN1_UTCTIME_ADJ: u32 = 0;
pub const ASN1_F_ASN1_VERIFY: u32 = 0;
pub const ASN1_F_B64_READ_ASN1: u32 = 0;
pub const ASN1_F_B64_WRITE_ASN1: u32 = 0;
pub const ASN1_F_BIO_NEW_NDEF: u32 = 0;
pub const ASN1_F_BITSTR_CB: u32 = 0;
pub const ASN1_F_BN_TO_ASN1_STRING: u32 = 0;
pub const ASN1_F_C2I_ASN1_BIT_STRING: u32 = 0;
pub const ASN1_F_C2I_ASN1_INTEGER: u32 = 0;
pub const ASN1_F_C2I_ASN1_OBJECT: u32 = 0;
pub const ASN1_F_C2I_IBUF: u32 = 0;
pub const ASN1_F_C2I_UINT64_INT: u32 = 0;
pub const ASN1_F_COLLECT_DATA: u32 = 0;
pub const ASN1_F_D2I_ASN1_OBJECT: u32 = 0;
pub const ASN1_F_D2I_ASN1_UINTEGER: u32 = 0;
pub const ASN1_F_D2I_AUTOPRIVATEKEY: u32 = 0;
pub const ASN1_F_D2I_PRIVATEKEY: u32 = 0;
pub const ASN1_F_D2I_PUBLICKEY: u32 = 0;
pub const ASN1_F_DO_BUF: u32 = 0;
pub const ASN1_F_DO_CREATE: u32 = 0;
pub const ASN1_F_DO_DUMP: u32 = 0;
pub const ASN1_F_DO_TCREATE: u32 = 0;
pub const ASN1_F_I2A_ASN1_OBJECT: u32 = 0;
pub const ASN1_F_I2D_ASN1_BIO_STREAM: u32 = 0;
pub const ASN1_F_I2D_ASN1_OBJECT: u32 = 0;
pub const ASN1_F_I2D_DSA_PUBKEY: u32 = 0;
pub const ASN1_F_I2D_EC_PUBKEY: u32 = 0;
pub const ASN1_F_I2D_PRIVATEKEY: u32 = 0;
pub const ASN1_F_I2D_PUBLICKEY: u32 = 0;
pub const ASN1_F_I2D_RSA_PUBKEY: u32 = 0;
pub const ASN1_F_LONG_C2I: u32 = 0;
pub const ASN1_F_NDEF_PREFIX: u32 = 0;
pub const ASN1_F_NDEF_SUFFIX: u32 = 0;
pub const ASN1_F_OID_MODULE_INIT: u32 = 0;
pub const ASN1_F_PARSE_TAGGING: u32 = 0;
pub const ASN1_F_PKCS5_PBE2_SET_IV: u32 = 0;
pub const ASN1_F_PKCS5_PBE2_SET_SCRYPT: u32 = 0;
pub const ASN1_F_PKCS5_PBE_SET: u32 = 0;
pub const ASN1_F_PKCS5_PBE_SET0_ALGOR: u32 = 0;
pub const ASN1_F_PKCS5_PBKDF2_SET: u32 = 0;
pub const ASN1_F_PKCS5_SCRYPT_SET: u32 = 0;
pub const ASN1_F_SMIME_READ_ASN1: u32 = 0;
pub const ASN1_F_SMIME_TEXT: u32 = 0;
pub const ASN1_F_STABLE_GET: u32 = 0;
pub const ASN1_F_STBL_MODULE_INIT: u32 = 0;
pub const ASN1_F_UINT32_C2I: u32 = 0;
pub const ASN1_F_UINT32_NEW: u32 = 0;
pub const ASN1_F_UINT64_C2I: u32 = 0;
pub const ASN1_F_UINT64_NEW: u32 = 0;
pub const ASN1_F_X509_CRL_ADD0_REVOKED: u32 = 0;
pub const ASN1_F_X509_INFO_NEW: u32 = 0;
pub const ASN1_F_X509_NAME_ENCODE: u32 = 0;
pub const ASN1_F_X509_NAME_EX_D2I: u32 = 0;
pub const ASN1_F_X509_NAME_EX_NEW: u32 = 0;
pub const ASN1_F_X509_PKEY_NEW: u32 = 0;
pub const ASYNC_F_ASYNC_CTX_NEW: u32 = 0;
pub const ASYNC_F_ASYNC_INIT_THREAD: u32 = 0;
pub const ASYNC_F_ASYNC_JOB_NEW: u32 = 0;
pub const ASYNC_F_ASYNC_PAUSE_JOB: u32 = 0;
pub const ASYNC_F_ASYNC_START_FUNC: u32 = 0;
pub const ASYNC_F_ASYNC_START_JOB: u32 = 0;
pub const ASYNC_F_ASYNC_WAIT_CTX_SET_WAIT_FD: u32 = 0;
pub const BIO_F_ACPT_STATE: u32 = 0;
pub const BIO_F_ADDRINFO_WRAP: u32 = 0;
pub const BIO_F_ADDR_STRINGS: u32 = 0;
pub const BIO_F_BIO_ACCEPT: u32 = 0;
pub const BIO_F_BIO_ACCEPT_EX: u32 = 0;
pub const BIO_F_BIO_ACCEPT_NEW: u32 = 0;
pub const BIO_F_BIO_ADDR_NEW: u32 = 0;
pub const BIO_F_BIO_BIND: u32 = 0;
pub const BIO_F_BIO_CALLBACK_CTRL: u32 = 0;
pub const BIO_F_BIO_CONNECT: u32 = 0;
pub const BIO_F_BIO_CONNECT_NEW: u32 = 0;
pub const BIO_F_BIO_CTRL: u32 = 0;
pub const BIO_F_BIO_GETS: u32 = 0;
pub const BIO_F_BIO_GET_HOST_IP: u32 = 0;
pub const BIO_F_BIO_GET_NEW_INDEX: u32 = 0;
pub const BIO_F_BIO_GET_PORT: u32 = 0;
pub const BIO_F_BIO_LISTEN: u32 = 0;
pub const BIO_F_BIO_LOOKUP: u32 = 0;
pub const BIO_F_BIO_LOOKUP_EX: u32 = 0;
pub const BIO_F_BIO_MAKE_PAIR: u32 = 0;
pub const BIO_F_BIO_METH_NEW: u32 = 0;
pub const BIO_F_BIO_NEW: u32 = 0;
pub const BIO_F_BIO_NEW_DGRAM_SCTP: u32 = 0;
pub const BIO_F_BIO_NEW_FILE: u32 = 0;
pub const BIO_F_BIO_NEW_MEM_BUF: u32 = 0;
pub const BIO_F_BIO_NREAD: u32 = 0;
pub const BIO_F_BIO_NREAD0: u32 = 0;
pub const BIO_F_BIO_NWRITE: u32 = 0;
pub const BIO_F_BIO_NWRITE0: u32 = 0;
pub const BIO_F_BIO_PARSE_HOSTSERV: u32 = 0;
pub const BIO_F_BIO_PUTS: u32 = 0;
pub const BIO_F_BIO_READ: u32 = 0;
pub const BIO_F_BIO_READ_EX: u32 = 0;
pub const BIO_F_BIO_READ_INTERN: u32 = 0;
pub const BIO_F_BIO_SOCKET: u32 = 0;
pub const BIO_F_BIO_SOCKET_NBIO: u32 = 0;
pub const BIO_F_BIO_SOCK_INFO: u32 = 0;
pub const BIO_F_BIO_SOCK_INIT: u32 = 0;
pub const BIO_F_BIO_WRITE: u32 = 0;
pub const BIO_F_BIO_WRITE_EX: u32 = 0;
pub const BIO_F_BIO_WRITE_INTERN: u32 = 0;
pub const BIO_F_BUFFER_CTRL: u32 = 0;
pub const BIO_F_CONN_CTRL: u32 = 0;
pub const BIO_F_CONN_STATE: u32 = 0;
pub const BIO_F_DGRAM_SCTP_NEW: u32 = 0;
pub const BIO_F_DGRAM_SCTP_READ: u32 = 0;
pub const BIO_F_DGRAM_SCTP_WRITE: u32 = 0;
pub const BIO_F_DOAPR_OUTCH: u32 = 0;
pub const BIO_F_FILE_CTRL: u32 = 0;
pub const BIO_F_FILE_READ: u32 = 0;
pub const BIO_F_LINEBUFFER_CTRL: u32 = 0;
pub const BIO_F_LINEBUFFER_NEW: u32 = 0;
pub const BIO_F_MEM_WRITE: u32 = 0;
pub const BIO_F_NBIOF_NEW: u32 = 0;
pub const BIO_F_SLG_WRITE: u32 = 0;
pub const BIO_F_SSL_NEW: u32 = 0;
pub const BN_F_BNRAND: u32 = 0;
pub const BN_F_BNRAND_RANGE: u32 = 0;
pub const BN_F_BN_BLINDING_CONVERT_EX: u32 = 0;
pub const BN_F_BN_BLINDING_CREATE_PARAM: u32 = 0;
pub const BN_F_BN_BLINDING_INVERT_EX: u32 = 0;
pub const BN_F_BN_BLINDING_NEW: u32 = 0;
pub const BN_F_BN_BLINDING_UPDATE: u32 = 0;
pub const BN_F_BN_BN2DEC: u32 = 0;
pub const BN_F_BN_BN2HEX: u32 = 0;
pub const BN_F_BN_COMPUTE_WNAF: u32 = 0;
pub const BN_F_BN_CTX_GET: u32 = 0;
pub const BN_F_BN_CTX_NEW: u32 = 0;
pub const BN_F_BN_CTX_START: u32 = 0;
pub const BN_F_BN_DIV: u32 = 0;
pub const BN_F_BN_DIV_RECP: u32 = 0;
pub const BN_F_BN_EXP: u32 = 0;
pub const BN_F_BN_EXPAND_INTERNAL: u32 = 0;
pub const BN_F_BN_GENCB_NEW: u32 = 0;
pub const BN_F_BN_GENERATE_DSA_NONCE: u32 = 0;
pub const BN_F_BN_GENERATE_PRIME_EX: u32 = 0;
pub const BN_F_BN_GF2M_MOD: u32 = 0;
pub const BN_F_BN_GF2M_MOD_EXP: u32 = 0;
pub const BN_F_BN_GF2M_MOD_MUL: u32 = 0;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD: u32 = 0;
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR: u32 = 0;
pub const BN_F_BN_GF2M_MOD_SQR: u32 = 0;
pub const BN_F_BN_GF2M_MOD_SQRT: u32 = 0;
pub const BN_F_BN_LSHIFT: u32 = 0;
pub const BN_F_BN_MOD_EXP2_MONT: u32 = 0;
pub const BN_F_BN_MOD_EXP_MONT: u32 = 0;
pub const BN_F_BN_MOD_EXP_MONT_CONSTTIME: u32 = 0;
pub const BN_F_BN_MOD_EXP_MONT_WORD: u32 = 0;
pub const BN_F_BN_MOD_EXP_RECP: u32 = 0;
pub const BN_F_BN_MOD_EXP_SIMPLE: u32 = 0;
pub const BN_F_BN_MOD_INVERSE: u32 = 0;
pub const BN_F_BN_MOD_INVERSE_NO_BRANCH: u32 = 0;
pub const BN_F_BN_MOD_LSHIFT_QUICK: u32 = 0;
pub const BN_F_BN_MOD_SQRT: u32 = 0;
pub const BN_F_BN_MONT_CTX_NEW: u32 = 0;
pub const BN_F_BN_MPI2BN: u32 = 0;
pub const BN_F_BN_NEW: u32 = 0;
pub const BN_F_BN_POOL_GET: u32 = 0;
pub const BN_F_BN_RAND: u32 = 0;
pub const BN_F_BN_RAND_RANGE: u32 = 0;
pub const BN_F_BN_RECP_CTX_NEW: u32 = 0;
pub const BN_F_BN_RSHIFT: u32 = 0;
pub const BN_F_BN_SET_WORDS: u32 = 0;
pub const BN_F_BN_STACK_PUSH: u32 = 0;
pub const BN_F_BN_USUB: u32 = 0;
pub const BUF_F_BUF_MEM_GROW: u32 = 0;
pub const BUF_F_BUF_MEM_GROW_CLEAN: u32 = 0;
pub const BUF_F_BUF_MEM_NEW: u32 = 0;
pub const CMS_F_CHECK_CONTENT: u32 = 0;
pub const CMS_F_CMS_ADD0_CERT: u32 = 0;
pub const CMS_F_CMS_ADD0_RECIPIENT_KEY: u32 = 0;
pub const CMS_F_CMS_ADD0_RECIPIENT_PASSWORD: u32 = 0;
pub const CMS_F_CMS_ADD1_RECEIPTREQUEST: u32 = 0;
pub const CMS_F_CMS_ADD1_RECIPIENT_CERT: u32 = 0;
pub const CMS_F_CMS_ADD1_SIGNER: u32 = 0;
pub const CMS_F_CMS_ADD1_SIGNINGTIME: u32 = 0;
pub const CMS_F_CMS_COMPRESS: u32 = 0;
pub const CMS_F_CMS_COMPRESSEDDATA_CREATE: u32 = 0;
pub const CMS_F_CMS_COMPRESSEDDATA_INIT_BIO: u32 = 0;
pub const CMS_F_CMS_COPY_CONTENT: u32 = 0;
pub const CMS_F_CMS_COPY_MESSAGEDIGEST: u32 = 0;
pub const CMS_F_CMS_DATA: u32 = 0;
pub const CMS_F_CMS_DATAFINAL: u32 = 0;
pub const CMS_F_CMS_DATAINIT: u32 = 0;
pub const CMS_F_CMS_DECRYPT: u32 = 0;
pub const CMS_F_CMS_DECRYPT_SET1_KEY: u32 = 0;
pub const CMS_F_CMS_DECRYPT_SET1_PASSWORD: u32 = 0;
pub const CMS_F_CMS_DECRYPT_SET1_PKEY: u32 = 0;
pub const CMS_F_CMS_DIGESTALGORITHM_FIND_CTX: u32 = 0;
pub const CMS_F_CMS_DIGESTALGORITHM_INIT_BIO: u32 = 0;
pub const CMS_F_CMS_DIGESTEDDATA_DO_FINAL: u32 = 0;
pub const CMS_F_CMS_DIGEST_VERIFY: u32 = 0;
pub const CMS_F_CMS_ENCODE_RECEIPT: u32 = 0;
pub const CMS_F_CMS_ENCRYPT: u32 = 0;
pub const CMS_F_CMS_ENCRYPTEDCONTENT_INIT: u32 = 0;
pub const CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO: u32 = 0;
pub const CMS_F_CMS_ENCRYPTEDDATA_DECRYPT: u32 = 0;
pub const CMS_F_CMS_ENCRYPTEDDATA_ENCRYPT: u32 = 0;
pub const CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY: u32 = 0;
pub const CMS_F_CMS_ENVELOPEDDATA_CREATE: u32 = 0;
pub const CMS_F_CMS_ENVELOPEDDATA_INIT_BIO: u32 = 0;
pub const CMS_F_CMS_ENVELOPED_DATA_INIT: u32 = 0;
pub const CMS_F_CMS_ENV_ASN1_CTRL: u32 = 0;
pub const CMS_F_CMS_FINAL: u32 = 0;
pub const CMS_F_CMS_GET0_CERTIFICATE_CHOICES: u32 = 0;
pub const CMS_F_CMS_GET0_CONTENT: u32 = 0;
pub const CMS_F_CMS_GET0_ECONTENT_TYPE: u32 = 0;
pub const CMS_F_CMS_GET0_ENVELOPED: u32 = 0;
pub const CMS_F_CMS_GET0_REVOCATION_CHOICES: u32 = 0;
pub const CMS_F_CMS_GET0_SIGNED: u32 = 0;
pub const CMS_F_CMS_MSGSIGDIGEST_ADD1: u32 = 0;
pub const CMS_F_CMS_RECEIPTREQUEST_CREATE0: u32 = 0;
pub const CMS_F_CMS_RECEIPT_VERIFY: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_DECRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_ENCRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ORIG_ID: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_REKS: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_GET0_ID: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_ID_CMP: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_CERT_CMP: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_ALGS: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_SIGNER_ID: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_SET0_KEY: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_SET0_PASSWORD: u32 = 0;
pub const CMS_F_CMS_RECIPIENTINFO_SET0_PKEY: u32 = 0;
pub const CMS_F_CMS_SD_ASN1_CTRL: u32 = 0;
pub const CMS_F_CMS_SET1_IAS: u32 = 0;
pub const CMS_F_CMS_SET1_KEYID: u32 = 0;
pub const CMS_F_CMS_SET1_SIGNERIDENTIFIER: u32 = 0;
pub const CMS_F_CMS_SET_DETACHED: u32 = 0;
pub const CMS_F_CMS_SIGN: u32 = 0;
pub const CMS_F_CMS_SIGNED_DATA_INIT: u32 = 0;
pub const CMS_F_CMS_SIGNERINFO_CONTENT_SIGN: u32 = 0;
pub const CMS_F_CMS_SIGNERINFO_SIGN: u32 = 0;
pub const CMS_F_CMS_SIGNERINFO_VERIFY: u32 = 0;
pub const CMS_F_CMS_SIGNERINFO_VERIFY_CERT: u32 = 0;
pub const CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT: u32 = 0;
pub const CMS_F_CMS_SIGN_RECEIPT: u32 = 0;
pub const CMS_F_CMS_SI_CHECK_ATTRIBUTES: u32 = 0;
pub const CMS_F_CMS_STREAM: u32 = 0;
pub const CMS_F_CMS_UNCOMPRESS: u32 = 0;
pub const CMS_F_CMS_VERIFY: u32 = 0;
pub const CMS_F_KEK_UNWRAP_KEY: u32 = 0;
pub const COMP_F_BIO_ZLIB_FLUSH: u32 = 0;
pub const COMP_F_BIO_ZLIB_NEW: u32 = 0;
pub const COMP_F_BIO_ZLIB_READ: u32 = 0;
pub const COMP_F_BIO_ZLIB_WRITE: u32 = 0;
pub const COMP_F_COMP_CTX_NEW: u32 = 0;
pub const CONF_F_CONF_DUMP_FP: u32 = 0;
pub const CONF_F_CONF_LOAD: u32 = 0;
pub const CONF_F_CONF_LOAD_FP: u32 = 0;
pub const CONF_F_CONF_PARSE_LIST: u32 = 0;
pub const CONF_F_DEF_LOAD: u32 = 0;
pub const CONF_F_DEF_LOAD_BIO: u32 = 0;
pub const CONF_F_GET_NEXT_FILE: u32 = 0;
pub const CONF_F_MODULE_ADD: u32 = 0;
pub const CONF_F_MODULE_INIT: u32 = 0;
pub const CONF_F_MODULE_LOAD_DSO: u32 = 0;
pub const CONF_F_MODULE_RUN: u32 = 0;
pub const CONF_F_NCONF_DUMP_BIO: u32 = 0;
pub const CONF_F_NCONF_DUMP_FP: u32 = 0;
pub const CONF_F_NCONF_GET_NUMBER_E: u32 = 0;
pub const CONF_F_NCONF_GET_SECTION: u32 = 0;
pub const CONF_F_NCONF_GET_STRING: u32 = 0;
pub const CONF_F_NCONF_LOAD: u32 = 0;
pub const CONF_F_NCONF_LOAD_BIO: u32 = 0;
pub const CONF_F_NCONF_LOAD_FP: u32 = 0;
pub const CONF_F_NCONF_NEW: u32 = 0;
pub const CONF_F_PROCESS_INCLUDE: u32 = 0;
pub const CONF_F_SSL_MODULE_INIT: u32 = 0;
pub const CONF_F_STR_COPY: u32 = 0;
pub const CRYPTO_F_CMAC_CTX_NEW: u32 = 0;
pub const CRYPTO_F_CRYPTO_DUP_EX_DATA: u32 = 0;
pub const CRYPTO_F_CRYPTO_FREE_EX_DATA: u32 = 0;
pub const CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX: u32 = 0;
pub const CRYPTO_F_CRYPTO_MEMDUP: u32 = 0;
pub const CRYPTO_F_CRYPTO_NEW_EX_DATA: u32 = 0;
pub const CRYPTO_F_CRYPTO_OCB128_COPY_CTX: u32 = 0;
pub const CRYPTO_F_CRYPTO_OCB128_INIT: u32 = 0;
pub const CRYPTO_F_CRYPTO_SET_EX_DATA: u32 = 0;
pub const CRYPTO_F_GET_AND_LOCK: u32 = 0;
pub const CRYPTO_F_OPENSSL_ATEXIT: u32 = 0;
pub const CRYPTO_F_OPENSSL_BUF2HEXSTR: u32 = 0;
pub const CRYPTO_F_OPENSSL_FOPEN: u32 = 0;
pub const CRYPTO_F_OPENSSL_HEXSTR2BUF: u32 = 0;
pub const CRYPTO_F_OPENSSL_INIT_CRYPTO: u32 = 0;
pub const CRYPTO_F_OPENSSL_LH_NEW: u32 = 0;
pub const CRYPTO_F_OPENSSL_SK_DEEP_COPY: u32 = 0;
pub const CRYPTO_F_OPENSSL_SK_DUP: u32 = 0;
pub const CRYPTO_F_PKEY_HMAC_INIT: u32 = 0;
pub const CRYPTO_F_PKEY_POLY1305_INIT: u32 = 0;
pub const CRYPTO_F_PKEY_SIPHASH_INIT: u32 = 0;
pub const CRYPTO_F_SK_RESERVE: u32 = 0;
pub const CT_F_CTLOG_NEW: u32 = 0;
pub const CT_F_CTLOG_NEW_FROM_BASE64: u32 = 0;
pub const CT_F_CTLOG_NEW_FROM_CONF: u32 = 0;
pub const CT_F_CTLOG_STORE_LOAD_CTX_NEW: u32 = 0;
pub const CT_F_CTLOG_STORE_LOAD_FILE: u32 = 0;
pub const CT_F_CTLOG_STORE_LOAD_LOG: u32 = 0;
pub const CT_F_CTLOG_STORE_NEW: u32 = 0;
pub const CT_F_CT_BASE64_DECODE: u32 = 0;
pub const CT_F_CT_POLICY_EVAL_CTX_NEW: u32 = 0;
pub const CT_F_CT_V1_LOG_ID_FROM_PKEY: u32 = 0;
pub const CT_F_I2O_SCT: u32 = 0;
pub const CT_F_I2O_SCT_LIST: u32 = 0;
pub const CT_F_I2O_SCT_SIGNATURE: u32 = 0;
pub const CT_F_O2I_SCT: u32 = 0;
pub const CT_F_O2I_SCT_LIST: u32 = 0;
pub const CT_F_O2I_SCT_SIGNATURE: u32 = 0;
pub const CT_F_SCT_CTX_NEW: u32 = 0;
pub const CT_F_SCT_CTX_VERIFY: u32 = 0;
pub const CT_F_SCT_NEW: u32 = 0;
pub const CT_F_SCT_NEW_FROM_BASE64: u32 = 0;
pub const CT_F_SCT_SET0_LOG_ID: u32 = 0;
pub const CT_F_SCT_SET1_EXTENSIONS: u32 = 0;
pub const CT_F_SCT_SET1_LOG_ID: u32 = 0;
pub const CT_F_SCT_SET1_SIGNATURE: u32 = 0;
pub const CT_F_SCT_SET_LOG_ENTRY_TYPE: u32 = 0;
pub const CT_F_SCT_SET_SIGNATURE_NID: u32 = 0;
pub const CT_F_SCT_SET_VERSION: u32 = 0;
pub const DH_F_COMPUTE_KEY: u32 = 0;
pub const DH_F_DHPARAMS_PRINT_FP: u32 = 0;
pub const DH_F_DH_BUILTIN_GENPARAMS: u32 = 0;
pub const DH_F_DH_CHECK_EX: u32 = 0;
pub const DH_F_DH_CHECK_PARAMS_EX: u32 = 0;
pub const DH_F_DH_CHECK_PUB_KEY_EX: u32 = 0;
pub const DH_F_DH_CMS_DECRYPT: u32 = 0;
pub const DH_F_DH_CMS_SET_PEERKEY: u32 = 0;
pub const DH_F_DH_CMS_SET_SHARED_INFO: u32 = 0;
pub const DH_F_DH_METH_DUP: u32 = 0;
pub const DH_F_DH_METH_NEW: u32 = 0;
pub const DH_F_DH_METH_SET1_NAME: u32 = 0;
pub const DH_F_DH_NEW_BY_NID: u32 = 0;
pub const DH_F_DH_NEW_METHOD: u32 = 0;
pub const DH_F_DH_PARAM_DECODE: u32 = 0;
pub const DH_F_DH_PKEY_PUBLIC_CHECK: u32 = 0;
pub const DH_F_DH_PRIV_DECODE: u32 = 0;
pub const DH_F_DH_PRIV_ENCODE: u32 = 0;
pub const DH_F_DH_PUB_DECODE: u32 = 0;
pub const DH_F_DH_PUB_ENCODE: u32 = 0;
pub const DH_F_DO_DH_PRINT: u32 = 0;
pub const DH_F_GENERATE_KEY: u32 = 0;
pub const DH_F_PKEY_DH_CTRL_STR: u32 = 0;
pub const DH_F_PKEY_DH_DERIVE: u32 = 0;
pub const DH_F_PKEY_DH_INIT: u32 = 0;
pub const DH_F_PKEY_DH_KEYGEN: u32 = 0;
pub const DSA_F_DSAPARAMS_PRINT: u32 = 0;
pub const DSA_F_DSAPARAMS_PRINT_FP: u32 = 0;
pub const DSA_F_DSA_BUILTIN_PARAMGEN: u32 = 0;
pub const DSA_F_DSA_BUILTIN_PARAMGEN2: u32 = 0;
pub const DSA_F_DSA_DO_SIGN: u32 = 0;
pub const DSA_F_DSA_DO_VERIFY: u32 = 0;
pub const DSA_F_DSA_METH_DUP: u32 = 0;
pub const DSA_F_DSA_METH_NEW: u32 = 0;
pub const DSA_F_DSA_METH_SET1_NAME: u32 = 0;
pub const DSA_F_DSA_NEW_METHOD: u32 = 0;
pub const DSA_F_DSA_PARAM_DECODE: u32 = 0;
pub const DSA_F_DSA_PRINT_FP: u32 = 0;
pub const DSA_F_DSA_PRIV_DECODE: u32 = 0;
pub const DSA_F_DSA_PRIV_ENCODE: u32 = 0;
pub const DSA_F_DSA_PUB_DECODE: u32 = 0;
pub const DSA_F_DSA_PUB_ENCODE: u32 = 0;
pub const DSA_F_DSA_SIGN: u32 = 0;
pub const DSA_F_DSA_SIGN_SETUP: u32 = 0;
pub const DSA_F_DSA_SIG_NEW: u32 = 0;
pub const DSA_F_OLD_DSA_PRIV_DECODE: u32 = 0;
pub const DSA_F_PKEY_DSA_CTRL: u32 = 0;
pub const DSA_F_PKEY_DSA_CTRL_STR: u32 = 0;
pub const DSA_F_PKEY_DSA_KEYGEN: u32 = 0;
pub const EC_F_BN_TO_FELEM: u32 = 0;
pub const EC_F_D2I_ECPARAMETERS: u32 = 0;
pub const EC_F_D2I_ECPKPARAMETERS: u32 = 0;
pub const EC_F_D2I_ECPRIVATEKEY: u32 = 0;
pub const EC_F_DO_EC_KEY_PRINT: u32 = 0;
pub const EC_F_ECDH_CMS_DECRYPT: u32 = 0;
pub const EC_F_ECDH_CMS_SET_SHARED_INFO: u32 = 0;
pub const EC_F_ECDH_COMPUTE_KEY: u32 = 0;
pub const EC_F_ECDH_SIMPLE_COMPUTE_KEY: u32 = 0;
pub const EC_F_ECDSA_DO_SIGN_EX: u32 = 0;
pub const EC_F_ECDSA_DO_VERIFY: u32 = 0;
pub const EC_F_ECDSA_SIGN_EX: u32 = 0;
pub const EC_F_ECDSA_SIGN_SETUP: u32 = 0;
pub const EC_F_ECDSA_SIG_NEW: u32 = 0;
pub const EC_F_ECDSA_VERIFY: u32 = 0;
pub const EC_F_ECD_ITEM_VERIFY: u32 = 0;
pub const EC_F_ECKEY_PARAM2TYPE: u32 = 0;
pub const EC_F_ECKEY_PARAM_DECODE: u32 = 0;
pub const EC_F_ECKEY_PRIV_DECODE: u32 = 0;
pub const EC_F_ECKEY_PRIV_ENCODE: u32 = 0;
pub const EC_F_ECKEY_PUB_DECODE: u32 = 0;
pub const EC_F_ECKEY_PUB_ENCODE: u32 = 0;
pub const EC_F_ECKEY_TYPE2PARAM: u32 = 0;
pub const EC_F_ECPARAMETERS_PRINT: u32 = 0;
pub const EC_F_ECPARAMETERS_PRINT_FP: u32 = 0;
pub const EC_F_ECPKPARAMETERS_PRINT: u32 = 0;
pub const EC_F_ECPKPARAMETERS_PRINT_FP: u32 = 0;
pub const EC_F_ECP_NISTZ256_GET_AFFINE: u32 = 0;
pub const EC_F_ECP_NISTZ256_INV_MOD_ORD: u32 = 0;
pub const EC_F_ECP_NISTZ256_MULT_PRECOMPUTE: u32 = 0;
pub const EC_F_ECP_NISTZ256_POINTS_MUL: u32 = 0;
pub const EC_F_ECP_NISTZ256_PRE_COMP_NEW: u32 = 0;
pub const EC_F_ECP_NISTZ256_WINDOWED_MUL: u32 = 0;
pub const EC_F_ECX_KEY_OP: u32 = 0;
pub const EC_F_ECX_PRIV_ENCODE: u32 = 0;
pub const EC_F_ECX_PUB_ENCODE: u32 = 0;
pub const EC_F_EC_ASN1_GROUP2CURVE: u32 = 0;
pub const EC_F_EC_ASN1_GROUP2FIELDID: u32 = 0;
pub const EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_FIELD_INV: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_LADDER_POST: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_LADDER_PRE: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_OCT2POINT: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_POINT2OCT: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_POINTS_MUL: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_MONT_FIELD_DECODE: u32 = 0;
pub const EC_F_EC_GFP_MONT_FIELD_ENCODE: u32 = 0;
pub const EC_F_EC_GFP_MONT_FIELD_INV: u32 = 0;
pub const EC_F_EC_GFP_MONT_FIELD_MUL: u32 = 0;
pub const EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE: u32 = 0;
pub const EC_F_EC_GFP_MONT_FIELD_SQR: u32 = 0;
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GFP_NISTP224_POINTS_MUL: u32 = 0;
pub const EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GFP_NISTP256_POINTS_MUL: u32 = 0;
pub const EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GFP_NISTP521_POINTS_MUL: u32 = 0;
pub const EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_NIST_FIELD_MUL: u32 = 0;
pub const EC_F_EC_GFP_NIST_FIELD_SQR: u32 = 0;
pub const EC_F_EC_GFP_NIST_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_FIELD_INV: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_MAKE_AFFINE: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_OCT2POINT: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_POINT2OCT: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES: u32 = 0;
pub const EC_F_EC_GROUP_CHECK: u32 = 0;
pub const EC_F_EC_GROUP_CHECK_DISCRIMINANT: u32 = 0;
pub const EC_F_EC_GROUP_COPY: u32 = 0;
pub const EC_F_EC_GROUP_GET_CURVE: u32 = 0;
pub const EC_F_EC_GROUP_GET_CURVE_GF2M: u32 = 0;
pub const EC_F_EC_GROUP_GET_CURVE_GFP: u32 = 0;
pub const EC_F_EC_GROUP_GET_DEGREE: u32 = 0;
pub const EC_F_EC_GROUP_GET_ECPARAMETERS: u32 = 0;
pub const EC_F_EC_GROUP_GET_ECPKPARAMETERS: u32 = 0;
pub const EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS: u32 = 0;
pub const EC_F_EC_GROUP_GET_TRINOMIAL_BASIS: u32 = 0;
pub const EC_F_EC_GROUP_NEW: u32 = 0;
pub const EC_F_EC_GROUP_NEW_BY_CURVE_NAME: u32 = 0;
pub const EC_F_EC_GROUP_NEW_FROM_DATA: u32 = 0;
pub const EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS: u32 = 0;
pub const EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS: u32 = 0;
pub const EC_F_EC_GROUP_SET_CURVE: u32 = 0;
pub const EC_F_EC_GROUP_SET_CURVE_GF2M: u32 = 0;
pub const EC_F_EC_GROUP_SET_CURVE_GFP: u32 = 0;
pub const EC_F_EC_GROUP_SET_GENERATOR: u32 = 0;
pub const EC_F_EC_GROUP_SET_SEED: u32 = 0;
pub const EC_F_EC_KEY_CHECK_KEY: u32 = 0;
pub const EC_F_EC_KEY_COPY: u32 = 0;
pub const EC_F_EC_KEY_GENERATE_KEY: u32 = 0;
pub const EC_F_EC_KEY_NEW: u32 = 0;
pub const EC_F_EC_KEY_NEW_METHOD: u32 = 0;
pub const EC_F_EC_KEY_OCT2PRIV: u32 = 0;
pub const EC_F_EC_KEY_PRINT: u32 = 0;
pub const EC_F_EC_KEY_PRINT_FP: u32 = 0;
pub const EC_F_EC_KEY_PRIV2BUF: u32 = 0;
pub const EC_F_EC_KEY_PRIV2OCT: u32 = 0;
pub const EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_KEY_SIMPLE_CHECK_KEY: u32 = 0;
pub const EC_F_EC_KEY_SIMPLE_OCT2PRIV: u32 = 0;
pub const EC_F_EC_KEY_SIMPLE_PRIV2OCT: u32 = 0;
pub const EC_F_EC_PKEY_CHECK: u32 = 0;
pub const EC_F_EC_PKEY_PARAM_CHECK: u32 = 0;
pub const EC_F_EC_POINTS_MAKE_AFFINE: u32 = 0;
pub const EC_F_EC_POINTS_MUL: u32 = 0;
pub const EC_F_EC_POINT_ADD: u32 = 0;
pub const EC_F_EC_POINT_BN2POINT: u32 = 0;
pub const EC_F_EC_POINT_CMP: u32 = 0;
pub const EC_F_EC_POINT_COPY: u32 = 0;
pub const EC_F_EC_POINT_DBL: u32 = 0;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M: u32 = 0;
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP: u32 = 0;
pub const EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP: u32 = 0;
pub const EC_F_EC_POINT_INVERT: u32 = 0;
pub const EC_F_EC_POINT_IS_AT_INFINITY: u32 = 0;
pub const EC_F_EC_POINT_IS_ON_CURVE: u32 = 0;
pub const EC_F_EC_POINT_MAKE_AFFINE: u32 = 0;
pub const EC_F_EC_POINT_NEW: u32 = 0;
pub const EC_F_EC_POINT_OCT2POINT: u32 = 0;
pub const EC_F_EC_POINT_POINT2BUF: u32 = 0;
pub const EC_F_EC_POINT_POINT2OCT: u32 = 0;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES: u32 = 0;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M: u32 = 0;
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP: u32 = 0;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES: u32 = 0;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M: u32 = 0;
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP: u32 = 0;
pub const EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP: u32 = 0;
pub const EC_F_EC_POINT_SET_TO_INFINITY: u32 = 0;
pub const EC_F_EC_PRE_COMP_NEW: u32 = 0;
pub const EC_F_EC_SCALAR_MUL_LADDER: u32 = 0;
pub const EC_F_EC_WNAF_MUL: u32 = 0;
pub const EC_F_EC_WNAF_PRECOMPUTE_MULT: u32 = 0;
pub const EC_F_I2D_ECPARAMETERS: u32 = 0;
pub const EC_F_I2D_ECPKPARAMETERS: u32 = 0;
pub const EC_F_I2D_ECPRIVATEKEY: u32 = 0;
pub const EC_F_I2O_ECPUBLICKEY: u32 = 0;
pub const EC_F_NISTP224_PRE_COMP_NEW: u32 = 0;
pub const EC_F_NISTP256_PRE_COMP_NEW: u32 = 0;
pub const EC_F_NISTP521_PRE_COMP_NEW: u32 = 0;
pub const EC_F_O2I_ECPUBLICKEY: u32 = 0;
pub const EC_F_OLD_EC_PRIV_DECODE: u32 = 0;
pub const EC_F_OSSL_ECDH_COMPUTE_KEY: u32 = 0;
pub const EC_F_OSSL_ECDSA_SIGN_SIG: u32 = 0;
pub const EC_F_OSSL_ECDSA_VERIFY_SIG: u32 = 0;
pub const EC_F_PKEY_ECD_CTRL: u32 = 0;
pub const EC_F_PKEY_ECD_DIGESTSIGN: u32 = 0;
pub const EC_F_PKEY_ECD_DIGESTSIGN25519: u32 = 0;
pub const EC_F_PKEY_ECD_DIGESTSIGN448: u32 = 0;
pub const EC_F_PKEY_ECX_DERIVE: u32 = 0;
pub const EC_F_PKEY_EC_CTRL: u32 = 0;
pub const EC_F_PKEY_EC_CTRL_STR: u32 = 0;
pub const EC_F_PKEY_EC_DERIVE: u32 = 0;
pub const EC_F_PKEY_EC_INIT: u32 = 0;
pub const EC_F_PKEY_EC_KDF_DERIVE: u32 = 0;
pub const EC_F_PKEY_EC_KEYGEN: u32 = 0;
pub const EC_F_PKEY_EC_PARAMGEN: u32 = 0;
pub const EC_F_PKEY_EC_SIGN: u32 = 0;
pub const EC_F_VALIDATE_ECX_DERIVE: u32 = 0;
pub const ENGINE_F_DIGEST_UPDATE: u32 = 0;
pub const ENGINE_F_DYNAMIC_CTRL: u32 = 0;
pub const ENGINE_F_DYNAMIC_GET_DATA_CTX: u32 = 0;
pub const ENGINE_F_DYNAMIC_LOAD: u32 = 0;
pub const ENGINE_F_DYNAMIC_SET_DATA_CTX: u32 = 0;
pub const ENGINE_F_ENGINE_ADD: u32 = 0;
pub const ENGINE_F_ENGINE_BY_ID: u32 = 0;
pub const ENGINE_F_ENGINE_CMD_IS_EXECUTABLE: u32 = 0;
pub const ENGINE_F_ENGINE_CTRL: u32 = 0;
pub const ENGINE_F_ENGINE_CTRL_CMD: u32 = 0;
pub const ENGINE_F_ENGINE_CTRL_CMD_STRING: u32 = 0;
pub const ENGINE_F_ENGINE_FINISH: u32 = 0;
pub const ENGINE_F_ENGINE_GET_CIPHER: u32 = 0;
pub const ENGINE_F_ENGINE_GET_DIGEST: u32 = 0;
pub const ENGINE_F_ENGINE_GET_FIRST: u32 = 0;
pub const ENGINE_F_ENGINE_GET_LAST: u32 = 0;
pub const ENGINE_F_ENGINE_GET_NEXT: u32 = 0;
pub const ENGINE_F_ENGINE_GET_PKEY_ASN1_METH: u32 = 0;
pub const ENGINE_F_ENGINE_GET_PKEY_METH: u32 = 0;
pub const ENGINE_F_ENGINE_GET_PREV: u32 = 0;
pub const ENGINE_F_ENGINE_INIT: u32 = 0;
pub const ENGINE_F_ENGINE_LIST_ADD: u32 = 0;
pub const ENGINE_F_ENGINE_LIST_REMOVE: u32 = 0;
pub const ENGINE_F_ENGINE_LOAD_PRIVATE_KEY: u32 = 0;
pub const ENGINE_F_ENGINE_LOAD_PUBLIC_KEY: u32 = 0;
pub const ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT: u32 = 0;
pub const ENGINE_F_ENGINE_NEW: u32 = 0;
pub const ENGINE_F_ENGINE_PKEY_ASN1_FIND_STR: u32 = 0;
pub const ENGINE_F_ENGINE_REMOVE: u32 = 0;
pub const ENGINE_F_ENGINE_SET_DEFAULT_STRING: u32 = 0;
pub const ENGINE_F_ENGINE_SET_ID: u32 = 0;
pub const ENGINE_F_ENGINE_SET_NAME: u32 = 0;
pub const ENGINE_F_ENGINE_TABLE_REGISTER: u32 = 0;
pub const ENGINE_F_ENGINE_UNLOCKED_FINISH: u32 = 0;
pub const ENGINE_F_ENGINE_UP_REF: u32 = 0;
pub const ENGINE_F_INT_CLEANUP_ITEM: u32 = 0;
pub const ENGINE_F_INT_CTRL_HELPER: u32 = 0;
pub const ENGINE_F_INT_ENGINE_CONFIGURE: u32 = 0;
pub const ENGINE_F_INT_ENGINE_MODULE_INIT: u32 = 0;
pub const ENGINE_F_OSSL_HMAC_INIT: u32 = 0;
pub const EVP_F_AESNI_INIT_KEY: u32 = 0;
pub const EVP_F_AESNI_XTS_INIT_KEY: u32 = 0;
pub const EVP_F_AES_GCM_CTRL: u32 = 0;
pub const EVP_F_AES_INIT_KEY: u32 = 0;
pub const EVP_F_AES_OCB_CIPHER: u32 = 0;
pub const EVP_F_AES_T4_INIT_KEY: u32 = 0;
pub const EVP_F_AES_T4_XTS_INIT_KEY: u32 = 0;
pub const EVP_F_AES_WRAP_CIPHER: u32 = 0;
pub const EVP_F_AES_XTS_INIT_KEY: u32 = 0;
pub const EVP_F_ALG_MODULE_INIT: u32 = 0;
pub const EVP_F_ARIA_CCM_INIT_KEY: u32 = 0;
pub const EVP_F_ARIA_GCM_CTRL: u32 = 0;
pub const EVP_F_ARIA_GCM_INIT_KEY: u32 = 0;
pub const EVP_F_ARIA_INIT_KEY: u32 = 0;
pub const EVP_F_B64_NEW: u32 = 0;
pub const EVP_F_CAMELLIA_INIT_KEY: u32 = 0;
pub const EVP_F_CHACHA20_POLY1305_CTRL: u32 = 0;
pub const EVP_F_CMLL_T4_INIT_KEY: u32 = 0;
pub const EVP_F_DES_EDE3_WRAP_CIPHER: u32 = 0;
pub const EVP_F_DO_SIGVER_INIT: u32 = 0;
pub const EVP_F_ENC_NEW: u32 = 0;
pub const EVP_F_EVP_CIPHERINIT_EX: u32 = 0;
pub const EVP_F_EVP_CIPHER_ASN1_TO_PARAM: u32 = 0;
pub const EVP_F_EVP_CIPHER_CTX_COPY: u32 = 0;
pub const EVP_F_EVP_CIPHER_CTX_CTRL: u32 = 0;
pub const EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH: u32 = 0;
pub const EVP_F_EVP_CIPHER_PARAM_TO_ASN1: u32 = 0;
pub const EVP_F_EVP_DECRYPTFINAL_EX: u32 = 0;
pub const EVP_F_EVP_DECRYPTUPDATE: u32 = 0;
pub const EVP_F_EVP_DIGESTFINALXOF: u32 = 0;
pub const EVP_F_EVP_DIGESTINIT_EX: u32 = 0;
pub const EVP_F_EVP_ENCRYPTDECRYPTUPDATE: u32 = 0;
pub const EVP_F_EVP_ENCRYPTFINAL_EX: u32 = 0;
pub const EVP_F_EVP_ENCRYPTUPDATE: u32 = 0;
pub const EVP_F_EVP_MD_CTX_COPY_EX: u32 = 0;
pub const EVP_F_EVP_MD_SIZE: u32 = 0;
pub const EVP_F_EVP_OPENINIT: u32 = 0;
pub const EVP_F_EVP_PBE_ALG_ADD: u32 = 0;
pub const EVP_F_EVP_PBE_ALG_ADD_TYPE: u32 = 0;
pub const EVP_F_EVP_PBE_CIPHERINIT: u32 = 0;
pub const EVP_F_EVP_PBE_SCRYPT: u32 = 0;
pub const EVP_F_EVP_PKCS82PKEY: u32 = 0;
pub const EVP_F_EVP_PKEY2PKCS8: u32 = 0;
pub const EVP_F_EVP_PKEY_ASN1_ADD0: u32 = 0;
pub const EVP_F_EVP_PKEY_CHECK: u32 = 0;
pub const EVP_F_EVP_PKEY_COPY_PARAMETERS: u32 = 0;
pub const EVP_F_EVP_PKEY_CTX_CTRL: u32 = 0;
pub const EVP_F_EVP_PKEY_CTX_CTRL_STR: u32 = 0;
pub const EVP_F_EVP_PKEY_CTX_DUP: u32 = 0;
pub const EVP_F_EVP_PKEY_CTX_MD: u32 = 0;
pub const EVP_F_EVP_PKEY_DECRYPT: u32 = 0;
pub const EVP_F_EVP_PKEY_DECRYPT_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_DECRYPT_OLD: u32 = 0;
pub const EVP_F_EVP_PKEY_DERIVE: u32 = 0;
pub const EVP_F_EVP_PKEY_DERIVE_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_DERIVE_SET_PEER: u32 = 0;
pub const EVP_F_EVP_PKEY_ENCRYPT: u32 = 0;
pub const EVP_F_EVP_PKEY_ENCRYPT_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_ENCRYPT_OLD: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_DH: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_DSA: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_EC_KEY: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_HMAC: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_POLY1305: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_RSA: u32 = 0;
pub const EVP_F_EVP_PKEY_GET0_SIPHASH: u32 = 0;
pub const EVP_F_EVP_PKEY_GET_RAW_PRIVATE_KEY: u32 = 0;
pub const EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY: u32 = 0;
pub const EVP_F_EVP_PKEY_KEYGEN: u32 = 0;
pub const EVP_F_EVP_PKEY_KEYGEN_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_METH_ADD0: u32 = 0;
pub const EVP_F_EVP_PKEY_METH_NEW: u32 = 0;
pub const EVP_F_EVP_PKEY_NEW: u32 = 0;
pub const EVP_F_EVP_PKEY_NEW_CMAC_KEY: u32 = 0;
pub const EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY: u32 = 0;
pub const EVP_F_EVP_PKEY_NEW_RAW_PUBLIC_KEY: u32 = 0;
pub const EVP_F_EVP_PKEY_PARAMGEN: u32 = 0;
pub const EVP_F_EVP_PKEY_PARAMGEN_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_PARAM_CHECK: u32 = 0;
pub const EVP_F_EVP_PKEY_PUBLIC_CHECK: u32 = 0;
pub const EVP_F_EVP_PKEY_SET1_ENGINE: u32 = 0;
pub const EVP_F_EVP_PKEY_SET_ALIAS_TYPE: u32 = 0;
pub const EVP_F_EVP_PKEY_SIGN: u32 = 0;
pub const EVP_F_EVP_PKEY_SIGN_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_VERIFY: u32 = 0;
pub const EVP_F_EVP_PKEY_VERIFY_INIT: u32 = 0;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER: u32 = 0;
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT: u32 = 0;
pub const EVP_F_EVP_SIGNFINAL: u32 = 0;
pub const EVP_F_EVP_VERIFYFINAL: u32 = 0;
pub const EVP_F_INT_CTX_NEW: u32 = 0;
pub const EVP_F_OK_NEW: u32 = 0;
pub const EVP_F_PKCS5_PBE_KEYIVGEN: u32 = 0;
pub const EVP_F_PKCS5_V2_PBE_KEYIVGEN: u32 = 0;
pub const EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN: u32 = 0;
pub const EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN: u32 = 0;
pub const EVP_F_PKEY_SET_TYPE: u32 = 0;
pub const EVP_F_RC2_MAGIC_TO_METH: u32 = 0;
pub const EVP_F_RC5_CTRL: u32 = 0;
pub const EVP_F_R_32_12_16_INIT_KEY: u32 = 0;
pub const EVP_F_S390X_AES_GCM_CTRL: u32 = 0;
pub const EVP_F_UPDATE: u32 = 0;
pub const KDF_F_PKEY_HKDF_CTRL_STR: u32 = 0;
pub const KDF_F_PKEY_HKDF_DERIVE: u32 = 0;
pub const KDF_F_PKEY_HKDF_INIT: u32 = 0;
pub const KDF_F_PKEY_SCRYPT_CTRL_STR: u32 = 0;
pub const KDF_F_PKEY_SCRYPT_CTRL_UINT64: u32 = 0;
pub const KDF_F_PKEY_SCRYPT_DERIVE: u32 = 0;
pub const KDF_F_PKEY_SCRYPT_INIT: u32 = 0;
pub const KDF_F_PKEY_SCRYPT_SET_MEMBUF: u32 = 0;
pub const KDF_F_PKEY_TLS1_PRF_CTRL_STR: u32 = 0;
pub const KDF_F_PKEY_TLS1_PRF_DERIVE: u32 = 0;
pub const KDF_F_PKEY_TLS1_PRF_INIT: u32 = 0;
pub const KDF_F_TLS1_PRF_ALG: u32 = 0;
pub const KDF_R_INVALID_DIGEST: u32 = 0;
pub const KDF_R_MISSING_ITERATION_COUNT: u32 = 0;
pub const KDF_R_MISSING_KEY: u32 = 0;
pub const KDF_R_MISSING_MESSAGE_DIGEST: u32 = 0;
pub const KDF_R_MISSING_PARAMETER: u32 = 0;
pub const KDF_R_MISSING_PASS: u32 = 0;
pub const KDF_R_MISSING_SALT: u32 = 0;
pub const KDF_R_MISSING_SECRET: u32 = 0;
pub const KDF_R_MISSING_SEED: u32 = 0;
pub const KDF_R_UNKNOWN_PARAMETER_TYPE: u32 = 0;
pub const KDF_R_VALUE_ERROR: u32 = 0;
pub const KDF_R_VALUE_MISSING: u32 = 0;
pub const OBJ_F_OBJ_ADD_OBJECT: u32 = 0;
pub const OBJ_F_OBJ_ADD_SIGID: u32 = 0;
pub const OBJ_F_OBJ_CREATE: u32 = 0;
pub const OBJ_F_OBJ_DUP: u32 = 0;
pub const OBJ_F_OBJ_NAME_NEW_INDEX: u32 = 0;
pub const OBJ_F_OBJ_NID2LN: u32 = 0;
pub const OBJ_F_OBJ_NID2OBJ: u32 = 0;
pub const OBJ_F_OBJ_NID2SN: u32 = 0;
pub const OBJ_F_OBJ_TXT2OBJ: u32 = 0;
pub const OCSP_F_D2I_OCSP_NONCE: u32 = 0;
pub const OCSP_F_OCSP_BASIC_ADD1_STATUS: u32 = 0;
pub const OCSP_F_OCSP_BASIC_SIGN: u32 = 0;
pub const OCSP_F_OCSP_BASIC_SIGN_CTX: u32 = 0;
pub const OCSP_F_OCSP_BASIC_VERIFY: u32 = 0;
pub const OCSP_F_OCSP_CERT_ID_NEW: u32 = 0;
pub const OCSP_F_OCSP_CHECK_DELEGATED: u32 = 0;
pub const OCSP_F_OCSP_CHECK_IDS: u32 = 0;
pub const OCSP_F_OCSP_CHECK_ISSUER: u32 = 0;
pub const OCSP_F_OCSP_CHECK_VALIDITY: u32 = 0;
pub const OCSP_F_OCSP_MATCH_ISSUERID: u32 = 0;
pub const OCSP_F_OCSP_PARSE_URL: u32 = 0;
pub const OCSP_F_OCSP_REQUEST_SIGN: u32 = 0;
pub const OCSP_F_OCSP_REQUEST_VERIFY: u32 = 0;
pub const OCSP_F_OCSP_RESPONSE_GET1_BASIC: u32 = 0;
pub const OCSP_F_PARSE_HTTP_LINE1: u32 = 0;
pub const PEM_F_B2I_DSS: u32 = 0;
pub const PEM_F_B2I_PVK_BIO: u32 = 0;
pub const PEM_F_B2I_RSA: u32 = 0;
pub const PEM_F_CHECK_BITLEN_DSA: u32 = 0;
pub const PEM_F_CHECK_BITLEN_RSA: u32 = 0;
pub const PEM_F_D2I_PKCS8PRIVATEKEY_BIO: u32 = 0;
pub const PEM_F_D2I_PKCS8PRIVATEKEY_FP: u32 = 0;
pub const PEM_F_DO_B2I: u32 = 0;
pub const PEM_F_DO_B2I_BIO: u32 = 0;
pub const PEM_F_DO_BLOB_HEADER: u32 = 0;
pub const PEM_F_DO_I2B: u32 = 0;
pub const PEM_F_DO_PK8PKEY: u32 = 0;
pub const PEM_F_DO_PK8PKEY_FP: u32 = 0;
pub const PEM_F_DO_PVK_BODY: u32 = 0;
pub const PEM_F_DO_PVK_HEADER: u32 = 0;
pub const PEM_F_GET_HEADER_AND_DATA: u32 = 0;
pub const PEM_F_GET_NAME: u32 = 0;
pub const PEM_F_I2B_PVK: u32 = 0;
pub const PEM_F_I2B_PVK_BIO: u32 = 0;
pub const PEM_F_LOAD_IV: u32 = 0;
pub const PEM_F_PEM_ASN1_READ: u32 = 0;
pub const PEM_F_PEM_ASN1_READ_BIO: u32 = 0;
pub const PEM_F_PEM_ASN1_WRITE: u32 = 0;
pub const PEM_F_PEM_ASN1_WRITE_BIO: u32 = 0;
pub const PEM_F_PEM_DEF_CALLBACK: u32 = 0;
pub const PEM_F_PEM_DO_HEADER: u32 = 0;
pub const PEM_F_PEM_GET_EVP_CIPHER_INFO: u32 = 0;
pub const PEM_F_PEM_READ: u32 = 0;
pub const PEM_F_PEM_READ_BIO: u32 = 0;
pub const PEM_F_PEM_READ_BIO_DHPARAMS: u32 = 0;
pub const PEM_F_PEM_READ_BIO_EX: u32 = 0;
pub const PEM_F_PEM_READ_BIO_PARAMETERS: u32 = 0;
pub const PEM_F_PEM_READ_BIO_PRIVATEKEY: u32 = 0;
pub const PEM_F_PEM_READ_DHPARAMS: u32 = 0;
pub const PEM_F_PEM_READ_PRIVATEKEY: u32 = 0;
pub const PEM_F_PEM_SIGNFINAL: u32 = 0;
pub const PEM_F_PEM_WRITE: u32 = 0;
pub const PEM_F_PEM_WRITE_BIO: u32 = 0;
pub const PEM_F_PEM_WRITE_BIO_PRIVATEKEY_TRADITIONAL: u32 = 0;
pub const PEM_F_PEM_WRITE_PRIVATEKEY: u32 = 0;
pub const PEM_F_PEM_X509_INFO_READ: u32 = 0;
pub const PEM_F_PEM_X509_INFO_READ_BIO: u32 = 0;
pub const PEM_F_PEM_X509_INFO_WRITE_BIO: u32 = 0;
pub const PKCS12_F_OPENSSL_ASC2UNI: u32 = 0;
pub const PKCS12_F_OPENSSL_UNI2ASC: u32 = 0;
pub const PKCS12_F_OPENSSL_UNI2UTF8: u32 = 0;
pub const PKCS12_F_OPENSSL_UTF82UNI: u32 = 0;
pub const PKCS12_F_PKCS12_CREATE: u32 = 0;
pub const PKCS12_F_PKCS12_GEN_MAC: u32 = 0;
pub const PKCS12_F_PKCS12_INIT: u32 = 0;
pub const PKCS12_F_PKCS12_ITEM_DECRYPT_D2I: u32 = 0;
pub const PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT: u32 = 0;
pub const PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG: u32 = 0;
pub const PKCS12_F_PKCS12_KEY_GEN_ASC: u32 = 0;
pub const PKCS12_F_PKCS12_KEY_GEN_UNI: u32 = 0;
pub const PKCS12_F_PKCS12_KEY_GEN_UTF8: u32 = 0;
pub const PKCS12_F_PKCS12_NEWPASS: u32 = 0;
pub const PKCS12_F_PKCS12_PACK_P7DATA: u32 = 0;
pub const PKCS12_F_PKCS12_PACK_P7ENCDATA: u32 = 0;
pub const PKCS12_F_PKCS12_PARSE: u32 = 0;
pub const PKCS12_F_PKCS12_PBE_CRYPT: u32 = 0;
pub const PKCS12_F_PKCS12_PBE_KEYIVGEN: u32 = 0;
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE0_P8INF: u32 = 0;
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE0_PKCS8: u32 = 0;
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE_PKCS8_ENCRYPT: u32 = 0;
pub const PKCS12_F_PKCS12_SETUP_MAC: u32 = 0;
pub const PKCS12_F_PKCS12_SET_MAC: u32 = 0;
pub const PKCS12_F_PKCS12_UNPACK_AUTHSAFES: u32 = 0;
pub const PKCS12_F_PKCS12_UNPACK_P7DATA: u32 = 0;
pub const PKCS12_F_PKCS12_VERIFY_MAC: u32 = 0;
pub const PKCS12_F_PKCS8_ENCRYPT: u32 = 0;
pub const PKCS12_F_PKCS8_SET0_PBE: u32 = 0;
pub const PKCS7_F_DO_PKCS7_SIGNED_ATTRIB: u32 = 0;
pub const PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME: u32 = 0;
pub const PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP: u32 = 0;
pub const PKCS7_F_PKCS7_ADD_CERTIFICATE: u32 = 0;
pub const PKCS7_F_PKCS7_ADD_CRL: u32 = 0;
pub const PKCS7_F_PKCS7_ADD_RECIPIENT_INFO: u32 = 0;
pub const PKCS7_F_PKCS7_ADD_SIGNATURE: u32 = 0;
pub const PKCS7_F_PKCS7_ADD_SIGNER: u32 = 0;
pub const PKCS7_F_PKCS7_BIO_ADD_DIGEST: u32 = 0;
pub const PKCS7_F_PKCS7_COPY_EXISTING_DIGEST: u32 = 0;
pub const PKCS7_F_PKCS7_CTRL: u32 = 0;
pub const PKCS7_F_PKCS7_DATADECODE: u32 = 0;
pub const PKCS7_F_PKCS7_DATAFINAL: u32 = 0;
pub const PKCS7_F_PKCS7_DATAINIT: u32 = 0;
pub const PKCS7_F_PKCS7_DATAVERIFY: u32 = 0;
pub const PKCS7_F_PKCS7_DECRYPT: u32 = 0;
pub const PKCS7_F_PKCS7_DECRYPT_RINFO: u32 = 0;
pub const PKCS7_F_PKCS7_ENCODE_RINFO: u32 = 0;
pub const PKCS7_F_PKCS7_ENCRYPT: u32 = 0;
pub const PKCS7_F_PKCS7_FINAL: u32 = 0;
pub const PKCS7_F_PKCS7_FIND_DIGEST: u32 = 0;
pub const PKCS7_F_PKCS7_GET0_SIGNERS: u32 = 0;
pub const PKCS7_F_PKCS7_RECIP_INFO_SET: u32 = 0;
pub const PKCS7_F_PKCS7_SET_CIPHER: u32 = 0;
pub const PKCS7_F_PKCS7_SET_CONTENT: u32 = 0;
pub const PKCS7_F_PKCS7_SET_DIGEST: u32 = 0;
pub const PKCS7_F_PKCS7_SET_TYPE: u32 = 0;
pub const PKCS7_F_PKCS7_SIGN: u32 = 0;
pub const PKCS7_F_PKCS7_SIGNATUREVERIFY: u32 = 0;
pub const PKCS7_F_PKCS7_SIGNER_INFO_SET: u32 = 0;
pub const PKCS7_F_PKCS7_SIGNER_INFO_SIGN: u32 = 0;
pub const PKCS7_F_PKCS7_SIGN_ADD_SIGNER: u32 = 0;
pub const PKCS7_F_PKCS7_SIMPLE_SMIMECAP: u32 = 0;
pub const PKCS7_F_PKCS7_VERIFY: u32 = 0;
pub const RAND_F_DATA_COLLECT_METHOD: u32 = 0;
pub const RAND_F_DRBG_BYTES: u32 = 0;
pub const RAND_F_DRBG_GET_ENTROPY: u32 = 0;
pub const RAND_F_DRBG_SETUP: u32 = 0;
pub const RAND_F_GET_ENTROPY: u32 = 0;
pub const RAND_F_RAND_BYTES: u32 = 0;
pub const RAND_F_RAND_DRBG_ENABLE_LOCKING: u32 = 0;
pub const RAND_F_RAND_DRBG_GENERATE: u32 = 0;
pub const RAND_F_RAND_DRBG_GET_ENTROPY: u32 = 0;
pub const RAND_F_RAND_DRBG_GET_NONCE: u32 = 0;
pub const RAND_F_RAND_DRBG_INSTANTIATE: u32 = 0;
pub const RAND_F_RAND_DRBG_NEW: u32 = 0;
pub const RAND_F_RAND_DRBG_RESEED: u32 = 0;
pub const RAND_F_RAND_DRBG_RESTART: u32 = 0;
pub const RAND_F_RAND_DRBG_SET: u32 = 0;
pub const RAND_F_RAND_DRBG_SET_DEFAULTS: u32 = 0;
pub const RAND_F_RAND_DRBG_UNINSTANTIATE: u32 = 0;
pub const RAND_F_RAND_LOAD_FILE: u32 = 0;
pub const RAND_F_RAND_POOL_ACQUIRE_ENTROPY: u32 = 0;
pub const RAND_F_RAND_POOL_ADD: u32 = 0;
pub const RAND_F_RAND_POOL_ADD_BEGIN: u32 = 0;
pub const RAND_F_RAND_POOL_ADD_END: u32 = 0;
pub const RAND_F_RAND_POOL_ATTACH: u32 = 0;
pub const RAND_F_RAND_POOL_BYTES_NEEDED: u32 = 0;
pub const RAND_F_RAND_POOL_GROW: u32 = 0;
pub const RAND_F_RAND_POOL_NEW: u32 = 0;
pub const RAND_F_RAND_PSEUDO_BYTES: u32 = 0;
pub const RAND_F_RAND_WRITE_FILE: u32 = 0;
pub const RSA_F_CHECK_PADDING_MD: u32 = 0;
pub const RSA_F_ENCODE_PKCS1: u32 = 0;
pub const RSA_F_INT_RSA_VERIFY: u32 = 0;
pub const RSA_F_OLD_RSA_PRIV_DECODE: u32 = 0;
pub const RSA_F_PKEY_PSS_INIT: u32 = 0;
pub const RSA_F_PKEY_RSA_CTRL: u32 = 0;
pub const RSA_F_PKEY_RSA_CTRL_STR: u32 = 0;
pub const RSA_F_PKEY_RSA_SIGN: u32 = 0;
pub const RSA_F_PKEY_RSA_VERIFY: u32 = 0;
pub const RSA_F_PKEY_RSA_VERIFYRECOVER: u32 = 0;
pub const RSA_F_RSA_ALGOR_TO_MD: u32 = 0;
pub const RSA_F_RSA_BUILTIN_KEYGEN: u32 = 0;
pub const RSA_F_RSA_CHECK_KEY: u32 = 0;
pub const RSA_F_RSA_CHECK_KEY_EX: u32 = 0;
pub const RSA_F_RSA_CMS_DECRYPT: u32 = 0;
pub const RSA_F_RSA_CMS_VERIFY: u32 = 0;
pub const RSA_F_RSA_ITEM_VERIFY: u32 = 0;
pub const RSA_F_RSA_METH_DUP: u32 = 0;
pub const RSA_F_RSA_METH_NEW: u32 = 0;
pub const RSA_F_RSA_METH_SET1_NAME: u32 = 0;
pub const RSA_F_RSA_MGF1_TO_MD: u32 = 0;
pub const RSA_F_RSA_MULTIP_INFO_NEW: u32 = 0;
pub const RSA_F_RSA_NEW_METHOD: u32 = 0;
pub const RSA_F_RSA_NULL: u32 = 0;
pub const RSA_F_RSA_NULL_PRIVATE_DECRYPT: u32 = 0;
pub const RSA_F_RSA_NULL_PRIVATE_ENCRYPT: u32 = 0;
pub const RSA_F_RSA_NULL_PUBLIC_DECRYPT: u32 = 0;
pub const RSA_F_RSA_NULL_PUBLIC_ENCRYPT: u32 = 0;
pub const RSA_F_RSA_OSSL_PRIVATE_DECRYPT: u32 = 0;
pub const RSA_F_RSA_OSSL_PRIVATE_ENCRYPT: u32 = 0;
pub const RSA_F_RSA_OSSL_PUBLIC_DECRYPT: u32 = 0;
pub const RSA_F_RSA_OSSL_PUBLIC_ENCRYPT: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_NONE: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_SSLV23: u32 = 0;
pub const RSA_F_RSA_PADDING_ADD_X931: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_NONE: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_SSLV23: u32 = 0;
pub const RSA_F_RSA_PADDING_CHECK_X931: u32 = 0;
pub const RSA_F_RSA_PARAM_DECODE: u32 = 0;
pub const RSA_F_RSA_PRINT: u32 = 0;
pub const RSA_F_RSA_PRINT_FP: u32 = 0;
pub const RSA_F_RSA_PRIV_DECODE: u32 = 0;
pub const RSA_F_RSA_PRIV_ENCODE: u32 = 0;
pub const RSA_F_RSA_PSS_GET_PARAM: u32 = 0;
pub const RSA_F_RSA_PSS_TO_CTX: u32 = 0;
pub const RSA_F_RSA_PUB_DECODE: u32 = 0;
pub const RSA_F_RSA_SETUP_BLINDING: u32 = 0;
pub const RSA_F_RSA_SIGN: u32 = 0;
pub const RSA_F_RSA_SIGN_ASN1_OCTET_STRING: u32 = 0;
pub const RSA_F_RSA_VERIFY: u32 = 0;
pub const RSA_F_RSA_VERIFY_ASN1_OCTET_STRING: u32 = 0;
pub const RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1: u32 = 0;
pub const RSA_F_SETUP_TBUF: u32 = 0;
pub const OSSL_STORE_F_FILE_CTRL: u32 = 0;
pub const OSSL_STORE_F_FILE_FIND: u32 = 0;
pub const OSSL_STORE_F_FILE_GET_PASS: u32 = 0;
pub const OSSL_STORE_F_FILE_LOAD: u32 = 0;
pub const OSSL_STORE_F_FILE_LOAD_TRY_DECODE: u32 = 0;
pub const OSSL_STORE_F_FILE_NAME_TO_URI: u32 = 0;
pub const OSSL_STORE_F_FILE_OPEN: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_ATTACH_PEM_BIO: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_EXPECT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_FILE_ATTACH_PEM_BIO_INT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_FIND: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_INIT_ONCE: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_LOADER_NEW: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_OPEN: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_OPEN_INT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_ALIAS: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_ISSUER_SERIAL: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_KEY_FINGERPRINT: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_NAME: u32 = 0;
pub const OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT: u32 = 0;
pub const OSSL_STORE_F_TRY_DECODE_PARAMS: u32 = 0;
pub const OSSL_STORE_F_TRY_DECODE_PKCS12: u32 = 0;
pub const OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED: u32 = 0;
pub const TS_F_DEF_SERIAL_CB: u32 = 0;
pub const TS_F_DEF_TIME_CB: u32 = 0;
pub const TS_F_ESS_ADD_SIGNING_CERT: u32 = 0;
pub const TS_F_ESS_ADD_SIGNING_CERT_V2: u32 = 0;
pub const TS_F_ESS_CERT_ID_NEW_INIT: u32 = 0;
pub const TS_F_ESS_CERT_ID_V2_NEW_INIT: u32 = 0;
pub const TS_F_ESS_SIGNING_CERT_NEW_INIT: u32 = 0;
pub const TS_F_ESS_SIGNING_CERT_V2_NEW_INIT: u32 = 0;
pub const TS_F_INT_TS_RESP_VERIFY_TOKEN: u32 = 0;
pub const TS_F_PKCS7_TO_TS_TST_INFO: u32 = 0;
pub const TS_F_TS_ACCURACY_SET_MICROS: u32 = 0;
pub const TS_F_TS_ACCURACY_SET_MILLIS: u32 = 0;
pub const TS_F_TS_ACCURACY_SET_SECONDS: u32 = 0;
pub const TS_F_TS_CHECK_IMPRINTS: u32 = 0;
pub const TS_F_TS_CHECK_NONCES: u32 = 0;
pub const TS_F_TS_CHECK_POLICY: u32 = 0;
pub const TS_F_TS_CHECK_SIGNING_CERTS: u32 = 0;
pub const TS_F_TS_CHECK_STATUS_INFO: u32 = 0;
pub const TS_F_TS_COMPUTE_IMPRINT: u32 = 0;
pub const TS_F_TS_CONF_INVALID: u32 = 0;
pub const TS_F_TS_CONF_LOAD_CERT: u32 = 0;
pub const TS_F_TS_CONF_LOAD_CERTS: u32 = 0;
pub const TS_F_TS_CONF_LOAD_KEY: u32 = 0;
pub const TS_F_TS_CONF_LOOKUP_FAIL: u32 = 0;
pub const TS_F_TS_CONF_SET_DEFAULT_ENGINE: u32 = 0;
pub const TS_F_TS_GET_STATUS_TEXT: u32 = 0;
pub const TS_F_TS_MSG_IMPRINT_SET_ALGO: u32 = 0;
pub const TS_F_TS_REQ_SET_MSG_IMPRINT: u32 = 0;
pub const TS_F_TS_REQ_SET_NONCE: u32 = 0;
pub const TS_F_TS_REQ_SET_POLICY_ID: u32 = 0;
pub const TS_F_TS_RESP_CREATE_RESPONSE: u32 = 0;
pub const TS_F_TS_RESP_CREATE_TST_INFO: u32 = 0;
pub const TS_F_TS_RESP_CTX_ADD_FAILURE_INFO: u32 = 0;
pub const TS_F_TS_RESP_CTX_ADD_MD: u32 = 0;
pub const TS_F_TS_RESP_CTX_ADD_POLICY: u32 = 0;
pub const TS_F_TS_RESP_CTX_NEW: u32 = 0;
pub const TS_F_TS_RESP_CTX_SET_ACCURACY: u32 = 0;
pub const TS_F_TS_RESP_CTX_SET_CERTS: u32 = 0;
pub const TS_F_TS_RESP_CTX_SET_DEF_POLICY: u32 = 0;
pub const TS_F_TS_RESP_CTX_SET_SIGNER_CERT: u32 = 0;
pub const TS_F_TS_RESP_CTX_SET_STATUS_INFO: u32 = 0;
pub const TS_F_TS_RESP_GET_POLICY: u32 = 0;
pub const TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION: u32 = 0;
pub const TS_F_TS_RESP_SET_STATUS_INFO: u32 = 0;
pub const TS_F_TS_RESP_SET_TST_INFO: u32 = 0;
pub const TS_F_TS_RESP_SIGN: u32 = 0;
pub const TS_F_TS_RESP_VERIFY_SIGNATURE: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_ACCURACY: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_MSG_IMPRINT: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_NONCE: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_POLICY_ID: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_SERIAL: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_TIME: u32 = 0;
pub const TS_F_TS_TST_INFO_SET_TSA: u32 = 0;
pub const TS_F_TS_VERIFY: u32 = 0;
pub const TS_F_TS_VERIFY_CERT: u32 = 0;
pub const TS_F_TS_VERIFY_CTX_NEW: u32 = 0;
pub const UI_F_CLOSE_CONSOLE: u32 = 0;
pub const UI_F_ECHO_CONSOLE: u32 = 0;
pub const UI_F_GENERAL_ALLOCATE_BOOLEAN: u32 = 0;
pub const UI_F_GENERAL_ALLOCATE_PROMPT: u32 = 0;
pub const UI_F_NOECHO_CONSOLE: u32 = 0;
pub const UI_F_OPEN_CONSOLE: u32 = 0;
pub const UI_F_UI_CONSTRUCT_PROMPT: u32 = 0;
pub const UI_F_UI_CREATE_METHOD: u32 = 0;
pub const UI_F_UI_CTRL: u32 = 0;
pub const UI_F_UI_DUP_ERROR_STRING: u32 = 0;
pub const UI_F_UI_DUP_INFO_STRING: u32 = 0;
pub const UI_F_UI_DUP_INPUT_BOOLEAN: u32 = 0;
pub const UI_F_UI_DUP_INPUT_STRING: u32 = 0;
pub const UI_F_UI_DUP_USER_DATA: u32 = 0;
pub const UI_F_UI_DUP_VERIFY_STRING: u32 = 0;
pub const UI_F_UI_GET0_RESULT: u32 = 0;
pub const UI_F_UI_GET_RESULT_LENGTH: u32 = 0;
pub const UI_F_UI_NEW_METHOD: u32 = 0;
pub const UI_F_UI_PROCESS: u32 = 0;
pub const UI_F_UI_SET_RESULT: u32 = 0;
pub const UI_F_UI_SET_RESULT_EX: u32 = 0;
pub const X509_F_ADD_CERT_DIR: u32 = 0;
pub const X509_F_BUILD_CHAIN: u32 = 0;
pub const X509_F_BY_FILE_CTRL: u32 = 0;
pub const X509_F_CHECK_NAME_CONSTRAINTS: u32 = 0;
pub const X509_F_CHECK_POLICY: u32 = 0;
pub const X509_F_DANE_I2D: u32 = 0;
pub const X509_F_DIR_CTRL: u32 = 0;
pub const X509_F_GET_CERT_BY_SUBJECT: u32 = 0;
pub const X509_F_I2D_X509_AUX: u32 = 0;
pub const X509_F_LOOKUP_CERTS_SK: u32 = 0;
pub const X509_F_NETSCAPE_SPKI_B64_DECODE: u32 = 0;
pub const X509_F_NETSCAPE_SPKI_B64_ENCODE: u32 = 0;
pub const X509_F_NEW_DIR: u32 = 0;
pub const X509_F_X509AT_ADD1_ATTR: u32 = 0;
pub const X509_F_X509V3_ADD_EXT: u32 = 0;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_NID: u32 = 0;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ: u32 = 0;
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_TXT: u32 = 0;
pub const X509_F_X509_ATTRIBUTE_GET0_DATA: u32 = 0;
pub const X509_F_X509_ATTRIBUTE_SET1_DATA: u32 = 0;
pub const X509_F_X509_CHECK_PRIVATE_KEY: u32 = 0;
pub const X509_F_X509_CRL_DIFF: u32 = 0;
pub const X509_F_X509_CRL_METHOD_NEW: u32 = 0;
pub const X509_F_X509_CRL_PRINT_FP: u32 = 0;
pub const X509_F_X509_EXTENSION_CREATE_BY_NID: u32 = 0;
pub const X509_F_X509_EXTENSION_CREATE_BY_OBJ: u32 = 0;
pub const X509_F_X509_GET_PUBKEY_PARAMETERS: u32 = 0;
pub const X509_F_X509_LOAD_CERT_CRL_FILE: u32 = 0;
pub const X509_F_X509_LOAD_CERT_FILE: u32 = 0;
pub const X509_F_X509_LOAD_CRL_FILE: u32 = 0;
pub const X509_F_X509_LOOKUP_METH_NEW: u32 = 0;
pub const X509_F_X509_LOOKUP_NEW: u32 = 0;
pub const X509_F_X509_NAME_ADD_ENTRY: u32 = 0;
pub const X509_F_X509_NAME_CANON: u32 = 0;
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_NID: u32 = 0;
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_TXT: u32 = 0;
pub const X509_F_X509_NAME_ENTRY_SET_OBJECT: u32 = 0;
pub const X509_F_X509_NAME_ONELINE: u32 = 0;
pub const X509_F_X509_NAME_PRINT: u32 = 0;
pub const X509_F_X509_OBJECT_NEW: u32 = 0;
pub const X509_F_X509_PRINT_EX_FP: u32 = 0;
pub const X509_F_X509_PUBKEY_DECODE: u32 = 0;
pub const X509_F_X509_PUBKEY_GET: u32 = 0;
pub const X509_F_X509_PUBKEY_GET0: u32 = 0;
pub const X509_F_X509_PUBKEY_SET: u32 = 0;
pub const X509_F_X509_REQ_CHECK_PRIVATE_KEY: u32 = 0;
pub const X509_F_X509_REQ_PRINT_EX: u32 = 0;
pub const X509_F_X509_REQ_PRINT_FP: u32 = 0;
pub const X509_F_X509_REQ_TO_X509: u32 = 0;
pub const X509_F_X509_STORE_ADD_CERT: u32 = 0;
pub const X509_F_X509_STORE_ADD_CRL: u32 = 0;
pub const X509_F_X509_STORE_ADD_LOOKUP: u32 = 0;
pub const X509_F_X509_STORE_CTX_GET1_ISSUER: u32 = 0;
pub const X509_F_X509_STORE_CTX_INIT: u32 = 0;
pub const X509_F_X509_STORE_CTX_NEW: u32 = 0;
pub const X509_F_X509_STORE_CTX_PURPOSE_INHERIT: u32 = 0;
pub const X509_F_X509_STORE_NEW: u32 = 0;
pub const X509_F_X509_TO_X509_REQ: u32 = 0;
pub const X509_F_X509_TRUST_ADD: u32 = 0;
pub const X509_F_X509_TRUST_SET: u32 = 0;
pub const X509_F_X509_VERIFY_CERT: u32 = 0;
pub const X509_F_X509_VERIFY_PARAM_NEW: u32 = 0;
pub const X509V3_F_A2I_GENERAL_NAME: u32 = 0;
pub const X509V3_F_ADDR_VALIDATE_PATH_INTERNAL: u32 = 0;
pub const X509V3_F_ASIDENTIFIERCHOICE_CANONIZE: u32 = 0;
pub const X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL: u32 = 0;
pub const X509V3_F_BIGNUM_TO_STRING: u32 = 0;
pub const X509V3_F_COPY_EMAIL: u32 = 0;
pub const X509V3_F_COPY_ISSUER: u32 = 0;
pub const X509V3_F_DO_DIRNAME: u32 = 0;
pub const X509V3_F_DO_EXT_I2D: u32 = 0;
pub const X509V3_F_DO_EXT_NCONF: u32 = 0;
pub const X509V3_F_GNAMES_FROM_SECTNAME: u32 = 0;
pub const X509V3_F_I2S_ASN1_ENUMERATED: u32 = 0;
pub const X509V3_F_I2S_ASN1_IA5STRING: u32 = 0;
pub const X509V3_F_I2S_ASN1_INTEGER: u32 = 0;
pub const X509V3_F_I2V_AUTHORITY_INFO_ACCESS: u32 = 0;
pub const X509V3_F_LEVEL_ADD_NODE: u32 = 0;
pub const X509V3_F_NOTICE_SECTION: u32 = 0;
pub const X509V3_F_NREF_NOS: u32 = 0;
pub const X509V3_F_POLICY_CACHE_CREATE: u32 = 0;
pub const X509V3_F_POLICY_CACHE_NEW: u32 = 0;
pub const X509V3_F_POLICY_DATA_NEW: u32 = 0;
pub const X509V3_F_POLICY_SECTION: u32 = 0;
pub const X509V3_F_PROCESS_PCI_VALUE: u32 = 0;
pub const X509V3_F_R2I_CERTPOL: u32 = 0;
pub const X509V3_F_R2I_PCI: u32 = 0;
pub const X509V3_F_S2I_ASN1_IA5STRING: u32 = 0;
pub const X509V3_F_S2I_ASN1_INTEGER: u32 = 0;
pub const X509V3_F_S2I_ASN1_OCTET_STRING: u32 = 0;
pub const X509V3_F_S2I_SKEY_ID: u32 = 0;
pub const X509V3_F_SET_DIST_POINT_NAME: u32 = 0;
pub const X509V3_F_SXNET_ADD_ID_ASC: u32 = 0;
pub const X509V3_F_SXNET_ADD_ID_INTEGER: u32 = 0;
pub const X509V3_F_SXNET_ADD_ID_ULONG: u32 = 0;
pub const X509V3_F_SXNET_GET_ID_ASC: u32 = 0;
pub const X509V3_F_SXNET_GET_ID_ULONG: u32 = 0;
pub const X509V3_F_TREE_INIT: u32 = 0;
pub const X509V3_F_V2I_ASIDENTIFIERS: u32 = 0;
pub const X509V3_F_V2I_ASN1_BIT_STRING: u32 = 0;
pub const X509V3_F_V2I_AUTHORITY_INFO_ACCESS: u32 = 0;
pub const X509V3_F_V2I_AUTHORITY_KEYID: u32 = 0;
pub const X509V3_F_V2I_BASIC_CONSTRAINTS: u32 = 0;
pub const X509V3_F_V2I_CRLD: u32 = 0;
pub const X509V3_F_V2I_EXTENDED_KEY_USAGE: u32 = 0;
pub const X509V3_F_V2I_GENERAL_NAMES: u32 = 0;
pub const X509V3_F_V2I_GENERAL_NAME_EX: u32 = 0;
pub const X509V3_F_V2I_IDP: u32 = 0;
pub const X509V3_F_V2I_IPADDRBLOCKS: u32 = 0;
pub const X509V3_F_V2I_ISSUER_ALT: u32 = 0;
pub const X509V3_F_V2I_NAME_CONSTRAINTS: u32 = 0;
pub const X509V3_F_V2I_POLICY_CONSTRAINTS: u32 = 0;
pub const X509V3_F_V2I_POLICY_MAPPINGS: u32 = 0;
pub const X509V3_F_V2I_SUBJECT_ALT: u32 = 0;
pub const X509V3_F_V2I_TLS_FEATURE: u32 = 0;
pub const X509V3_F_V3_GENERIC_EXTENSION: u32 = 0;
pub const X509V3_F_X509V3_ADD1_I2D: u32 = 0;
pub const X509V3_F_X509V3_ADD_VALUE: u32 = 0;
pub const X509V3_F_X509V3_EXT_ADD: u32 = 0;
pub const X509V3_F_X509V3_EXT_ADD_ALIAS: u32 = 0;
pub const X509V3_F_X509V3_EXT_I2D: u32 = 0;
pub const X509V3_F_X509V3_EXT_NCONF: u32 = 0;
pub const X509V3_F_X509V3_GET_SECTION: u32 = 0;
pub const X509V3_F_X509V3_GET_STRING: u32 = 0;
pub const X509V3_F_X509V3_GET_VALUE_BOOL: u32 = 0;
pub const X509V3_F_X509V3_PARSE_LIST: u32 = 0;
pub const X509V3_F_X509_PURPOSE_ADD: u32 = 0;
pub const X509V3_F_X509_PURPOSE_SET: u32 = 0;
pub const CRYPTO_R_BAD_ALGORITHM_NAME: u32 = 117;
pub const CRYPTO_R_CONFLICTING_NAMES: u32 = 118;
pub const CRYPTO_R_HEX_STRING_TOO_SHORT: u32 = 121;
pub const CRYPTO_R_ILLEGAL_HEX_DIGIT: u32 = 102;
pub const CRYPTO_R_INSUFFICIENT_DATA_SPACE: u32 = 106;
pub const CRYPTO_R_INSUFFICIENT_PARAM_SIZE: u32 = 107;
pub const CRYPTO_R_INSUFFICIENT_SECURE_DATA_SPACE: u32 = 108;
pub const CRYPTO_R_INTEGER_OVERFLOW: u32 = 127;
pub const CRYPTO_R_INVALID_NEGATIVE_VALUE: u32 = 122;
pub const CRYPTO_R_INVALID_NULL_ARGUMENT: u32 = 109;
pub const CRYPTO_R_INVALID_OSSL_PARAM_TYPE: u32 = 110;
pub const CRYPTO_R_NO_PARAMS_TO_MERGE: u32 = 131;
pub const CRYPTO_R_NO_SPACE_FOR_TERMINATING_NULL: u32 = 128;
pub const CRYPTO_R_ODD_NUMBER_OF_DIGITS: u32 = 103;
pub const CRYPTO_R_PARAM_CANNOT_BE_REPRESENTED_EXACTLY: u32 = 123;
pub const CRYPTO_R_PARAM_NOT_INTEGER_TYPE: u32 = 124;
pub const CRYPTO_R_PARAM_OF_INCOMPATIBLE_TYPE: u32 = 129;
pub const CRYPTO_R_PARAM_UNSIGNED_INTEGER_NEGATIVE_VALUE_UNSUPPORTED: u32 = 125;
pub const CRYPTO_R_PARAM_UNSUPPORTED_FLOATING_POINT_FORMAT: u32 = 130;
pub const CRYPTO_R_PARAM_VALUE_TOO_LARGE_FOR_DESTINATION: u32 = 126;
pub const CRYPTO_R_PROVIDER_ALREADY_EXISTS: u32 = 104;
pub const CRYPTO_R_PROVIDER_SECTION_ERROR: u32 = 105;
pub const CRYPTO_R_RANDOM_SECTION_ERROR: u32 = 119;
pub const CRYPTO_R_SECURE_MALLOC_FAILURE: u32 = 111;
pub const CRYPTO_R_STRING_TOO_LONG: u32 = 112;
pub const CRYPTO_R_TOO_MANY_BYTES: u32 = 113;
pub const CRYPTO_R_TOO_MANY_RECORDS: u32 = 114;
pub const CRYPTO_R_TOO_SMALL_BUFFER: u32 = 116;
pub const CRYPTO_R_UNKNOWN_NAME_IN_RANDOM_SECTION: u32 = 120;
pub const CRYPTO_R_ZERO_LENGTH_NUMBER: u32 = 115;
pub const OSSL_PARAM_INTEGER: u32 = 1;
pub const OSSL_PARAM_UNSIGNED_INTEGER: u32 = 2;
pub const OSSL_PARAM_REAL: u32 = 3;
pub const OSSL_PARAM_UTF8_STRING: u32 = 4;
pub const OSSL_PARAM_OCTET_STRING: u32 = 5;
pub const OSSL_PARAM_UTF8_PTR: u32 = 6;
pub const OSSL_PARAM_OCTET_PTR: u32 = 7;
pub const SSLEAY_VERSION_NUMBER: u32 = 806355024;
pub const OPENSSL_VERSION: u32 = 0;
pub const OPENSSL_CFLAGS: u32 = 1;
pub const OPENSSL_BUILT_ON: u32 = 2;
pub const OPENSSL_PLATFORM: u32 = 3;
pub const OPENSSL_DIR: u32 = 4;
pub const OPENSSL_ENGINES_DIR: u32 = 5;
pub const OPENSSL_VERSION_STRING: u32 = 6;
pub const OPENSSL_FULL_VERSION_STRING: u32 = 7;
pub const OPENSSL_MODULES_DIR: u32 = 8;
pub const OPENSSL_CPU_INFO: u32 = 9;
pub const OPENSSL_INFO_CONFIG_DIR: u32 = 1001;
pub const OPENSSL_INFO_ENGINES_DIR: u32 = 1002;
pub const OPENSSL_INFO_MODULES_DIR: u32 = 1003;
pub const OPENSSL_INFO_DSO_EXTENSION: u32 = 1004;
pub const OPENSSL_INFO_DIR_FILENAME_SEPARATOR: u32 = 1005;
pub const OPENSSL_INFO_LIST_SEPARATOR: u32 = 1006;
pub const OPENSSL_INFO_SEED_SOURCE: u32 = 1007;
pub const OPENSSL_INFO_CPU_SETTINGS: u32 = 1008;
pub const CRYPTO_EX_INDEX_SSL: u32 = 0;
pub const CRYPTO_EX_INDEX_SSL_CTX: u32 = 1;
pub const CRYPTO_EX_INDEX_SSL_SESSION: u32 = 2;
pub const CRYPTO_EX_INDEX_X509: u32 = 3;
pub const CRYPTO_EX_INDEX_X509_STORE: u32 = 4;
pub const CRYPTO_EX_INDEX_X509_STORE_CTX: u32 = 5;
pub const CRYPTO_EX_INDEX_DH: u32 = 6;
pub const CRYPTO_EX_INDEX_DSA: u32 = 7;
pub const CRYPTO_EX_INDEX_EC_KEY: u32 = 8;
pub const CRYPTO_EX_INDEX_RSA: u32 = 9;
pub const CRYPTO_EX_INDEX_ENGINE: u32 = 10;
pub const CRYPTO_EX_INDEX_UI: u32 = 11;
pub const CRYPTO_EX_INDEX_BIO: u32 = 12;
pub const CRYPTO_EX_INDEX_APP: u32 = 13;
pub const CRYPTO_EX_INDEX_UI_METHOD: u32 = 14;
pub const CRYPTO_EX_INDEX_RAND_DRBG: u32 = 15;
pub const CRYPTO_EX_INDEX_DRBG: u32 = 15;
pub const CRYPTO_EX_INDEX_OSSL_LIB_CTX: u32 = 16;
pub const CRYPTO_EX_INDEX_EVP_PKEY: u32 = 17;
pub const CRYPTO_EX_INDEX__COUNT: u32 = 18;
pub const CRYPTO_LOCK: u32 = 1;
pub const CRYPTO_UNLOCK: u32 = 2;
pub const CRYPTO_READ: u32 = 4;
pub const CRYPTO_WRITE: u32 = 8;
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS: u32 = 1;
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS: u32 = 2;
pub const OPENSSL_INIT_ADD_ALL_CIPHERS: u32 = 4;
pub const OPENSSL_INIT_ADD_ALL_DIGESTS: u32 = 8;
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS: u32 = 16;
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS: u32 = 32;
pub const OPENSSL_INIT_LOAD_CONFIG: u32 = 64;
pub const OPENSSL_INIT_NO_LOAD_CONFIG: u32 = 128;
pub const OPENSSL_INIT_ASYNC: u32 = 256;
pub const OPENSSL_INIT_ENGINE_RDRAND: u32 = 512;
pub const OPENSSL_INIT_ENGINE_DYNAMIC: u32 = 1024;
pub const OPENSSL_INIT_ENGINE_OPENSSL: u32 = 2048;
pub const OPENSSL_INIT_ENGINE_CRYPTODEV: u32 = 4096;
pub const OPENSSL_INIT_ENGINE_CAPI: u32 = 8192;
pub const OPENSSL_INIT_ENGINE_PADLOCK: u32 = 16384;
pub const OPENSSL_INIT_ENGINE_AFALG: u32 = 32768;
pub const OPENSSL_INIT_ATFORK: u32 = 131072;
pub const OPENSSL_INIT_NO_ATEXIT: u32 = 524288;
pub const OPENSSL_INIT_ENGINE_ALL_BUILTIN: u32 = 30208;
pub const CRYPTO_ONCE_STATIC_INIT: u32 = 0;
pub const COMP_R_ZLIB_DEFLATE_ERROR: u32 = 99;
pub const COMP_R_ZLIB_INFLATE_ERROR: u32 = 100;
pub const COMP_R_ZLIB_NOT_SUPPORTED: u32 = 101;
pub const BIO_R_ACCEPT_ERROR: u32 = 100;
pub const BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET: u32 = 141;
pub const BIO_R_AMBIGUOUS_HOST_OR_SERVICE: u32 = 129;
pub const BIO_R_BAD_FOPEN_MODE: u32 = 101;
pub const BIO_R_BROKEN_PIPE: u32 = 124;
pub const BIO_R_CONNECT_ERROR: u32 = 103;
pub const BIO_R_CONNECT_TIMEOUT: u32 = 147;
pub const BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET: u32 = 107;
pub const BIO_R_GETSOCKNAME_ERROR: u32 = 132;
pub const BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS: u32 = 133;
pub const BIO_R_GETTING_SOCKTYPE: u32 = 134;
pub const BIO_R_INVALID_ARGUMENT: u32 = 125;
pub const BIO_R_INVALID_SOCKET: u32 = 135;
pub const BIO_R_IN_USE: u32 = 123;
pub const BIO_R_LENGTH_TOO_LONG: u32 = 102;
pub const BIO_R_LISTEN_V6_ONLY: u32 = 136;
pub const BIO_R_LOOKUP_RETURNED_NOTHING: u32 = 142;
pub const BIO_R_MALFORMED_HOST_OR_SERVICE: u32 = 130;
pub const BIO_R_NBIO_CONNECT_ERROR: u32 = 110;
pub const BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED: u32 = 143;
pub const BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED: u32 = 144;
pub const BIO_R_NO_PORT_DEFINED: u32 = 113;
pub const BIO_R_NO_SUCH_FILE: u32 = 128;
pub const BIO_R_NULL_PARAMETER: u32 = 115;
pub const BIO_R_TRANSFER_ERROR: u32 = 104;
pub const BIO_R_TRANSFER_TIMEOUT: u32 = 105;
pub const BIO_R_UNABLE_TO_BIND_SOCKET: u32 = 117;
pub const BIO_R_UNABLE_TO_CREATE_SOCKET: u32 = 118;
pub const BIO_R_UNABLE_TO_KEEPALIVE: u32 = 137;
pub const BIO_R_UNABLE_TO_LISTEN_SOCKET: u32 = 119;
pub const BIO_R_UNABLE_TO_NODELAY: u32 = 138;
pub const BIO_R_UNABLE_TO_REUSEADDR: u32 = 139;
pub const BIO_R_UNAVAILABLE_IP_FAMILY: u32 = 145;
pub const BIO_R_UNINITIALIZED: u32 = 120;
pub const BIO_R_UNKNOWN_INFO_TYPE: u32 = 140;
pub const BIO_R_UNSUPPORTED_IP_FAMILY: u32 = 146;
pub const BIO_R_UNSUPPORTED_METHOD: u32 = 121;
pub const BIO_R_UNSUPPORTED_PROTOCOL_FAMILY: u32 = 131;
pub const BIO_R_WRITE_TO_READ_ONLY_BIO: u32 = 126;
pub const BIO_R_WSASTARTUP: u32 = 122;
pub const BIO_TYPE_DESCRIPTOR: u32 = 256;
pub const BIO_TYPE_FILTER: u32 = 512;
pub const BIO_TYPE_SOURCE_SINK: u32 = 1024;
pub const BIO_TYPE_NONE: u32 = 0;
pub const BIO_TYPE_MEM: u32 = 1025;
pub const BIO_TYPE_FILE: u32 = 1026;
pub const BIO_TYPE_FD: u32 = 1284;
pub const BIO_TYPE_SOCKET: u32 = 1285;
pub const BIO_TYPE_NULL: u32 = 1030;
pub const BIO_TYPE_SSL: u32 = 519;
pub const BIO_TYPE_MD: u32 = 520;
pub const BIO_TYPE_BUFFER: u32 = 521;
pub const BIO_TYPE_CIPHER: u32 = 522;
pub const BIO_TYPE_BASE64: u32 = 523;
pub const BIO_TYPE_CONNECT: u32 = 1292;
pub const BIO_TYPE_ACCEPT: u32 = 1293;
pub const BIO_TYPE_NBIO_TEST: u32 = 528;
pub const BIO_TYPE_NULL_FILTER: u32 = 529;
pub const BIO_TYPE_BIO: u32 = 1043;
pub const BIO_TYPE_LINEBUFFER: u32 = 532;
pub const BIO_TYPE_DGRAM: u32 = 1301;
pub const BIO_TYPE_ASN1: u32 = 534;
pub const BIO_TYPE_COMP: u32 = 535;
pub const BIO_TYPE_CORE_TO_PROV: u32 = 1049;
pub const BIO_TYPE_START: u32 = 128;
pub const BIO_NOCLOSE: u32 = 0;
pub const BIO_CLOSE: u32 = 1;
pub const BIO_CTRL_RESET: u32 = 1;
pub const BIO_CTRL_EOF: u32 = 2;
pub const BIO_CTRL_INFO: u32 = 3;
pub const BIO_CTRL_SET: u32 = 4;
pub const BIO_CTRL_GET: u32 = 5;
pub const BIO_CTRL_PUSH: u32 = 6;
pub const BIO_CTRL_POP: u32 = 7;
pub const BIO_CTRL_GET_CLOSE: u32 = 8;
pub const BIO_CTRL_SET_CLOSE: u32 = 9;
pub const BIO_CTRL_PENDING: u32 = 10;
pub const BIO_CTRL_FLUSH: u32 = 11;
pub const BIO_CTRL_DUP: u32 = 12;
pub const BIO_CTRL_WPENDING: u32 = 13;
pub const BIO_CTRL_SET_CALLBACK: u32 = 14;
pub const BIO_CTRL_GET_CALLBACK: u32 = 15;
pub const BIO_CTRL_PEEK: u32 = 29;
pub const BIO_CTRL_SET_FILENAME: u32 = 30;
pub const BIO_CTRL_DGRAM_CONNECT: u32 = 31;
pub const BIO_CTRL_DGRAM_SET_CONNECTED: u32 = 32;
pub const BIO_CTRL_DGRAM_SET_RECV_TIMEOUT: u32 = 33;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMEOUT: u32 = 34;
pub const BIO_CTRL_DGRAM_SET_SEND_TIMEOUT: u32 = 35;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMEOUT: u32 = 36;
pub const BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP: u32 = 37;
pub const BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP: u32 = 38;
pub const BIO_CTRL_DGRAM_MTU_DISCOVER: u32 = 39;
pub const BIO_CTRL_DGRAM_QUERY_MTU: u32 = 40;
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU: u32 = 47;
pub const BIO_CTRL_DGRAM_GET_MTU: u32 = 41;
pub const BIO_CTRL_DGRAM_SET_MTU: u32 = 42;
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED: u32 = 43;
pub const BIO_CTRL_DGRAM_GET_PEER: u32 = 46;
pub const BIO_CTRL_DGRAM_SET_PEER: u32 = 44;
pub const BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT: u32 = 45;
pub const BIO_CTRL_DGRAM_SET_DONT_FRAG: u32 = 48;
pub const BIO_CTRL_DGRAM_GET_MTU_OVERHEAD: u32 = 49;
pub const BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE: u32 = 50;
pub const BIO_CTRL_DGRAM_SET_PEEK_MODE: u32 = 71;
pub const BIO_CTRL_GET_KTLS_SEND: u32 = 73;
pub const BIO_CTRL_GET_KTLS_RECV: u32 = 76;
pub const BIO_CTRL_DGRAM_SCTP_WAIT_FOR_DRY: u32 = 77;
pub const BIO_CTRL_DGRAM_SCTP_MSG_WAITING: u32 = 78;
pub const BIO_CTRL_SET_PREFIX: u32 = 79;
pub const BIO_CTRL_SET_INDENT: u32 = 80;
pub const BIO_CTRL_GET_INDENT: u32 = 81;
pub const BIO_FP_READ: u32 = 2;
pub const BIO_FP_WRITE: u32 = 4;
pub const BIO_FP_APPEND: u32 = 8;
pub const BIO_FP_TEXT: u32 = 16;
pub const BIO_FLAGS_READ: u32 = 1;
pub const BIO_FLAGS_WRITE: u32 = 2;
pub const BIO_FLAGS_IO_SPECIAL: u32 = 4;
pub const BIO_FLAGS_RWS: u32 = 7;
pub const BIO_FLAGS_SHOULD_RETRY: u32 = 8;
pub const BIO_FLAGS_UPLINK: u32 = 0;
pub const BIO_FLAGS_BASE64_NO_NL: u32 = 256;
pub const BIO_FLAGS_MEM_RDONLY: u32 = 512;
pub const BIO_FLAGS_NONCLEAR_RST: u32 = 1024;
pub const BIO_FLAGS_IN_EOF: u32 = 2048;
pub const BIO_RR_SSL_X509_LOOKUP: u32 = 1;
pub const BIO_RR_CONNECT: u32 = 2;
pub const BIO_RR_ACCEPT: u32 = 3;
pub const BIO_CB_FREE: u32 = 1;
pub const BIO_CB_READ: u32 = 2;
pub const BIO_CB_WRITE: u32 = 3;
pub const BIO_CB_PUTS: u32 = 4;
pub const BIO_CB_GETS: u32 = 5;
pub const BIO_CB_CTRL: u32 = 6;
pub const BIO_CB_RETURN: u32 = 128;
pub const BIO_C_SET_CONNECT: u32 = 100;
pub const BIO_C_DO_STATE_MACHINE: u32 = 101;
pub const BIO_C_SET_NBIO: u32 = 102;
pub const BIO_C_SET_FD: u32 = 104;
pub const BIO_C_GET_FD: u32 = 105;
pub const BIO_C_SET_FILE_PTR: u32 = 106;
pub const BIO_C_GET_FILE_PTR: u32 = 107;
pub const BIO_C_SET_FILENAME: u32 = 108;
pub const BIO_C_SET_SSL: u32 = 109;
pub const BIO_C_GET_SSL: u32 = 110;
pub const BIO_C_SET_MD: u32 = 111;
pub const BIO_C_GET_MD: u32 = 112;
pub const BIO_C_GET_CIPHER_STATUS: u32 = 113;
pub const BIO_C_SET_BUF_MEM: u32 = 114;
pub const BIO_C_GET_BUF_MEM_PTR: u32 = 115;
pub const BIO_C_GET_BUFF_NUM_LINES: u32 = 116;
pub const BIO_C_SET_BUFF_SIZE: u32 = 117;
pub const BIO_C_SET_ACCEPT: u32 = 118;
pub const BIO_C_SSL_MODE: u32 = 119;
pub const BIO_C_GET_MD_CTX: u32 = 120;
pub const BIO_C_SET_BUFF_READ_DATA: u32 = 122;
pub const BIO_C_GET_CONNECT: u32 = 123;
pub const BIO_C_GET_ACCEPT: u32 = 124;
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES: u32 = 125;
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES: u32 = 126;
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT: u32 = 127;
pub const BIO_C_FILE_SEEK: u32 = 128;
pub const BIO_C_GET_CIPHER_CTX: u32 = 129;
pub const BIO_C_SET_BUF_MEM_EOF_RETURN: u32 = 130;
pub const BIO_C_SET_BIND_MODE: u32 = 131;
pub const BIO_C_GET_BIND_MODE: u32 = 132;
pub const BIO_C_FILE_TELL: u32 = 133;
pub const BIO_C_GET_SOCKS: u32 = 134;
pub const BIO_C_SET_SOCKS: u32 = 135;
pub const BIO_C_SET_WRITE_BUF_SIZE: u32 = 136;
pub const BIO_C_GET_WRITE_BUF_SIZE: u32 = 137;
pub const BIO_C_MAKE_BIO_PAIR: u32 = 138;
pub const BIO_C_DESTROY_BIO_PAIR: u32 = 139;
pub const BIO_C_GET_WRITE_GUARANTEE: u32 = 140;
pub const BIO_C_GET_READ_REQUEST: u32 = 141;
pub const BIO_C_SHUTDOWN_WR: u32 = 142;
pub const BIO_C_NREAD0: u32 = 143;
pub const BIO_C_NREAD: u32 = 144;
pub const BIO_C_NWRITE0: u32 = 145;
pub const BIO_C_NWRITE: u32 = 146;
pub const BIO_C_RESET_READ_REQUEST: u32 = 147;
pub const BIO_C_SET_MD_CTX: u32 = 148;
pub const BIO_C_SET_PREFIX: u32 = 149;
pub const BIO_C_GET_PREFIX: u32 = 150;
pub const BIO_C_SET_SUFFIX: u32 = 151;
pub const BIO_C_GET_SUFFIX: u32 = 152;
pub const BIO_C_SET_EX_ARG: u32 = 153;
pub const BIO_C_GET_EX_ARG: u32 = 154;
pub const BIO_C_SET_CONNECT_MODE: u32 = 155;
pub const BIO_FAMILY_IPV4: u32 = 4;
pub const BIO_FAMILY_IPV6: u32 = 6;
pub const BIO_FAMILY_IPANY: u32 = 256;
pub const BIO_BIND_NORMAL: u32 = 0;
pub const BIO_SOCK_REUSEADDR: u32 = 1;
pub const BIO_SOCK_V6_ONLY: u32 = 2;
pub const BIO_SOCK_KEEPALIVE: u32 = 4;
pub const BIO_SOCK_NONBLOCK: u32 = 8;
pub const BIO_SOCK_NODELAY: u32 = 16;
pub const BUF_MEM_FLAG_SECURE: u32 = 1;
pub const OSSL_FUNC_CORE_GETTABLE_PARAMS: u32 = 1;
pub const OSSL_FUNC_CORE_GET_PARAMS: u32 = 2;
pub const OSSL_FUNC_CORE_THREAD_START: u32 = 3;
pub const OSSL_FUNC_CORE_GET_LIBCTX: u32 = 4;
pub const OSSL_FUNC_CORE_NEW_ERROR: u32 = 5;
pub const OSSL_FUNC_CORE_SET_ERROR_DEBUG: u32 = 6;
pub const OSSL_FUNC_CORE_VSET_ERROR: u32 = 7;
pub const OSSL_FUNC_CORE_SET_ERROR_MARK: u32 = 8;
pub const OSSL_FUNC_CORE_CLEAR_LAST_ERROR_MARK: u32 = 9;
pub const OSSL_FUNC_CORE_POP_ERROR_TO_MARK: u32 = 10;
pub const OSSL_FUNC_CORE_OBJ_ADD_SIGID: u32 = 11;
pub const OSSL_FUNC_CORE_OBJ_CREATE: u32 = 12;
pub const OSSL_FUNC_CRYPTO_MALLOC: u32 = 20;
pub const OSSL_FUNC_CRYPTO_ZALLOC: u32 = 21;
pub const OSSL_FUNC_CRYPTO_FREE: u32 = 22;
pub const OSSL_FUNC_CRYPTO_CLEAR_FREE: u32 = 23;
pub const OSSL_FUNC_CRYPTO_REALLOC: u32 = 24;
pub const OSSL_FUNC_CRYPTO_CLEAR_REALLOC: u32 = 25;
pub const OSSL_FUNC_CRYPTO_SECURE_MALLOC: u32 = 26;
pub const OSSL_FUNC_CRYPTO_SECURE_ZALLOC: u32 = 27;
pub const OSSL_FUNC_CRYPTO_SECURE_FREE: u32 = 28;
pub const OSSL_FUNC_CRYPTO_SECURE_CLEAR_FREE: u32 = 29;
pub const OSSL_FUNC_CRYPTO_SECURE_ALLOCATED: u32 = 30;
pub const OSSL_FUNC_OPENSSL_CLEANSE: u32 = 31;
pub const OSSL_FUNC_BIO_NEW_FILE: u32 = 40;
pub const OSSL_FUNC_BIO_NEW_MEMBUF: u32 = 41;
pub const OSSL_FUNC_BIO_READ_EX: u32 = 42;
pub const OSSL_FUNC_BIO_WRITE_EX: u32 = 43;
pub const OSSL_FUNC_BIO_UP_REF: u32 = 44;
pub const OSSL_FUNC_BIO_FREE: u32 = 45;
pub const OSSL_FUNC_BIO_VPRINTF: u32 = 46;
pub const OSSL_FUNC_BIO_VSNPRINTF: u32 = 47;
pub const OSSL_FUNC_BIO_PUTS: u32 = 48;
pub const OSSL_FUNC_BIO_GETS: u32 = 49;
pub const OSSL_FUNC_BIO_CTRL: u32 = 50;
pub const OSSL_FUNC_CLEANUP_USER_ENTROPY: u32 = 96;
pub const OSSL_FUNC_CLEANUP_USER_NONCE: u32 = 97;
pub const OSSL_FUNC_GET_USER_ENTROPY: u32 = 98;
pub const OSSL_FUNC_GET_USER_NONCE: u32 = 99;
pub const OSSL_FUNC_SELF_TEST_CB: u32 = 100;
pub const OSSL_FUNC_GET_ENTROPY: u32 = 101;
pub const OSSL_FUNC_CLEANUP_ENTROPY: u32 = 102;
pub const OSSL_FUNC_GET_NONCE: u32 = 103;
pub const OSSL_FUNC_CLEANUP_NONCE: u32 = 104;
pub const OSSL_FUNC_PROVIDER_REGISTER_CHILD_CB: u32 = 105;
pub const OSSL_FUNC_PROVIDER_DEREGISTER_CHILD_CB: u32 = 106;
pub const OSSL_FUNC_PROVIDER_NAME: u32 = 107;
pub const OSSL_FUNC_PROVIDER_GET0_PROVIDER_CTX: u32 = 108;
pub const OSSL_FUNC_PROVIDER_GET0_DISPATCH: u32 = 109;
pub const OSSL_FUNC_PROVIDER_UP_REF: u32 = 110;
pub const OSSL_FUNC_PROVIDER_FREE: u32 = 111;
pub const OSSL_FUNC_PROVIDER_TEARDOWN: u32 = 1024;
pub const OSSL_FUNC_PROVIDER_GETTABLE_PARAMS: u32 = 1025;
pub const OSSL_FUNC_PROVIDER_GET_PARAMS: u32 = 1026;
pub const OSSL_FUNC_PROVIDER_QUERY_OPERATION: u32 = 1027;
pub const OSSL_FUNC_PROVIDER_UNQUERY_OPERATION: u32 = 1028;
pub const OSSL_FUNC_PROVIDER_GET_REASON_STRINGS: u32 = 1029;
pub const OSSL_FUNC_PROVIDER_GET_CAPABILITIES: u32 = 1030;
pub const OSSL_FUNC_PROVIDER_SELF_TEST: u32 = 1031;
pub const OSSL_OP_DIGEST: u32 = 1;
pub const OSSL_OP_CIPHER: u32 = 2;
pub const OSSL_OP_MAC: u32 = 3;
pub const OSSL_OP_KDF: u32 = 4;
pub const OSSL_OP_RAND: u32 = 5;
pub const OSSL_OP_KEYMGMT: u32 = 10;
pub const OSSL_OP_KEYEXCH: u32 = 11;
pub const OSSL_OP_SIGNATURE: u32 = 12;
pub const OSSL_OP_ASYM_CIPHER: u32 = 13;
pub const OSSL_OP_KEM: u32 = 14;
pub const OSSL_OP_ENCODER: u32 = 20;
pub const OSSL_OP_DECODER: u32 = 21;
pub const OSSL_OP_STORE: u32 = 22;
pub const OSSL_OP__HIGHEST: u32 = 22;
pub const OSSL_FUNC_DIGEST_NEWCTX: u32 = 1;
pub const OSSL_FUNC_DIGEST_INIT: u32 = 2;
pub const OSSL_FUNC_DIGEST_UPDATE: u32 = 3;
pub const OSSL_FUNC_DIGEST_FINAL: u32 = 4;
pub const OSSL_FUNC_DIGEST_DIGEST: u32 = 5;
pub const OSSL_FUNC_DIGEST_FREECTX: u32 = 6;
pub const OSSL_FUNC_DIGEST_DUPCTX: u32 = 7;
pub const OSSL_FUNC_DIGEST_GET_PARAMS: u32 = 8;
pub const OSSL_FUNC_DIGEST_SET_CTX_PARAMS: u32 = 9;
pub const OSSL_FUNC_DIGEST_GET_CTX_PARAMS: u32 = 10;
pub const OSSL_FUNC_DIGEST_GETTABLE_PARAMS: u32 = 11;
pub const OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS: u32 = 12;
pub const OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS: u32 = 13;
pub const OSSL_FUNC_CIPHER_NEWCTX: u32 = 1;
pub const OSSL_FUNC_CIPHER_ENCRYPT_INIT: u32 = 2;
pub const OSSL_FUNC_CIPHER_DECRYPT_INIT: u32 = 3;
pub const OSSL_FUNC_CIPHER_UPDATE: u32 = 4;
pub const OSSL_FUNC_CIPHER_FINAL: u32 = 5;
pub const OSSL_FUNC_CIPHER_CIPHER: u32 = 6;
pub const OSSL_FUNC_CIPHER_FREECTX: u32 = 7;
pub const OSSL_FUNC_CIPHER_DUPCTX: u32 = 8;
pub const OSSL_FUNC_CIPHER_GET_PARAMS: u32 = 9;
pub const OSSL_FUNC_CIPHER_GET_CTX_PARAMS: u32 = 10;
pub const OSSL_FUNC_CIPHER_SET_CTX_PARAMS: u32 = 11;
pub const OSSL_FUNC_CIPHER_GETTABLE_PARAMS: u32 = 12;
pub const OSSL_FUNC_CIPHER_GETTABLE_CTX_PARAMS: u32 = 13;
pub const OSSL_FUNC_CIPHER_SETTABLE_CTX_PARAMS: u32 = 14;
pub const OSSL_FUNC_MAC_NEWCTX: u32 = 1;
pub const OSSL_FUNC_MAC_DUPCTX: u32 = 2;
pub const OSSL_FUNC_MAC_FREECTX: u32 = 3;
pub const OSSL_FUNC_MAC_INIT: u32 = 4;
pub const OSSL_FUNC_MAC_UPDATE: u32 = 5;
pub const OSSL_FUNC_MAC_FINAL: u32 = 6;
pub const OSSL_FUNC_MAC_GET_PARAMS: u32 = 7;
pub const OSSL_FUNC_MAC_GET_CTX_PARAMS: u32 = 8;
pub const OSSL_FUNC_MAC_SET_CTX_PARAMS: u32 = 9;
pub const OSSL_FUNC_MAC_GETTABLE_PARAMS: u32 = 10;
pub const OSSL_FUNC_MAC_GETTABLE_CTX_PARAMS: u32 = 11;
pub const OSSL_FUNC_MAC_SETTABLE_CTX_PARAMS: u32 = 12;
pub const OSSL_FUNC_KDF_NEWCTX: u32 = 1;
pub const OSSL_FUNC_KDF_DUPCTX: u32 = 2;
pub const OSSL_FUNC_KDF_FREECTX: u32 = 3;
pub const OSSL_FUNC_KDF_RESET: u32 = 4;
pub const OSSL_FUNC_KDF_DERIVE: u32 = 5;
pub const OSSL_FUNC_KDF_GETTABLE_PARAMS: u32 = 6;
pub const OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS: u32 = 7;
pub const OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS: u32 = 8;
pub const OSSL_FUNC_KDF_GET_PARAMS: u32 = 9;
pub const OSSL_FUNC_KDF_GET_CTX_PARAMS: u32 = 10;
pub const OSSL_FUNC_KDF_SET_CTX_PARAMS: u32 = 11;
pub const OSSL_FUNC_RAND_NEWCTX: u32 = 1;
pub const OSSL_FUNC_RAND_FREECTX: u32 = 2;
pub const OSSL_FUNC_RAND_INSTANTIATE: u32 = 3;
pub const OSSL_FUNC_RAND_UNINSTANTIATE: u32 = 4;
pub const OSSL_FUNC_RAND_GENERATE: u32 = 5;
pub const OSSL_FUNC_RAND_RESEED: u32 = 6;
pub const OSSL_FUNC_RAND_NONCE: u32 = 7;
pub const OSSL_FUNC_RAND_ENABLE_LOCKING: u32 = 8;
pub const OSSL_FUNC_RAND_LOCK: u32 = 9;
pub const OSSL_FUNC_RAND_UNLOCK: u32 = 10;
pub const OSSL_FUNC_RAND_GETTABLE_PARAMS: u32 = 11;
pub const OSSL_FUNC_RAND_GETTABLE_CTX_PARAMS: u32 = 12;
pub const OSSL_FUNC_RAND_SETTABLE_CTX_PARAMS: u32 = 13;
pub const OSSL_FUNC_RAND_GET_PARAMS: u32 = 14;
pub const OSSL_FUNC_RAND_GET_CTX_PARAMS: u32 = 15;
pub const OSSL_FUNC_RAND_SET_CTX_PARAMS: u32 = 16;
pub const OSSL_FUNC_RAND_VERIFY_ZEROIZATION: u32 = 17;
pub const OSSL_FUNC_RAND_GET_SEED: u32 = 18;
pub const OSSL_FUNC_RAND_CLEAR_SEED: u32 = 19;
pub const OSSL_KEYMGMT_SELECT_PRIVATE_KEY: u32 = 1;
pub const OSSL_KEYMGMT_SELECT_PUBLIC_KEY: u32 = 2;
pub const OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS: u32 = 4;
pub const OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS: u32 = 128;
pub const OSSL_KEYMGMT_SELECT_ALL_PARAMETERS: u32 = 132;
pub const OSSL_KEYMGMT_SELECT_KEYPAIR: u32 = 3;
pub const OSSL_KEYMGMT_SELECT_ALL: u32 = 135;
pub const OSSL_KEYMGMT_VALIDATE_FULL_CHECK: u32 = 0;
pub const OSSL_KEYMGMT_VALIDATE_QUICK_CHECK: u32 = 1;
pub const OSSL_FUNC_KEYMGMT_NEW: u32 = 1;
pub const OSSL_FUNC_KEYMGMT_GEN_INIT: u32 = 2;
pub const OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE: u32 = 3;
pub const OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS: u32 = 4;
pub const OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS: u32 = 5;
pub const OSSL_FUNC_KEYMGMT_GEN: u32 = 6;
pub const OSSL_FUNC_KEYMGMT_GEN_CLEANUP: u32 = 7;
pub const OSSL_FUNC_KEYMGMT_LOAD: u32 = 8;
pub const OSSL_FUNC_KEYMGMT_FREE: u32 = 10;
pub const OSSL_FUNC_KEYMGMT_GET_PARAMS: u32 = 11;
pub const OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS: u32 = 12;
pub const OSSL_FUNC_KEYMGMT_SET_PARAMS: u32 = 13;
pub const OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS: u32 = 14;
pub const OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME: u32 = 20;
pub const OSSL_FUNC_KEYMGMT_HAS: u32 = 21;
pub const OSSL_FUNC_KEYMGMT_VALIDATE: u32 = 22;
pub const OSSL_FUNC_KEYMGMT_MATCH: u32 = 23;
pub const OSSL_FUNC_KEYMGMT_IMPORT: u32 = 40;
pub const OSSL_FUNC_KEYMGMT_IMPORT_TYPES: u32 = 41;
pub const OSSL_FUNC_KEYMGMT_EXPORT: u32 = 42;
pub const OSSL_FUNC_KEYMGMT_EXPORT_TYPES: u32 = 43;
pub const OSSL_FUNC_KEYMGMT_DUP: u32 = 44;
pub const OSSL_FUNC_KEYEXCH_NEWCTX: u32 = 1;
pub const OSSL_FUNC_KEYEXCH_INIT: u32 = 2;
pub const OSSL_FUNC_KEYEXCH_DERIVE: u32 = 3;
pub const OSSL_FUNC_KEYEXCH_SET_PEER: u32 = 4;
pub const OSSL_FUNC_KEYEXCH_FREECTX: u32 = 5;
pub const OSSL_FUNC_KEYEXCH_DUPCTX: u32 = 6;
pub const OSSL_FUNC_KEYEXCH_SET_CTX_PARAMS: u32 = 7;
pub const OSSL_FUNC_KEYEXCH_SETTABLE_CTX_PARAMS: u32 = 8;
pub const OSSL_FUNC_KEYEXCH_GET_CTX_PARAMS: u32 = 9;
pub const OSSL_FUNC_KEYEXCH_GETTABLE_CTX_PARAMS: u32 = 10;
pub const OSSL_FUNC_SIGNATURE_NEWCTX: u32 = 1;
pub const OSSL_FUNC_SIGNATURE_SIGN_INIT: u32 = 2;
pub const OSSL_FUNC_SIGNATURE_SIGN: u32 = 3;
pub const OSSL_FUNC_SIGNATURE_VERIFY_INIT: u32 = 4;
pub const OSSL_FUNC_SIGNATURE_VERIFY: u32 = 5;
pub const OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT: u32 = 6;
pub const OSSL_FUNC_SIGNATURE_VERIFY_RECOVER: u32 = 7;
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_INIT: u32 = 8;
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_UPDATE: u32 = 9;
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_FINAL: u32 = 10;
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN: u32 = 11;
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_INIT: u32 = 12;
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_UPDATE: u32 = 13;
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_FINAL: u32 = 14;
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY: u32 = 15;
pub const OSSL_FUNC_SIGNATURE_FREECTX: u32 = 16;
pub const OSSL_FUNC_SIGNATURE_DUPCTX: u32 = 17;
pub const OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS: u32 = 18;
pub const OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS: u32 = 19;
pub const OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS: u32 = 20;
pub const OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS: u32 = 21;
pub const OSSL_FUNC_SIGNATURE_GET_CTX_MD_PARAMS: u32 = 22;
pub const OSSL_FUNC_SIGNATURE_GETTABLE_CTX_MD_PARAMS: u32 = 23;
pub const OSSL_FUNC_SIGNATURE_SET_CTX_MD_PARAMS: u32 = 24;
pub const OSSL_FUNC_SIGNATURE_SETTABLE_CTX_MD_PARAMS: u32 = 25;
pub const OSSL_FUNC_ASYM_CIPHER_NEWCTX: u32 = 1;
pub const OSSL_FUNC_ASYM_CIPHER_ENCRYPT_INIT: u32 = 2;
pub const OSSL_FUNC_ASYM_CIPHER_ENCRYPT: u32 = 3;
pub const OSSL_FUNC_ASYM_CIPHER_DECRYPT_INIT: u32 = 4;
pub const OSSL_FUNC_ASYM_CIPHER_DECRYPT: u32 = 5;
pub const OSSL_FUNC_ASYM_CIPHER_FREECTX: u32 = 6;
pub const OSSL_FUNC_ASYM_CIPHER_DUPCTX: u32 = 7;
pub const OSSL_FUNC_ASYM_CIPHER_GET_CTX_PARAMS: u32 = 8;
pub const OSSL_FUNC_ASYM_CIPHER_GETTABLE_CTX_PARAMS: u32 = 9;
pub const OSSL_FUNC_ASYM_CIPHER_SET_CTX_PARAMS: u32 = 10;
pub const OSSL_FUNC_ASYM_CIPHER_SETTABLE_CTX_PARAMS: u32 = 11;
pub const OSSL_FUNC_KEM_NEWCTX: u32 = 1;
pub const OSSL_FUNC_KEM_ENCAPSULATE_INIT: u32 = 2;
pub const OSSL_FUNC_KEM_ENCAPSULATE: u32 = 3;
pub const OSSL_FUNC_KEM_DECAPSULATE_INIT: u32 = 4;
pub const OSSL_FUNC_KEM_DECAPSULATE: u32 = 5;
pub const OSSL_FUNC_KEM_FREECTX: u32 = 6;
pub const OSSL_FUNC_KEM_DUPCTX: u32 = 7;
pub const OSSL_FUNC_KEM_GET_CTX_PARAMS: u32 = 8;
pub const OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS: u32 = 9;
pub const OSSL_FUNC_KEM_SET_CTX_PARAMS: u32 = 10;
pub const OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS: u32 = 11;
pub const OSSL_FUNC_ENCODER_NEWCTX: u32 = 1;
pub const OSSL_FUNC_ENCODER_FREECTX: u32 = 2;
pub const OSSL_FUNC_ENCODER_GET_PARAMS: u32 = 3;
pub const OSSL_FUNC_ENCODER_GETTABLE_PARAMS: u32 = 4;
pub const OSSL_FUNC_ENCODER_SET_CTX_PARAMS: u32 = 5;
pub const OSSL_FUNC_ENCODER_SETTABLE_CTX_PARAMS: u32 = 6;
pub const OSSL_FUNC_ENCODER_DOES_SELECTION: u32 = 10;
pub const OSSL_FUNC_ENCODER_ENCODE: u32 = 11;
pub const OSSL_FUNC_ENCODER_IMPORT_OBJECT: u32 = 20;
pub const OSSL_FUNC_ENCODER_FREE_OBJECT: u32 = 21;
pub const OSSL_FUNC_DECODER_NEWCTX: u32 = 1;
pub const OSSL_FUNC_DECODER_FREECTX: u32 = 2;
pub const OSSL_FUNC_DECODER_GET_PARAMS: u32 = 3;
pub const OSSL_FUNC_DECODER_GETTABLE_PARAMS: u32 = 4;
pub const OSSL_FUNC_DECODER_SET_CTX_PARAMS: u32 = 5;
pub const OSSL_FUNC_DECODER_SETTABLE_CTX_PARAMS: u32 = 6;
pub const OSSL_FUNC_DECODER_DOES_SELECTION: u32 = 10;
pub const OSSL_FUNC_DECODER_DECODE: u32 = 11;
pub const OSSL_FUNC_DECODER_EXPORT_OBJECT: u32 = 20;
pub const OSSL_FUNC_STORE_OPEN: u32 = 1;
pub const OSSL_FUNC_STORE_ATTACH: u32 = 2;
pub const OSSL_FUNC_STORE_SETTABLE_CTX_PARAMS: u32 = 3;
pub const OSSL_FUNC_STORE_SET_CTX_PARAMS: u32 = 4;
pub const OSSL_FUNC_STORE_LOAD: u32 = 5;
pub const OSSL_FUNC_STORE_EOF: u32 = 6;
pub const OSSL_FUNC_STORE_CLOSE: u32 = 7;
pub const OSSL_FUNC_STORE_EXPORT_OBJECT: u32 = 8;
pub const EVP_R_AES_KEY_SETUP_FAILED: u32 = 143;
pub const EVP_R_ARIA_KEY_SETUP_FAILED: u32 = 176;
pub const EVP_R_BAD_ALGORITHM_NAME: u32 = 200;
pub const EVP_R_BAD_DECRYPT: u32 = 100;
pub const EVP_R_BAD_KEY_LENGTH: u32 = 195;
pub const EVP_R_BUFFER_TOO_SMALL: u32 = 155;
pub const EVP_R_CACHE_CONSTANTS_FAILED: u32 = 225;
pub const EVP_R_CAMELLIA_KEY_SETUP_FAILED: u32 = 157;
pub const EVP_R_CANNOT_GET_PARAMETERS: u32 = 197;
pub const EVP_R_CANNOT_SET_PARAMETERS: u32 = 198;
pub const EVP_R_CIPHER_NOT_GCM_MODE: u32 = 184;
pub const EVP_R_CIPHER_PARAMETER_ERROR: u32 = 122;
pub const EVP_R_COMMAND_NOT_SUPPORTED: u32 = 147;
pub const EVP_R_CONFLICTING_ALGORITHM_NAME: u32 = 201;
pub const EVP_R_COPY_ERROR: u32 = 173;
pub const EVP_R_CTRL_NOT_IMPLEMENTED: u32 = 132;
pub const EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED: u32 = 133;
pub const EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH: u32 = 138;
pub const EVP_R_DECODE_ERROR: u32 = 114;
pub const EVP_R_DEFAULT_QUERY_PARSE_ERROR: u32 = 210;
pub const EVP_R_DIFFERENT_KEY_TYPES: u32 = 101;
pub const EVP_R_DIFFERENT_PARAMETERS: u32 = 153;
pub const EVP_R_ERROR_LOADING_SECTION: u32 = 165;
pub const EVP_R_EXPECTING_AN_HMAC_KEY: u32 = 174;
pub const EVP_R_EXPECTING_AN_RSA_KEY: u32 = 127;
pub const EVP_R_EXPECTING_A_DH_KEY: u32 = 128;
pub const EVP_R_EXPECTING_A_DSA_KEY: u32 = 129;
pub const EVP_R_EXPECTING_A_ECX_KEY: u32 = 219;
pub const EVP_R_EXPECTING_A_EC_KEY: u32 = 142;
pub const EVP_R_EXPECTING_A_POLY1305_KEY: u32 = 164;
pub const EVP_R_EXPECTING_A_SIPHASH_KEY: u32 = 175;
pub const EVP_R_FINAL_ERROR: u32 = 188;
pub const EVP_R_GENERATE_ERROR: u32 = 214;
pub const EVP_R_GET_RAW_KEY_FAILED: u32 = 182;
pub const EVP_R_ILLEGAL_SCRYPT_PARAMETERS: u32 = 171;
pub const EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS: u32 = 204;
pub const EVP_R_INACCESSIBLE_KEY: u32 = 203;
pub const EVP_R_INITIALIZATION_ERROR: u32 = 134;
pub const EVP_R_INPUT_NOT_INITIALIZED: u32 = 111;
pub const EVP_R_INVALID_CUSTOM_LENGTH: u32 = 185;
pub const EVP_R_INVALID_DIGEST: u32 = 152;
pub const EVP_R_INVALID_IV_LENGTH: u32 = 194;
pub const EVP_R_INVALID_KEY: u32 = 163;
pub const EVP_R_INVALID_KEY_LENGTH: u32 = 130;
pub const EVP_R_INVALID_LENGTH: u32 = 221;
pub const EVP_R_INVALID_NULL_ALGORITHM: u32 = 218;
pub const EVP_R_INVALID_OPERATION: u32 = 148;
pub const EVP_R_INVALID_PROVIDER_FUNCTIONS: u32 = 193;
pub const EVP_R_INVALID_SALT_LENGTH: u32 = 186;
pub const EVP_R_INVALID_SECRET_LENGTH: u32 = 223;
pub const EVP_R_INVALID_SEED_LENGTH: u32 = 220;
pub const EVP_R_INVALID_VALUE: u32 = 222;
pub const EVP_R_KEYMGMT_EXPORT_FAILURE: u32 = 205;
pub const EVP_R_KEY_SETUP_FAILED: u32 = 180;
pub const EVP_R_LOCKING_NOT_SUPPORTED: u32 = 213;
pub const EVP_R_MEMORY_LIMIT_EXCEEDED: u32 = 172;
pub const EVP_R_MESSAGE_DIGEST_IS_NULL: u32 = 159;
pub const EVP_R_METHOD_NOT_SUPPORTED: u32 = 144;
pub const EVP_R_MISSING_PARAMETERS: u32 = 103;
pub const EVP_R_NOT_ABLE_TO_COPY_CTX: u32 = 190;
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH: u32 = 178;
pub const EVP_R_NO_CIPHER_SET: u32 = 131;
pub const EVP_R_NO_DEFAULT_DIGEST: u32 = 158;
pub const EVP_R_NO_DIGEST_SET: u32 = 139;
pub const EVP_R_NO_IMPORT_FUNCTION: u32 = 206;
pub const EVP_R_NO_KEYMGMT_AVAILABLE: u32 = 199;
pub const EVP_R_NO_KEYMGMT_PRESENT: u32 = 196;
pub const EVP_R_NO_KEY_SET: u32 = 154;
pub const EVP_R_NO_OPERATION_SET: u32 = 149;
pub const EVP_R_NULL_MAC_PKEY_CTX: u32 = 208;
pub const EVP_R_ONLY_ONESHOT_SUPPORTED: u32 = 177;
pub const EVP_R_OPERATION_NOT_INITIALIZED: u32 = 151;
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 150;
pub const EVP_R_OUTPUT_WOULD_OVERFLOW: u32 = 202;
pub const EVP_R_PARAMETER_TOO_LARGE: u32 = 187;
pub const EVP_R_PARTIALLY_OVERLAPPING: u32 = 162;
pub const EVP_R_PBKDF2_ERROR: u32 = 181;
pub const EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED: u32 = 179;
pub const EVP_R_PRIVATE_KEY_DECODE_ERROR: u32 = 145;
pub const EVP_R_PRIVATE_KEY_ENCODE_ERROR: u32 = 146;
pub const EVP_R_PUBLIC_KEY_NOT_RSA: u32 = 106;
pub const EVP_R_SETTING_XOF_FAILED: u32 = 227;
pub const EVP_R_SET_DEFAULT_PROPERTY_FAILURE: u32 = 209;
pub const EVP_R_TOO_MANY_RECORDS: u32 = 183;
pub const EVP_R_UNABLE_TO_ENABLE_LOCKING: u32 = 212;
pub const EVP_R_UNABLE_TO_GET_MAXIMUM_REQUEST_SIZE: u32 = 215;
pub const EVP_R_UNABLE_TO_GET_RANDOM_STRENGTH: u32 = 216;
pub const EVP_R_UNABLE_TO_LOCK_CONTEXT: u32 = 211;
pub const EVP_R_UNABLE_TO_SET_CALLBACKS: u32 = 217;
pub const EVP_R_UNKNOWN_CIPHER: u32 = 160;
pub const EVP_R_UNKNOWN_DIGEST: u32 = 161;
pub const EVP_R_UNKNOWN_KEY_TYPE: u32 = 207;
pub const EVP_R_UNKNOWN_OPTION: u32 = 169;
pub const EVP_R_UNKNOWN_PBE_ALGORITHM: u32 = 121;
pub const EVP_R_UNSUPPORTED_ALGORITHM: u32 = 156;
pub const EVP_R_UNSUPPORTED_CIPHER: u32 = 107;
pub const EVP_R_UNSUPPORTED_KEYLENGTH: u32 = 123;
pub const EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION: u32 = 124;
pub const EVP_R_UNSUPPORTED_KEY_SIZE: u32 = 108;
pub const EVP_R_UNSUPPORTED_KEY_TYPE: u32 = 224;
pub const EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS: u32 = 135;
pub const EVP_R_UNSUPPORTED_PRF: u32 = 125;
pub const EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM: u32 = 118;
pub const EVP_R_UNSUPPORTED_SALT_TYPE: u32 = 126;
pub const EVP_R_UPDATE_ERROR: u32 = 189;
pub const EVP_R_WRAP_MODE_NOT_ALLOWED: u32 = 170;
pub const EVP_R_WRONG_FINAL_BLOCK_LENGTH: u32 = 109;
pub const EVP_R_XTS_DATA_UNIT_IS_TOO_LARGE: u32 = 191;
pub const EVP_R_XTS_DUPLICATED_KEYS: u32 = 192;
pub const BN_R_ARG2_LT_ARG3: u32 = 100;
pub const BN_R_BAD_RECIPROCAL: u32 = 101;
pub const BN_R_BIGNUM_TOO_LONG: u32 = 114;
pub const BN_R_BITS_TOO_SMALL: u32 = 118;
pub const BN_R_CALLED_WITH_EVEN_MODULUS: u32 = 102;
pub const BN_R_DIV_BY_ZERO: u32 = 103;
pub const BN_R_ENCODING_ERROR: u32 = 104;
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA: u32 = 105;
pub const BN_R_INPUT_NOT_REDUCED: u32 = 110;
pub const BN_R_INVALID_LENGTH: u32 = 106;
pub const BN_R_INVALID_RANGE: u32 = 115;
pub const BN_R_INVALID_SHIFT: u32 = 119;
pub const BN_R_NOT_A_SQUARE: u32 = 111;
pub const BN_R_NOT_INITIALIZED: u32 = 107;
pub const BN_R_NO_INVERSE: u32 = 108;
pub const BN_R_NO_PRIME_CANDIDATE: u32 = 121;
pub const BN_R_NO_SOLUTION: u32 = 116;
pub const BN_R_NO_SUITABLE_DIGEST: u32 = 120;
pub const BN_R_PRIVATE_KEY_TOO_LARGE: u32 = 117;
pub const BN_R_P_IS_NOT_PRIME: u32 = 112;
pub const BN_R_TOO_MANY_ITERATIONS: u32 = 113;
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES: u32 = 109;
pub const BN_BYTES: u32 = 8;
pub const BN_BITS2: u32 = 64;
pub const BN_BITS: u32 = 128;
pub const BN_FLG_MALLOCED: u32 = 1;
pub const BN_FLG_STATIC_DATA: u32 = 2;
pub const BN_FLG_CONSTTIME: u32 = 4;
pub const BN_FLG_SECURE: u32 = 8;
pub const BN_FLG_EXP_CONSTTIME: u32 = 4;
pub const BN_FLG_FREE: u32 = 32768;
pub const BN_RAND_TOP_ANY: i32 = -1;
pub const BN_RAND_TOP_ONE: u32 = 0;
pub const BN_RAND_TOP_TWO: u32 = 1;
pub const BN_RAND_BOTTOM_ANY: u32 = 0;
pub const BN_RAND_BOTTOM_ODD: u32 = 1;
pub const BN_prime_checks: u32 = 0;
pub const BN_BLINDING_NO_UPDATE: u32 = 1;
pub const BN_BLINDING_NO_RECREATE: u32 = 2;
pub const EVP_MAX_MD_SIZE: u32 = 64;
pub const EVP_MAX_KEY_LENGTH: u32 = 64;
pub const EVP_MAX_IV_LENGTH: u32 = 16;
pub const EVP_MAX_BLOCK_LENGTH: u32 = 32;
pub const PKCS5_SALT_LEN: u32 = 8;
pub const PKCS5_DEFAULT_ITER: u32 = 2048;
pub const SN_undef: &[u8; 6] = b"UNDEF\0";
pub const LN_undef: &[u8; 10] = b"undefined\0";
pub const NID_undef: u32 = 0;
pub const OBJ_undef: u32 = 0;
pub const SN_itu_t: &[u8; 6] = b"ITU-T\0";
pub const LN_itu_t: &[u8; 6] = b"itu-t\0";
pub const NID_itu_t: u32 = 645;
pub const OBJ_itu_t: u32 = 0;
pub const NID_ccitt: u32 = 404;
pub const OBJ_ccitt: u32 = 0;
pub const SN_iso: &[u8; 4] = b"ISO\0";
pub const LN_iso: &[u8; 4] = b"iso\0";
pub const NID_iso: u32 = 181;
pub const OBJ_iso: u32 = 1;
pub const SN_joint_iso_itu_t: &[u8; 16] = b"JOINT-ISO-ITU-T\0";
pub const LN_joint_iso_itu_t: &[u8; 16] = b"joint-iso-itu-t\0";
pub const NID_joint_iso_itu_t: u32 = 646;
pub const OBJ_joint_iso_itu_t: u32 = 2;
pub const NID_joint_iso_ccitt: u32 = 393;
pub const OBJ_joint_iso_ccitt: u32 = 2;
pub const SN_member_body: &[u8; 12] = b"member-body\0";
pub const LN_member_body: &[u8; 16] = b"ISO Member Body\0";
pub const NID_member_body: u32 = 182;
pub const SN_identified_organization: &[u8; 24] = b"identified-organization\0";
pub const NID_identified_organization: u32 = 676;
pub const SN_gmac: &[u8; 5] = b"GMAC\0";
pub const LN_gmac: &[u8; 5] = b"gmac\0";
pub const NID_gmac: u32 = 1195;
pub const SN_hmac_md5: &[u8; 9] = b"HMAC-MD5\0";
pub const LN_hmac_md5: &[u8; 9] = b"hmac-md5\0";
pub const NID_hmac_md5: u32 = 780;
pub const SN_hmac_sha1: &[u8; 10] = b"HMAC-SHA1\0";
pub const LN_hmac_sha1: &[u8; 10] = b"hmac-sha1\0";
pub const NID_hmac_sha1: u32 = 781;
pub const SN_x509ExtAdmission: &[u8; 17] = b"x509ExtAdmission\0";
pub const LN_x509ExtAdmission: &[u8; 48] = b"Professional Information or basis for Admission\0";
pub const NID_x509ExtAdmission: u32 = 1093;
pub const SN_certicom_arc: &[u8; 13] = b"certicom-arc\0";
pub const NID_certicom_arc: u32 = 677;
pub const SN_ieee: &[u8; 5] = b"ieee\0";
pub const NID_ieee: u32 = 1170;
pub const SN_ieee_siswg: &[u8; 11] = b"ieee-siswg\0";
pub const LN_ieee_siswg: &[u8; 39] = b"IEEE Security in Storage Working Group\0";
pub const NID_ieee_siswg: u32 = 1171;
pub const SN_international_organizations: &[u8; 28] = b"international-organizations\0";
pub const LN_international_organizations: &[u8; 28] = b"International Organizations\0";
pub const NID_international_organizations: u32 = 647;
pub const SN_wap: &[u8; 4] = b"wap\0";
pub const NID_wap: u32 = 678;
pub const SN_wap_wsg: &[u8; 8] = b"wap-wsg\0";
pub const NID_wap_wsg: u32 = 679;
pub const SN_selected_attribute_types: &[u8; 25] = b"selected-attribute-types\0";
pub const LN_selected_attribute_types: &[u8; 25] = b"Selected Attribute Types\0";
pub const NID_selected_attribute_types: u32 = 394;
pub const SN_clearance: &[u8; 10] = b"clearance\0";
pub const NID_clearance: u32 = 395;
pub const SN_ISO_US: &[u8; 7] = b"ISO-US\0";
pub const LN_ISO_US: &[u8; 19] = b"ISO US Member Body\0";
pub const NID_ISO_US: u32 = 183;
pub const SN_X9_57: &[u8; 6] = b"X9-57\0";
pub const LN_X9_57: &[u8; 6] = b"X9.57\0";
pub const NID_X9_57: u32 = 184;
pub const SN_X9cm: &[u8; 5] = b"X9cm\0";
pub const LN_X9cm: &[u8; 11] = b"X9.57 CM ?\0";
pub const NID_X9cm: u32 = 185;
pub const SN_ISO_CN: &[u8; 7] = b"ISO-CN\0";
pub const LN_ISO_CN: &[u8; 19] = b"ISO CN Member Body\0";
pub const NID_ISO_CN: u32 = 1140;
pub const SN_oscca: &[u8; 6] = b"oscca\0";
pub const NID_oscca: u32 = 1141;
pub const SN_sm_scheme: &[u8; 10] = b"sm-scheme\0";
pub const NID_sm_scheme: u32 = 1142;
pub const SN_dsa: &[u8; 4] = b"DSA\0";
pub const LN_dsa: &[u8; 14] = b"dsaEncryption\0";
pub const NID_dsa: u32 = 116;
pub const SN_dsaWithSHA1: &[u8; 9] = b"DSA-SHA1\0";
pub const LN_dsaWithSHA1: &[u8; 12] = b"dsaWithSHA1\0";
pub const NID_dsaWithSHA1: u32 = 113;
pub const SN_ansi_X9_62: &[u8; 11] = b"ansi-X9-62\0";
pub const LN_ansi_X9_62: &[u8; 11] = b"ANSI X9.62\0";
pub const NID_ansi_X9_62: u32 = 405;
pub const SN_X9_62_prime_field: &[u8; 12] = b"prime-field\0";
pub const NID_X9_62_prime_field: u32 = 406;
pub const SN_X9_62_characteristic_two_field: &[u8; 25] = b"characteristic-two-field\0";
pub const NID_X9_62_characteristic_two_field: u32 = 407;
pub const SN_X9_62_id_characteristic_two_basis: &[u8; 28] = b"id-characteristic-two-basis\0";
pub const NID_X9_62_id_characteristic_two_basis: u32 = 680;
pub const SN_X9_62_onBasis: &[u8; 8] = b"onBasis\0";
pub const NID_X9_62_onBasis: u32 = 681;
pub const SN_X9_62_tpBasis: &[u8; 8] = b"tpBasis\0";
pub const NID_X9_62_tpBasis: u32 = 682;
pub const SN_X9_62_ppBasis: &[u8; 8] = b"ppBasis\0";
pub const NID_X9_62_ppBasis: u32 = 683;
pub const SN_X9_62_id_ecPublicKey: &[u8; 15] = b"id-ecPublicKey\0";
pub const NID_X9_62_id_ecPublicKey: u32 = 408;
pub const SN_X9_62_c2pnb163v1: &[u8; 11] = b"c2pnb163v1\0";
pub const NID_X9_62_c2pnb163v1: u32 = 684;
pub const SN_X9_62_c2pnb163v2: &[u8; 11] = b"c2pnb163v2\0";
pub const NID_X9_62_c2pnb163v2: u32 = 685;
pub const SN_X9_62_c2pnb163v3: &[u8; 11] = b"c2pnb163v3\0";
pub const NID_X9_62_c2pnb163v3: u32 = 686;
pub const SN_X9_62_c2pnb176v1: &[u8; 11] = b"c2pnb176v1\0";
pub const NID_X9_62_c2pnb176v1: u32 = 687;
pub const SN_X9_62_c2tnb191v1: &[u8; 11] = b"c2tnb191v1\0";
pub const NID_X9_62_c2tnb191v1: u32 = 688;
pub const SN_X9_62_c2tnb191v2: &[u8; 11] = b"c2tnb191v2\0";
pub const NID_X9_62_c2tnb191v2: u32 = 689;
pub const SN_X9_62_c2tnb191v3: &[u8; 11] = b"c2tnb191v3\0";
pub const NID_X9_62_c2tnb191v3: u32 = 690;
pub const SN_X9_62_c2onb191v4: &[u8; 11] = b"c2onb191v4\0";
pub const NID_X9_62_c2onb191v4: u32 = 691;
pub const SN_X9_62_c2onb191v5: &[u8; 11] = b"c2onb191v5\0";
pub const NID_X9_62_c2onb191v5: u32 = 692;
pub const SN_X9_62_c2pnb208w1: &[u8; 11] = b"c2pnb208w1\0";
pub const NID_X9_62_c2pnb208w1: u32 = 693;
pub const SN_X9_62_c2tnb239v1: &[u8; 11] = b"c2tnb239v1\0";
pub const NID_X9_62_c2tnb239v1: u32 = 694;
pub const SN_X9_62_c2tnb239v2: &[u8; 11] = b"c2tnb239v2\0";
pub const NID_X9_62_c2tnb239v2: u32 = 695;
pub const SN_X9_62_c2tnb239v3: &[u8; 11] = b"c2tnb239v3\0";
pub const NID_X9_62_c2tnb239v3: u32 = 696;
pub const SN_X9_62_c2onb239v4: &[u8; 11] = b"c2onb239v4\0";
pub const NID_X9_62_c2onb239v4: u32 = 697;
pub const SN_X9_62_c2onb239v5: &[u8; 11] = b"c2onb239v5\0";
pub const NID_X9_62_c2onb239v5: u32 = 698;
pub const SN_X9_62_c2pnb272w1: &[u8; 11] = b"c2pnb272w1\0";
pub const NID_X9_62_c2pnb272w1: u32 = 699;
pub const SN_X9_62_c2pnb304w1: &[u8; 11] = b"c2pnb304w1\0";
pub const NID_X9_62_c2pnb304w1: u32 = 700;
pub const SN_X9_62_c2tnb359v1: &[u8; 11] = b"c2tnb359v1\0";
pub const NID_X9_62_c2tnb359v1: u32 = 701;
pub const SN_X9_62_c2pnb368w1: &[u8; 11] = b"c2pnb368w1\0";
pub const NID_X9_62_c2pnb368w1: u32 = 702;
pub const SN_X9_62_c2tnb431r1: &[u8; 11] = b"c2tnb431r1\0";
pub const NID_X9_62_c2tnb431r1: u32 = 703;
pub const SN_X9_62_prime192v1: &[u8; 11] = b"prime192v1\0";
pub const NID_X9_62_prime192v1: u32 = 409;
pub const SN_X9_62_prime192v2: &[u8; 11] = b"prime192v2\0";
pub const NID_X9_62_prime192v2: u32 = 410;
pub const SN_X9_62_prime192v3: &[u8; 11] = b"prime192v3\0";
pub const NID_X9_62_prime192v3: u32 = 411;
pub const SN_X9_62_prime239v1: &[u8; 11] = b"prime239v1\0";
pub const NID_X9_62_prime239v1: u32 = 412;
pub const SN_X9_62_prime239v2: &[u8; 11] = b"prime239v2\0";
pub const NID_X9_62_prime239v2: u32 = 413;
pub const SN_X9_62_prime239v3: &[u8; 11] = b"prime239v3\0";
pub const NID_X9_62_prime239v3: u32 = 414;
pub const SN_X9_62_prime256v1: &[u8; 11] = b"prime256v1\0";
pub const NID_X9_62_prime256v1: u32 = 415;
pub const SN_ecdsa_with_SHA1: &[u8; 16] = b"ecdsa-with-SHA1\0";
pub const NID_ecdsa_with_SHA1: u32 = 416;
pub const SN_ecdsa_with_Recommended: &[u8; 23] = b"ecdsa-with-Recommended\0";
pub const NID_ecdsa_with_Recommended: u32 = 791;
pub const SN_ecdsa_with_Specified: &[u8; 21] = b"ecdsa-with-Specified\0";
pub const NID_ecdsa_with_Specified: u32 = 792;
pub const SN_ecdsa_with_SHA224: &[u8; 18] = b"ecdsa-with-SHA224\0";
pub const NID_ecdsa_with_SHA224: u32 = 793;
pub const SN_ecdsa_with_SHA256: &[u8; 18] = b"ecdsa-with-SHA256\0";
pub const NID_ecdsa_with_SHA256: u32 = 794;
pub const SN_ecdsa_with_SHA384: &[u8; 18] = b"ecdsa-with-SHA384\0";
pub const NID_ecdsa_with_SHA384: u32 = 795;
pub const SN_ecdsa_with_SHA512: &[u8; 18] = b"ecdsa-with-SHA512\0";
pub const NID_ecdsa_with_SHA512: u32 = 796;
pub const SN_secp112r1: &[u8; 10] = b"secp112r1\0";
pub const NID_secp112r1: u32 = 704;
pub const SN_secp112r2: &[u8; 10] = b"secp112r2\0";
pub const NID_secp112r2: u32 = 705;
pub const SN_secp128r1: &[u8; 10] = b"secp128r1\0";
pub const NID_secp128r1: u32 = 706;
pub const SN_secp128r2: &[u8; 10] = b"secp128r2\0";
pub const NID_secp128r2: u32 = 707;
pub const SN_secp160k1: &[u8; 10] = b"secp160k1\0";
pub const NID_secp160k1: u32 = 708;
pub const SN_secp160r1: &[u8; 10] = b"secp160r1\0";
pub const NID_secp160r1: u32 = 709;
pub const SN_secp160r2: &[u8; 10] = b"secp160r2\0";
pub const NID_secp160r2: u32 = 710;
pub const SN_secp192k1: &[u8; 10] = b"secp192k1\0";
pub const NID_secp192k1: u32 = 711;
pub const SN_secp224k1: &[u8; 10] = b"secp224k1\0";
pub const NID_secp224k1: u32 = 712;
pub const SN_secp224r1: &[u8; 10] = b"secp224r1\0";
pub const NID_secp224r1: u32 = 713;
pub const SN_secp256k1: &[u8; 10] = b"secp256k1\0";
pub const NID_secp256k1: u32 = 714;
pub const SN_secp384r1: &[u8; 10] = b"secp384r1\0";
pub const NID_secp384r1: u32 = 715;
pub const SN_secp521r1: &[u8; 10] = b"secp521r1\0";
pub const NID_secp521r1: u32 = 716;
pub const SN_sect113r1: &[u8; 10] = b"sect113r1\0";
pub const NID_sect113r1: u32 = 717;
pub const SN_sect113r2: &[u8; 10] = b"sect113r2\0";
pub const NID_sect113r2: u32 = 718;
pub const SN_sect131r1: &[u8; 10] = b"sect131r1\0";
pub const NID_sect131r1: u32 = 719;
pub const SN_sect131r2: &[u8; 10] = b"sect131r2\0";
pub const NID_sect131r2: u32 = 720;
pub const SN_sect163k1: &[u8; 10] = b"sect163k1\0";
pub const NID_sect163k1: u32 = 721;
pub const SN_sect163r1: &[u8; 10] = b"sect163r1\0";
pub const NID_sect163r1: u32 = 722;
pub const SN_sect163r2: &[u8; 10] = b"sect163r2\0";
pub const NID_sect163r2: u32 = 723;
pub const SN_sect193r1: &[u8; 10] = b"sect193r1\0";
pub const NID_sect193r1: u32 = 724;
pub const SN_sect193r2: &[u8; 10] = b"sect193r2\0";
pub const NID_sect193r2: u32 = 725;
pub const SN_sect233k1: &[u8; 10] = b"sect233k1\0";
pub const NID_sect233k1: u32 = 726;
pub const SN_sect233r1: &[u8; 10] = b"sect233r1\0";
pub const NID_sect233r1: u32 = 727;
pub const SN_sect239k1: &[u8; 10] = b"sect239k1\0";
pub const NID_sect239k1: u32 = 728;
pub const SN_sect283k1: &[u8; 10] = b"sect283k1\0";
pub const NID_sect283k1: u32 = 729;
pub const SN_sect283r1: &[u8; 10] = b"sect283r1\0";
pub const NID_sect283r1: u32 = 730;
pub const SN_sect409k1: &[u8; 10] = b"sect409k1\0";
pub const NID_sect409k1: u32 = 731;
pub const SN_sect409r1: &[u8; 10] = b"sect409r1\0";
pub const NID_sect409r1: u32 = 732;
pub const SN_sect571k1: &[u8; 10] = b"sect571k1\0";
pub const NID_sect571k1: u32 = 733;
pub const SN_sect571r1: &[u8; 10] = b"sect571r1\0";
pub const NID_sect571r1: u32 = 734;
pub const SN_wap_wsg_idm_ecid_wtls1: &[u8; 23] = b"wap-wsg-idm-ecid-wtls1\0";
pub const NID_wap_wsg_idm_ecid_wtls1: u32 = 735;
pub const SN_wap_wsg_idm_ecid_wtls3: &[u8; 23] = b"wap-wsg-idm-ecid-wtls3\0";
pub const NID_wap_wsg_idm_ecid_wtls3: u32 = 736;
pub const SN_wap_wsg_idm_ecid_wtls4: &[u8; 23] = b"wap-wsg-idm-ecid-wtls4\0";
pub const NID_wap_wsg_idm_ecid_wtls4: u32 = 737;
pub const SN_wap_wsg_idm_ecid_wtls5: &[u8; 23] = b"wap-wsg-idm-ecid-wtls5\0";
pub const NID_wap_wsg_idm_ecid_wtls5: u32 = 738;
pub const SN_wap_wsg_idm_ecid_wtls6: &[u8; 23] = b"wap-wsg-idm-ecid-wtls6\0";
pub const NID_wap_wsg_idm_ecid_wtls6: u32 = 739;
pub const SN_wap_wsg_idm_ecid_wtls7: &[u8; 23] = b"wap-wsg-idm-ecid-wtls7\0";
pub const NID_wap_wsg_idm_ecid_wtls7: u32 = 740;
pub const SN_wap_wsg_idm_ecid_wtls8: &[u8; 23] = b"wap-wsg-idm-ecid-wtls8\0";
pub const NID_wap_wsg_idm_ecid_wtls8: u32 = 741;
pub const SN_wap_wsg_idm_ecid_wtls9: &[u8; 23] = b"wap-wsg-idm-ecid-wtls9\0";
pub const NID_wap_wsg_idm_ecid_wtls9: u32 = 742;
pub const SN_wap_wsg_idm_ecid_wtls10: &[u8; 24] = b"wap-wsg-idm-ecid-wtls10\0";
pub const NID_wap_wsg_idm_ecid_wtls10: u32 = 743;
pub const SN_wap_wsg_idm_ecid_wtls11: &[u8; 24] = b"wap-wsg-idm-ecid-wtls11\0";
pub const NID_wap_wsg_idm_ecid_wtls11: u32 = 744;
pub const SN_wap_wsg_idm_ecid_wtls12: &[u8; 24] = b"wap-wsg-idm-ecid-wtls12\0";
pub const NID_wap_wsg_idm_ecid_wtls12: u32 = 745;
pub const SN_cast5_cbc: &[u8; 10] = b"CAST5-CBC\0";
pub const LN_cast5_cbc: &[u8; 10] = b"cast5-cbc\0";
pub const NID_cast5_cbc: u32 = 108;
pub const SN_cast5_ecb: &[u8; 10] = b"CAST5-ECB\0";
pub const LN_cast5_ecb: &[u8; 10] = b"cast5-ecb\0";
pub const NID_cast5_ecb: u32 = 109;
pub const SN_cast5_cfb64: &[u8; 10] = b"CAST5-CFB\0";
pub const LN_cast5_cfb64: &[u8; 10] = b"cast5-cfb\0";
pub const NID_cast5_cfb64: u32 = 110;
pub const SN_cast5_ofb64: &[u8; 10] = b"CAST5-OFB\0";
pub const LN_cast5_ofb64: &[u8; 10] = b"cast5-ofb\0";
pub const NID_cast5_ofb64: u32 = 111;
pub const LN_pbeWithMD5AndCast5_CBC: &[u8; 22] = b"pbeWithMD5AndCast5CBC\0";
pub const NID_pbeWithMD5AndCast5_CBC: u32 = 112;
pub const SN_id_PasswordBasedMAC: &[u8; 20] = b"id-PasswordBasedMAC\0";
pub const LN_id_PasswordBasedMAC: &[u8; 19] = b"password based MAC\0";
pub const NID_id_PasswordBasedMAC: u32 = 782;
pub const SN_id_DHBasedMac: &[u8; 14] = b"id-DHBasedMac\0";
pub const LN_id_DHBasedMac: &[u8; 25] = b"Diffie-Hellman based MAC\0";
pub const NID_id_DHBasedMac: u32 = 783;
pub const SN_rsadsi: &[u8; 7] = b"rsadsi\0";
pub const LN_rsadsi: &[u8; 24] = b"RSA Data Security, Inc.\0";
pub const NID_rsadsi: u32 = 1;
pub const SN_pkcs: &[u8; 5] = b"pkcs\0";
pub const LN_pkcs: &[u8; 29] = b"RSA Data Security, Inc. PKCS\0";
pub const NID_pkcs: u32 = 2;
pub const SN_pkcs1: &[u8; 6] = b"pkcs1\0";
pub const NID_pkcs1: u32 = 186;
pub const LN_rsaEncryption: &[u8; 14] = b"rsaEncryption\0";
pub const NID_rsaEncryption: u32 = 6;
pub const SN_md2WithRSAEncryption: &[u8; 8] = b"RSA-MD2\0";
pub const LN_md2WithRSAEncryption: &[u8; 21] = b"md2WithRSAEncryption\0";
pub const NID_md2WithRSAEncryption: u32 = 7;
pub const SN_md4WithRSAEncryption: &[u8; 8] = b"RSA-MD4\0";
pub const LN_md4WithRSAEncryption: &[u8; 21] = b"md4WithRSAEncryption\0";
pub const NID_md4WithRSAEncryption: u32 = 396;
pub const SN_md5WithRSAEncryption: &[u8; 8] = b"RSA-MD5\0";
pub const LN_md5WithRSAEncryption: &[u8; 21] = b"md5WithRSAEncryption\0";
pub const NID_md5WithRSAEncryption: u32 = 8;
pub const SN_sha1WithRSAEncryption: &[u8; 9] = b"RSA-SHA1\0";
pub const LN_sha1WithRSAEncryption: &[u8; 22] = b"sha1WithRSAEncryption\0";
pub const NID_sha1WithRSAEncryption: u32 = 65;
pub const SN_rsaesOaep: &[u8; 11] = b"RSAES-OAEP\0";
pub const LN_rsaesOaep: &[u8; 10] = b"rsaesOaep\0";
pub const NID_rsaesOaep: u32 = 919;
pub const SN_mgf1: &[u8; 5] = b"MGF1\0";
pub const LN_mgf1: &[u8; 5] = b"mgf1\0";
pub const NID_mgf1: u32 = 911;
pub const SN_pSpecified: &[u8; 11] = b"PSPECIFIED\0";
pub const LN_pSpecified: &[u8; 11] = b"pSpecified\0";
pub const NID_pSpecified: u32 = 935;
pub const SN_rsassaPss: &[u8; 11] = b"RSASSA-PSS\0";
pub const LN_rsassaPss: &[u8; 10] = b"rsassaPss\0";
pub const NID_rsassaPss: u32 = 912;
pub const SN_sha256WithRSAEncryption: &[u8; 11] = b"RSA-SHA256\0";
pub const LN_sha256WithRSAEncryption: &[u8; 24] = b"sha256WithRSAEncryption\0";
pub const NID_sha256WithRSAEncryption: u32 = 668;
pub const SN_sha384WithRSAEncryption: &[u8; 11] = b"RSA-SHA384\0";
pub const LN_sha384WithRSAEncryption: &[u8; 24] = b"sha384WithRSAEncryption\0";
pub const NID_sha384WithRSAEncryption: u32 = 669;
pub const SN_sha512WithRSAEncryption: &[u8; 11] = b"RSA-SHA512\0";
pub const LN_sha512WithRSAEncryption: &[u8; 24] = b"sha512WithRSAEncryption\0";
pub const NID_sha512WithRSAEncryption: u32 = 670;
pub const SN_sha224WithRSAEncryption: &[u8; 11] = b"RSA-SHA224\0";
pub const LN_sha224WithRSAEncryption: &[u8; 24] = b"sha224WithRSAEncryption\0";
pub const NID_sha224WithRSAEncryption: u32 = 671;
pub const SN_sha512_224WithRSAEncryption: &[u8; 15] = b"RSA-SHA512/224\0";
pub const LN_sha512_224WithRSAEncryption: &[u8; 28] = b"sha512-224WithRSAEncryption\0";
pub const NID_sha512_224WithRSAEncryption: u32 = 1145;
pub const SN_sha512_256WithRSAEncryption: &[u8; 15] = b"RSA-SHA512/256\0";
pub const LN_sha512_256WithRSAEncryption: &[u8; 28] = b"sha512-256WithRSAEncryption\0";
pub const NID_sha512_256WithRSAEncryption: u32 = 1146;
pub const SN_pkcs3: &[u8; 6] = b"pkcs3\0";
pub const NID_pkcs3: u32 = 27;
pub const LN_dhKeyAgreement: &[u8; 15] = b"dhKeyAgreement\0";
pub const NID_dhKeyAgreement: u32 = 28;
pub const SN_pkcs5: &[u8; 6] = b"pkcs5\0";
pub const NID_pkcs5: u32 = 187;
pub const SN_pbeWithMD2AndDES_CBC: &[u8; 12] = b"PBE-MD2-DES\0";
pub const LN_pbeWithMD2AndDES_CBC: &[u8; 21] = b"pbeWithMD2AndDES-CBC\0";
pub const NID_pbeWithMD2AndDES_CBC: u32 = 9;
pub const SN_pbeWithMD5AndDES_CBC: &[u8; 12] = b"PBE-MD5-DES\0";
pub const LN_pbeWithMD5AndDES_CBC: &[u8; 21] = b"pbeWithMD5AndDES-CBC\0";
pub const NID_pbeWithMD5AndDES_CBC: u32 = 10;
pub const SN_pbeWithMD2AndRC2_CBC: &[u8; 15] = b"PBE-MD2-RC2-64\0";
pub const LN_pbeWithMD2AndRC2_CBC: &[u8; 21] = b"pbeWithMD2AndRC2-CBC\0";
pub const NID_pbeWithMD2AndRC2_CBC: u32 = 168;
pub const SN_pbeWithMD5AndRC2_CBC: &[u8; 15] = b"PBE-MD5-RC2-64\0";
pub const LN_pbeWithMD5AndRC2_CBC: &[u8; 21] = b"pbeWithMD5AndRC2-CBC\0";
pub const NID_pbeWithMD5AndRC2_CBC: u32 = 169;
pub const SN_pbeWithSHA1AndDES_CBC: &[u8; 13] = b"PBE-SHA1-DES\0";
pub const LN_pbeWithSHA1AndDES_CBC: &[u8; 22] = b"pbeWithSHA1AndDES-CBC\0";
pub const NID_pbeWithSHA1AndDES_CBC: u32 = 170;
pub const SN_pbeWithSHA1AndRC2_CBC: &[u8; 16] = b"PBE-SHA1-RC2-64\0";
pub const LN_pbeWithSHA1AndRC2_CBC: &[u8; 22] = b"pbeWithSHA1AndRC2-CBC\0";
pub const NID_pbeWithSHA1AndRC2_CBC: u32 = 68;
pub const LN_id_pbkdf2: &[u8; 7] = b"PBKDF2\0";
pub const NID_id_pbkdf2: u32 = 69;
pub const LN_pbes2: &[u8; 6] = b"PBES2\0";
pub const NID_pbes2: u32 = 161;
pub const LN_pbmac1: &[u8; 7] = b"PBMAC1\0";
pub const NID_pbmac1: u32 = 162;
pub const SN_pkcs7: &[u8; 6] = b"pkcs7\0";
pub const NID_pkcs7: u32 = 20;
pub const LN_pkcs7_data: &[u8; 11] = b"pkcs7-data\0";
pub const NID_pkcs7_data: u32 = 21;
pub const LN_pkcs7_signed: &[u8; 17] = b"pkcs7-signedData\0";
pub const NID_pkcs7_signed: u32 = 22;
pub const LN_pkcs7_enveloped: &[u8; 20] = b"pkcs7-envelopedData\0";
pub const NID_pkcs7_enveloped: u32 = 23;
pub const LN_pkcs7_signedAndEnveloped: &[u8; 29] = b"pkcs7-signedAndEnvelopedData\0";
pub const NID_pkcs7_signedAndEnveloped: u32 = 24;
pub const LN_pkcs7_digest: &[u8; 17] = b"pkcs7-digestData\0";
pub const NID_pkcs7_digest: u32 = 25;
pub const LN_pkcs7_encrypted: &[u8; 20] = b"pkcs7-encryptedData\0";
pub const NID_pkcs7_encrypted: u32 = 26;
pub const SN_pkcs9: &[u8; 6] = b"pkcs9\0";
pub const NID_pkcs9: u32 = 47;
pub const LN_pkcs9_emailAddress: &[u8; 13] = b"emailAddress\0";
pub const NID_pkcs9_emailAddress: u32 = 48;
pub const LN_pkcs9_unstructuredName: &[u8; 17] = b"unstructuredName\0";
pub const NID_pkcs9_unstructuredName: u32 = 49;
pub const LN_pkcs9_contentType: &[u8; 12] = b"contentType\0";
pub const NID_pkcs9_contentType: u32 = 50;
pub const LN_pkcs9_messageDigest: &[u8; 14] = b"messageDigest\0";
pub const NID_pkcs9_messageDigest: u32 = 51;
pub const LN_pkcs9_signingTime: &[u8; 12] = b"signingTime\0";
pub const NID_pkcs9_signingTime: u32 = 52;
pub const LN_pkcs9_countersignature: &[u8; 17] = b"countersignature\0";
pub const NID_pkcs9_countersignature: u32 = 53;
pub const LN_pkcs9_challengePassword: &[u8; 18] = b"challengePassword\0";
pub const NID_pkcs9_challengePassword: u32 = 54;
pub const LN_pkcs9_unstructuredAddress: &[u8; 20] = b"unstructuredAddress\0";
pub const NID_pkcs9_unstructuredAddress: u32 = 55;
pub const LN_pkcs9_extCertAttributes: &[u8; 30] = b"extendedCertificateAttributes\0";
pub const NID_pkcs9_extCertAttributes: u32 = 56;
pub const SN_ext_req: &[u8; 7] = b"extReq\0";
pub const LN_ext_req: &[u8; 18] = b"Extension Request\0";
pub const NID_ext_req: u32 = 172;
pub const SN_SMIMECapabilities: &[u8; 11] = b"SMIME-CAPS\0";
pub const LN_SMIMECapabilities: &[u8; 20] = b"S/MIME Capabilities\0";
pub const NID_SMIMECapabilities: u32 = 167;
pub const SN_SMIME: &[u8; 6] = b"SMIME\0";
pub const LN_SMIME: &[u8; 7] = b"S/MIME\0";
pub const NID_SMIME: u32 = 188;
pub const SN_id_smime_mod: &[u8; 13] = b"id-smime-mod\0";
pub const NID_id_smime_mod: u32 = 189;
pub const SN_id_smime_ct: &[u8; 12] = b"id-smime-ct\0";
pub const NID_id_smime_ct: u32 = 190;
pub const SN_id_smime_aa: &[u8; 12] = b"id-smime-aa\0";
pub const NID_id_smime_aa: u32 = 191;
pub const SN_id_smime_alg: &[u8; 13] = b"id-smime-alg\0";
pub const NID_id_smime_alg: u32 = 192;
pub const SN_id_smime_cd: &[u8; 12] = b"id-smime-cd\0";
pub const NID_id_smime_cd: u32 = 193;
pub const SN_id_smime_spq: &[u8; 13] = b"id-smime-spq\0";
pub const NID_id_smime_spq: u32 = 194;
pub const SN_id_smime_cti: &[u8; 13] = b"id-smime-cti\0";
pub const NID_id_smime_cti: u32 = 195;
pub const SN_id_smime_mod_cms: &[u8; 17] = b"id-smime-mod-cms\0";
pub const NID_id_smime_mod_cms: u32 = 196;
pub const SN_id_smime_mod_ess: &[u8; 17] = b"id-smime-mod-ess\0";
pub const NID_id_smime_mod_ess: u32 = 197;
pub const SN_id_smime_mod_oid: &[u8; 17] = b"id-smime-mod-oid\0";
pub const NID_id_smime_mod_oid: u32 = 198;
pub const SN_id_smime_mod_msg_v3: &[u8; 20] = b"id-smime-mod-msg-v3\0";
pub const NID_id_smime_mod_msg_v3: u32 = 199;
pub const SN_id_smime_mod_ets_eSignature_88: &[u8; 31] = b"id-smime-mod-ets-eSignature-88\0";
pub const NID_id_smime_mod_ets_eSignature_88: u32 = 200;
pub const SN_id_smime_mod_ets_eSignature_97: &[u8; 31] = b"id-smime-mod-ets-eSignature-97\0";
pub const NID_id_smime_mod_ets_eSignature_97: u32 = 201;
pub const SN_id_smime_mod_ets_eSigPolicy_88: &[u8; 31] = b"id-smime-mod-ets-eSigPolicy-88\0";
pub const NID_id_smime_mod_ets_eSigPolicy_88: u32 = 202;
pub const SN_id_smime_mod_ets_eSigPolicy_97: &[u8; 31] = b"id-smime-mod-ets-eSigPolicy-97\0";
pub const NID_id_smime_mod_ets_eSigPolicy_97: u32 = 203;
pub const SN_id_smime_ct_receipt: &[u8; 20] = b"id-smime-ct-receipt\0";
pub const NID_id_smime_ct_receipt: u32 = 204;
pub const SN_id_smime_ct_authData: &[u8; 21] = b"id-smime-ct-authData\0";
pub const NID_id_smime_ct_authData: u32 = 205;
pub const SN_id_smime_ct_publishCert: &[u8; 24] = b"id-smime-ct-publishCert\0";
pub const NID_id_smime_ct_publishCert: u32 = 206;
pub const SN_id_smime_ct_TSTInfo: &[u8; 20] = b"id-smime-ct-TSTInfo\0";
pub const NID_id_smime_ct_TSTInfo: u32 = 207;
pub const SN_id_smime_ct_TDTInfo: &[u8; 20] = b"id-smime-ct-TDTInfo\0";
pub const NID_id_smime_ct_TDTInfo: u32 = 208;
pub const SN_id_smime_ct_contentInfo: &[u8; 24] = b"id-smime-ct-contentInfo\0";
pub const NID_id_smime_ct_contentInfo: u32 = 209;
pub const SN_id_smime_ct_DVCSRequestData: &[u8; 28] = b"id-smime-ct-DVCSRequestData\0";
pub const NID_id_smime_ct_DVCSRequestData: u32 = 210;
pub const SN_id_smime_ct_DVCSResponseData: &[u8; 29] = b"id-smime-ct-DVCSResponseData\0";
pub const NID_id_smime_ct_DVCSResponseData: u32 = 211;
pub const SN_id_smime_ct_compressedData: &[u8; 27] = b"id-smime-ct-compressedData\0";
pub const NID_id_smime_ct_compressedData: u32 = 786;
pub const SN_id_smime_ct_contentCollection: &[u8; 30] = b"id-smime-ct-contentCollection\0";
pub const NID_id_smime_ct_contentCollection: u32 = 1058;
pub const SN_id_smime_ct_authEnvelopedData: &[u8; 30] = b"id-smime-ct-authEnvelopedData\0";
pub const NID_id_smime_ct_authEnvelopedData: u32 = 1059;
pub const SN_id_ct_routeOriginAuthz: &[u8; 23] = b"id-ct-routeOriginAuthz\0";
pub const NID_id_ct_routeOriginAuthz: u32 = 1234;
pub const SN_id_ct_rpkiManifest: &[u8; 19] = b"id-ct-rpkiManifest\0";
pub const NID_id_ct_rpkiManifest: u32 = 1235;
pub const SN_id_ct_asciiTextWithCRLF: &[u8; 24] = b"id-ct-asciiTextWithCRLF\0";
pub const NID_id_ct_asciiTextWithCRLF: u32 = 787;
pub const SN_id_ct_xml: &[u8; 10] = b"id-ct-xml\0";
pub const NID_id_ct_xml: u32 = 1060;
pub const SN_id_ct_rpkiGhostbusters: &[u8; 23] = b"id-ct-rpkiGhostbusters\0";
pub const NID_id_ct_rpkiGhostbusters: u32 = 1236;
pub const SN_id_ct_resourceTaggedAttest: &[u8; 27] = b"id-ct-resourceTaggedAttest\0";
pub const NID_id_ct_resourceTaggedAttest: u32 = 1237;
pub const SN_id_ct_geofeedCSVwithCRLF: &[u8; 25] = b"id-ct-geofeedCSVwithCRLF\0";
pub const NID_id_ct_geofeedCSVwithCRLF: u32 = 1246;
pub const SN_id_ct_signedChecklist: &[u8; 22] = b"id-ct-signedChecklist\0";
pub const NID_id_ct_signedChecklist: u32 = 1247;
pub const SN_id_smime_aa_receiptRequest: &[u8; 27] = b"id-smime-aa-receiptRequest\0";
pub const NID_id_smime_aa_receiptRequest: u32 = 212;
pub const SN_id_smime_aa_securityLabel: &[u8; 26] = b"id-smime-aa-securityLabel\0";
pub const NID_id_smime_aa_securityLabel: u32 = 213;
pub const SN_id_smime_aa_mlExpandHistory: &[u8; 28] = b"id-smime-aa-mlExpandHistory\0";
pub const NID_id_smime_aa_mlExpandHistory: u32 = 214;
pub const SN_id_smime_aa_contentHint: &[u8; 24] = b"id-smime-aa-contentHint\0";
pub const NID_id_smime_aa_contentHint: u32 = 215;
pub const SN_id_smime_aa_msgSigDigest: &[u8; 25] = b"id-smime-aa-msgSigDigest\0";
pub const NID_id_smime_aa_msgSigDigest: u32 = 216;
pub const SN_id_smime_aa_encapContentType: &[u8; 29] = b"id-smime-aa-encapContentType\0";
pub const NID_id_smime_aa_encapContentType: u32 = 217;
pub const SN_id_smime_aa_contentIdentifier: &[u8; 30] = b"id-smime-aa-contentIdentifier\0";
pub const NID_id_smime_aa_contentIdentifier: u32 = 218;
pub const SN_id_smime_aa_macValue: &[u8; 21] = b"id-smime-aa-macValue\0";
pub const NID_id_smime_aa_macValue: u32 = 219;
pub const SN_id_smime_aa_equivalentLabels: &[u8; 29] = b"id-smime-aa-equivalentLabels\0";
pub const NID_id_smime_aa_equivalentLabels: u32 = 220;
pub const SN_id_smime_aa_contentReference: &[u8; 29] = b"id-smime-aa-contentReference\0";
pub const NID_id_smime_aa_contentReference: u32 = 221;
pub const SN_id_smime_aa_encrypKeyPref: &[u8; 26] = b"id-smime-aa-encrypKeyPref\0";
pub const NID_id_smime_aa_encrypKeyPref: u32 = 222;
pub const SN_id_smime_aa_signingCertificate: &[u8; 31] = b"id-smime-aa-signingCertificate\0";
pub const NID_id_smime_aa_signingCertificate: u32 = 223;
pub const SN_id_smime_aa_smimeEncryptCerts: &[u8; 30] = b"id-smime-aa-smimeEncryptCerts\0";
pub const NID_id_smime_aa_smimeEncryptCerts: u32 = 224;
pub const SN_id_smime_aa_timeStampToken: &[u8; 27] = b"id-smime-aa-timeStampToken\0";
pub const NID_id_smime_aa_timeStampToken: u32 = 225;
pub const SN_id_smime_aa_ets_sigPolicyId: &[u8; 28] = b"id-smime-aa-ets-sigPolicyId\0";
pub const NID_id_smime_aa_ets_sigPolicyId: u32 = 226;
pub const SN_id_smime_aa_ets_commitmentType: &[u8; 31] = b"id-smime-aa-ets-commitmentType\0";
pub const NID_id_smime_aa_ets_commitmentType: u32 = 227;
pub const SN_id_smime_aa_ets_signerLocation: &[u8; 31] = b"id-smime-aa-ets-signerLocation\0";
pub const NID_id_smime_aa_ets_signerLocation: u32 = 228;
pub const SN_id_smime_aa_ets_signerAttr: &[u8; 27] = b"id-smime-aa-ets-signerAttr\0";
pub const NID_id_smime_aa_ets_signerAttr: u32 = 229;
pub const SN_id_smime_aa_ets_otherSigCert: &[u8; 29] = b"id-smime-aa-ets-otherSigCert\0";
pub const NID_id_smime_aa_ets_otherSigCert: u32 = 230;
pub const SN_id_smime_aa_ets_contentTimestamp: &[u8; 33] = b"id-smime-aa-ets-contentTimestamp\0";
pub const NID_id_smime_aa_ets_contentTimestamp: u32 = 231;
pub const SN_id_smime_aa_ets_CertificateRefs: &[u8; 32] = b"id-smime-aa-ets-CertificateRefs\0";
pub const NID_id_smime_aa_ets_CertificateRefs: u32 = 232;
pub const SN_id_smime_aa_ets_RevocationRefs: &[u8; 31] = b"id-smime-aa-ets-RevocationRefs\0";
pub const NID_id_smime_aa_ets_RevocationRefs: u32 = 233;
pub const SN_id_smime_aa_ets_certValues: &[u8; 27] = b"id-smime-aa-ets-certValues\0";
pub const NID_id_smime_aa_ets_certValues: u32 = 234;
pub const SN_id_smime_aa_ets_revocationValues: &[u8; 33] = b"id-smime-aa-ets-revocationValues\0";
pub const NID_id_smime_aa_ets_revocationValues: u32 = 235;
pub const SN_id_smime_aa_ets_escTimeStamp: &[u8; 29] = b"id-smime-aa-ets-escTimeStamp\0";
pub const NID_id_smime_aa_ets_escTimeStamp: u32 = 236;
pub const SN_id_smime_aa_ets_certCRLTimestamp: &[u8; 33] = b"id-smime-aa-ets-certCRLTimestamp\0";
pub const NID_id_smime_aa_ets_certCRLTimestamp: u32 = 237;
pub const SN_id_smime_aa_ets_archiveTimeStamp: &[u8; 33] = b"id-smime-aa-ets-archiveTimeStamp\0";
pub const NID_id_smime_aa_ets_archiveTimeStamp: u32 = 238;
pub const SN_id_smime_aa_signatureType: &[u8; 26] = b"id-smime-aa-signatureType\0";
pub const NID_id_smime_aa_signatureType: u32 = 239;
pub const SN_id_smime_aa_dvcs_dvc: &[u8; 21] = b"id-smime-aa-dvcs-dvc\0";
pub const NID_id_smime_aa_dvcs_dvc: u32 = 240;
pub const SN_id_smime_aa_signingCertificateV2: &[u8; 33] = b"id-smime-aa-signingCertificateV2\0";
pub const NID_id_smime_aa_signingCertificateV2: u32 = 1086;
pub const SN_id_smime_alg_ESDHwith3DES: &[u8; 26] = b"id-smime-alg-ESDHwith3DES\0";
pub const NID_id_smime_alg_ESDHwith3DES: u32 = 241;
pub const SN_id_smime_alg_ESDHwithRC2: &[u8; 25] = b"id-smime-alg-ESDHwithRC2\0";
pub const NID_id_smime_alg_ESDHwithRC2: u32 = 242;
pub const SN_id_smime_alg_3DESwrap: &[u8; 22] = b"id-smime-alg-3DESwrap\0";
pub const NID_id_smime_alg_3DESwrap: u32 = 243;
pub const SN_id_smime_alg_RC2wrap: &[u8; 21] = b"id-smime-alg-RC2wrap\0";
pub const NID_id_smime_alg_RC2wrap: u32 = 244;
pub const SN_id_smime_alg_ESDH: &[u8; 18] = b"id-smime-alg-ESDH\0";
pub const NID_id_smime_alg_ESDH: u32 = 245;
pub const SN_id_smime_alg_CMS3DESwrap: &[u8; 25] = b"id-smime-alg-CMS3DESwrap\0";
pub const NID_id_smime_alg_CMS3DESwrap: u32 = 246;
pub const SN_id_smime_alg_CMSRC2wrap: &[u8; 24] = b"id-smime-alg-CMSRC2wrap\0";
pub const NID_id_smime_alg_CMSRC2wrap: u32 = 247;
pub const SN_id_alg_PWRI_KEK: &[u8; 16] = b"id-alg-PWRI-KEK\0";
pub const NID_id_alg_PWRI_KEK: u32 = 893;
pub const SN_id_smime_cd_ldap: &[u8; 17] = b"id-smime-cd-ldap\0";
pub const NID_id_smime_cd_ldap: u32 = 248;
pub const SN_id_smime_spq_ets_sqt_uri: &[u8; 25] = b"id-smime-spq-ets-sqt-uri\0";
pub const NID_id_smime_spq_ets_sqt_uri: u32 = 249;
pub const SN_id_smime_spq_ets_sqt_unotice: &[u8; 29] = b"id-smime-spq-ets-sqt-unotice\0";
pub const NID_id_smime_spq_ets_sqt_unotice: u32 = 250;
pub const SN_id_smime_cti_ets_proofOfOrigin: &[u8; 31] = b"id-smime-cti-ets-proofOfOrigin\0";
pub const NID_id_smime_cti_ets_proofOfOrigin: u32 = 251;
pub const SN_id_smime_cti_ets_proofOfReceipt: &[u8; 32] = b"id-smime-cti-ets-proofOfReceipt\0";
pub const NID_id_smime_cti_ets_proofOfReceipt: u32 = 252;
pub const SN_id_smime_cti_ets_proofOfDelivery: &[u8; 33] = b"id-smime-cti-ets-proofOfDelivery\0";
pub const NID_id_smime_cti_ets_proofOfDelivery: u32 = 253;
pub const SN_id_smime_cti_ets_proofOfSender: &[u8; 31] = b"id-smime-cti-ets-proofOfSender\0";
pub const NID_id_smime_cti_ets_proofOfSender: u32 = 254;
pub const SN_id_smime_cti_ets_proofOfApproval: &[u8; 33] = b"id-smime-cti-ets-proofOfApproval\0";
pub const NID_id_smime_cti_ets_proofOfApproval: u32 = 255;
pub const SN_id_smime_cti_ets_proofOfCreation: &[u8; 33] = b"id-smime-cti-ets-proofOfCreation\0";
pub const NID_id_smime_cti_ets_proofOfCreation: u32 = 256;
pub const LN_friendlyName: &[u8; 13] = b"friendlyName\0";
pub const NID_friendlyName: u32 = 156;
pub const LN_localKeyID: &[u8; 11] = b"localKeyID\0";
pub const NID_localKeyID: u32 = 157;
pub const SN_ms_csp_name: &[u8; 8] = b"CSPName\0";
pub const LN_ms_csp_name: &[u8; 19] = b"Microsoft CSP Name\0";
pub const NID_ms_csp_name: u32 = 417;
pub const SN_LocalKeySet: &[u8; 12] = b"LocalKeySet\0";
pub const LN_LocalKeySet: &[u8; 24] = b"Microsoft Local Key set\0";
pub const NID_LocalKeySet: u32 = 856;
pub const LN_x509Certificate: &[u8; 16] = b"x509Certificate\0";
pub const NID_x509Certificate: u32 = 158;
pub const LN_sdsiCertificate: &[u8; 16] = b"sdsiCertificate\0";
pub const NID_sdsiCertificate: u32 = 159;
pub const LN_x509Crl: &[u8; 8] = b"x509Crl\0";
pub const NID_x509Crl: u32 = 160;
pub const SN_pbe_WithSHA1And128BitRC4: &[u8; 17] = b"PBE-SHA1-RC4-128\0";
pub const LN_pbe_WithSHA1And128BitRC4: &[u8; 24] = b"pbeWithSHA1And128BitRC4\0";
pub const NID_pbe_WithSHA1And128BitRC4: u32 = 144;
pub const SN_pbe_WithSHA1And40BitRC4: &[u8; 16] = b"PBE-SHA1-RC4-40\0";
pub const LN_pbe_WithSHA1And40BitRC4: &[u8; 23] = b"pbeWithSHA1And40BitRC4\0";
pub const NID_pbe_WithSHA1And40BitRC4: u32 = 145;
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 14] = b"PBE-SHA1-3DES\0";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 33] = b"pbeWithSHA1And3-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: u32 = 146;
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 14] = b"PBE-SHA1-2DES\0";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 33] = b"pbeWithSHA1And2-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: u32 = 147;
pub const SN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 17] = b"PBE-SHA1-RC2-128\0";
pub const LN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 28] = b"pbeWithSHA1And128BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And128BitRC2_CBC: u32 = 148;
pub const SN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 16] = b"PBE-SHA1-RC2-40\0";
pub const LN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 27] = b"pbeWithSHA1And40BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And40BitRC2_CBC: u32 = 149;
pub const LN_keyBag: &[u8; 7] = b"keyBag\0";
pub const NID_keyBag: u32 = 150;
pub const LN_pkcs8ShroudedKeyBag: &[u8; 20] = b"pkcs8ShroudedKeyBag\0";
pub const NID_pkcs8ShroudedKeyBag: u32 = 151;
pub const LN_certBag: &[u8; 8] = b"certBag\0";
pub const NID_certBag: u32 = 152;
pub const LN_crlBag: &[u8; 7] = b"crlBag\0";
pub const NID_crlBag: u32 = 153;
pub const LN_secretBag: &[u8; 10] = b"secretBag\0";
pub const NID_secretBag: u32 = 154;
pub const LN_safeContentsBag: &[u8; 16] = b"safeContentsBag\0";
pub const NID_safeContentsBag: u32 = 155;
pub const SN_md2: &[u8; 4] = b"MD2\0";
pub const LN_md2: &[u8; 4] = b"md2\0";
pub const NID_md2: u32 = 3;
pub const SN_md4: &[u8; 4] = b"MD4\0";
pub const LN_md4: &[u8; 4] = b"md4\0";
pub const NID_md4: u32 = 257;
pub const SN_md5: &[u8; 4] = b"MD5\0";
pub const LN_md5: &[u8; 4] = b"md5\0";
pub const NID_md5: u32 = 4;
pub const SN_md5_sha1: &[u8; 9] = b"MD5-SHA1\0";
pub const LN_md5_sha1: &[u8; 9] = b"md5-sha1\0";
pub const NID_md5_sha1: u32 = 114;
pub const LN_hmacWithMD5: &[u8; 12] = b"hmacWithMD5\0";
pub const NID_hmacWithMD5: u32 = 797;
pub const LN_hmacWithSHA1: &[u8; 13] = b"hmacWithSHA1\0";
pub const NID_hmacWithSHA1: u32 = 163;
pub const SN_sm2: &[u8; 4] = b"SM2\0";
pub const LN_sm2: &[u8; 4] = b"sm2\0";
pub const NID_sm2: u32 = 1172;
pub const SN_sm3: &[u8; 4] = b"SM3\0";
pub const LN_sm3: &[u8; 4] = b"sm3\0";
pub const NID_sm3: u32 = 1143;
pub const SN_sm3WithRSAEncryption: &[u8; 8] = b"RSA-SM3\0";
pub const LN_sm3WithRSAEncryption: &[u8; 21] = b"sm3WithRSAEncryption\0";
pub const NID_sm3WithRSAEncryption: u32 = 1144;
pub const SN_SM2_with_SM3: &[u8; 8] = b"SM2-SM3\0";
pub const LN_SM2_with_SM3: &[u8; 13] = b"SM2-with-SM3\0";
pub const NID_SM2_with_SM3: u32 = 1204;
pub const LN_hmacWithSHA224: &[u8; 15] = b"hmacWithSHA224\0";
pub const NID_hmacWithSHA224: u32 = 798;
pub const LN_hmacWithSHA256: &[u8; 15] = b"hmacWithSHA256\0";
pub const NID_hmacWithSHA256: u32 = 799;
pub const LN_hmacWithSHA384: &[u8; 15] = b"hmacWithSHA384\0";
pub const NID_hmacWithSHA384: u32 = 800;
pub const LN_hmacWithSHA512: &[u8; 15] = b"hmacWithSHA512\0";
pub const NID_hmacWithSHA512: u32 = 801;
pub const LN_hmacWithSHA512_224: &[u8; 19] = b"hmacWithSHA512-224\0";
pub const NID_hmacWithSHA512_224: u32 = 1193;
pub const LN_hmacWithSHA512_256: &[u8; 19] = b"hmacWithSHA512-256\0";
pub const NID_hmacWithSHA512_256: u32 = 1194;
pub const SN_rc2_cbc: &[u8; 8] = b"RC2-CBC\0";
pub const LN_rc2_cbc: &[u8; 8] = b"rc2-cbc\0";
pub const NID_rc2_cbc: u32 = 37;
pub const SN_rc2_ecb: &[u8; 8] = b"RC2-ECB\0";
pub const LN_rc2_ecb: &[u8; 8] = b"rc2-ecb\0";
pub const NID_rc2_ecb: u32 = 38;
pub const SN_rc2_cfb64: &[u8; 8] = b"RC2-CFB\0";
pub const LN_rc2_cfb64: &[u8; 8] = b"rc2-cfb\0";
pub const NID_rc2_cfb64: u32 = 39;
pub const SN_rc2_ofb64: &[u8; 8] = b"RC2-OFB\0";
pub const LN_rc2_ofb64: &[u8; 8] = b"rc2-ofb\0";
pub const NID_rc2_ofb64: u32 = 40;
pub const SN_rc2_40_cbc: &[u8; 11] = b"RC2-40-CBC\0";
pub const LN_rc2_40_cbc: &[u8; 11] = b"rc2-40-cbc\0";
pub const NID_rc2_40_cbc: u32 = 98;
pub const SN_rc2_64_cbc: &[u8; 11] = b"RC2-64-CBC\0";
pub const LN_rc2_64_cbc: &[u8; 11] = b"rc2-64-cbc\0";
pub const NID_rc2_64_cbc: u32 = 166;
pub const SN_rc4: &[u8; 4] = b"RC4\0";
pub const LN_rc4: &[u8; 4] = b"rc4\0";
pub const NID_rc4: u32 = 5;
pub const SN_rc4_40: &[u8; 7] = b"RC4-40\0";
pub const LN_rc4_40: &[u8; 7] = b"rc4-40\0";
pub const NID_rc4_40: u32 = 97;
pub const SN_des_ede3_cbc: &[u8; 13] = b"DES-EDE3-CBC\0";
pub const LN_des_ede3_cbc: &[u8; 13] = b"des-ede3-cbc\0";
pub const NID_des_ede3_cbc: u32 = 44;
pub const SN_rc5_cbc: &[u8; 8] = b"RC5-CBC\0";
pub const LN_rc5_cbc: &[u8; 8] = b"rc5-cbc\0";
pub const NID_rc5_cbc: u32 = 120;
pub const SN_rc5_ecb: &[u8; 8] = b"RC5-ECB\0";
pub const LN_rc5_ecb: &[u8; 8] = b"rc5-ecb\0";
pub const NID_rc5_ecb: u32 = 121;
pub const SN_rc5_cfb64: &[u8; 8] = b"RC5-CFB\0";
pub const LN_rc5_cfb64: &[u8; 8] = b"rc5-cfb\0";
pub const NID_rc5_cfb64: u32 = 122;
pub const SN_rc5_ofb64: &[u8; 8] = b"RC5-OFB\0";
pub const LN_rc5_ofb64: &[u8; 8] = b"rc5-ofb\0";
pub const NID_rc5_ofb64: u32 = 123;
pub const SN_ms_ext_req: &[u8; 9] = b"msExtReq\0";
pub const LN_ms_ext_req: &[u8; 28] = b"Microsoft Extension Request\0";
pub const NID_ms_ext_req: u32 = 171;
pub const SN_ms_code_ind: &[u8; 10] = b"msCodeInd\0";
pub const LN_ms_code_ind: &[u8; 34] = b"Microsoft Individual Code Signing\0";
pub const NID_ms_code_ind: u32 = 134;
pub const SN_ms_code_com: &[u8; 10] = b"msCodeCom\0";
pub const LN_ms_code_com: &[u8; 34] = b"Microsoft Commercial Code Signing\0";
pub const NID_ms_code_com: u32 = 135;
pub const SN_ms_ctl_sign: &[u8; 10] = b"msCTLSign\0";
pub const LN_ms_ctl_sign: &[u8; 29] = b"Microsoft Trust List Signing\0";
pub const NID_ms_ctl_sign: u32 = 136;
pub const SN_ms_sgc: &[u8; 6] = b"msSGC\0";
pub const LN_ms_sgc: &[u8; 30] = b"Microsoft Server Gated Crypto\0";
pub const NID_ms_sgc: u32 = 137;
pub const SN_ms_efs: &[u8; 6] = b"msEFS\0";
pub const LN_ms_efs: &[u8; 32] = b"Microsoft Encrypted File System\0";
pub const NID_ms_efs: u32 = 138;
pub const SN_ms_smartcard_login: &[u8; 17] = b"msSmartcardLogin\0";
pub const LN_ms_smartcard_login: &[u8; 26] = b"Microsoft Smartcard Login\0";
pub const NID_ms_smartcard_login: u32 = 648;
pub const SN_ms_upn: &[u8; 6] = b"msUPN\0";
pub const LN_ms_upn: &[u8; 30] = b"Microsoft User Principal Name\0";
pub const NID_ms_upn: u32 = 649;
pub const SN_idea_cbc: &[u8; 9] = b"IDEA-CBC\0";
pub const LN_idea_cbc: &[u8; 9] = b"idea-cbc\0";
pub const NID_idea_cbc: u32 = 34;
pub const SN_idea_ecb: &[u8; 9] = b"IDEA-ECB\0";
pub const LN_idea_ecb: &[u8; 9] = b"idea-ecb\0";
pub const NID_idea_ecb: u32 = 36;
pub const SN_idea_cfb64: &[u8; 9] = b"IDEA-CFB\0";
pub const LN_idea_cfb64: &[u8; 9] = b"idea-cfb\0";
pub const NID_idea_cfb64: u32 = 35;
pub const SN_idea_ofb64: &[u8; 9] = b"IDEA-OFB\0";
pub const LN_idea_ofb64: &[u8; 9] = b"idea-ofb\0";
pub const NID_idea_ofb64: u32 = 46;
pub const SN_bf_cbc: &[u8; 7] = b"BF-CBC\0";
pub const LN_bf_cbc: &[u8; 7] = b"bf-cbc\0";
pub const NID_bf_cbc: u32 = 91;
pub const SN_bf_ecb: &[u8; 7] = b"BF-ECB\0";
pub const LN_bf_ecb: &[u8; 7] = b"bf-ecb\0";
pub const NID_bf_ecb: u32 = 92;
pub const SN_bf_cfb64: &[u8; 7] = b"BF-CFB\0";
pub const LN_bf_cfb64: &[u8; 7] = b"bf-cfb\0";
pub const NID_bf_cfb64: u32 = 93;
pub const SN_bf_ofb64: &[u8; 7] = b"BF-OFB\0";
pub const LN_bf_ofb64: &[u8; 7] = b"bf-ofb\0";
pub const NID_bf_ofb64: u32 = 94;
pub const SN_id_pkix: &[u8; 5] = b"PKIX\0";
pub const NID_id_pkix: u32 = 127;
pub const SN_id_pkix_mod: &[u8; 12] = b"id-pkix-mod\0";
pub const NID_id_pkix_mod: u32 = 258;
pub const SN_id_pe: &[u8; 6] = b"id-pe\0";
pub const NID_id_pe: u32 = 175;
pub const SN_id_qt: &[u8; 6] = b"id-qt\0";
pub const NID_id_qt: u32 = 259;
pub const SN_id_kp: &[u8; 6] = b"id-kp\0";
pub const NID_id_kp: u32 = 128;
pub const SN_id_it: &[u8; 6] = b"id-it\0";
pub const NID_id_it: u32 = 260;
pub const SN_id_pkip: &[u8; 8] = b"id-pkip\0";
pub const NID_id_pkip: u32 = 261;
pub const SN_id_alg: &[u8; 7] = b"id-alg\0";
pub const NID_id_alg: u32 = 262;
pub const SN_id_cmc: &[u8; 7] = b"id-cmc\0";
pub const NID_id_cmc: u32 = 263;
pub const SN_id_on: &[u8; 6] = b"id-on\0";
pub const NID_id_on: u32 = 264;
pub const SN_id_pda: &[u8; 7] = b"id-pda\0";
pub const NID_id_pda: u32 = 265;
pub const SN_id_aca: &[u8; 7] = b"id-aca\0";
pub const NID_id_aca: u32 = 266;
pub const SN_id_qcs: &[u8; 7] = b"id-qcs\0";
pub const NID_id_qcs: u32 = 267;
pub const SN_id_cp: &[u8; 6] = b"id-cp\0";
pub const NID_id_cp: u32 = 1238;
pub const SN_id_cct: &[u8; 7] = b"id-cct\0";
pub const NID_id_cct: u32 = 268;
pub const SN_id_ppl: &[u8; 7] = b"id-ppl\0";
pub const NID_id_ppl: u32 = 662;
pub const SN_id_ad: &[u8; 6] = b"id-ad\0";
pub const NID_id_ad: u32 = 176;
pub const SN_id_pkix1_explicit_88: &[u8; 21] = b"id-pkix1-explicit-88\0";
pub const NID_id_pkix1_explicit_88: u32 = 269;
pub const SN_id_pkix1_implicit_88: &[u8; 21] = b"id-pkix1-implicit-88\0";
pub const NID_id_pkix1_implicit_88: u32 = 270;
pub const SN_id_pkix1_explicit_93: &[u8; 21] = b"id-pkix1-explicit-93\0";
pub const NID_id_pkix1_explicit_93: u32 = 271;
pub const SN_id_pkix1_implicit_93: &[u8; 21] = b"id-pkix1-implicit-93\0";
pub const NID_id_pkix1_implicit_93: u32 = 272;
pub const SN_id_mod_crmf: &[u8; 12] = b"id-mod-crmf\0";
pub const NID_id_mod_crmf: u32 = 273;
pub const SN_id_mod_cmc: &[u8; 11] = b"id-mod-cmc\0";
pub const NID_id_mod_cmc: u32 = 274;
pub const SN_id_mod_kea_profile_88: &[u8; 22] = b"id-mod-kea-profile-88\0";
pub const NID_id_mod_kea_profile_88: u32 = 275;
pub const SN_id_mod_kea_profile_93: &[u8; 22] = b"id-mod-kea-profile-93\0";
pub const NID_id_mod_kea_profile_93: u32 = 276;
pub const SN_id_mod_cmp: &[u8; 11] = b"id-mod-cmp\0";
pub const NID_id_mod_cmp: u32 = 277;
pub const SN_id_mod_qualified_cert_88: &[u8; 25] = b"id-mod-qualified-cert-88\0";
pub const NID_id_mod_qualified_cert_88: u32 = 278;
pub const SN_id_mod_qualified_cert_93: &[u8; 25] = b"id-mod-qualified-cert-93\0";
pub const NID_id_mod_qualified_cert_93: u32 = 279;
pub const SN_id_mod_attribute_cert: &[u8; 22] = b"id-mod-attribute-cert\0";
pub const NID_id_mod_attribute_cert: u32 = 280;
pub const SN_id_mod_timestamp_protocol: &[u8; 26] = b"id-mod-timestamp-protocol\0";
pub const NID_id_mod_timestamp_protocol: u32 = 281;
pub const SN_id_mod_ocsp: &[u8; 12] = b"id-mod-ocsp\0";
pub const NID_id_mod_ocsp: u32 = 282;
pub const SN_id_mod_dvcs: &[u8; 12] = b"id-mod-dvcs\0";
pub const NID_id_mod_dvcs: u32 = 283;
pub const SN_id_mod_cmp2000: &[u8; 15] = b"id-mod-cmp2000\0";
pub const NID_id_mod_cmp2000: u32 = 284;
pub const SN_info_access: &[u8; 20] = b"authorityInfoAccess\0";
pub const LN_info_access: &[u8; 29] = b"Authority Information Access\0";
pub const NID_info_access: u32 = 177;
pub const SN_biometricInfo: &[u8; 14] = b"biometricInfo\0";
pub const LN_biometricInfo: &[u8; 15] = b"Biometric Info\0";
pub const NID_biometricInfo: u32 = 285;
pub const SN_qcStatements: &[u8; 13] = b"qcStatements\0";
pub const NID_qcStatements: u32 = 286;
pub const SN_ac_auditEntity: &[u8; 15] = b"ac-auditEntity\0";
pub const NID_ac_auditEntity: u32 = 287;
pub const SN_ac_targeting: &[u8; 13] = b"ac-targeting\0";
pub const NID_ac_targeting: u32 = 288;
pub const SN_aaControls: &[u8; 11] = b"aaControls\0";
pub const NID_aaControls: u32 = 289;
pub const SN_sbgp_ipAddrBlock: &[u8; 17] = b"sbgp-ipAddrBlock\0";
pub const NID_sbgp_ipAddrBlock: u32 = 290;
pub const SN_sbgp_autonomousSysNum: &[u8; 22] = b"sbgp-autonomousSysNum\0";
pub const NID_sbgp_autonomousSysNum: u32 = 291;
pub const SN_sbgp_routerIdentifier: &[u8; 22] = b"sbgp-routerIdentifier\0";
pub const NID_sbgp_routerIdentifier: u32 = 292;
pub const SN_ac_proxying: &[u8; 12] = b"ac-proxying\0";
pub const NID_ac_proxying: u32 = 397;
pub const SN_sinfo_access: &[u8; 18] = b"subjectInfoAccess\0";
pub const LN_sinfo_access: &[u8; 27] = b"Subject Information Access\0";
pub const NID_sinfo_access: u32 = 398;
pub const SN_proxyCertInfo: &[u8; 14] = b"proxyCertInfo\0";
pub const LN_proxyCertInfo: &[u8; 30] = b"Proxy Certificate Information\0";
pub const NID_proxyCertInfo: u32 = 663;
pub const SN_tlsfeature: &[u8; 11] = b"tlsfeature\0";
pub const LN_tlsfeature: &[u8; 12] = b"TLS Feature\0";
pub const NID_tlsfeature: u32 = 1020;
pub const SN_sbgp_ipAddrBlockv2: &[u8; 19] = b"sbgp-ipAddrBlockv2\0";
pub const NID_sbgp_ipAddrBlockv2: u32 = 1239;
pub const SN_sbgp_autonomousSysNumv2: &[u8; 24] = b"sbgp-autonomousSysNumv2\0";
pub const NID_sbgp_autonomousSysNumv2: u32 = 1240;
pub const SN_id_qt_cps: &[u8; 10] = b"id-qt-cps\0";
pub const LN_id_qt_cps: &[u8; 21] = b"Policy Qualifier CPS\0";
pub const NID_id_qt_cps: u32 = 164;
pub const SN_id_qt_unotice: &[u8; 14] = b"id-qt-unotice\0";
pub const LN_id_qt_unotice: &[u8; 29] = b"Policy Qualifier User Notice\0";
pub const NID_id_qt_unotice: u32 = 165;
pub const SN_textNotice: &[u8; 11] = b"textNotice\0";
pub const NID_textNotice: u32 = 293;
pub const SN_server_auth: &[u8; 11] = b"serverAuth\0";
pub const LN_server_auth: &[u8; 30] = b"TLS Web Server Authentication\0";
pub const NID_server_auth: u32 = 129;
pub const SN_client_auth: &[u8; 11] = b"clientAuth\0";
pub const LN_client_auth: &[u8; 30] = b"TLS Web Client Authentication\0";
pub const NID_client_auth: u32 = 130;
pub const SN_code_sign: &[u8; 12] = b"codeSigning\0";
pub const LN_code_sign: &[u8; 13] = b"Code Signing\0";
pub const NID_code_sign: u32 = 131;
pub const SN_email_protect: &[u8; 16] = b"emailProtection\0";
pub const LN_email_protect: &[u8; 18] = b"E-mail Protection\0";
pub const NID_email_protect: u32 = 132;
pub const SN_ipsecEndSystem: &[u8; 15] = b"ipsecEndSystem\0";
pub const LN_ipsecEndSystem: &[u8; 17] = b"IPSec End System\0";
pub const NID_ipsecEndSystem: u32 = 294;
pub const SN_ipsecTunnel: &[u8; 12] = b"ipsecTunnel\0";
pub const LN_ipsecTunnel: &[u8; 13] = b"IPSec Tunnel\0";
pub const NID_ipsecTunnel: u32 = 295;
pub const SN_ipsecUser: &[u8; 10] = b"ipsecUser\0";
pub const LN_ipsecUser: &[u8; 11] = b"IPSec User\0";
pub const NID_ipsecUser: u32 = 296;
pub const SN_time_stamp: &[u8; 13] = b"timeStamping\0";
pub const LN_time_stamp: &[u8; 14] = b"Time Stamping\0";
pub const NID_time_stamp: u32 = 133;
pub const SN_OCSP_sign: &[u8; 12] = b"OCSPSigning\0";
pub const LN_OCSP_sign: &[u8; 13] = b"OCSP Signing\0";
pub const NID_OCSP_sign: u32 = 180;
pub const SN_dvcs: &[u8; 5] = b"DVCS\0";
pub const LN_dvcs: &[u8; 5] = b"dvcs\0";
pub const NID_dvcs: u32 = 297;
pub const SN_ipsec_IKE: &[u8; 9] = b"ipsecIKE\0";
pub const LN_ipsec_IKE: &[u8; 28] = b"ipsec Internet Key Exchange\0";
pub const NID_ipsec_IKE: u32 = 1022;
pub const SN_capwapAC: &[u8; 9] = b"capwapAC\0";
pub const LN_capwapAC: &[u8; 26] = b"Ctrl/provision WAP Access\0";
pub const NID_capwapAC: u32 = 1023;
pub const SN_capwapWTP: &[u8; 10] = b"capwapWTP\0";
pub const LN_capwapWTP: &[u8; 31] = b"Ctrl/Provision WAP Termination\0";
pub const NID_capwapWTP: u32 = 1024;
pub const SN_sshClient: &[u8; 18] = b"secureShellClient\0";
pub const LN_sshClient: &[u8; 11] = b"SSH Client\0";
pub const NID_sshClient: u32 = 1025;
pub const SN_sshServer: &[u8; 18] = b"secureShellServer\0";
pub const LN_sshServer: &[u8; 11] = b"SSH Server\0";
pub const NID_sshServer: u32 = 1026;
pub const SN_sendRouter: &[u8; 11] = b"sendRouter\0";
pub const LN_sendRouter: &[u8; 12] = b"Send Router\0";
pub const NID_sendRouter: u32 = 1027;
pub const SN_sendProxiedRouter: &[u8; 18] = b"sendProxiedRouter\0";
pub const LN_sendProxiedRouter: &[u8; 20] = b"Send Proxied Router\0";
pub const NID_sendProxiedRouter: u32 = 1028;
pub const SN_sendOwner: &[u8; 10] = b"sendOwner\0";
pub const LN_sendOwner: &[u8; 11] = b"Send Owner\0";
pub const NID_sendOwner: u32 = 1029;
pub const SN_sendProxiedOwner: &[u8; 17] = b"sendProxiedOwner\0";
pub const LN_sendProxiedOwner: &[u8; 19] = b"Send Proxied Owner\0";
pub const NID_sendProxiedOwner: u32 = 1030;
pub const SN_cmcCA: &[u8; 6] = b"cmcCA\0";
pub const LN_cmcCA: &[u8; 26] = b"CMC Certificate Authority\0";
pub const NID_cmcCA: u32 = 1131;
pub const SN_cmcRA: &[u8; 6] = b"cmcRA\0";
pub const LN_cmcRA: &[u8; 27] = b"CMC Registration Authority\0";
pub const NID_cmcRA: u32 = 1132;
pub const SN_cmcArchive: &[u8; 11] = b"cmcArchive\0";
pub const LN_cmcArchive: &[u8; 19] = b"CMC Archive Server\0";
pub const NID_cmcArchive: u32 = 1219;
pub const SN_id_kp_bgpsec_router: &[u8; 20] = b"id-kp-bgpsec-router\0";
pub const LN_id_kp_bgpsec_router: &[u8; 14] = b"BGPsec Router\0";
pub const NID_id_kp_bgpsec_router: u32 = 1220;
pub const SN_id_kp_BrandIndicatorforMessageIdentification: &[u8; 45] =
    b"id-kp-BrandIndicatorforMessageIdentification\0";
pub const LN_id_kp_BrandIndicatorforMessageIdentification: &[u8; 43] = b"Brand Indicator for Message Identification\0";
pub const NID_id_kp_BrandIndicatorforMessageIdentification: u32 = 1221;
pub const SN_cmKGA: &[u8; 6] = b"cmKGA\0";
pub const LN_cmKGA: &[u8; 48] = b"Certificate Management Key Generation Authority\0";
pub const NID_cmKGA: u32 = 1222;
pub const SN_id_it_caProtEncCert: &[u8; 20] = b"id-it-caProtEncCert\0";
pub const NID_id_it_caProtEncCert: u32 = 298;
pub const SN_id_it_signKeyPairTypes: &[u8; 23] = b"id-it-signKeyPairTypes\0";
pub const NID_id_it_signKeyPairTypes: u32 = 299;
pub const SN_id_it_encKeyPairTypes: &[u8; 22] = b"id-it-encKeyPairTypes\0";
pub const NID_id_it_encKeyPairTypes: u32 = 300;
pub const SN_id_it_preferredSymmAlg: &[u8; 23] = b"id-it-preferredSymmAlg\0";
pub const NID_id_it_preferredSymmAlg: u32 = 301;
pub const SN_id_it_caKeyUpdateInfo: &[u8; 22] = b"id-it-caKeyUpdateInfo\0";
pub const NID_id_it_caKeyUpdateInfo: u32 = 302;
pub const SN_id_it_currentCRL: &[u8; 17] = b"id-it-currentCRL\0";
pub const NID_id_it_currentCRL: u32 = 303;
pub const SN_id_it_unsupportedOIDs: &[u8; 22] = b"id-it-unsupportedOIDs\0";
pub const NID_id_it_unsupportedOIDs: u32 = 304;
pub const SN_id_it_subscriptionRequest: &[u8; 26] = b"id-it-subscriptionRequest\0";
pub const NID_id_it_subscriptionRequest: u32 = 305;
pub const SN_id_it_subscriptionResponse: &[u8; 27] = b"id-it-subscriptionResponse\0";
pub const NID_id_it_subscriptionResponse: u32 = 306;
pub const SN_id_it_keyPairParamReq: &[u8; 22] = b"id-it-keyPairParamReq\0";
pub const NID_id_it_keyPairParamReq: u32 = 307;
pub const SN_id_it_keyPairParamRep: &[u8; 22] = b"id-it-keyPairParamRep\0";
pub const NID_id_it_keyPairParamRep: u32 = 308;
pub const SN_id_it_revPassphrase: &[u8; 20] = b"id-it-revPassphrase\0";
pub const NID_id_it_revPassphrase: u32 = 309;
pub const SN_id_it_implicitConfirm: &[u8; 22] = b"id-it-implicitConfirm\0";
pub const NID_id_it_implicitConfirm: u32 = 310;
pub const SN_id_it_confirmWaitTime: &[u8; 22] = b"id-it-confirmWaitTime\0";
pub const NID_id_it_confirmWaitTime: u32 = 311;
pub const SN_id_it_origPKIMessage: &[u8; 21] = b"id-it-origPKIMessage\0";
pub const NID_id_it_origPKIMessage: u32 = 312;
pub const SN_id_it_suppLangTags: &[u8; 19] = b"id-it-suppLangTags\0";
pub const NID_id_it_suppLangTags: u32 = 784;
pub const SN_id_it_caCerts: &[u8; 14] = b"id-it-caCerts\0";
pub const NID_id_it_caCerts: u32 = 1223;
pub const SN_id_it_rootCaKeyUpdate: &[u8; 22] = b"id-it-rootCaKeyUpdate\0";
pub const NID_id_it_rootCaKeyUpdate: u32 = 1224;
pub const SN_id_it_certReqTemplate: &[u8; 22] = b"id-it-certReqTemplate\0";
pub const NID_id_it_certReqTemplate: u32 = 1225;
pub const SN_id_regCtrl: &[u8; 11] = b"id-regCtrl\0";
pub const NID_id_regCtrl: u32 = 313;
pub const SN_id_regInfo: &[u8; 11] = b"id-regInfo\0";
pub const NID_id_regInfo: u32 = 314;
pub const SN_id_regCtrl_regToken: &[u8; 20] = b"id-regCtrl-regToken\0";
pub const NID_id_regCtrl_regToken: u32 = 315;
pub const SN_id_regCtrl_authenticator: &[u8; 25] = b"id-regCtrl-authenticator\0";
pub const NID_id_regCtrl_authenticator: u32 = 316;
pub const SN_id_regCtrl_pkiPublicationInfo: &[u8; 30] = b"id-regCtrl-pkiPublicationInfo\0";
pub const NID_id_regCtrl_pkiPublicationInfo: u32 = 317;
pub const SN_id_regCtrl_pkiArchiveOptions: &[u8; 29] = b"id-regCtrl-pkiArchiveOptions\0";
pub const NID_id_regCtrl_pkiArchiveOptions: u32 = 318;
pub const SN_id_regCtrl_oldCertID: &[u8; 21] = b"id-regCtrl-oldCertID\0";
pub const NID_id_regCtrl_oldCertID: u32 = 319;
pub const SN_id_regCtrl_protocolEncrKey: &[u8; 27] = b"id-regCtrl-protocolEncrKey\0";
pub const NID_id_regCtrl_protocolEncrKey: u32 = 320;
pub const SN_id_regInfo_utf8Pairs: &[u8; 21] = b"id-regInfo-utf8Pairs\0";
pub const NID_id_regInfo_utf8Pairs: u32 = 321;
pub const SN_id_regInfo_certReq: &[u8; 19] = b"id-regInfo-certReq\0";
pub const NID_id_regInfo_certReq: u32 = 322;
pub const SN_id_alg_des40: &[u8; 13] = b"id-alg-des40\0";
pub const NID_id_alg_des40: u32 = 323;
pub const SN_id_alg_noSignature: &[u8; 19] = b"id-alg-noSignature\0";
pub const NID_id_alg_noSignature: u32 = 324;
pub const SN_id_alg_dh_sig_hmac_sha1: &[u8; 24] = b"id-alg-dh-sig-hmac-sha1\0";
pub const NID_id_alg_dh_sig_hmac_sha1: u32 = 325;
pub const SN_id_alg_dh_pop: &[u8; 14] = b"id-alg-dh-pop\0";
pub const NID_id_alg_dh_pop: u32 = 326;
pub const SN_id_cmc_statusInfo: &[u8; 18] = b"id-cmc-statusInfo\0";
pub const NID_id_cmc_statusInfo: u32 = 327;
pub const SN_id_cmc_identification: &[u8; 22] = b"id-cmc-identification\0";
pub const NID_id_cmc_identification: u32 = 328;
pub const SN_id_cmc_identityProof: &[u8; 21] = b"id-cmc-identityProof\0";
pub const NID_id_cmc_identityProof: u32 = 329;
pub const SN_id_cmc_dataReturn: &[u8; 18] = b"id-cmc-dataReturn\0";
pub const NID_id_cmc_dataReturn: u32 = 330;
pub const SN_id_cmc_transactionId: &[u8; 21] = b"id-cmc-transactionId\0";
pub const NID_id_cmc_transactionId: u32 = 331;
pub const SN_id_cmc_senderNonce: &[u8; 19] = b"id-cmc-senderNonce\0";
pub const NID_id_cmc_senderNonce: u32 = 332;
pub const SN_id_cmc_recipientNonce: &[u8; 22] = b"id-cmc-recipientNonce\0";
pub const NID_id_cmc_recipientNonce: u32 = 333;
pub const SN_id_cmc_addExtensions: &[u8; 21] = b"id-cmc-addExtensions\0";
pub const NID_id_cmc_addExtensions: u32 = 334;
pub const SN_id_cmc_encryptedPOP: &[u8; 20] = b"id-cmc-encryptedPOP\0";
pub const NID_id_cmc_encryptedPOP: u32 = 335;
pub const SN_id_cmc_decryptedPOP: &[u8; 20] = b"id-cmc-decryptedPOP\0";
pub const NID_id_cmc_decryptedPOP: u32 = 336;
pub const SN_id_cmc_lraPOPWitness: &[u8; 21] = b"id-cmc-lraPOPWitness\0";
pub const NID_id_cmc_lraPOPWitness: u32 = 337;
pub const SN_id_cmc_getCert: &[u8; 15] = b"id-cmc-getCert\0";
pub const NID_id_cmc_getCert: u32 = 338;
pub const SN_id_cmc_getCRL: &[u8; 14] = b"id-cmc-getCRL\0";
pub const NID_id_cmc_getCRL: u32 = 339;
pub const SN_id_cmc_revokeRequest: &[u8; 21] = b"id-cmc-revokeRequest\0";
pub const NID_id_cmc_revokeRequest: u32 = 340;
pub const SN_id_cmc_regInfo: &[u8; 15] = b"id-cmc-regInfo\0";
pub const NID_id_cmc_regInfo: u32 = 341;
pub const SN_id_cmc_responseInfo: &[u8; 20] = b"id-cmc-responseInfo\0";
pub const NID_id_cmc_responseInfo: u32 = 342;
pub const SN_id_cmc_queryPending: &[u8; 20] = b"id-cmc-queryPending\0";
pub const NID_id_cmc_queryPending: u32 = 343;
pub const SN_id_cmc_popLinkRandom: &[u8; 21] = b"id-cmc-popLinkRandom\0";
pub const NID_id_cmc_popLinkRandom: u32 = 344;
pub const SN_id_cmc_popLinkWitness: &[u8; 22] = b"id-cmc-popLinkWitness\0";
pub const NID_id_cmc_popLinkWitness: u32 = 345;
pub const SN_id_cmc_confirmCertAcceptance: &[u8; 29] = b"id-cmc-confirmCertAcceptance\0";
pub const NID_id_cmc_confirmCertAcceptance: u32 = 346;
pub const SN_id_on_personalData: &[u8; 19] = b"id-on-personalData\0";
pub const NID_id_on_personalData: u32 = 347;
pub const SN_id_on_permanentIdentifier: &[u8; 26] = b"id-on-permanentIdentifier\0";
pub const LN_id_on_permanentIdentifier: &[u8; 21] = b"Permanent Identifier\0";
pub const NID_id_on_permanentIdentifier: u32 = 858;
pub const SN_XmppAddr: &[u8; 15] = b"id-on-xmppAddr\0";
pub const LN_XmppAddr: &[u8; 9] = b"XmppAddr\0";
pub const NID_XmppAddr: u32 = 1209;
pub const SN_SRVName: &[u8; 13] = b"id-on-dnsSRV\0";
pub const LN_SRVName: &[u8; 8] = b"SRVName\0";
pub const NID_SRVName: u32 = 1210;
pub const SN_NAIRealm: &[u8; 15] = b"id-on-NAIRealm\0";
pub const LN_NAIRealm: &[u8; 9] = b"NAIRealm\0";
pub const NID_NAIRealm: u32 = 1211;
pub const SN_id_on_SmtpUTF8Mailbox: &[u8; 22] = b"id-on-SmtpUTF8Mailbox\0";
pub const LN_id_on_SmtpUTF8Mailbox: &[u8; 18] = b"Smtp UTF8 Mailbox\0";
pub const NID_id_on_SmtpUTF8Mailbox: u32 = 1208;
pub const SN_id_pda_dateOfBirth: &[u8; 19] = b"id-pda-dateOfBirth\0";
pub const NID_id_pda_dateOfBirth: u32 = 348;
pub const SN_id_pda_placeOfBirth: &[u8; 20] = b"id-pda-placeOfBirth\0";
pub const NID_id_pda_placeOfBirth: u32 = 349;
pub const SN_id_pda_gender: &[u8; 14] = b"id-pda-gender\0";
pub const NID_id_pda_gender: u32 = 351;
pub const SN_id_pda_countryOfCitizenship: &[u8; 28] = b"id-pda-countryOfCitizenship\0";
pub const NID_id_pda_countryOfCitizenship: u32 = 352;
pub const SN_id_pda_countryOfResidence: &[u8; 26] = b"id-pda-countryOfResidence\0";
pub const NID_id_pda_countryOfResidence: u32 = 353;
pub const SN_id_aca_authenticationInfo: &[u8; 26] = b"id-aca-authenticationInfo\0";
pub const NID_id_aca_authenticationInfo: u32 = 354;
pub const SN_id_aca_accessIdentity: &[u8; 22] = b"id-aca-accessIdentity\0";
pub const NID_id_aca_accessIdentity: u32 = 355;
pub const SN_id_aca_chargingIdentity: &[u8; 24] = b"id-aca-chargingIdentity\0";
pub const NID_id_aca_chargingIdentity: u32 = 356;
pub const SN_id_aca_group: &[u8; 13] = b"id-aca-group\0";
pub const NID_id_aca_group: u32 = 357;
pub const SN_id_aca_role: &[u8; 12] = b"id-aca-role\0";
pub const NID_id_aca_role: u32 = 358;
pub const SN_id_aca_encAttrs: &[u8; 16] = b"id-aca-encAttrs\0";
pub const NID_id_aca_encAttrs: u32 = 399;
pub const SN_id_qcs_pkixQCSyntax_v1: &[u8; 23] = b"id-qcs-pkixQCSyntax-v1\0";
pub const NID_id_qcs_pkixQCSyntax_v1: u32 = 359;
pub const SN_ipAddr_asNumber: &[u8; 16] = b"ipAddr-asNumber\0";
pub const NID_ipAddr_asNumber: u32 = 1241;
pub const SN_ipAddr_asNumberv2: &[u8; 18] = b"ipAddr-asNumberv2\0";
pub const NID_ipAddr_asNumberv2: u32 = 1242;
pub const SN_id_cct_crs: &[u8; 11] = b"id-cct-crs\0";
pub const NID_id_cct_crs: u32 = 360;
pub const SN_id_cct_PKIData: &[u8; 15] = b"id-cct-PKIData\0";
pub const NID_id_cct_PKIData: u32 = 361;
pub const SN_id_cct_PKIResponse: &[u8; 19] = b"id-cct-PKIResponse\0";
pub const NID_id_cct_PKIResponse: u32 = 362;
pub const SN_id_ppl_anyLanguage: &[u8; 19] = b"id-ppl-anyLanguage\0";
pub const LN_id_ppl_anyLanguage: &[u8; 13] = b"Any language\0";
pub const NID_id_ppl_anyLanguage: u32 = 664;
pub const SN_id_ppl_inheritAll: &[u8; 18] = b"id-ppl-inheritAll\0";
pub const LN_id_ppl_inheritAll: &[u8; 12] = b"Inherit all\0";
pub const NID_id_ppl_inheritAll: u32 = 665;
pub const SN_Independent: &[u8; 19] = b"id-ppl-independent\0";
pub const LN_Independent: &[u8; 12] = b"Independent\0";
pub const NID_Independent: u32 = 667;
pub const SN_ad_OCSP: &[u8; 5] = b"OCSP\0";
pub const LN_ad_OCSP: &[u8; 5] = b"OCSP\0";
pub const NID_ad_OCSP: u32 = 178;
pub const SN_ad_ca_issuers: &[u8; 10] = b"caIssuers\0";
pub const LN_ad_ca_issuers: &[u8; 11] = b"CA Issuers\0";
pub const NID_ad_ca_issuers: u32 = 179;
pub const SN_ad_timeStamping: &[u8; 16] = b"ad_timestamping\0";
pub const LN_ad_timeStamping: &[u8; 17] = b"AD Time Stamping\0";
pub const NID_ad_timeStamping: u32 = 363;
pub const SN_ad_dvcs: &[u8; 8] = b"AD_DVCS\0";
pub const LN_ad_dvcs: &[u8; 8] = b"ad dvcs\0";
pub const NID_ad_dvcs: u32 = 364;
pub const SN_caRepository: &[u8; 13] = b"caRepository\0";
pub const LN_caRepository: &[u8; 14] = b"CA Repository\0";
pub const NID_caRepository: u32 = 785;
pub const SN_rpkiManifest: &[u8; 13] = b"rpkiManifest\0";
pub const LN_rpkiManifest: &[u8; 14] = b"RPKI Manifest\0";
pub const NID_rpkiManifest: u32 = 1243;
pub const SN_signedObject: &[u8; 13] = b"signedObject\0";
pub const LN_signedObject: &[u8; 14] = b"Signed Object\0";
pub const NID_signedObject: u32 = 1244;
pub const SN_rpkiNotify: &[u8; 11] = b"rpkiNotify\0";
pub const LN_rpkiNotify: &[u8; 12] = b"RPKI Notify\0";
pub const NID_rpkiNotify: u32 = 1245;
pub const SN_id_pkix_OCSP_basic: &[u8; 18] = b"basicOCSPResponse\0";
pub const LN_id_pkix_OCSP_basic: &[u8; 20] = b"Basic OCSP Response\0";
pub const NID_id_pkix_OCSP_basic: u32 = 365;
pub const SN_id_pkix_OCSP_Nonce: &[u8; 6] = b"Nonce\0";
pub const LN_id_pkix_OCSP_Nonce: &[u8; 11] = b"OCSP Nonce\0";
pub const NID_id_pkix_OCSP_Nonce: u32 = 366;
pub const SN_id_pkix_OCSP_CrlID: &[u8; 6] = b"CrlID\0";
pub const LN_id_pkix_OCSP_CrlID: &[u8; 12] = b"OCSP CRL ID\0";
pub const NID_id_pkix_OCSP_CrlID: u32 = 367;
pub const SN_id_pkix_OCSP_acceptableResponses: &[u8; 20] = b"acceptableResponses\0";
pub const LN_id_pkix_OCSP_acceptableResponses: &[u8; 26] = b"Acceptable OCSP Responses\0";
pub const NID_id_pkix_OCSP_acceptableResponses: u32 = 368;
pub const SN_id_pkix_OCSP_noCheck: &[u8; 8] = b"noCheck\0";
pub const LN_id_pkix_OCSP_noCheck: &[u8; 14] = b"OCSP No Check\0";
pub const NID_id_pkix_OCSP_noCheck: u32 = 369;
pub const SN_id_pkix_OCSP_archiveCutoff: &[u8; 14] = b"archiveCutoff\0";
pub const LN_id_pkix_OCSP_archiveCutoff: &[u8; 20] = b"OCSP Archive Cutoff\0";
pub const NID_id_pkix_OCSP_archiveCutoff: u32 = 370;
pub const SN_id_pkix_OCSP_serviceLocator: &[u8; 15] = b"serviceLocator\0";
pub const LN_id_pkix_OCSP_serviceLocator: &[u8; 21] = b"OCSP Service Locator\0";
pub const NID_id_pkix_OCSP_serviceLocator: u32 = 371;
pub const SN_id_pkix_OCSP_extendedStatus: &[u8; 15] = b"extendedStatus\0";
pub const LN_id_pkix_OCSP_extendedStatus: &[u8; 21] = b"Extended OCSP Status\0";
pub const NID_id_pkix_OCSP_extendedStatus: u32 = 372;
pub const SN_id_pkix_OCSP_valid: &[u8; 6] = b"valid\0";
pub const NID_id_pkix_OCSP_valid: u32 = 373;
pub const SN_id_pkix_OCSP_path: &[u8; 5] = b"path\0";
pub const NID_id_pkix_OCSP_path: u32 = 374;
pub const SN_id_pkix_OCSP_trustRoot: &[u8; 10] = b"trustRoot\0";
pub const LN_id_pkix_OCSP_trustRoot: &[u8; 11] = b"Trust Root\0";
pub const NID_id_pkix_OCSP_trustRoot: u32 = 375;
pub const SN_algorithm: &[u8; 10] = b"algorithm\0";
pub const LN_algorithm: &[u8; 10] = b"algorithm\0";
pub const NID_algorithm: u32 = 376;
pub const SN_md5WithRSA: &[u8; 11] = b"RSA-NP-MD5\0";
pub const LN_md5WithRSA: &[u8; 11] = b"md5WithRSA\0";
pub const NID_md5WithRSA: u32 = 104;
pub const SN_des_ecb: &[u8; 8] = b"DES-ECB\0";
pub const LN_des_ecb: &[u8; 8] = b"des-ecb\0";
pub const NID_des_ecb: u32 = 29;
pub const SN_des_cbc: &[u8; 8] = b"DES-CBC\0";
pub const LN_des_cbc: &[u8; 8] = b"des-cbc\0";
pub const NID_des_cbc: u32 = 31;
pub const SN_des_ofb64: &[u8; 8] = b"DES-OFB\0";
pub const LN_des_ofb64: &[u8; 8] = b"des-ofb\0";
pub const NID_des_ofb64: u32 = 45;
pub const SN_des_cfb64: &[u8; 8] = b"DES-CFB\0";
pub const LN_des_cfb64: &[u8; 8] = b"des-cfb\0";
pub const NID_des_cfb64: u32 = 30;
pub const SN_rsaSignature: &[u8; 13] = b"rsaSignature\0";
pub const NID_rsaSignature: u32 = 377;
pub const SN_dsa_2: &[u8; 8] = b"DSA-old\0";
pub const LN_dsa_2: &[u8; 18] = b"dsaEncryption-old\0";
pub const NID_dsa_2: u32 = 67;
pub const SN_dsaWithSHA: &[u8; 8] = b"DSA-SHA\0";
pub const LN_dsaWithSHA: &[u8; 11] = b"dsaWithSHA\0";
pub const NID_dsaWithSHA: u32 = 66;
pub const SN_shaWithRSAEncryption: &[u8; 8] = b"RSA-SHA\0";
pub const LN_shaWithRSAEncryption: &[u8; 21] = b"shaWithRSAEncryption\0";
pub const NID_shaWithRSAEncryption: u32 = 42;
pub const SN_des_ede_ecb: &[u8; 8] = b"DES-EDE\0";
pub const LN_des_ede_ecb: &[u8; 8] = b"des-ede\0";
pub const NID_des_ede_ecb: u32 = 32;
pub const SN_des_ede3_ecb: &[u8; 9] = b"DES-EDE3\0";
pub const LN_des_ede3_ecb: &[u8; 9] = b"des-ede3\0";
pub const NID_des_ede3_ecb: u32 = 33;
pub const SN_des_ede_cbc: &[u8; 12] = b"DES-EDE-CBC\0";
pub const LN_des_ede_cbc: &[u8; 12] = b"des-ede-cbc\0";
pub const NID_des_ede_cbc: u32 = 43;
pub const SN_des_ede_cfb64: &[u8; 12] = b"DES-EDE-CFB\0";
pub const LN_des_ede_cfb64: &[u8; 12] = b"des-ede-cfb\0";
pub const NID_des_ede_cfb64: u32 = 60;
pub const SN_des_ede3_cfb64: &[u8; 13] = b"DES-EDE3-CFB\0";
pub const LN_des_ede3_cfb64: &[u8; 13] = b"des-ede3-cfb\0";
pub const NID_des_ede3_cfb64: u32 = 61;
pub const SN_des_ede_ofb64: &[u8; 12] = b"DES-EDE-OFB\0";
pub const LN_des_ede_ofb64: &[u8; 12] = b"des-ede-ofb\0";
pub const NID_des_ede_ofb64: u32 = 62;
pub const SN_des_ede3_ofb64: &[u8; 13] = b"DES-EDE3-OFB\0";
pub const LN_des_ede3_ofb64: &[u8; 13] = b"des-ede3-ofb\0";
pub const NID_des_ede3_ofb64: u32 = 63;
pub const SN_desx_cbc: &[u8; 9] = b"DESX-CBC\0";
pub const LN_desx_cbc: &[u8; 9] = b"desx-cbc\0";
pub const NID_desx_cbc: u32 = 80;
pub const SN_sha: &[u8; 4] = b"SHA\0";
pub const LN_sha: &[u8; 4] = b"sha\0";
pub const NID_sha: u32 = 41;
pub const SN_sha1: &[u8; 5] = b"SHA1\0";
pub const LN_sha1: &[u8; 5] = b"sha1\0";
pub const NID_sha1: u32 = 64;
pub const SN_dsaWithSHA1_2: &[u8; 13] = b"DSA-SHA1-old\0";
pub const LN_dsaWithSHA1_2: &[u8; 16] = b"dsaWithSHA1-old\0";
pub const NID_dsaWithSHA1_2: u32 = 70;
pub const SN_sha1WithRSA: &[u8; 11] = b"RSA-SHA1-2\0";
pub const LN_sha1WithRSA: &[u8; 12] = b"sha1WithRSA\0";
pub const NID_sha1WithRSA: u32 = 115;
pub const SN_ripemd160: &[u8; 10] = b"RIPEMD160\0";
pub const LN_ripemd160: &[u8; 10] = b"ripemd160\0";
pub const NID_ripemd160: u32 = 117;
pub const SN_ripemd160WithRSA: &[u8; 14] = b"RSA-RIPEMD160\0";
pub const LN_ripemd160WithRSA: &[u8; 17] = b"ripemd160WithRSA\0";
pub const NID_ripemd160WithRSA: u32 = 119;
pub const SN_blake2bmac: &[u8; 11] = b"BLAKE2BMAC\0";
pub const LN_blake2bmac: &[u8; 11] = b"blake2bmac\0";
pub const NID_blake2bmac: u32 = 1201;
pub const SN_blake2smac: &[u8; 11] = b"BLAKE2SMAC\0";
pub const LN_blake2smac: &[u8; 11] = b"blake2smac\0";
pub const NID_blake2smac: u32 = 1202;
pub const SN_blake2b512: &[u8; 11] = b"BLAKE2b512\0";
pub const LN_blake2b512: &[u8; 11] = b"blake2b512\0";
pub const NID_blake2b512: u32 = 1056;
pub const SN_blake2s256: &[u8; 11] = b"BLAKE2s256\0";
pub const LN_blake2s256: &[u8; 11] = b"blake2s256\0";
pub const NID_blake2s256: u32 = 1057;
pub const SN_sxnet: &[u8; 8] = b"SXNetID\0";
pub const LN_sxnet: &[u8; 19] = b"Strong Extranet ID\0";
pub const NID_sxnet: u32 = 143;
pub const SN_X500: &[u8; 5] = b"X500\0";
pub const LN_X500: &[u8; 27] = b"directory services (X.500)\0";
pub const NID_X500: u32 = 11;
pub const SN_X509: &[u8; 5] = b"X509\0";
pub const NID_X509: u32 = 12;
pub const SN_commonName: &[u8; 3] = b"CN\0";
pub const LN_commonName: &[u8; 11] = b"commonName\0";
pub const NID_commonName: u32 = 13;
pub const SN_surname: &[u8; 3] = b"SN\0";
pub const LN_surname: &[u8; 8] = b"surname\0";
pub const NID_surname: u32 = 100;
pub const LN_serialNumber: &[u8; 13] = b"serialNumber\0";
pub const NID_serialNumber: u32 = 105;
pub const SN_countryName: &[u8; 2] = b"C\0";
pub const LN_countryName: &[u8; 12] = b"countryName\0";
pub const NID_countryName: u32 = 14;
pub const SN_localityName: &[u8; 2] = b"L\0";
pub const LN_localityName: &[u8; 13] = b"localityName\0";
pub const NID_localityName: u32 = 15;
pub const SN_stateOrProvinceName: &[u8; 3] = b"ST\0";
pub const LN_stateOrProvinceName: &[u8; 20] = b"stateOrProvinceName\0";
pub const NID_stateOrProvinceName: u32 = 16;
pub const SN_streetAddress: &[u8; 7] = b"street\0";
pub const LN_streetAddress: &[u8; 14] = b"streetAddress\0";
pub const NID_streetAddress: u32 = 660;
pub const SN_organizationName: &[u8; 2] = b"O\0";
pub const LN_organizationName: &[u8; 17] = b"organizationName\0";
pub const NID_organizationName: u32 = 17;
pub const SN_organizationalUnitName: &[u8; 3] = b"OU\0";
pub const LN_organizationalUnitName: &[u8; 23] = b"organizationalUnitName\0";
pub const NID_organizationalUnitName: u32 = 18;
pub const SN_title: &[u8; 6] = b"title\0";
pub const LN_title: &[u8; 6] = b"title\0";
pub const NID_title: u32 = 106;
pub const LN_description: &[u8; 12] = b"description\0";
pub const NID_description: u32 = 107;
pub const LN_searchGuide: &[u8; 12] = b"searchGuide\0";
pub const NID_searchGuide: u32 = 859;
pub const LN_businessCategory: &[u8; 17] = b"businessCategory\0";
pub const NID_businessCategory: u32 = 860;
pub const LN_postalAddress: &[u8; 14] = b"postalAddress\0";
pub const NID_postalAddress: u32 = 861;
pub const LN_postalCode: &[u8; 11] = b"postalCode\0";
pub const NID_postalCode: u32 = 661;
pub const LN_postOfficeBox: &[u8; 14] = b"postOfficeBox\0";
pub const NID_postOfficeBox: u32 = 862;
pub const LN_physicalDeliveryOfficeName: &[u8; 27] = b"physicalDeliveryOfficeName\0";
pub const NID_physicalDeliveryOfficeName: u32 = 863;
pub const LN_telephoneNumber: &[u8; 16] = b"telephoneNumber\0";
pub const NID_telephoneNumber: u32 = 864;
pub const LN_telexNumber: &[u8; 12] = b"telexNumber\0";
pub const NID_telexNumber: u32 = 865;
pub const LN_teletexTerminalIdentifier: &[u8; 26] = b"teletexTerminalIdentifier\0";
pub const NID_teletexTerminalIdentifier: u32 = 866;
pub const LN_facsimileTelephoneNumber: &[u8; 25] = b"facsimileTelephoneNumber\0";
pub const NID_facsimileTelephoneNumber: u32 = 867;
pub const LN_x121Address: &[u8; 12] = b"x121Address\0";
pub const NID_x121Address: u32 = 868;
pub const LN_internationaliSDNNumber: &[u8; 24] = b"internationaliSDNNumber\0";
pub const NID_internationaliSDNNumber: u32 = 869;
pub const LN_registeredAddress: &[u8; 18] = b"registeredAddress\0";
pub const NID_registeredAddress: u32 = 870;
pub const LN_destinationIndicator: &[u8; 21] = b"destinationIndicator\0";
pub const NID_destinationIndicator: u32 = 871;
pub const LN_preferredDeliveryMethod: &[u8; 24] = b"preferredDeliveryMethod\0";
pub const NID_preferredDeliveryMethod: u32 = 872;
pub const LN_presentationAddress: &[u8; 20] = b"presentationAddress\0";
pub const NID_presentationAddress: u32 = 873;
pub const LN_supportedApplicationContext: &[u8; 28] = b"supportedApplicationContext\0";
pub const NID_supportedApplicationContext: u32 = 874;
pub const SN_member: &[u8; 7] = b"member\0";
pub const NID_member: u32 = 875;
pub const SN_owner: &[u8; 6] = b"owner\0";
pub const NID_owner: u32 = 876;
pub const LN_roleOccupant: &[u8; 13] = b"roleOccupant\0";
pub const NID_roleOccupant: u32 = 877;
pub const SN_seeAlso: &[u8; 8] = b"seeAlso\0";
pub const NID_seeAlso: u32 = 878;
pub const LN_userPassword: &[u8; 13] = b"userPassword\0";
pub const NID_userPassword: u32 = 879;
pub const LN_userCertificate: &[u8; 16] = b"userCertificate\0";
pub const NID_userCertificate: u32 = 880;
pub const LN_cACertificate: &[u8; 14] = b"cACertificate\0";
pub const NID_cACertificate: u32 = 881;
pub const LN_authorityRevocationList: &[u8; 24] = b"authorityRevocationList\0";
pub const NID_authorityRevocationList: u32 = 882;
pub const LN_certificateRevocationList: &[u8; 26] = b"certificateRevocationList\0";
pub const NID_certificateRevocationList: u32 = 883;
pub const LN_crossCertificatePair: &[u8; 21] = b"crossCertificatePair\0";
pub const NID_crossCertificatePair: u32 = 884;
pub const SN_name: &[u8; 5] = b"name\0";
pub const LN_name: &[u8; 5] = b"name\0";
pub const NID_name: u32 = 173;
pub const SN_givenName: &[u8; 3] = b"GN\0";
pub const LN_givenName: &[u8; 10] = b"givenName\0";
pub const NID_givenName: u32 = 99;
pub const SN_initials: &[u8; 9] = b"initials\0";
pub const LN_initials: &[u8; 9] = b"initials\0";
pub const NID_initials: u32 = 101;
pub const LN_generationQualifier: &[u8; 20] = b"generationQualifier\0";
pub const NID_generationQualifier: u32 = 509;
pub const LN_x500UniqueIdentifier: &[u8; 21] = b"x500UniqueIdentifier\0";
pub const NID_x500UniqueIdentifier: u32 = 503;
pub const SN_dnQualifier: &[u8; 12] = b"dnQualifier\0";
pub const LN_dnQualifier: &[u8; 12] = b"dnQualifier\0";
pub const NID_dnQualifier: u32 = 174;
pub const LN_enhancedSearchGuide: &[u8; 20] = b"enhancedSearchGuide\0";
pub const NID_enhancedSearchGuide: u32 = 885;
pub const LN_protocolInformation: &[u8; 20] = b"protocolInformation\0";
pub const NID_protocolInformation: u32 = 886;
pub const LN_distinguishedName: &[u8; 18] = b"distinguishedName\0";
pub const NID_distinguishedName: u32 = 887;
pub const LN_uniqueMember: &[u8; 13] = b"uniqueMember\0";
pub const NID_uniqueMember: u32 = 888;
pub const LN_houseIdentifier: &[u8; 16] = b"houseIdentifier\0";
pub const NID_houseIdentifier: u32 = 889;
pub const LN_supportedAlgorithms: &[u8; 20] = b"supportedAlgorithms\0";
pub const NID_supportedAlgorithms: u32 = 890;
pub const LN_deltaRevocationList: &[u8; 20] = b"deltaRevocationList\0";
pub const NID_deltaRevocationList: u32 = 891;
pub const SN_dmdName: &[u8; 8] = b"dmdName\0";
pub const NID_dmdName: u32 = 892;
pub const LN_pseudonym: &[u8; 10] = b"pseudonym\0";
pub const NID_pseudonym: u32 = 510;
pub const SN_role: &[u8; 5] = b"role\0";
pub const LN_role: &[u8; 5] = b"role\0";
pub const NID_role: u32 = 400;
pub const LN_organizationIdentifier: &[u8; 23] = b"organizationIdentifier\0";
pub const NID_organizationIdentifier: u32 = 1089;
pub const SN_countryCode3c: &[u8; 3] = b"c3\0";
pub const LN_countryCode3c: &[u8; 14] = b"countryCode3c\0";
pub const NID_countryCode3c: u32 = 1090;
pub const SN_countryCode3n: &[u8; 3] = b"n3\0";
pub const LN_countryCode3n: &[u8; 14] = b"countryCode3n\0";
pub const NID_countryCode3n: u32 = 1091;
pub const LN_dnsName: &[u8; 8] = b"dnsName\0";
pub const NID_dnsName: u32 = 1092;
pub const SN_X500algorithms: &[u8; 15] = b"X500algorithms\0";
pub const LN_X500algorithms: &[u8; 32] = b"directory services - algorithms\0";
pub const NID_X500algorithms: u32 = 378;
pub const SN_rsa: &[u8; 4] = b"RSA\0";
pub const LN_rsa: &[u8; 4] = b"rsa\0";
pub const NID_rsa: u32 = 19;
pub const SN_mdc2WithRSA: &[u8; 9] = b"RSA-MDC2\0";
pub const LN_mdc2WithRSA: &[u8; 12] = b"mdc2WithRSA\0";
pub const NID_mdc2WithRSA: u32 = 96;
pub const SN_mdc2: &[u8; 5] = b"MDC2\0";
pub const LN_mdc2: &[u8; 5] = b"mdc2\0";
pub const NID_mdc2: u32 = 95;
pub const SN_id_ce: &[u8; 6] = b"id-ce\0";
pub const NID_id_ce: u32 = 81;
pub const SN_subject_directory_attributes: &[u8; 27] = b"subjectDirectoryAttributes\0";
pub const LN_subject_directory_attributes: &[u8; 36] = b"X509v3 Subject Directory Attributes\0";
pub const NID_subject_directory_attributes: u32 = 769;
pub const SN_subject_key_identifier: &[u8; 21] = b"subjectKeyIdentifier\0";
pub const LN_subject_key_identifier: &[u8; 30] = b"X509v3 Subject Key Identifier\0";
pub const NID_subject_key_identifier: u32 = 82;
pub const SN_key_usage: &[u8; 9] = b"keyUsage\0";
pub const LN_key_usage: &[u8; 17] = b"X509v3 Key Usage\0";
pub const NID_key_usage: u32 = 83;
pub const SN_private_key_usage_period: &[u8; 22] = b"privateKeyUsagePeriod\0";
pub const LN_private_key_usage_period: &[u8; 32] = b"X509v3 Private Key Usage Period\0";
pub const NID_private_key_usage_period: u32 = 84;
pub const SN_subject_alt_name: &[u8; 15] = b"subjectAltName\0";
pub const LN_subject_alt_name: &[u8; 32] = b"X509v3 Subject Alternative Name\0";
pub const NID_subject_alt_name: u32 = 85;
pub const SN_issuer_alt_name: &[u8; 14] = b"issuerAltName\0";
pub const LN_issuer_alt_name: &[u8; 31] = b"X509v3 Issuer Alternative Name\0";
pub const NID_issuer_alt_name: u32 = 86;
pub const SN_basic_constraints: &[u8; 17] = b"basicConstraints\0";
pub const LN_basic_constraints: &[u8; 25] = b"X509v3 Basic Constraints\0";
pub const NID_basic_constraints: u32 = 87;
pub const SN_crl_number: &[u8; 10] = b"crlNumber\0";
pub const LN_crl_number: &[u8; 18] = b"X509v3 CRL Number\0";
pub const NID_crl_number: u32 = 88;
pub const SN_crl_reason: &[u8; 10] = b"CRLReason\0";
pub const LN_crl_reason: &[u8; 23] = b"X509v3 CRL Reason Code\0";
pub const NID_crl_reason: u32 = 141;
pub const SN_invalidity_date: &[u8; 15] = b"invalidityDate\0";
pub const LN_invalidity_date: &[u8; 16] = b"Invalidity Date\0";
pub const NID_invalidity_date: u32 = 142;
pub const SN_delta_crl: &[u8; 9] = b"deltaCRL\0";
pub const LN_delta_crl: &[u8; 27] = b"X509v3 Delta CRL Indicator\0";
pub const NID_delta_crl: u32 = 140;
pub const SN_issuing_distribution_point: &[u8; 25] = b"issuingDistributionPoint\0";
pub const LN_issuing_distribution_point: &[u8; 34] = b"X509v3 Issuing Distribution Point\0";
pub const NID_issuing_distribution_point: u32 = 770;
pub const SN_certificate_issuer: &[u8; 18] = b"certificateIssuer\0";
pub const LN_certificate_issuer: &[u8; 26] = b"X509v3 Certificate Issuer\0";
pub const NID_certificate_issuer: u32 = 771;
pub const SN_name_constraints: &[u8; 16] = b"nameConstraints\0";
pub const LN_name_constraints: &[u8; 24] = b"X509v3 Name Constraints\0";
pub const NID_name_constraints: u32 = 666;
pub const SN_crl_distribution_points: &[u8; 22] = b"crlDistributionPoints\0";
pub const LN_crl_distribution_points: &[u8; 31] = b"X509v3 CRL Distribution Points\0";
pub const NID_crl_distribution_points: u32 = 103;
pub const SN_certificate_policies: &[u8; 20] = b"certificatePolicies\0";
pub const LN_certificate_policies: &[u8; 28] = b"X509v3 Certificate Policies\0";
pub const NID_certificate_policies: u32 = 89;
pub const SN_any_policy: &[u8; 10] = b"anyPolicy\0";
pub const LN_any_policy: &[u8; 18] = b"X509v3 Any Policy\0";
pub const NID_any_policy: u32 = 746;
pub const SN_policy_mappings: &[u8; 15] = b"policyMappings\0";
pub const LN_policy_mappings: &[u8; 23] = b"X509v3 Policy Mappings\0";
pub const NID_policy_mappings: u32 = 747;
pub const SN_authority_key_identifier: &[u8; 23] = b"authorityKeyIdentifier\0";
pub const LN_authority_key_identifier: &[u8; 32] = b"X509v3 Authority Key Identifier\0";
pub const NID_authority_key_identifier: u32 = 90;
pub const SN_policy_constraints: &[u8; 18] = b"policyConstraints\0";
pub const LN_policy_constraints: &[u8; 26] = b"X509v3 Policy Constraints\0";
pub const NID_policy_constraints: u32 = 401;
pub const SN_ext_key_usage: &[u8; 17] = b"extendedKeyUsage\0";
pub const LN_ext_key_usage: &[u8; 26] = b"X509v3 Extended Key Usage\0";
pub const NID_ext_key_usage: u32 = 126;
pub const SN_freshest_crl: &[u8; 12] = b"freshestCRL\0";
pub const LN_freshest_crl: &[u8; 20] = b"X509v3 Freshest CRL\0";
pub const NID_freshest_crl: u32 = 857;
pub const SN_inhibit_any_policy: &[u8; 17] = b"inhibitAnyPolicy\0";
pub const LN_inhibit_any_policy: &[u8; 26] = b"X509v3 Inhibit Any Policy\0";
pub const NID_inhibit_any_policy: u32 = 748;
pub const SN_target_information: &[u8; 18] = b"targetInformation\0";
pub const LN_target_information: &[u8; 20] = b"X509v3 AC Targeting\0";
pub const NID_target_information: u32 = 402;
pub const SN_no_rev_avail: &[u8; 11] = b"noRevAvail\0";
pub const LN_no_rev_avail: &[u8; 31] = b"X509v3 No Revocation Available\0";
pub const NID_no_rev_avail: u32 = 403;
pub const SN_anyExtendedKeyUsage: &[u8; 20] = b"anyExtendedKeyUsage\0";
pub const LN_anyExtendedKeyUsage: &[u8; 23] = b"Any Extended Key Usage\0";
pub const NID_anyExtendedKeyUsage: u32 = 910;
pub const SN_netscape: &[u8; 9] = b"Netscape\0";
pub const LN_netscape: &[u8; 30] = b"Netscape Communications Corp.\0";
pub const NID_netscape: u32 = 57;
pub const SN_netscape_cert_extension: &[u8; 10] = b"nsCertExt\0";
pub const LN_netscape_cert_extension: &[u8; 31] = b"Netscape Certificate Extension\0";
pub const NID_netscape_cert_extension: u32 = 58;
pub const SN_netscape_data_type: &[u8; 11] = b"nsDataType\0";
pub const LN_netscape_data_type: &[u8; 19] = b"Netscape Data Type\0";
pub const NID_netscape_data_type: u32 = 59;
pub const SN_netscape_cert_type: &[u8; 11] = b"nsCertType\0";
pub const LN_netscape_cert_type: &[u8; 19] = b"Netscape Cert Type\0";
pub const NID_netscape_cert_type: u32 = 71;
pub const SN_netscape_base_url: &[u8; 10] = b"nsBaseUrl\0";
pub const LN_netscape_base_url: &[u8; 18] = b"Netscape Base Url\0";
pub const NID_netscape_base_url: u32 = 72;
pub const SN_netscape_revocation_url: &[u8; 16] = b"nsRevocationUrl\0";
pub const LN_netscape_revocation_url: &[u8; 24] = b"Netscape Revocation Url\0";
pub const NID_netscape_revocation_url: u32 = 73;
pub const SN_netscape_ca_revocation_url: &[u8; 18] = b"nsCaRevocationUrl\0";
pub const LN_netscape_ca_revocation_url: &[u8; 27] = b"Netscape CA Revocation Url\0";
pub const NID_netscape_ca_revocation_url: u32 = 74;
pub const SN_netscape_renewal_url: &[u8; 13] = b"nsRenewalUrl\0";
pub const LN_netscape_renewal_url: &[u8; 21] = b"Netscape Renewal Url\0";
pub const NID_netscape_renewal_url: u32 = 75;
pub const SN_netscape_ca_policy_url: &[u8; 14] = b"nsCaPolicyUrl\0";
pub const LN_netscape_ca_policy_url: &[u8; 23] = b"Netscape CA Policy Url\0";
pub const NID_netscape_ca_policy_url: u32 = 76;
pub const SN_netscape_ssl_server_name: &[u8; 16] = b"nsSslServerName\0";
pub const LN_netscape_ssl_server_name: &[u8; 25] = b"Netscape SSL Server Name\0";
pub const NID_netscape_ssl_server_name: u32 = 77;
pub const SN_netscape_comment: &[u8; 10] = b"nsComment\0";
pub const LN_netscape_comment: &[u8; 17] = b"Netscape Comment\0";
pub const NID_netscape_comment: u32 = 78;
pub const SN_netscape_cert_sequence: &[u8; 15] = b"nsCertSequence\0";
pub const LN_netscape_cert_sequence: &[u8; 30] = b"Netscape Certificate Sequence\0";
pub const NID_netscape_cert_sequence: u32 = 79;
pub const SN_ns_sgc: &[u8; 6] = b"nsSGC\0";
pub const LN_ns_sgc: &[u8; 29] = b"Netscape Server Gated Crypto\0";
pub const NID_ns_sgc: u32 = 139;
pub const SN_org: &[u8; 4] = b"ORG\0";
pub const LN_org: &[u8; 4] = b"org\0";
pub const NID_org: u32 = 379;
pub const SN_dod: &[u8; 4] = b"DOD\0";
pub const LN_dod: &[u8; 4] = b"dod\0";
pub const NID_dod: u32 = 380;
pub const SN_iana: &[u8; 5] = b"IANA\0";
pub const LN_iana: &[u8; 5] = b"iana\0";
pub const NID_iana: u32 = 381;
pub const SN_Directory: &[u8; 10] = b"directory\0";
pub const LN_Directory: &[u8; 10] = b"Directory\0";
pub const NID_Directory: u32 = 382;
pub const SN_Management: &[u8; 5] = b"mgmt\0";
pub const LN_Management: &[u8; 11] = b"Management\0";
pub const NID_Management: u32 = 383;
pub const SN_Experimental: &[u8; 13] = b"experimental\0";
pub const LN_Experimental: &[u8; 13] = b"Experimental\0";
pub const NID_Experimental: u32 = 384;
pub const SN_Private: &[u8; 8] = b"private\0";
pub const LN_Private: &[u8; 8] = b"Private\0";
pub const NID_Private: u32 = 385;
pub const SN_Security: &[u8; 9] = b"security\0";
pub const LN_Security: &[u8; 9] = b"Security\0";
pub const NID_Security: u32 = 386;
pub const SN_SNMPv2: &[u8; 7] = b"snmpv2\0";
pub const LN_SNMPv2: &[u8; 7] = b"SNMPv2\0";
pub const NID_SNMPv2: u32 = 387;
pub const LN_Mail: &[u8; 5] = b"Mail\0";
pub const NID_Mail: u32 = 388;
pub const SN_Enterprises: &[u8; 12] = b"enterprises\0";
pub const LN_Enterprises: &[u8; 12] = b"Enterprises\0";
pub const NID_Enterprises: u32 = 389;
pub const SN_dcObject: &[u8; 9] = b"dcobject\0";
pub const LN_dcObject: &[u8; 9] = b"dcObject\0";
pub const NID_dcObject: u32 = 390;
pub const SN_mime_mhs: &[u8; 9] = b"mime-mhs\0";
pub const LN_mime_mhs: &[u8; 9] = b"MIME MHS\0";
pub const NID_mime_mhs: u32 = 504;
pub const SN_mime_mhs_headings: &[u8; 18] = b"mime-mhs-headings\0";
pub const LN_mime_mhs_headings: &[u8; 18] = b"mime-mhs-headings\0";
pub const NID_mime_mhs_headings: u32 = 505;
pub const SN_mime_mhs_bodies: &[u8; 16] = b"mime-mhs-bodies\0";
pub const LN_mime_mhs_bodies: &[u8; 16] = b"mime-mhs-bodies\0";
pub const NID_mime_mhs_bodies: u32 = 506;
pub const SN_id_hex_partial_message: &[u8; 23] = b"id-hex-partial-message\0";
pub const LN_id_hex_partial_message: &[u8; 23] = b"id-hex-partial-message\0";
pub const NID_id_hex_partial_message: u32 = 507;
pub const SN_id_hex_multipart_message: &[u8; 25] = b"id-hex-multipart-message\0";
pub const LN_id_hex_multipart_message: &[u8; 25] = b"id-hex-multipart-message\0";
pub const NID_id_hex_multipart_message: u32 = 508;
pub const SN_zlib_compression: &[u8; 5] = b"ZLIB\0";
pub const LN_zlib_compression: &[u8; 17] = b"zlib compression\0";
pub const NID_zlib_compression: u32 = 125;
pub const SN_aes_128_ecb: &[u8; 12] = b"AES-128-ECB\0";
pub const LN_aes_128_ecb: &[u8; 12] = b"aes-128-ecb\0";
pub const NID_aes_128_ecb: u32 = 418;
pub const SN_aes_128_cbc: &[u8; 12] = b"AES-128-CBC\0";
pub const LN_aes_128_cbc: &[u8; 12] = b"aes-128-cbc\0";
pub const NID_aes_128_cbc: u32 = 419;
pub const SN_aes_128_ofb128: &[u8; 12] = b"AES-128-OFB\0";
pub const LN_aes_128_ofb128: &[u8; 12] = b"aes-128-ofb\0";
pub const NID_aes_128_ofb128: u32 = 420;
pub const SN_aes_128_cfb128: &[u8; 12] = b"AES-128-CFB\0";
pub const LN_aes_128_cfb128: &[u8; 12] = b"aes-128-cfb\0";
pub const NID_aes_128_cfb128: u32 = 421;
pub const SN_id_aes128_wrap: &[u8; 15] = b"id-aes128-wrap\0";
pub const NID_id_aes128_wrap: u32 = 788;
pub const SN_aes_128_gcm: &[u8; 14] = b"id-aes128-GCM\0";
pub const LN_aes_128_gcm: &[u8; 12] = b"aes-128-gcm\0";
pub const NID_aes_128_gcm: u32 = 895;
pub const SN_aes_128_ccm: &[u8; 14] = b"id-aes128-CCM\0";
pub const LN_aes_128_ccm: &[u8; 12] = b"aes-128-ccm\0";
pub const NID_aes_128_ccm: u32 = 896;
pub const SN_id_aes128_wrap_pad: &[u8; 19] = b"id-aes128-wrap-pad\0";
pub const NID_id_aes128_wrap_pad: u32 = 897;
pub const SN_aes_192_ecb: &[u8; 12] = b"AES-192-ECB\0";
pub const LN_aes_192_ecb: &[u8; 12] = b"aes-192-ecb\0";
pub const NID_aes_192_ecb: u32 = 422;
pub const SN_aes_192_cbc: &[u8; 12] = b"AES-192-CBC\0";
pub const LN_aes_192_cbc: &[u8; 12] = b"aes-192-cbc\0";
pub const NID_aes_192_cbc: u32 = 423;
pub const SN_aes_192_ofb128: &[u8; 12] = b"AES-192-OFB\0";
pub const LN_aes_192_ofb128: &[u8; 12] = b"aes-192-ofb\0";
pub const NID_aes_192_ofb128: u32 = 424;
pub const SN_aes_192_cfb128: &[u8; 12] = b"AES-192-CFB\0";
pub const LN_aes_192_cfb128: &[u8; 12] = b"aes-192-cfb\0";
pub const NID_aes_192_cfb128: u32 = 425;
pub const SN_id_aes192_wrap: &[u8; 15] = b"id-aes192-wrap\0";
pub const NID_id_aes192_wrap: u32 = 789;
pub const SN_aes_192_gcm: &[u8; 14] = b"id-aes192-GCM\0";
pub const LN_aes_192_gcm: &[u8; 12] = b"aes-192-gcm\0";
pub const NID_aes_192_gcm: u32 = 898;
pub const SN_aes_192_ccm: &[u8; 14] = b"id-aes192-CCM\0";
pub const LN_aes_192_ccm: &[u8; 12] = b"aes-192-ccm\0";
pub const NID_aes_192_ccm: u32 = 899;
pub const SN_id_aes192_wrap_pad: &[u8; 19] = b"id-aes192-wrap-pad\0";
pub const NID_id_aes192_wrap_pad: u32 = 900;
pub const SN_aes_256_ecb: &[u8; 12] = b"AES-256-ECB\0";
pub const LN_aes_256_ecb: &[u8; 12] = b"aes-256-ecb\0";
pub const NID_aes_256_ecb: u32 = 426;
pub const SN_aes_256_cbc: &[u8; 12] = b"AES-256-CBC\0";
pub const LN_aes_256_cbc: &[u8; 12] = b"aes-256-cbc\0";
pub const NID_aes_256_cbc: u32 = 427;
pub const SN_aes_256_ofb128: &[u8; 12] = b"AES-256-OFB\0";
pub const LN_aes_256_ofb128: &[u8; 12] = b"aes-256-ofb\0";
pub const NID_aes_256_ofb128: u32 = 428;
pub const SN_aes_256_cfb128: &[u8; 12] = b"AES-256-CFB\0";
pub const LN_aes_256_cfb128: &[u8; 12] = b"aes-256-cfb\0";
pub const NID_aes_256_cfb128: u32 = 429;
pub const SN_id_aes256_wrap: &[u8; 15] = b"id-aes256-wrap\0";
pub const NID_id_aes256_wrap: u32 = 790;
pub const SN_aes_256_gcm: &[u8; 14] = b"id-aes256-GCM\0";
pub const LN_aes_256_gcm: &[u8; 12] = b"aes-256-gcm\0";
pub const NID_aes_256_gcm: u32 = 901;
pub const SN_aes_256_ccm: &[u8; 14] = b"id-aes256-CCM\0";
pub const LN_aes_256_ccm: &[u8; 12] = b"aes-256-ccm\0";
pub const NID_aes_256_ccm: u32 = 902;
pub const SN_id_aes256_wrap_pad: &[u8; 19] = b"id-aes256-wrap-pad\0";
pub const NID_id_aes256_wrap_pad: u32 = 903;
pub const SN_aes_128_xts: &[u8; 12] = b"AES-128-XTS\0";
pub const LN_aes_128_xts: &[u8; 12] = b"aes-128-xts\0";
pub const NID_aes_128_xts: u32 = 913;
pub const SN_aes_256_xts: &[u8; 12] = b"AES-256-XTS\0";
pub const LN_aes_256_xts: &[u8; 12] = b"aes-256-xts\0";
pub const NID_aes_256_xts: u32 = 914;
pub const SN_aes_128_cfb1: &[u8; 13] = b"AES-128-CFB1\0";
pub const LN_aes_128_cfb1: &[u8; 13] = b"aes-128-cfb1\0";
pub const NID_aes_128_cfb1: u32 = 650;
pub const SN_aes_192_cfb1: &[u8; 13] = b"AES-192-CFB1\0";
pub const LN_aes_192_cfb1: &[u8; 13] = b"aes-192-cfb1\0";
pub const NID_aes_192_cfb1: u32 = 651;
pub const SN_aes_256_cfb1: &[u8; 13] = b"AES-256-CFB1\0";
pub const LN_aes_256_cfb1: &[u8; 13] = b"aes-256-cfb1\0";
pub const NID_aes_256_cfb1: u32 = 652;
pub const SN_aes_128_cfb8: &[u8; 13] = b"AES-128-CFB8\0";
pub const LN_aes_128_cfb8: &[u8; 13] = b"aes-128-cfb8\0";
pub const NID_aes_128_cfb8: u32 = 653;
pub const SN_aes_192_cfb8: &[u8; 13] = b"AES-192-CFB8\0";
pub const LN_aes_192_cfb8: &[u8; 13] = b"aes-192-cfb8\0";
pub const NID_aes_192_cfb8: u32 = 654;
pub const SN_aes_256_cfb8: &[u8; 13] = b"AES-256-CFB8\0";
pub const LN_aes_256_cfb8: &[u8; 13] = b"aes-256-cfb8\0";
pub const NID_aes_256_cfb8: u32 = 655;
pub const SN_aes_128_ctr: &[u8; 12] = b"AES-128-CTR\0";
pub const LN_aes_128_ctr: &[u8; 12] = b"aes-128-ctr\0";
pub const NID_aes_128_ctr: u32 = 904;
pub const SN_aes_192_ctr: &[u8; 12] = b"AES-192-CTR\0";
pub const LN_aes_192_ctr: &[u8; 12] = b"aes-192-ctr\0";
pub const NID_aes_192_ctr: u32 = 905;
pub const SN_aes_256_ctr: &[u8; 12] = b"AES-256-CTR\0";
pub const LN_aes_256_ctr: &[u8; 12] = b"aes-256-ctr\0";
pub const NID_aes_256_ctr: u32 = 906;
pub const SN_aes_128_ocb: &[u8; 12] = b"AES-128-OCB\0";
pub const LN_aes_128_ocb: &[u8; 12] = b"aes-128-ocb\0";
pub const NID_aes_128_ocb: u32 = 958;
pub const SN_aes_192_ocb: &[u8; 12] = b"AES-192-OCB\0";
pub const LN_aes_192_ocb: &[u8; 12] = b"aes-192-ocb\0";
pub const NID_aes_192_ocb: u32 = 959;
pub const SN_aes_256_ocb: &[u8; 12] = b"AES-256-OCB\0";
pub const LN_aes_256_ocb: &[u8; 12] = b"aes-256-ocb\0";
pub const NID_aes_256_ocb: u32 = 960;
pub const SN_des_cfb1: &[u8; 9] = b"DES-CFB1\0";
pub const LN_des_cfb1: &[u8; 9] = b"des-cfb1\0";
pub const NID_des_cfb1: u32 = 656;
pub const SN_des_cfb8: &[u8; 9] = b"DES-CFB8\0";
pub const LN_des_cfb8: &[u8; 9] = b"des-cfb8\0";
pub const NID_des_cfb8: u32 = 657;
pub const SN_des_ede3_cfb1: &[u8; 14] = b"DES-EDE3-CFB1\0";
pub const LN_des_ede3_cfb1: &[u8; 14] = b"des-ede3-cfb1\0";
pub const NID_des_ede3_cfb1: u32 = 658;
pub const SN_des_ede3_cfb8: &[u8; 14] = b"DES-EDE3-CFB8\0";
pub const LN_des_ede3_cfb8: &[u8; 14] = b"des-ede3-cfb8\0";
pub const NID_des_ede3_cfb8: u32 = 659;
pub const SN_sha256: &[u8; 7] = b"SHA256\0";
pub const LN_sha256: &[u8; 7] = b"sha256\0";
pub const NID_sha256: u32 = 672;
pub const SN_sha384: &[u8; 7] = b"SHA384\0";
pub const LN_sha384: &[u8; 7] = b"sha384\0";
pub const NID_sha384: u32 = 673;
pub const SN_sha512: &[u8; 7] = b"SHA512\0";
pub const LN_sha512: &[u8; 7] = b"sha512\0";
pub const NID_sha512: u32 = 674;
pub const SN_sha224: &[u8; 7] = b"SHA224\0";
pub const LN_sha224: &[u8; 7] = b"sha224\0";
pub const NID_sha224: u32 = 675;
pub const SN_sha512_224: &[u8; 11] = b"SHA512-224\0";
pub const LN_sha512_224: &[u8; 11] = b"sha512-224\0";
pub const NID_sha512_224: u32 = 1094;
pub const SN_sha512_256: &[u8; 11] = b"SHA512-256\0";
pub const LN_sha512_256: &[u8; 11] = b"sha512-256\0";
pub const NID_sha512_256: u32 = 1095;
pub const SN_sha3_224: &[u8; 9] = b"SHA3-224\0";
pub const LN_sha3_224: &[u8; 9] = b"sha3-224\0";
pub const NID_sha3_224: u32 = 1096;
pub const SN_sha3_256: &[u8; 9] = b"SHA3-256\0";
pub const LN_sha3_256: &[u8; 9] = b"sha3-256\0";
pub const NID_sha3_256: u32 = 1097;
pub const SN_sha3_384: &[u8; 9] = b"SHA3-384\0";
pub const LN_sha3_384: &[u8; 9] = b"sha3-384\0";
pub const NID_sha3_384: u32 = 1098;
pub const SN_sha3_512: &[u8; 9] = b"SHA3-512\0";
pub const LN_sha3_512: &[u8; 9] = b"sha3-512\0";
pub const NID_sha3_512: u32 = 1099;
pub const SN_shake128: &[u8; 9] = b"SHAKE128\0";
pub const LN_shake128: &[u8; 9] = b"shake128\0";
pub const NID_shake128: u32 = 1100;
pub const SN_shake256: &[u8; 9] = b"SHAKE256\0";
pub const LN_shake256: &[u8; 9] = b"shake256\0";
pub const NID_shake256: u32 = 1101;
pub const SN_hmac_sha3_224: &[u8; 20] = b"id-hmacWithSHA3-224\0";
pub const LN_hmac_sha3_224: &[u8; 14] = b"hmac-sha3-224\0";
pub const NID_hmac_sha3_224: u32 = 1102;
pub const SN_hmac_sha3_256: &[u8; 20] = b"id-hmacWithSHA3-256\0";
pub const LN_hmac_sha3_256: &[u8; 14] = b"hmac-sha3-256\0";
pub const NID_hmac_sha3_256: u32 = 1103;
pub const SN_hmac_sha3_384: &[u8; 20] = b"id-hmacWithSHA3-384\0";
pub const LN_hmac_sha3_384: &[u8; 14] = b"hmac-sha3-384\0";
pub const NID_hmac_sha3_384: u32 = 1104;
pub const SN_hmac_sha3_512: &[u8; 20] = b"id-hmacWithSHA3-512\0";
pub const LN_hmac_sha3_512: &[u8; 14] = b"hmac-sha3-512\0";
pub const NID_hmac_sha3_512: u32 = 1105;
pub const SN_kmac128: &[u8; 8] = b"KMAC128\0";
pub const LN_kmac128: &[u8; 8] = b"kmac128\0";
pub const NID_kmac128: u32 = 1196;
pub const SN_kmac256: &[u8; 8] = b"KMAC256\0";
pub const LN_kmac256: &[u8; 8] = b"kmac256\0";
pub const NID_kmac256: u32 = 1197;
pub const SN_dsa_with_SHA224: &[u8; 16] = b"dsa_with_SHA224\0";
pub const NID_dsa_with_SHA224: u32 = 802;
pub const SN_dsa_with_SHA256: &[u8; 16] = b"dsa_with_SHA256\0";
pub const NID_dsa_with_SHA256: u32 = 803;
pub const SN_dsa_with_SHA384: &[u8; 19] = b"id-dsa-with-sha384\0";
pub const LN_dsa_with_SHA384: &[u8; 16] = b"dsa_with_SHA384\0";
pub const NID_dsa_with_SHA384: u32 = 1106;
pub const SN_dsa_with_SHA512: &[u8; 19] = b"id-dsa-with-sha512\0";
pub const LN_dsa_with_SHA512: &[u8; 16] = b"dsa_with_SHA512\0";
pub const NID_dsa_with_SHA512: u32 = 1107;
pub const SN_dsa_with_SHA3_224: &[u8; 21] = b"id-dsa-with-sha3-224\0";
pub const LN_dsa_with_SHA3_224: &[u8; 18] = b"dsa_with_SHA3-224\0";
pub const NID_dsa_with_SHA3_224: u32 = 1108;
pub const SN_dsa_with_SHA3_256: &[u8; 21] = b"id-dsa-with-sha3-256\0";
pub const LN_dsa_with_SHA3_256: &[u8; 18] = b"dsa_with_SHA3-256\0";
pub const NID_dsa_with_SHA3_256: u32 = 1109;
pub const SN_dsa_with_SHA3_384: &[u8; 21] = b"id-dsa-with-sha3-384\0";
pub const LN_dsa_with_SHA3_384: &[u8; 18] = b"dsa_with_SHA3-384\0";
pub const NID_dsa_with_SHA3_384: u32 = 1110;
pub const SN_dsa_with_SHA3_512: &[u8; 21] = b"id-dsa-with-sha3-512\0";
pub const LN_dsa_with_SHA3_512: &[u8; 18] = b"dsa_with_SHA3-512\0";
pub const NID_dsa_with_SHA3_512: u32 = 1111;
pub const SN_ecdsa_with_SHA3_224: &[u8; 23] = b"id-ecdsa-with-sha3-224\0";
pub const LN_ecdsa_with_SHA3_224: &[u8; 20] = b"ecdsa_with_SHA3-224\0";
pub const NID_ecdsa_with_SHA3_224: u32 = 1112;
pub const SN_ecdsa_with_SHA3_256: &[u8; 23] = b"id-ecdsa-with-sha3-256\0";
pub const LN_ecdsa_with_SHA3_256: &[u8; 20] = b"ecdsa_with_SHA3-256\0";
pub const NID_ecdsa_with_SHA3_256: u32 = 1113;
pub const SN_ecdsa_with_SHA3_384: &[u8; 23] = b"id-ecdsa-with-sha3-384\0";
pub const LN_ecdsa_with_SHA3_384: &[u8; 20] = b"ecdsa_with_SHA3-384\0";
pub const NID_ecdsa_with_SHA3_384: u32 = 1114;
pub const SN_ecdsa_with_SHA3_512: &[u8; 23] = b"id-ecdsa-with-sha3-512\0";
pub const LN_ecdsa_with_SHA3_512: &[u8; 20] = b"ecdsa_with_SHA3-512\0";
pub const NID_ecdsa_with_SHA3_512: u32 = 1115;
pub const SN_RSA_SHA3_224: &[u8; 35] = b"id-rsassa-pkcs1-v1_5-with-sha3-224\0";
pub const LN_RSA_SHA3_224: &[u8; 13] = b"RSA-SHA3-224\0";
pub const NID_RSA_SHA3_224: u32 = 1116;
pub const SN_RSA_SHA3_256: &[u8; 35] = b"id-rsassa-pkcs1-v1_5-with-sha3-256\0";
pub const LN_RSA_SHA3_256: &[u8; 13] = b"RSA-SHA3-256\0";
pub const NID_RSA_SHA3_256: u32 = 1117;
pub const SN_RSA_SHA3_384: &[u8; 35] = b"id-rsassa-pkcs1-v1_5-with-sha3-384\0";
pub const LN_RSA_SHA3_384: &[u8; 13] = b"RSA-SHA3-384\0";
pub const NID_RSA_SHA3_384: u32 = 1118;
pub const SN_RSA_SHA3_512: &[u8; 35] = b"id-rsassa-pkcs1-v1_5-with-sha3-512\0";
pub const LN_RSA_SHA3_512: &[u8; 13] = b"RSA-SHA3-512\0";
pub const NID_RSA_SHA3_512: u32 = 1119;
pub const SN_hold_instruction_code: &[u8; 20] = b"holdInstructionCode\0";
pub const LN_hold_instruction_code: &[u8; 22] = b"Hold Instruction Code\0";
pub const NID_hold_instruction_code: u32 = 430;
pub const SN_hold_instruction_none: &[u8; 20] = b"holdInstructionNone\0";
pub const LN_hold_instruction_none: &[u8; 22] = b"Hold Instruction None\0";
pub const NID_hold_instruction_none: u32 = 431;
pub const SN_hold_instruction_call_issuer: &[u8; 26] = b"holdInstructionCallIssuer\0";
pub const LN_hold_instruction_call_issuer: &[u8; 29] = b"Hold Instruction Call Issuer\0";
pub const NID_hold_instruction_call_issuer: u32 = 432;
pub const SN_hold_instruction_reject: &[u8; 22] = b"holdInstructionReject\0";
pub const LN_hold_instruction_reject: &[u8; 24] = b"Hold Instruction Reject\0";
pub const NID_hold_instruction_reject: u32 = 433;
pub const SN_data: &[u8; 5] = b"data\0";
pub const NID_data: u32 = 434;
pub const SN_pss: &[u8; 4] = b"pss\0";
pub const NID_pss: u32 = 435;
pub const SN_ucl: &[u8; 4] = b"ucl\0";
pub const NID_ucl: u32 = 436;
pub const SN_pilot: &[u8; 6] = b"pilot\0";
pub const NID_pilot: u32 = 437;
pub const LN_pilotAttributeType: &[u8; 19] = b"pilotAttributeType\0";
pub const NID_pilotAttributeType: u32 = 438;
pub const LN_pilotAttributeSyntax: &[u8; 21] = b"pilotAttributeSyntax\0";
pub const NID_pilotAttributeSyntax: u32 = 439;
pub const LN_pilotObjectClass: &[u8; 17] = b"pilotObjectClass\0";
pub const NID_pilotObjectClass: u32 = 440;
pub const LN_pilotGroups: &[u8; 12] = b"pilotGroups\0";
pub const NID_pilotGroups: u32 = 441;
pub const LN_iA5StringSyntax: &[u8; 16] = b"iA5StringSyntax\0";
pub const NID_iA5StringSyntax: u32 = 442;
pub const LN_caseIgnoreIA5StringSyntax: &[u8; 26] = b"caseIgnoreIA5StringSyntax\0";
pub const NID_caseIgnoreIA5StringSyntax: u32 = 443;
pub const LN_pilotObject: &[u8; 12] = b"pilotObject\0";
pub const NID_pilotObject: u32 = 444;
pub const LN_pilotPerson: &[u8; 12] = b"pilotPerson\0";
pub const NID_pilotPerson: u32 = 445;
pub const SN_account: &[u8; 8] = b"account\0";
pub const NID_account: u32 = 446;
pub const SN_document: &[u8; 9] = b"document\0";
pub const NID_document: u32 = 447;
pub const SN_room: &[u8; 5] = b"room\0";
pub const NID_room: u32 = 448;
pub const LN_documentSeries: &[u8; 15] = b"documentSeries\0";
pub const NID_documentSeries: u32 = 449;
pub const SN_Domain: &[u8; 7] = b"domain\0";
pub const LN_Domain: &[u8; 7] = b"Domain\0";
pub const NID_Domain: u32 = 392;
pub const LN_rFC822localPart: &[u8; 16] = b"rFC822localPart\0";
pub const NID_rFC822localPart: u32 = 450;
pub const LN_dNSDomain: &[u8; 10] = b"dNSDomain\0";
pub const NID_dNSDomain: u32 = 451;
pub const LN_domainRelatedObject: &[u8; 20] = b"domainRelatedObject\0";
pub const NID_domainRelatedObject: u32 = 452;
pub const LN_friendlyCountry: &[u8; 16] = b"friendlyCountry\0";
pub const NID_friendlyCountry: u32 = 453;
pub const LN_simpleSecurityObject: &[u8; 21] = b"simpleSecurityObject\0";
pub const NID_simpleSecurityObject: u32 = 454;
pub const LN_pilotOrganization: &[u8; 18] = b"pilotOrganization\0";
pub const NID_pilotOrganization: u32 = 455;
pub const LN_pilotDSA: &[u8; 9] = b"pilotDSA\0";
pub const NID_pilotDSA: u32 = 456;
pub const LN_qualityLabelledData: &[u8; 20] = b"qualityLabelledData\0";
pub const NID_qualityLabelledData: u32 = 457;
pub const SN_userId: &[u8; 4] = b"UID\0";
pub const LN_userId: &[u8; 7] = b"userId\0";
pub const NID_userId: u32 = 458;
pub const LN_textEncodedORAddress: &[u8; 21] = b"textEncodedORAddress\0";
pub const NID_textEncodedORAddress: u32 = 459;
pub const SN_rfc822Mailbox: &[u8; 5] = b"mail\0";
pub const LN_rfc822Mailbox: &[u8; 14] = b"rfc822Mailbox\0";
pub const NID_rfc822Mailbox: u32 = 460;
pub const SN_info: &[u8; 5] = b"info\0";
pub const NID_info: u32 = 461;
pub const LN_favouriteDrink: &[u8; 15] = b"favouriteDrink\0";
pub const NID_favouriteDrink: u32 = 462;
pub const LN_roomNumber: &[u8; 11] = b"roomNumber\0";
pub const NID_roomNumber: u32 = 463;
pub const SN_photo: &[u8; 6] = b"photo\0";
pub const NID_photo: u32 = 464;
pub const LN_userClass: &[u8; 10] = b"userClass\0";
pub const NID_userClass: u32 = 465;
pub const SN_host: &[u8; 5] = b"host\0";
pub const NID_host: u32 = 466;
pub const SN_manager: &[u8; 8] = b"manager\0";
pub const NID_manager: u32 = 467;
pub const LN_documentIdentifier: &[u8; 19] = b"documentIdentifier\0";
pub const NID_documentIdentifier: u32 = 468;
pub const LN_documentTitle: &[u8; 14] = b"documentTitle\0";
pub const NID_documentTitle: u32 = 469;
pub const LN_documentVersion: &[u8; 16] = b"documentVersion\0";
pub const NID_documentVersion: u32 = 470;
pub const LN_documentAuthor: &[u8; 15] = b"documentAuthor\0";
pub const NID_documentAuthor: u32 = 471;
pub const LN_documentLocation: &[u8; 17] = b"documentLocation\0";
pub const NID_documentLocation: u32 = 472;
pub const LN_homeTelephoneNumber: &[u8; 20] = b"homeTelephoneNumber\0";
pub const NID_homeTelephoneNumber: u32 = 473;
pub const SN_secretary: &[u8; 10] = b"secretary\0";
pub const NID_secretary: u32 = 474;
pub const LN_otherMailbox: &[u8; 13] = b"otherMailbox\0";
pub const NID_otherMailbox: u32 = 475;
pub const LN_lastModifiedTime: &[u8; 17] = b"lastModifiedTime\0";
pub const NID_lastModifiedTime: u32 = 476;
pub const LN_lastModifiedBy: &[u8; 15] = b"lastModifiedBy\0";
pub const NID_lastModifiedBy: u32 = 477;
pub const SN_domainComponent: &[u8; 3] = b"DC\0";
pub const LN_domainComponent: &[u8; 16] = b"domainComponent\0";
pub const NID_domainComponent: u32 = 391;
pub const LN_aRecord: &[u8; 8] = b"aRecord\0";
pub const NID_aRecord: u32 = 478;
pub const LN_pilotAttributeType27: &[u8; 21] = b"pilotAttributeType27\0";
pub const NID_pilotAttributeType27: u32 = 479;
pub const LN_mXRecord: &[u8; 9] = b"mXRecord\0";
pub const NID_mXRecord: u32 = 480;
pub const LN_nSRecord: &[u8; 9] = b"nSRecord\0";
pub const NID_nSRecord: u32 = 481;
pub const LN_sOARecord: &[u8; 10] = b"sOARecord\0";
pub const NID_sOARecord: u32 = 482;
pub const LN_cNAMERecord: &[u8; 12] = b"cNAMERecord\0";
pub const NID_cNAMERecord: u32 = 483;
pub const LN_associatedDomain: &[u8; 17] = b"associatedDomain\0";
pub const NID_associatedDomain: u32 = 484;
pub const LN_associatedName: &[u8; 15] = b"associatedName\0";
pub const NID_associatedName: u32 = 485;
pub const LN_homePostalAddress: &[u8; 18] = b"homePostalAddress\0";
pub const NID_homePostalAddress: u32 = 486;
pub const LN_personalTitle: &[u8; 14] = b"personalTitle\0";
pub const NID_personalTitle: u32 = 487;
pub const LN_mobileTelephoneNumber: &[u8; 22] = b"mobileTelephoneNumber\0";
pub const NID_mobileTelephoneNumber: u32 = 488;
pub const LN_pagerTelephoneNumber: &[u8; 21] = b"pagerTelephoneNumber\0";
pub const NID_pagerTelephoneNumber: u32 = 489;
pub const LN_friendlyCountryName: &[u8; 20] = b"friendlyCountryName\0";
pub const NID_friendlyCountryName: u32 = 490;
pub const SN_uniqueIdentifier: &[u8; 4] = b"uid\0";
pub const LN_uniqueIdentifier: &[u8; 17] = b"uniqueIdentifier\0";
pub const NID_uniqueIdentifier: u32 = 102;
pub const LN_organizationalStatus: &[u8; 21] = b"organizationalStatus\0";
pub const NID_organizationalStatus: u32 = 491;
pub const LN_janetMailbox: &[u8; 13] = b"janetMailbox\0";
pub const NID_janetMailbox: u32 = 492;
pub const LN_mailPreferenceOption: &[u8; 21] = b"mailPreferenceOption\0";
pub const NID_mailPreferenceOption: u32 = 493;
pub const LN_buildingName: &[u8; 13] = b"buildingName\0";
pub const NID_buildingName: u32 = 494;
pub const LN_dSAQuality: &[u8; 11] = b"dSAQuality\0";
pub const NID_dSAQuality: u32 = 495;
pub const LN_singleLevelQuality: &[u8; 19] = b"singleLevelQuality\0";
pub const NID_singleLevelQuality: u32 = 496;
pub const LN_subtreeMinimumQuality: &[u8; 22] = b"subtreeMinimumQuality\0";
pub const NID_subtreeMinimumQuality: u32 = 497;
pub const LN_subtreeMaximumQuality: &[u8; 22] = b"subtreeMaximumQuality\0";
pub const NID_subtreeMaximumQuality: u32 = 498;
pub const LN_personalSignature: &[u8; 18] = b"personalSignature\0";
pub const NID_personalSignature: u32 = 499;
pub const LN_dITRedirect: &[u8; 12] = b"dITRedirect\0";
pub const NID_dITRedirect: u32 = 500;
pub const SN_audio: &[u8; 6] = b"audio\0";
pub const NID_audio: u32 = 501;
pub const LN_documentPublisher: &[u8; 18] = b"documentPublisher\0";
pub const NID_documentPublisher: u32 = 502;
pub const SN_id_set: &[u8; 7] = b"id-set\0";
pub const LN_id_set: &[u8; 31] = b"Secure Electronic Transactions\0";
pub const NID_id_set: u32 = 512;
pub const SN_set_ctype: &[u8; 10] = b"set-ctype\0";
pub const LN_set_ctype: &[u8; 14] = b"content types\0";
pub const NID_set_ctype: u32 = 513;
pub const SN_set_msgExt: &[u8; 11] = b"set-msgExt\0";
pub const LN_set_msgExt: &[u8; 19] = b"message extensions\0";
pub const NID_set_msgExt: u32 = 514;
pub const SN_set_attr: &[u8; 9] = b"set-attr\0";
pub const NID_set_attr: u32 = 515;
pub const SN_set_policy: &[u8; 11] = b"set-policy\0";
pub const NID_set_policy: u32 = 516;
pub const SN_set_certExt: &[u8; 12] = b"set-certExt\0";
pub const LN_set_certExt: &[u8; 23] = b"certificate extensions\0";
pub const NID_set_certExt: u32 = 517;
pub const SN_set_brand: &[u8; 10] = b"set-brand\0";
pub const NID_set_brand: u32 = 518;
pub const SN_setct_PANData: &[u8; 14] = b"setct-PANData\0";
pub const NID_setct_PANData: u32 = 519;
pub const SN_setct_PANToken: &[u8; 15] = b"setct-PANToken\0";
pub const NID_setct_PANToken: u32 = 520;
pub const SN_setct_PANOnly: &[u8; 14] = b"setct-PANOnly\0";
pub const NID_setct_PANOnly: u32 = 521;
pub const SN_setct_OIData: &[u8; 13] = b"setct-OIData\0";
pub const NID_setct_OIData: u32 = 522;
pub const SN_setct_PI: &[u8; 9] = b"setct-PI\0";
pub const NID_setct_PI: u32 = 523;
pub const SN_setct_PIData: &[u8; 13] = b"setct-PIData\0";
pub const NID_setct_PIData: u32 = 524;
pub const SN_setct_PIDataUnsigned: &[u8; 21] = b"setct-PIDataUnsigned\0";
pub const NID_setct_PIDataUnsigned: u32 = 525;
pub const SN_setct_HODInput: &[u8; 15] = b"setct-HODInput\0";
pub const NID_setct_HODInput: u32 = 526;
pub const SN_setct_AuthResBaggage: &[u8; 21] = b"setct-AuthResBaggage\0";
pub const NID_setct_AuthResBaggage: u32 = 527;
pub const SN_setct_AuthRevReqBaggage: &[u8; 24] = b"setct-AuthRevReqBaggage\0";
pub const NID_setct_AuthRevReqBaggage: u32 = 528;
pub const SN_setct_AuthRevResBaggage: &[u8; 24] = b"setct-AuthRevResBaggage\0";
pub const NID_setct_AuthRevResBaggage: u32 = 529;
pub const SN_setct_CapTokenSeq: &[u8; 18] = b"setct-CapTokenSeq\0";
pub const NID_setct_CapTokenSeq: u32 = 530;
pub const SN_setct_PInitResData: &[u8; 19] = b"setct-PInitResData\0";
pub const NID_setct_PInitResData: u32 = 531;
pub const SN_setct_PI_TBS: &[u8; 13] = b"setct-PI-TBS\0";
pub const NID_setct_PI_TBS: u32 = 532;
pub const SN_setct_PResData: &[u8; 15] = b"setct-PResData\0";
pub const NID_setct_PResData: u32 = 533;
pub const SN_setct_AuthReqTBS: &[u8; 17] = b"setct-AuthReqTBS\0";
pub const NID_setct_AuthReqTBS: u32 = 534;
pub const SN_setct_AuthResTBS: &[u8; 17] = b"setct-AuthResTBS\0";
pub const NID_setct_AuthResTBS: u32 = 535;
pub const SN_setct_AuthResTBSX: &[u8; 18] = b"setct-AuthResTBSX\0";
pub const NID_setct_AuthResTBSX: u32 = 536;
pub const SN_setct_AuthTokenTBS: &[u8; 19] = b"setct-AuthTokenTBS\0";
pub const NID_setct_AuthTokenTBS: u32 = 537;
pub const SN_setct_CapTokenData: &[u8; 19] = b"setct-CapTokenData\0";
pub const NID_setct_CapTokenData: u32 = 538;
pub const SN_setct_CapTokenTBS: &[u8; 18] = b"setct-CapTokenTBS\0";
pub const NID_setct_CapTokenTBS: u32 = 539;
pub const SN_setct_AcqCardCodeMsg: &[u8; 21] = b"setct-AcqCardCodeMsg\0";
pub const NID_setct_AcqCardCodeMsg: u32 = 540;
pub const SN_setct_AuthRevReqTBS: &[u8; 20] = b"setct-AuthRevReqTBS\0";
pub const NID_setct_AuthRevReqTBS: u32 = 541;
pub const SN_setct_AuthRevResData: &[u8; 21] = b"setct-AuthRevResData\0";
pub const NID_setct_AuthRevResData: u32 = 542;
pub const SN_setct_AuthRevResTBS: &[u8; 20] = b"setct-AuthRevResTBS\0";
pub const NID_setct_AuthRevResTBS: u32 = 543;
pub const SN_setct_CapReqTBS: &[u8; 16] = b"setct-CapReqTBS\0";
pub const NID_setct_CapReqTBS: u32 = 544;
pub const SN_setct_CapReqTBSX: &[u8; 17] = b"setct-CapReqTBSX\0";
pub const NID_setct_CapReqTBSX: u32 = 545;
pub const SN_setct_CapResData: &[u8; 17] = b"setct-CapResData\0";
pub const NID_setct_CapResData: u32 = 546;
pub const SN_setct_CapRevReqTBS: &[u8; 19] = b"setct-CapRevReqTBS\0";
pub const NID_setct_CapRevReqTBS: u32 = 547;
pub const SN_setct_CapRevReqTBSX: &[u8; 20] = b"setct-CapRevReqTBSX\0";
pub const NID_setct_CapRevReqTBSX: u32 = 548;
pub const SN_setct_CapRevResData: &[u8; 20] = b"setct-CapRevResData\0";
pub const NID_setct_CapRevResData: u32 = 549;
pub const SN_setct_CredReqTBS: &[u8; 17] = b"setct-CredReqTBS\0";
pub const NID_setct_CredReqTBS: u32 = 550;
pub const SN_setct_CredReqTBSX: &[u8; 18] = b"setct-CredReqTBSX\0";
pub const NID_setct_CredReqTBSX: u32 = 551;
pub const SN_setct_CredResData: &[u8; 18] = b"setct-CredResData\0";
pub const NID_setct_CredResData: u32 = 552;
pub const SN_setct_CredRevReqTBS: &[u8; 20] = b"setct-CredRevReqTBS\0";
pub const NID_setct_CredRevReqTBS: u32 = 553;
pub const SN_setct_CredRevReqTBSX: &[u8; 21] = b"setct-CredRevReqTBSX\0";
pub const NID_setct_CredRevReqTBSX: u32 = 554;
pub const SN_setct_CredRevResData: &[u8; 21] = b"setct-CredRevResData\0";
pub const NID_setct_CredRevResData: u32 = 555;
pub const SN_setct_PCertReqData: &[u8; 19] = b"setct-PCertReqData\0";
pub const NID_setct_PCertReqData: u32 = 556;
pub const SN_setct_PCertResTBS: &[u8; 18] = b"setct-PCertResTBS\0";
pub const NID_setct_PCertResTBS: u32 = 557;
pub const SN_setct_BatchAdminReqData: &[u8; 24] = b"setct-BatchAdminReqData\0";
pub const NID_setct_BatchAdminReqData: u32 = 558;
pub const SN_setct_BatchAdminResData: &[u8; 24] = b"setct-BatchAdminResData\0";
pub const NID_setct_BatchAdminResData: u32 = 559;
pub const SN_setct_CardCInitResTBS: &[u8; 22] = b"setct-CardCInitResTBS\0";
pub const NID_setct_CardCInitResTBS: u32 = 560;
pub const SN_setct_MeAqCInitResTBS: &[u8; 22] = b"setct-MeAqCInitResTBS\0";
pub const NID_setct_MeAqCInitResTBS: u32 = 561;
pub const SN_setct_RegFormResTBS: &[u8; 20] = b"setct-RegFormResTBS\0";
pub const NID_setct_RegFormResTBS: u32 = 562;
pub const SN_setct_CertReqData: &[u8; 18] = b"setct-CertReqData\0";
pub const NID_setct_CertReqData: u32 = 563;
pub const SN_setct_CertReqTBS: &[u8; 17] = b"setct-CertReqTBS\0";
pub const NID_setct_CertReqTBS: u32 = 564;
pub const SN_setct_CertResData: &[u8; 18] = b"setct-CertResData\0";
pub const NID_setct_CertResData: u32 = 565;
pub const SN_setct_CertInqReqTBS: &[u8; 20] = b"setct-CertInqReqTBS\0";
pub const NID_setct_CertInqReqTBS: u32 = 566;
pub const SN_setct_ErrorTBS: &[u8; 15] = b"setct-ErrorTBS\0";
pub const NID_setct_ErrorTBS: u32 = 567;
pub const SN_setct_PIDualSignedTBE: &[u8; 22] = b"setct-PIDualSignedTBE\0";
pub const NID_setct_PIDualSignedTBE: u32 = 568;
pub const SN_setct_PIUnsignedTBE: &[u8; 20] = b"setct-PIUnsignedTBE\0";
pub const NID_setct_PIUnsignedTBE: u32 = 569;
pub const SN_setct_AuthReqTBE: &[u8; 17] = b"setct-AuthReqTBE\0";
pub const NID_setct_AuthReqTBE: u32 = 570;
pub const SN_setct_AuthResTBE: &[u8; 17] = b"setct-AuthResTBE\0";
pub const NID_setct_AuthResTBE: u32 = 571;
pub const SN_setct_AuthResTBEX: &[u8; 18] = b"setct-AuthResTBEX\0";
pub const NID_setct_AuthResTBEX: u32 = 572;
pub const SN_setct_AuthTokenTBE: &[u8; 19] = b"setct-AuthTokenTBE\0";
pub const NID_setct_AuthTokenTBE: u32 = 573;
pub const SN_setct_CapTokenTBE: &[u8; 18] = b"setct-CapTokenTBE\0";
pub const NID_setct_CapTokenTBE: u32 = 574;
pub const SN_setct_CapTokenTBEX: &[u8; 19] = b"setct-CapTokenTBEX\0";
pub const NID_setct_CapTokenTBEX: u32 = 575;
pub const SN_setct_AcqCardCodeMsgTBE: &[u8; 24] = b"setct-AcqCardCodeMsgTBE\0";
pub const NID_setct_AcqCardCodeMsgTBE: u32 = 576;
pub const SN_setct_AuthRevReqTBE: &[u8; 20] = b"setct-AuthRevReqTBE\0";
pub const NID_setct_AuthRevReqTBE: u32 = 577;
pub const SN_setct_AuthRevResTBE: &[u8; 20] = b"setct-AuthRevResTBE\0";
pub const NID_setct_AuthRevResTBE: u32 = 578;
pub const SN_setct_AuthRevResTBEB: &[u8; 21] = b"setct-AuthRevResTBEB\0";
pub const NID_setct_AuthRevResTBEB: u32 = 579;
pub const SN_setct_CapReqTBE: &[u8; 16] = b"setct-CapReqTBE\0";
pub const NID_setct_CapReqTBE: u32 = 580;
pub const SN_setct_CapReqTBEX: &[u8; 17] = b"setct-CapReqTBEX\0";
pub const NID_setct_CapReqTBEX: u32 = 581;
pub const SN_setct_CapResTBE: &[u8; 16] = b"setct-CapResTBE\0";
pub const NID_setct_CapResTBE: u32 = 582;
pub const SN_setct_CapRevReqTBE: &[u8; 19] = b"setct-CapRevReqTBE\0";
pub const NID_setct_CapRevReqTBE: u32 = 583;
pub const SN_setct_CapRevReqTBEX: &[u8; 20] = b"setct-CapRevReqTBEX\0";
pub const NID_setct_CapRevReqTBEX: u32 = 584;
pub const SN_setct_CapRevResTBE: &[u8; 19] = b"setct-CapRevResTBE\0";
pub const NID_setct_CapRevResTBE: u32 = 585;
pub const SN_setct_CredReqTBE: &[u8; 17] = b"setct-CredReqTBE\0";
pub const NID_setct_CredReqTBE: u32 = 586;
pub const SN_setct_CredReqTBEX: &[u8; 18] = b"setct-CredReqTBEX\0";
pub const NID_setct_CredReqTBEX: u32 = 587;
pub const SN_setct_CredResTBE: &[u8; 17] = b"setct-CredResTBE\0";
pub const NID_setct_CredResTBE: u32 = 588;
pub const SN_setct_CredRevReqTBE: &[u8; 20] = b"setct-CredRevReqTBE\0";
pub const NID_setct_CredRevReqTBE: u32 = 589;
pub const SN_setct_CredRevReqTBEX: &[u8; 21] = b"setct-CredRevReqTBEX\0";
pub const NID_setct_CredRevReqTBEX: u32 = 590;
pub const SN_setct_CredRevResTBE: &[u8; 20] = b"setct-CredRevResTBE\0";
pub const NID_setct_CredRevResTBE: u32 = 591;
pub const SN_setct_BatchAdminReqTBE: &[u8; 23] = b"setct-BatchAdminReqTBE\0";
pub const NID_setct_BatchAdminReqTBE: u32 = 592;
pub const SN_setct_BatchAdminResTBE: &[u8; 23] = b"setct-BatchAdminResTBE\0";
pub const NID_setct_BatchAdminResTBE: u32 = 593;
pub const SN_setct_RegFormReqTBE: &[u8; 20] = b"setct-RegFormReqTBE\0";
pub const NID_setct_RegFormReqTBE: u32 = 594;
pub const SN_setct_CertReqTBE: &[u8; 17] = b"setct-CertReqTBE\0";
pub const NID_setct_CertReqTBE: u32 = 595;
pub const SN_setct_CertReqTBEX: &[u8; 18] = b"setct-CertReqTBEX\0";
pub const NID_setct_CertReqTBEX: u32 = 596;
pub const SN_setct_CertResTBE: &[u8; 17] = b"setct-CertResTBE\0";
pub const NID_setct_CertResTBE: u32 = 597;
pub const SN_setct_CRLNotificationTBS: &[u8; 25] = b"setct-CRLNotificationTBS\0";
pub const NID_setct_CRLNotificationTBS: u32 = 598;
pub const SN_setct_CRLNotificationResTBS: &[u8; 28] = b"setct-CRLNotificationResTBS\0";
pub const NID_setct_CRLNotificationResTBS: u32 = 599;
pub const SN_setct_BCIDistributionTBS: &[u8; 25] = b"setct-BCIDistributionTBS\0";
pub const NID_setct_BCIDistributionTBS: u32 = 600;
pub const SN_setext_genCrypt: &[u8; 16] = b"setext-genCrypt\0";
pub const LN_setext_genCrypt: &[u8; 19] = b"generic cryptogram\0";
pub const NID_setext_genCrypt: u32 = 601;
pub const SN_setext_miAuth: &[u8; 14] = b"setext-miAuth\0";
pub const LN_setext_miAuth: &[u8; 24] = b"merchant initiated auth\0";
pub const NID_setext_miAuth: u32 = 602;
pub const SN_setext_pinSecure: &[u8; 17] = b"setext-pinSecure\0";
pub const NID_setext_pinSecure: u32 = 603;
pub const SN_setext_pinAny: &[u8; 14] = b"setext-pinAny\0";
pub const NID_setext_pinAny: u32 = 604;
pub const SN_setext_track2: &[u8; 14] = b"setext-track2\0";
pub const NID_setext_track2: u32 = 605;
pub const SN_setext_cv: &[u8; 10] = b"setext-cv\0";
pub const LN_setext_cv: &[u8; 24] = b"additional verification\0";
pub const NID_setext_cv: u32 = 606;
pub const SN_set_policy_root: &[u8; 16] = b"set-policy-root\0";
pub const NID_set_policy_root: u32 = 607;
pub const SN_setCext_hashedRoot: &[u8; 19] = b"setCext-hashedRoot\0";
pub const NID_setCext_hashedRoot: u32 = 608;
pub const SN_setCext_certType: &[u8; 17] = b"setCext-certType\0";
pub const NID_setCext_certType: u32 = 609;
pub const SN_setCext_merchData: &[u8; 18] = b"setCext-merchData\0";
pub const NID_setCext_merchData: u32 = 610;
pub const SN_setCext_cCertRequired: &[u8; 22] = b"setCext-cCertRequired\0";
pub const NID_setCext_cCertRequired: u32 = 611;
pub const SN_setCext_tunneling: &[u8; 18] = b"setCext-tunneling\0";
pub const NID_setCext_tunneling: u32 = 612;
pub const SN_setCext_setExt: &[u8; 15] = b"setCext-setExt\0";
pub const NID_setCext_setExt: u32 = 613;
pub const SN_setCext_setQualf: &[u8; 17] = b"setCext-setQualf\0";
pub const NID_setCext_setQualf: u32 = 614;
pub const SN_setCext_PGWYcapabilities: &[u8; 25] = b"setCext-PGWYcapabilities\0";
pub const NID_setCext_PGWYcapabilities: u32 = 615;
pub const SN_setCext_TokenIdentifier: &[u8; 24] = b"setCext-TokenIdentifier\0";
pub const NID_setCext_TokenIdentifier: u32 = 616;
pub const SN_setCext_Track2Data: &[u8; 19] = b"setCext-Track2Data\0";
pub const NID_setCext_Track2Data: u32 = 617;
pub const SN_setCext_TokenType: &[u8; 18] = b"setCext-TokenType\0";
pub const NID_setCext_TokenType: u32 = 618;
pub const SN_setCext_IssuerCapabilities: &[u8; 27] = b"setCext-IssuerCapabilities\0";
pub const NID_setCext_IssuerCapabilities: u32 = 619;
pub const SN_setAttr_Cert: &[u8; 13] = b"setAttr-Cert\0";
pub const NID_setAttr_Cert: u32 = 620;
pub const SN_setAttr_PGWYcap: &[u8; 16] = b"setAttr-PGWYcap\0";
pub const LN_setAttr_PGWYcap: &[u8; 29] = b"payment gateway capabilities\0";
pub const NID_setAttr_PGWYcap: u32 = 621;
pub const SN_setAttr_TokenType: &[u8; 18] = b"setAttr-TokenType\0";
pub const NID_setAttr_TokenType: u32 = 622;
pub const SN_setAttr_IssCap: &[u8; 15] = b"setAttr-IssCap\0";
pub const LN_setAttr_IssCap: &[u8; 20] = b"issuer capabilities\0";
pub const NID_setAttr_IssCap: u32 = 623;
pub const SN_set_rootKeyThumb: &[u8; 17] = b"set-rootKeyThumb\0";
pub const NID_set_rootKeyThumb: u32 = 624;
pub const SN_set_addPolicy: &[u8; 14] = b"set-addPolicy\0";
pub const NID_set_addPolicy: u32 = 625;
pub const SN_setAttr_Token_EMV: &[u8; 18] = b"setAttr-Token-EMV\0";
pub const NID_setAttr_Token_EMV: u32 = 626;
pub const SN_setAttr_Token_B0Prime: &[u8; 22] = b"setAttr-Token-B0Prime\0";
pub const NID_setAttr_Token_B0Prime: u32 = 627;
pub const SN_setAttr_IssCap_CVM: &[u8; 19] = b"setAttr-IssCap-CVM\0";
pub const NID_setAttr_IssCap_CVM: u32 = 628;
pub const SN_setAttr_IssCap_T2: &[u8; 18] = b"setAttr-IssCap-T2\0";
pub const NID_setAttr_IssCap_T2: u32 = 629;
pub const SN_setAttr_IssCap_Sig: &[u8; 19] = b"setAttr-IssCap-Sig\0";
pub const NID_setAttr_IssCap_Sig: u32 = 630;
pub const SN_setAttr_GenCryptgrm: &[u8; 20] = b"setAttr-GenCryptgrm\0";
pub const LN_setAttr_GenCryptgrm: &[u8; 20] = b"generate cryptogram\0";
pub const NID_setAttr_GenCryptgrm: u32 = 631;
pub const SN_setAttr_T2Enc: &[u8; 14] = b"setAttr-T2Enc\0";
pub const LN_setAttr_T2Enc: &[u8; 18] = b"encrypted track 2\0";
pub const NID_setAttr_T2Enc: u32 = 632;
pub const SN_setAttr_T2cleartxt: &[u8; 19] = b"setAttr-T2cleartxt\0";
pub const LN_setAttr_T2cleartxt: &[u8; 18] = b"cleartext track 2\0";
pub const NID_setAttr_T2cleartxt: u32 = 633;
pub const SN_setAttr_TokICCsig: &[u8; 18] = b"setAttr-TokICCsig\0";
pub const LN_setAttr_TokICCsig: &[u8; 23] = b"ICC or token signature\0";
pub const NID_setAttr_TokICCsig: u32 = 634;
pub const SN_setAttr_SecDevSig: &[u8; 18] = b"setAttr-SecDevSig\0";
pub const LN_setAttr_SecDevSig: &[u8; 24] = b"secure device signature\0";
pub const NID_setAttr_SecDevSig: u32 = 635;
pub const SN_set_brand_IATA_ATA: &[u8; 19] = b"set-brand-IATA-ATA\0";
pub const NID_set_brand_IATA_ATA: u32 = 636;
pub const SN_set_brand_Diners: &[u8; 17] = b"set-brand-Diners\0";
pub const NID_set_brand_Diners: u32 = 637;
pub const SN_set_brand_AmericanExpress: &[u8; 26] = b"set-brand-AmericanExpress\0";
pub const NID_set_brand_AmericanExpress: u32 = 638;
pub const SN_set_brand_JCB: &[u8; 14] = b"set-brand-JCB\0";
pub const NID_set_brand_JCB: u32 = 639;
pub const SN_set_brand_Visa: &[u8; 15] = b"set-brand-Visa\0";
pub const NID_set_brand_Visa: u32 = 640;
pub const SN_set_brand_MasterCard: &[u8; 21] = b"set-brand-MasterCard\0";
pub const NID_set_brand_MasterCard: u32 = 641;
pub const SN_set_brand_Novus: &[u8; 16] = b"set-brand-Novus\0";
pub const NID_set_brand_Novus: u32 = 642;
pub const SN_des_cdmf: &[u8; 9] = b"DES-CDMF\0";
pub const LN_des_cdmf: &[u8; 9] = b"des-cdmf\0";
pub const NID_des_cdmf: u32 = 643;
pub const SN_rsaOAEPEncryptionSET: &[u8; 21] = b"rsaOAEPEncryptionSET\0";
pub const NID_rsaOAEPEncryptionSET: u32 = 644;
pub const SN_ipsec3: &[u8; 14] = b"Oakley-EC2N-3\0";
pub const LN_ipsec3: &[u8; 7] = b"ipsec3\0";
pub const NID_ipsec3: u32 = 749;
pub const SN_ipsec4: &[u8; 14] = b"Oakley-EC2N-4\0";
pub const LN_ipsec4: &[u8; 7] = b"ipsec4\0";
pub const NID_ipsec4: u32 = 750;
pub const SN_whirlpool: &[u8; 10] = b"whirlpool\0";
pub const NID_whirlpool: u32 = 804;
pub const SN_cryptopro: &[u8; 10] = b"cryptopro\0";
pub const NID_cryptopro: u32 = 805;
pub const SN_cryptocom: &[u8; 10] = b"cryptocom\0";
pub const NID_cryptocom: u32 = 806;
pub const SN_id_tc26: &[u8; 8] = b"id-tc26\0";
pub const NID_id_tc26: u32 = 974;
pub const SN_id_GostR3411_94_with_GostR3410_2001: &[u8; 36] = b"id-GostR3411-94-with-GostR3410-2001\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001: &[u8; 39] = b"GOST R 34.11-94 with GOST R 34.10-2001\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001: u32 = 807;
pub const SN_id_GostR3411_94_with_GostR3410_94: &[u8; 34] = b"id-GostR3411-94-with-GostR3410-94\0";
pub const LN_id_GostR3411_94_with_GostR3410_94: &[u8; 37] = b"GOST R 34.11-94 with GOST R 34.10-94\0";
pub const NID_id_GostR3411_94_with_GostR3410_94: u32 = 808;
pub const SN_id_GostR3411_94: &[u8; 10] = b"md_gost94\0";
pub const LN_id_GostR3411_94: &[u8; 16] = b"GOST R 34.11-94\0";
pub const NID_id_GostR3411_94: u32 = 809;
pub const SN_id_HMACGostR3411_94: &[u8; 20] = b"id-HMACGostR3411-94\0";
pub const LN_id_HMACGostR3411_94: &[u8; 19] = b"HMAC GOST 34.11-94\0";
pub const NID_id_HMACGostR3411_94: u32 = 810;
pub const SN_id_GostR3410_2001: &[u8; 9] = b"gost2001\0";
pub const LN_id_GostR3410_2001: &[u8; 18] = b"GOST R 34.10-2001\0";
pub const NID_id_GostR3410_2001: u32 = 811;
pub const SN_id_GostR3410_94: &[u8; 7] = b"gost94\0";
pub const LN_id_GostR3410_94: &[u8; 16] = b"GOST R 34.10-94\0";
pub const NID_id_GostR3410_94: u32 = 812;
pub const SN_id_Gost28147_89: &[u8; 7] = b"gost89\0";
pub const LN_id_Gost28147_89: &[u8; 14] = b"GOST 28147-89\0";
pub const NID_id_Gost28147_89: u32 = 813;
pub const SN_gost89_cnt: &[u8; 11] = b"gost89-cnt\0";
pub const NID_gost89_cnt: u32 = 814;
pub const SN_gost89_cnt_12: &[u8; 14] = b"gost89-cnt-12\0";
pub const NID_gost89_cnt_12: u32 = 975;
pub const SN_gost89_cbc: &[u8; 11] = b"gost89-cbc\0";
pub const NID_gost89_cbc: u32 = 1009;
pub const SN_gost89_ecb: &[u8; 11] = b"gost89-ecb\0";
pub const NID_gost89_ecb: u32 = 1010;
pub const SN_gost89_ctr: &[u8; 11] = b"gost89-ctr\0";
pub const NID_gost89_ctr: u32 = 1011;
pub const SN_id_Gost28147_89_MAC: &[u8; 9] = b"gost-mac\0";
pub const LN_id_Gost28147_89_MAC: &[u8; 18] = b"GOST 28147-89 MAC\0";
pub const NID_id_Gost28147_89_MAC: u32 = 815;
pub const SN_gost_mac_12: &[u8; 12] = b"gost-mac-12\0";
pub const NID_gost_mac_12: u32 = 976;
pub const SN_id_GostR3411_94_prf: &[u8; 17] = b"prf-gostr3411-94\0";
pub const LN_id_GostR3411_94_prf: &[u8; 20] = b"GOST R 34.11-94 PRF\0";
pub const NID_id_GostR3411_94_prf: u32 = 816;
pub const SN_id_GostR3410_2001DH: &[u8; 20] = b"id-GostR3410-2001DH\0";
pub const LN_id_GostR3410_2001DH: &[u8; 21] = b"GOST R 34.10-2001 DH\0";
pub const NID_id_GostR3410_2001DH: u32 = 817;
pub const SN_id_GostR3410_94DH: &[u8; 18] = b"id-GostR3410-94DH\0";
pub const LN_id_GostR3410_94DH: &[u8; 19] = b"GOST R 34.10-94 DH\0";
pub const NID_id_GostR3410_94DH: u32 = 818;
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing: &[u8; 37] = b"id-Gost28147-89-CryptoPro-KeyMeshing\0";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: u32 = 819;
pub const SN_id_Gost28147_89_None_KeyMeshing: &[u8; 32] = b"id-Gost28147-89-None-KeyMeshing\0";
pub const NID_id_Gost28147_89_None_KeyMeshing: u32 = 820;
pub const SN_id_GostR3411_94_TestParamSet: &[u8; 29] = b"id-GostR3411-94-TestParamSet\0";
pub const NID_id_GostR3411_94_TestParamSet: u32 = 821;
pub const SN_id_GostR3411_94_CryptoProParamSet: &[u8; 34] = b"id-GostR3411-94-CryptoProParamSet\0";
pub const NID_id_GostR3411_94_CryptoProParamSet: u32 = 822;
pub const SN_id_Gost28147_89_TestParamSet: &[u8; 29] = b"id-Gost28147-89-TestParamSet\0";
pub const NID_id_Gost28147_89_TestParamSet: u32 = 823;
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet: &[u8; 37] = b"id-Gost28147-89-CryptoPro-A-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: u32 = 824;
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet: &[u8; 37] = b"id-Gost28147-89-CryptoPro-B-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: u32 = 825;
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet: &[u8; 37] = b"id-Gost28147-89-CryptoPro-C-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: u32 = 826;
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet: &[u8; 37] = b"id-Gost28147-89-CryptoPro-D-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: u32 = 827;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: &[u8; 45] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: u32 = 828;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: &[u8; 45] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: u32 = 829;
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: &[u8; 41] = b"id-Gost28147-89-CryptoPro-RIC-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: u32 = 830;
pub const SN_id_GostR3410_94_TestParamSet: &[u8; 29] = b"id-GostR3410-94-TestParamSet\0";
pub const NID_id_GostR3410_94_TestParamSet: u32 = 831;
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet: &[u8; 37] = b"id-GostR3410-94-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: u32 = 832;
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet: &[u8; 37] = b"id-GostR3410-94-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: u32 = 833;
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet: &[u8; 37] = b"id-GostR3410-94-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: u32 = 834;
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet: &[u8; 37] = b"id-GostR3410-94-CryptoPro-D-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: u32 = 835;
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet: &[u8; 40] = b"id-GostR3410-94-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: u32 = 836;
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet: &[u8; 40] = b"id-GostR3410-94-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: u32 = 837;
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet: &[u8; 40] = b"id-GostR3410-94-CryptoPro-XchC-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: u32 = 838;
pub const SN_id_GostR3410_2001_TestParamSet: &[u8; 31] = b"id-GostR3410-2001-TestParamSet\0";
pub const NID_id_GostR3410_2001_TestParamSet: u32 = 839;
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet: &[u8; 39] = b"id-GostR3410-2001-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: u32 = 840;
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet: &[u8; 39] = b"id-GostR3410-2001-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: u32 = 841;
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet: &[u8; 39] = b"id-GostR3410-2001-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: u32 = 842;
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet: &[u8; 42] = b"id-GostR3410-2001-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: u32 = 843;
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet: &[u8; 42] = b"id-GostR3410-2001-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: u32 = 844;
pub const SN_id_GostR3410_94_a: &[u8; 18] = b"id-GostR3410-94-a\0";
pub const NID_id_GostR3410_94_a: u32 = 845;
pub const SN_id_GostR3410_94_aBis: &[u8; 21] = b"id-GostR3410-94-aBis\0";
pub const NID_id_GostR3410_94_aBis: u32 = 846;
pub const SN_id_GostR3410_94_b: &[u8; 18] = b"id-GostR3410-94-b\0";
pub const NID_id_GostR3410_94_b: u32 = 847;
pub const SN_id_GostR3410_94_bBis: &[u8; 21] = b"id-GostR3410-94-bBis\0";
pub const NID_id_GostR3410_94_bBis: u32 = 848;
pub const SN_id_Gost28147_89_cc: &[u8; 19] = b"id-Gost28147-89-cc\0";
pub const LN_id_Gost28147_89_cc: &[u8; 33] = b"GOST 28147-89 Cryptocom ParamSet\0";
pub const NID_id_Gost28147_89_cc: u32 = 849;
pub const SN_id_GostR3410_94_cc: &[u8; 9] = b"gost94cc\0";
pub const LN_id_GostR3410_94_cc: &[u8; 24] = b"GOST 34.10-94 Cryptocom\0";
pub const NID_id_GostR3410_94_cc: u32 = 850;
pub const SN_id_GostR3410_2001_cc: &[u8; 11] = b"gost2001cc\0";
pub const LN_id_GostR3410_2001_cc: &[u8; 26] = b"GOST 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3410_2001_cc: u32 = 851;
pub const SN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 37] = b"id-GostR3411-94-with-GostR3410-94-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 47] = b"GOST R 34.11-94 with GOST R 34.10-94 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc: u32 = 852;
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 39] = b"id-GostR3411-94-with-GostR3410-2001-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 49] = b"GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: u32 = 853;
pub const SN_id_GostR3410_2001_ParamSet_cc: &[u8; 30] = b"id-GostR3410-2001-ParamSet-cc\0";
pub const LN_id_GostR3410_2001_ParamSet_cc: &[u8; 41] = b"GOST R 3410-2001 Parameter Set Cryptocom\0";
pub const NID_id_GostR3410_2001_ParamSet_cc: u32 = 854;
pub const SN_id_tc26_algorithms: &[u8; 19] = b"id-tc26-algorithms\0";
pub const NID_id_tc26_algorithms: u32 = 977;
pub const SN_id_tc26_sign: &[u8; 13] = b"id-tc26-sign\0";
pub const NID_id_tc26_sign: u32 = 978;
pub const SN_id_GostR3410_2012_256: &[u8; 13] = b"gost2012_256\0";
pub const LN_id_GostR3410_2012_256: &[u8; 39] = b"GOST R 34.10-2012 with 256 bit modulus\0";
pub const NID_id_GostR3410_2012_256: u32 = 979;
pub const SN_id_GostR3410_2012_512: &[u8; 13] = b"gost2012_512\0";
pub const LN_id_GostR3410_2012_512: &[u8; 39] = b"GOST R 34.10-2012 with 512 bit modulus\0";
pub const NID_id_GostR3410_2012_512: u32 = 980;
pub const SN_id_tc26_digest: &[u8; 15] = b"id-tc26-digest\0";
pub const NID_id_tc26_digest: u32 = 981;
pub const SN_id_GostR3411_2012_256: &[u8; 14] = b"md_gost12_256\0";
pub const LN_id_GostR3411_2012_256: &[u8; 36] = b"GOST R 34.11-2012 with 256 bit hash\0";
pub const NID_id_GostR3411_2012_256: u32 = 982;
pub const SN_id_GostR3411_2012_512: &[u8; 14] = b"md_gost12_512\0";
pub const LN_id_GostR3411_2012_512: &[u8; 36] = b"GOST R 34.11-2012 with 512 bit hash\0";
pub const NID_id_GostR3411_2012_512: u32 = 983;
pub const SN_id_tc26_signwithdigest: &[u8; 23] = b"id-tc26-signwithdigest\0";
pub const NID_id_tc26_signwithdigest: u32 = 984;
pub const SN_id_tc26_signwithdigest_gost3410_2012_256: &[u8; 41] = b"id-tc26-signwithdigest-gost3410-2012-256\0";
pub const LN_id_tc26_signwithdigest_gost3410_2012_256: &[u8; 51] =
    b"GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)\0";
pub const NID_id_tc26_signwithdigest_gost3410_2012_256: u32 = 985;
pub const SN_id_tc26_signwithdigest_gost3410_2012_512: &[u8; 41] = b"id-tc26-signwithdigest-gost3410-2012-512\0";
pub const LN_id_tc26_signwithdigest_gost3410_2012_512: &[u8; 51] =
    b"GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)\0";
pub const NID_id_tc26_signwithdigest_gost3410_2012_512: u32 = 986;
pub const SN_id_tc26_mac: &[u8; 12] = b"id-tc26-mac\0";
pub const NID_id_tc26_mac: u32 = 987;
pub const SN_id_tc26_hmac_gost_3411_2012_256: &[u8; 32] = b"id-tc26-hmac-gost-3411-2012-256\0";
pub const LN_id_tc26_hmac_gost_3411_2012_256: &[u8; 29] = b"HMAC GOST 34.11-2012 256 bit\0";
pub const NID_id_tc26_hmac_gost_3411_2012_256: u32 = 988;
pub const SN_id_tc26_hmac_gost_3411_2012_512: &[u8; 32] = b"id-tc26-hmac-gost-3411-2012-512\0";
pub const LN_id_tc26_hmac_gost_3411_2012_512: &[u8; 29] = b"HMAC GOST 34.11-2012 512 bit\0";
pub const NID_id_tc26_hmac_gost_3411_2012_512: u32 = 989;
pub const SN_id_tc26_cipher: &[u8; 15] = b"id-tc26-cipher\0";
pub const NID_id_tc26_cipher: u32 = 990;
pub const SN_id_tc26_cipher_gostr3412_2015_magma: &[u8; 36] = b"id-tc26-cipher-gostr3412-2015-magma\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma: u32 = 1173;
pub const SN_magma_ctr_acpkm: &[u8; 16] = b"magma-ctr-acpkm\0";
pub const NID_magma_ctr_acpkm: u32 = 1174;
pub const SN_magma_ctr_acpkm_omac: &[u8; 21] = b"magma-ctr-acpkm-omac\0";
pub const NID_magma_ctr_acpkm_omac: u32 = 1175;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik: &[u8; 41] = b"id-tc26-cipher-gostr3412-2015-kuznyechik\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik: u32 = 1176;
pub const SN_kuznyechik_ctr_acpkm: &[u8; 21] = b"kuznyechik-ctr-acpkm\0";
pub const NID_kuznyechik_ctr_acpkm: u32 = 1177;
pub const SN_kuznyechik_ctr_acpkm_omac: &[u8; 26] = b"kuznyechik-ctr-acpkm-omac\0";
pub const NID_kuznyechik_ctr_acpkm_omac: u32 = 1178;
pub const SN_id_tc26_agreement: &[u8; 18] = b"id-tc26-agreement\0";
pub const NID_id_tc26_agreement: u32 = 991;
pub const SN_id_tc26_agreement_gost_3410_2012_256: &[u8; 37] = b"id-tc26-agreement-gost-3410-2012-256\0";
pub const NID_id_tc26_agreement_gost_3410_2012_256: u32 = 992;
pub const SN_id_tc26_agreement_gost_3410_2012_512: &[u8; 37] = b"id-tc26-agreement-gost-3410-2012-512\0";
pub const NID_id_tc26_agreement_gost_3410_2012_512: u32 = 993;
pub const SN_id_tc26_wrap: &[u8; 13] = b"id-tc26-wrap\0";
pub const NID_id_tc26_wrap: u32 = 1179;
pub const SN_id_tc26_wrap_gostr3412_2015_magma: &[u8; 34] = b"id-tc26-wrap-gostr3412-2015-magma\0";
pub const NID_id_tc26_wrap_gostr3412_2015_magma: u32 = 1180;
pub const SN_magma_kexp15: &[u8; 13] = b"magma-kexp15\0";
pub const NID_magma_kexp15: u32 = 1181;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik: &[u8; 39] = b"id-tc26-wrap-gostr3412-2015-kuznyechik\0";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik: u32 = 1182;
pub const SN_kuznyechik_kexp15: &[u8; 18] = b"kuznyechik-kexp15\0";
pub const NID_kuznyechik_kexp15: u32 = 1183;
pub const SN_id_tc26_constants: &[u8; 18] = b"id-tc26-constants\0";
pub const NID_id_tc26_constants: u32 = 994;
pub const SN_id_tc26_sign_constants: &[u8; 23] = b"id-tc26-sign-constants\0";
pub const NID_id_tc26_sign_constants: u32 = 995;
pub const SN_id_tc26_gost_3410_2012_256_constants: &[u8; 37] = b"id-tc26-gost-3410-2012-256-constants\0";
pub const NID_id_tc26_gost_3410_2012_256_constants: u32 = 1147;
pub const SN_id_tc26_gost_3410_2012_256_paramSetA: &[u8; 37] = b"id-tc26-gost-3410-2012-256-paramSetA\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetA: &[u8; 39] = b"GOST R 34.10-2012 (256 bit) ParamSet A\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetA: u32 = 1148;
pub const SN_id_tc26_gost_3410_2012_256_paramSetB: &[u8; 37] = b"id-tc26-gost-3410-2012-256-paramSetB\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetB: &[u8; 39] = b"GOST R 34.10-2012 (256 bit) ParamSet B\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetB: u32 = 1184;
pub const SN_id_tc26_gost_3410_2012_256_paramSetC: &[u8; 37] = b"id-tc26-gost-3410-2012-256-paramSetC\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetC: &[u8; 39] = b"GOST R 34.10-2012 (256 bit) ParamSet C\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetC: u32 = 1185;
pub const SN_id_tc26_gost_3410_2012_256_paramSetD: &[u8; 37] = b"id-tc26-gost-3410-2012-256-paramSetD\0";
pub const LN_id_tc26_gost_3410_2012_256_paramSetD: &[u8; 39] = b"GOST R 34.10-2012 (256 bit) ParamSet D\0";
pub const NID_id_tc26_gost_3410_2012_256_paramSetD: u32 = 1186;
pub const SN_id_tc26_gost_3410_2012_512_constants: &[u8; 37] = b"id-tc26-gost-3410-2012-512-constants\0";
pub const NID_id_tc26_gost_3410_2012_512_constants: u32 = 996;
pub const SN_id_tc26_gost_3410_2012_512_paramSetTest: &[u8; 40] = b"id-tc26-gost-3410-2012-512-paramSetTest\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetTest: &[u8; 50] =
    b"GOST R 34.10-2012 (512 bit) testing parameter set\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetTest: u32 = 997;
pub const SN_id_tc26_gost_3410_2012_512_paramSetA: &[u8; 37] = b"id-tc26-gost-3410-2012-512-paramSetA\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetA: &[u8; 39] = b"GOST R 34.10-2012 (512 bit) ParamSet A\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetA: u32 = 998;
pub const SN_id_tc26_gost_3410_2012_512_paramSetB: &[u8; 37] = b"id-tc26-gost-3410-2012-512-paramSetB\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetB: &[u8; 39] = b"GOST R 34.10-2012 (512 bit) ParamSet B\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetB: u32 = 999;
pub const SN_id_tc26_gost_3410_2012_512_paramSetC: &[u8; 37] = b"id-tc26-gost-3410-2012-512-paramSetC\0";
pub const LN_id_tc26_gost_3410_2012_512_paramSetC: &[u8; 39] = b"GOST R 34.10-2012 (512 bit) ParamSet C\0";
pub const NID_id_tc26_gost_3410_2012_512_paramSetC: u32 = 1149;
pub const SN_id_tc26_digest_constants: &[u8; 25] = b"id-tc26-digest-constants\0";
pub const NID_id_tc26_digest_constants: u32 = 1000;
pub const SN_id_tc26_cipher_constants: &[u8; 25] = b"id-tc26-cipher-constants\0";
pub const NID_id_tc26_cipher_constants: u32 = 1001;
pub const SN_id_tc26_gost_28147_constants: &[u8; 29] = b"id-tc26-gost-28147-constants\0";
pub const NID_id_tc26_gost_28147_constants: u32 = 1002;
pub const SN_id_tc26_gost_28147_param_Z: &[u8; 27] = b"id-tc26-gost-28147-param-Z\0";
pub const LN_id_tc26_gost_28147_param_Z: &[u8; 33] = b"GOST 28147-89 TC26 parameter set\0";
pub const NID_id_tc26_gost_28147_param_Z: u32 = 1003;
pub const SN_INN: &[u8; 4] = b"INN\0";
pub const LN_INN: &[u8; 4] = b"INN\0";
pub const NID_INN: u32 = 1004;
pub const SN_OGRN: &[u8; 5] = b"OGRN\0";
pub const LN_OGRN: &[u8; 5] = b"OGRN\0";
pub const NID_OGRN: u32 = 1005;
pub const SN_SNILS: &[u8; 6] = b"SNILS\0";
pub const LN_SNILS: &[u8; 6] = b"SNILS\0";
pub const NID_SNILS: u32 = 1006;
pub const SN_OGRNIP: &[u8; 7] = b"OGRNIP\0";
pub const LN_OGRNIP: &[u8; 7] = b"OGRNIP\0";
pub const NID_OGRNIP: u32 = 1226;
pub const SN_subjectSignTool: &[u8; 16] = b"subjectSignTool\0";
pub const LN_subjectSignTool: &[u8; 24] = b"Signing Tool of Subject\0";
pub const NID_subjectSignTool: u32 = 1007;
pub const SN_issuerSignTool: &[u8; 15] = b"issuerSignTool\0";
pub const LN_issuerSignTool: &[u8; 23] = b"Signing Tool of Issuer\0";
pub const NID_issuerSignTool: u32 = 1008;
pub const SN_classSignTool: &[u8; 14] = b"classSignTool\0";
pub const LN_classSignTool: &[u8; 22] = b"Class of Signing Tool\0";
pub const NID_classSignTool: u32 = 1227;
pub const SN_classSignToolKC1: &[u8; 17] = b"classSignToolKC1\0";
pub const LN_classSignToolKC1: &[u8; 26] = b"Class of Signing Tool KC1\0";
pub const NID_classSignToolKC1: u32 = 1228;
pub const SN_classSignToolKC2: &[u8; 17] = b"classSignToolKC2\0";
pub const LN_classSignToolKC2: &[u8; 26] = b"Class of Signing Tool KC2\0";
pub const NID_classSignToolKC2: u32 = 1229;
pub const SN_classSignToolKC3: &[u8; 17] = b"classSignToolKC3\0";
pub const LN_classSignToolKC3: &[u8; 26] = b"Class of Signing Tool KC3\0";
pub const NID_classSignToolKC3: u32 = 1230;
pub const SN_classSignToolKB1: &[u8; 17] = b"classSignToolKB1\0";
pub const LN_classSignToolKB1: &[u8; 26] = b"Class of Signing Tool KB1\0";
pub const NID_classSignToolKB1: u32 = 1231;
pub const SN_classSignToolKB2: &[u8; 17] = b"classSignToolKB2\0";
pub const LN_classSignToolKB2: &[u8; 26] = b"Class of Signing Tool KB2\0";
pub const NID_classSignToolKB2: u32 = 1232;
pub const SN_classSignToolKA1: &[u8; 17] = b"classSignToolKA1\0";
pub const LN_classSignToolKA1: &[u8; 26] = b"Class of Signing Tool KA1\0";
pub const NID_classSignToolKA1: u32 = 1233;
pub const SN_kuznyechik_ecb: &[u8; 15] = b"kuznyechik-ecb\0";
pub const NID_kuznyechik_ecb: u32 = 1012;
pub const SN_kuznyechik_ctr: &[u8; 15] = b"kuznyechik-ctr\0";
pub const NID_kuznyechik_ctr: u32 = 1013;
pub const SN_kuznyechik_ofb: &[u8; 15] = b"kuznyechik-ofb\0";
pub const NID_kuznyechik_ofb: u32 = 1014;
pub const SN_kuznyechik_cbc: &[u8; 15] = b"kuznyechik-cbc\0";
pub const NID_kuznyechik_cbc: u32 = 1015;
pub const SN_kuznyechik_cfb: &[u8; 15] = b"kuznyechik-cfb\0";
pub const NID_kuznyechik_cfb: u32 = 1016;
pub const SN_kuznyechik_mac: &[u8; 15] = b"kuznyechik-mac\0";
pub const NID_kuznyechik_mac: u32 = 1017;
pub const SN_magma_ecb: &[u8; 10] = b"magma-ecb\0";
pub const NID_magma_ecb: u32 = 1187;
pub const SN_magma_ctr: &[u8; 10] = b"magma-ctr\0";
pub const NID_magma_ctr: u32 = 1188;
pub const SN_magma_ofb: &[u8; 10] = b"magma-ofb\0";
pub const NID_magma_ofb: u32 = 1189;
pub const SN_magma_cbc: &[u8; 10] = b"magma-cbc\0";
pub const NID_magma_cbc: u32 = 1190;
pub const SN_magma_cfb: &[u8; 10] = b"magma-cfb\0";
pub const NID_magma_cfb: u32 = 1191;
pub const SN_magma_mac: &[u8; 10] = b"magma-mac\0";
pub const NID_magma_mac: u32 = 1192;
pub const SN_camellia_128_cbc: &[u8; 17] = b"CAMELLIA-128-CBC\0";
pub const LN_camellia_128_cbc: &[u8; 17] = b"camellia-128-cbc\0";
pub const NID_camellia_128_cbc: u32 = 751;
pub const SN_camellia_192_cbc: &[u8; 17] = b"CAMELLIA-192-CBC\0";
pub const LN_camellia_192_cbc: &[u8; 17] = b"camellia-192-cbc\0";
pub const NID_camellia_192_cbc: u32 = 752;
pub const SN_camellia_256_cbc: &[u8; 17] = b"CAMELLIA-256-CBC\0";
pub const LN_camellia_256_cbc: &[u8; 17] = b"camellia-256-cbc\0";
pub const NID_camellia_256_cbc: u32 = 753;
pub const SN_id_camellia128_wrap: &[u8; 20] = b"id-camellia128-wrap\0";
pub const NID_id_camellia128_wrap: u32 = 907;
pub const SN_id_camellia192_wrap: &[u8; 20] = b"id-camellia192-wrap\0";
pub const NID_id_camellia192_wrap: u32 = 908;
pub const SN_id_camellia256_wrap: &[u8; 20] = b"id-camellia256-wrap\0";
pub const NID_id_camellia256_wrap: u32 = 909;
pub const SN_camellia_128_ecb: &[u8; 17] = b"CAMELLIA-128-ECB\0";
pub const LN_camellia_128_ecb: &[u8; 17] = b"camellia-128-ecb\0";
pub const NID_camellia_128_ecb: u32 = 754;
pub const SN_camellia_128_ofb128: &[u8; 17] = b"CAMELLIA-128-OFB\0";
pub const LN_camellia_128_ofb128: &[u8; 17] = b"camellia-128-ofb\0";
pub const NID_camellia_128_ofb128: u32 = 766;
pub const SN_camellia_128_cfb128: &[u8; 17] = b"CAMELLIA-128-CFB\0";
pub const LN_camellia_128_cfb128: &[u8; 17] = b"camellia-128-cfb\0";
pub const NID_camellia_128_cfb128: u32 = 757;
pub const SN_camellia_128_gcm: &[u8; 17] = b"CAMELLIA-128-GCM\0";
pub const LN_camellia_128_gcm: &[u8; 17] = b"camellia-128-gcm\0";
pub const NID_camellia_128_gcm: u32 = 961;
pub const SN_camellia_128_ccm: &[u8; 17] = b"CAMELLIA-128-CCM\0";
pub const LN_camellia_128_ccm: &[u8; 17] = b"camellia-128-ccm\0";
pub const NID_camellia_128_ccm: u32 = 962;
pub const SN_camellia_128_ctr: &[u8; 17] = b"CAMELLIA-128-CTR\0";
pub const LN_camellia_128_ctr: &[u8; 17] = b"camellia-128-ctr\0";
pub const NID_camellia_128_ctr: u32 = 963;
pub const SN_camellia_128_cmac: &[u8; 18] = b"CAMELLIA-128-CMAC\0";
pub const LN_camellia_128_cmac: &[u8; 18] = b"camellia-128-cmac\0";
pub const NID_camellia_128_cmac: u32 = 964;
pub const SN_camellia_192_ecb: &[u8; 17] = b"CAMELLIA-192-ECB\0";
pub const LN_camellia_192_ecb: &[u8; 17] = b"camellia-192-ecb\0";
pub const NID_camellia_192_ecb: u32 = 755;
pub const SN_camellia_192_ofb128: &[u8; 17] = b"CAMELLIA-192-OFB\0";
pub const LN_camellia_192_ofb128: &[u8; 17] = b"camellia-192-ofb\0";
pub const NID_camellia_192_ofb128: u32 = 767;
pub const SN_camellia_192_cfb128: &[u8; 17] = b"CAMELLIA-192-CFB\0";
pub const LN_camellia_192_cfb128: &[u8; 17] = b"camellia-192-cfb\0";
pub const NID_camellia_192_cfb128: u32 = 758;
pub const SN_camellia_192_gcm: &[u8; 17] = b"CAMELLIA-192-GCM\0";
pub const LN_camellia_192_gcm: &[u8; 17] = b"camellia-192-gcm\0";
pub const NID_camellia_192_gcm: u32 = 965;
pub const SN_camellia_192_ccm: &[u8; 17] = b"CAMELLIA-192-CCM\0";
pub const LN_camellia_192_ccm: &[u8; 17] = b"camellia-192-ccm\0";
pub const NID_camellia_192_ccm: u32 = 966;
pub const SN_camellia_192_ctr: &[u8; 17] = b"CAMELLIA-192-CTR\0";
pub const LN_camellia_192_ctr: &[u8; 17] = b"camellia-192-ctr\0";
pub const NID_camellia_192_ctr: u32 = 967;
pub const SN_camellia_192_cmac: &[u8; 18] = b"CAMELLIA-192-CMAC\0";
pub const LN_camellia_192_cmac: &[u8; 18] = b"camellia-192-cmac\0";
pub const NID_camellia_192_cmac: u32 = 968;
pub const SN_camellia_256_ecb: &[u8; 17] = b"CAMELLIA-256-ECB\0";
pub const LN_camellia_256_ecb: &[u8; 17] = b"camellia-256-ecb\0";
pub const NID_camellia_256_ecb: u32 = 756;
pub const SN_camellia_256_ofb128: &[u8; 17] = b"CAMELLIA-256-OFB\0";
pub const LN_camellia_256_ofb128: &[u8; 17] = b"camellia-256-ofb\0";
pub const NID_camellia_256_ofb128: u32 = 768;
pub const SN_camellia_256_cfb128: &[u8; 17] = b"CAMELLIA-256-CFB\0";
pub const LN_camellia_256_cfb128: &[u8; 17] = b"camellia-256-cfb\0";
pub const NID_camellia_256_cfb128: u32 = 759;
pub const SN_camellia_256_gcm: &[u8; 17] = b"CAMELLIA-256-GCM\0";
pub const LN_camellia_256_gcm: &[u8; 17] = b"camellia-256-gcm\0";
pub const NID_camellia_256_gcm: u32 = 969;
pub const SN_camellia_256_ccm: &[u8; 17] = b"CAMELLIA-256-CCM\0";
pub const LN_camellia_256_ccm: &[u8; 17] = b"camellia-256-ccm\0";
pub const NID_camellia_256_ccm: u32 = 970;
pub const SN_camellia_256_ctr: &[u8; 17] = b"CAMELLIA-256-CTR\0";
pub const LN_camellia_256_ctr: &[u8; 17] = b"camellia-256-ctr\0";
pub const NID_camellia_256_ctr: u32 = 971;
pub const SN_camellia_256_cmac: &[u8; 18] = b"CAMELLIA-256-CMAC\0";
pub const LN_camellia_256_cmac: &[u8; 18] = b"camellia-256-cmac\0";
pub const NID_camellia_256_cmac: u32 = 972;
pub const SN_camellia_128_cfb1: &[u8; 18] = b"CAMELLIA-128-CFB1\0";
pub const LN_camellia_128_cfb1: &[u8; 18] = b"camellia-128-cfb1\0";
pub const NID_camellia_128_cfb1: u32 = 760;
pub const SN_camellia_192_cfb1: &[u8; 18] = b"CAMELLIA-192-CFB1\0";
pub const LN_camellia_192_cfb1: &[u8; 18] = b"camellia-192-cfb1\0";
pub const NID_camellia_192_cfb1: u32 = 761;
pub const SN_camellia_256_cfb1: &[u8; 18] = b"CAMELLIA-256-CFB1\0";
pub const LN_camellia_256_cfb1: &[u8; 18] = b"camellia-256-cfb1\0";
pub const NID_camellia_256_cfb1: u32 = 762;
pub const SN_camellia_128_cfb8: &[u8; 18] = b"CAMELLIA-128-CFB8\0";
pub const LN_camellia_128_cfb8: &[u8; 18] = b"camellia-128-cfb8\0";
pub const NID_camellia_128_cfb8: u32 = 763;
pub const SN_camellia_192_cfb8: &[u8; 18] = b"CAMELLIA-192-CFB8\0";
pub const LN_camellia_192_cfb8: &[u8; 18] = b"camellia-192-cfb8\0";
pub const NID_camellia_192_cfb8: u32 = 764;
pub const SN_camellia_256_cfb8: &[u8; 18] = b"CAMELLIA-256-CFB8\0";
pub const LN_camellia_256_cfb8: &[u8; 18] = b"camellia-256-cfb8\0";
pub const NID_camellia_256_cfb8: u32 = 765;
pub const SN_aria_128_ecb: &[u8; 13] = b"ARIA-128-ECB\0";
pub const LN_aria_128_ecb: &[u8; 13] = b"aria-128-ecb\0";
pub const NID_aria_128_ecb: u32 = 1065;
pub const SN_aria_128_cbc: &[u8; 13] = b"ARIA-128-CBC\0";
pub const LN_aria_128_cbc: &[u8; 13] = b"aria-128-cbc\0";
pub const NID_aria_128_cbc: u32 = 1066;
pub const SN_aria_128_cfb128: &[u8; 13] = b"ARIA-128-CFB\0";
pub const LN_aria_128_cfb128: &[u8; 13] = b"aria-128-cfb\0";
pub const NID_aria_128_cfb128: u32 = 1067;
pub const SN_aria_128_ofb128: &[u8; 13] = b"ARIA-128-OFB\0";
pub const LN_aria_128_ofb128: &[u8; 13] = b"aria-128-ofb\0";
pub const NID_aria_128_ofb128: u32 = 1068;
pub const SN_aria_128_ctr: &[u8; 13] = b"ARIA-128-CTR\0";
pub const LN_aria_128_ctr: &[u8; 13] = b"aria-128-ctr\0";
pub const NID_aria_128_ctr: u32 = 1069;
pub const SN_aria_192_ecb: &[u8; 13] = b"ARIA-192-ECB\0";
pub const LN_aria_192_ecb: &[u8; 13] = b"aria-192-ecb\0";
pub const NID_aria_192_ecb: u32 = 1070;
pub const SN_aria_192_cbc: &[u8; 13] = b"ARIA-192-CBC\0";
pub const LN_aria_192_cbc: &[u8; 13] = b"aria-192-cbc\0";
pub const NID_aria_192_cbc: u32 = 1071;
pub const SN_aria_192_cfb128: &[u8; 13] = b"ARIA-192-CFB\0";
pub const LN_aria_192_cfb128: &[u8; 13] = b"aria-192-cfb\0";
pub const NID_aria_192_cfb128: u32 = 1072;
pub const SN_aria_192_ofb128: &[u8; 13] = b"ARIA-192-OFB\0";
pub const LN_aria_192_ofb128: &[u8; 13] = b"aria-192-ofb\0";
pub const NID_aria_192_ofb128: u32 = 1073;
pub const SN_aria_192_ctr: &[u8; 13] = b"ARIA-192-CTR\0";
pub const LN_aria_192_ctr: &[u8; 13] = b"aria-192-ctr\0";
pub const NID_aria_192_ctr: u32 = 1074;
pub const SN_aria_256_ecb: &[u8; 13] = b"ARIA-256-ECB\0";
pub const LN_aria_256_ecb: &[u8; 13] = b"aria-256-ecb\0";
pub const NID_aria_256_ecb: u32 = 1075;
pub const SN_aria_256_cbc: &[u8; 13] = b"ARIA-256-CBC\0";
pub const LN_aria_256_cbc: &[u8; 13] = b"aria-256-cbc\0";
pub const NID_aria_256_cbc: u32 = 1076;
pub const SN_aria_256_cfb128: &[u8; 13] = b"ARIA-256-CFB\0";
pub const LN_aria_256_cfb128: &[u8; 13] = b"aria-256-cfb\0";
pub const NID_aria_256_cfb128: u32 = 1077;
pub const SN_aria_256_ofb128: &[u8; 13] = b"ARIA-256-OFB\0";
pub const LN_aria_256_ofb128: &[u8; 13] = b"aria-256-ofb\0";
pub const NID_aria_256_ofb128: u32 = 1078;
pub const SN_aria_256_ctr: &[u8; 13] = b"ARIA-256-CTR\0";
pub const LN_aria_256_ctr: &[u8; 13] = b"aria-256-ctr\0";
pub const NID_aria_256_ctr: u32 = 1079;
pub const SN_aria_128_cfb1: &[u8; 14] = b"ARIA-128-CFB1\0";
pub const LN_aria_128_cfb1: &[u8; 14] = b"aria-128-cfb1\0";
pub const NID_aria_128_cfb1: u32 = 1080;
pub const SN_aria_192_cfb1: &[u8; 14] = b"ARIA-192-CFB1\0";
pub const LN_aria_192_cfb1: &[u8; 14] = b"aria-192-cfb1\0";
pub const NID_aria_192_cfb1: u32 = 1081;
pub const SN_aria_256_cfb1: &[u8; 14] = b"ARIA-256-CFB1\0";
pub const LN_aria_256_cfb1: &[u8; 14] = b"aria-256-cfb1\0";
pub const NID_aria_256_cfb1: u32 = 1082;
pub const SN_aria_128_cfb8: &[u8; 14] = b"ARIA-128-CFB8\0";
pub const LN_aria_128_cfb8: &[u8; 14] = b"aria-128-cfb8\0";
pub const NID_aria_128_cfb8: u32 = 1083;
pub const SN_aria_192_cfb8: &[u8; 14] = b"ARIA-192-CFB8\0";
pub const LN_aria_192_cfb8: &[u8; 14] = b"aria-192-cfb8\0";
pub const NID_aria_192_cfb8: u32 = 1084;
pub const SN_aria_256_cfb8: &[u8; 14] = b"ARIA-256-CFB8\0";
pub const LN_aria_256_cfb8: &[u8; 14] = b"aria-256-cfb8\0";
pub const NID_aria_256_cfb8: u32 = 1085;
pub const SN_aria_128_ccm: &[u8; 13] = b"ARIA-128-CCM\0";
pub const LN_aria_128_ccm: &[u8; 13] = b"aria-128-ccm\0";
pub const NID_aria_128_ccm: u32 = 1120;
pub const SN_aria_192_ccm: &[u8; 13] = b"ARIA-192-CCM\0";
pub const LN_aria_192_ccm: &[u8; 13] = b"aria-192-ccm\0";
pub const NID_aria_192_ccm: u32 = 1121;
pub const SN_aria_256_ccm: &[u8; 13] = b"ARIA-256-CCM\0";
pub const LN_aria_256_ccm: &[u8; 13] = b"aria-256-ccm\0";
pub const NID_aria_256_ccm: u32 = 1122;
pub const SN_aria_128_gcm: &[u8; 13] = b"ARIA-128-GCM\0";
pub const LN_aria_128_gcm: &[u8; 13] = b"aria-128-gcm\0";
pub const NID_aria_128_gcm: u32 = 1123;
pub const SN_aria_192_gcm: &[u8; 13] = b"ARIA-192-GCM\0";
pub const LN_aria_192_gcm: &[u8; 13] = b"aria-192-gcm\0";
pub const NID_aria_192_gcm: u32 = 1124;
pub const SN_aria_256_gcm: &[u8; 13] = b"ARIA-256-GCM\0";
pub const LN_aria_256_gcm: &[u8; 13] = b"aria-256-gcm\0";
pub const NID_aria_256_gcm: u32 = 1125;
pub const SN_kisa: &[u8; 5] = b"KISA\0";
pub const LN_kisa: &[u8; 5] = b"kisa\0";
pub const NID_kisa: u32 = 773;
pub const SN_seed_ecb: &[u8; 9] = b"SEED-ECB\0";
pub const LN_seed_ecb: &[u8; 9] = b"seed-ecb\0";
pub const NID_seed_ecb: u32 = 776;
pub const SN_seed_cbc: &[u8; 9] = b"SEED-CBC\0";
pub const LN_seed_cbc: &[u8; 9] = b"seed-cbc\0";
pub const NID_seed_cbc: u32 = 777;
pub const SN_seed_cfb128: &[u8; 9] = b"SEED-CFB\0";
pub const LN_seed_cfb128: &[u8; 9] = b"seed-cfb\0";
pub const NID_seed_cfb128: u32 = 779;
pub const SN_seed_ofb128: &[u8; 9] = b"SEED-OFB\0";
pub const LN_seed_ofb128: &[u8; 9] = b"seed-ofb\0";
pub const NID_seed_ofb128: u32 = 778;
pub const SN_sm4_ecb: &[u8; 8] = b"SM4-ECB\0";
pub const LN_sm4_ecb: &[u8; 8] = b"sm4-ecb\0";
pub const NID_sm4_ecb: u32 = 1133;
pub const SN_sm4_cbc: &[u8; 8] = b"SM4-CBC\0";
pub const LN_sm4_cbc: &[u8; 8] = b"sm4-cbc\0";
pub const NID_sm4_cbc: u32 = 1134;
pub const SN_sm4_ofb128: &[u8; 8] = b"SM4-OFB\0";
pub const LN_sm4_ofb128: &[u8; 8] = b"sm4-ofb\0";
pub const NID_sm4_ofb128: u32 = 1135;
pub const SN_sm4_cfb128: &[u8; 8] = b"SM4-CFB\0";
pub const LN_sm4_cfb128: &[u8; 8] = b"sm4-cfb\0";
pub const NID_sm4_cfb128: u32 = 1137;
pub const SN_sm4_cfb1: &[u8; 9] = b"SM4-CFB1\0";
pub const LN_sm4_cfb1: &[u8; 9] = b"sm4-cfb1\0";
pub const NID_sm4_cfb1: u32 = 1136;
pub const SN_sm4_cfb8: &[u8; 9] = b"SM4-CFB8\0";
pub const LN_sm4_cfb8: &[u8; 9] = b"sm4-cfb8\0";
pub const NID_sm4_cfb8: u32 = 1138;
pub const SN_sm4_ctr: &[u8; 8] = b"SM4-CTR\0";
pub const LN_sm4_ctr: &[u8; 8] = b"sm4-ctr\0";
pub const NID_sm4_ctr: u32 = 1139;
pub const SN_hmac: &[u8; 5] = b"HMAC\0";
pub const LN_hmac: &[u8; 5] = b"hmac\0";
pub const NID_hmac: u32 = 855;
pub const SN_cmac: &[u8; 5] = b"CMAC\0";
pub const LN_cmac: &[u8; 5] = b"cmac\0";
pub const NID_cmac: u32 = 894;
pub const SN_rc4_hmac_md5: &[u8; 13] = b"RC4-HMAC-MD5\0";
pub const LN_rc4_hmac_md5: &[u8; 13] = b"rc4-hmac-md5\0";
pub const NID_rc4_hmac_md5: u32 = 915;
pub const SN_aes_128_cbc_hmac_sha1: &[u8; 22] = b"AES-128-CBC-HMAC-SHA1\0";
pub const LN_aes_128_cbc_hmac_sha1: &[u8; 22] = b"aes-128-cbc-hmac-sha1\0";
pub const NID_aes_128_cbc_hmac_sha1: u32 = 916;
pub const SN_aes_192_cbc_hmac_sha1: &[u8; 22] = b"AES-192-CBC-HMAC-SHA1\0";
pub const LN_aes_192_cbc_hmac_sha1: &[u8; 22] = b"aes-192-cbc-hmac-sha1\0";
pub const NID_aes_192_cbc_hmac_sha1: u32 = 917;
pub const SN_aes_256_cbc_hmac_sha1: &[u8; 22] = b"AES-256-CBC-HMAC-SHA1\0";
pub const LN_aes_256_cbc_hmac_sha1: &[u8; 22] = b"aes-256-cbc-hmac-sha1\0";
pub const NID_aes_256_cbc_hmac_sha1: u32 = 918;
pub const SN_aes_128_cbc_hmac_sha256: &[u8; 24] = b"AES-128-CBC-HMAC-SHA256\0";
pub const LN_aes_128_cbc_hmac_sha256: &[u8; 24] = b"aes-128-cbc-hmac-sha256\0";
pub const NID_aes_128_cbc_hmac_sha256: u32 = 948;
pub const SN_aes_192_cbc_hmac_sha256: &[u8; 24] = b"AES-192-CBC-HMAC-SHA256\0";
pub const LN_aes_192_cbc_hmac_sha256: &[u8; 24] = b"aes-192-cbc-hmac-sha256\0";
pub const NID_aes_192_cbc_hmac_sha256: u32 = 949;
pub const SN_aes_256_cbc_hmac_sha256: &[u8; 24] = b"AES-256-CBC-HMAC-SHA256\0";
pub const LN_aes_256_cbc_hmac_sha256: &[u8; 24] = b"aes-256-cbc-hmac-sha256\0";
pub const NID_aes_256_cbc_hmac_sha256: u32 = 950;
pub const SN_chacha20_poly1305: &[u8; 18] = b"ChaCha20-Poly1305\0";
pub const LN_chacha20_poly1305: &[u8; 18] = b"chacha20-poly1305\0";
pub const NID_chacha20_poly1305: u32 = 1018;
pub const SN_chacha20: &[u8; 9] = b"ChaCha20\0";
pub const LN_chacha20: &[u8; 9] = b"chacha20\0";
pub const NID_chacha20: u32 = 1019;
pub const SN_dhpublicnumber: &[u8; 15] = b"dhpublicnumber\0";
pub const LN_dhpublicnumber: &[u8; 9] = b"X9.42 DH\0";
pub const NID_dhpublicnumber: u32 = 920;
pub const SN_brainpoolP160r1: &[u8; 16] = b"brainpoolP160r1\0";
pub const NID_brainpoolP160r1: u32 = 921;
pub const SN_brainpoolP160t1: &[u8; 16] = b"brainpoolP160t1\0";
pub const NID_brainpoolP160t1: u32 = 922;
pub const SN_brainpoolP192r1: &[u8; 16] = b"brainpoolP192r1\0";
pub const NID_brainpoolP192r1: u32 = 923;
pub const SN_brainpoolP192t1: &[u8; 16] = b"brainpoolP192t1\0";
pub const NID_brainpoolP192t1: u32 = 924;
pub const SN_brainpoolP224r1: &[u8; 16] = b"brainpoolP224r1\0";
pub const NID_brainpoolP224r1: u32 = 925;
pub const SN_brainpoolP224t1: &[u8; 16] = b"brainpoolP224t1\0";
pub const NID_brainpoolP224t1: u32 = 926;
pub const SN_brainpoolP256r1: &[u8; 16] = b"brainpoolP256r1\0";
pub const NID_brainpoolP256r1: u32 = 927;
pub const SN_brainpoolP256t1: &[u8; 16] = b"brainpoolP256t1\0";
pub const NID_brainpoolP256t1: u32 = 928;
pub const SN_brainpoolP320r1: &[u8; 16] = b"brainpoolP320r1\0";
pub const NID_brainpoolP320r1: u32 = 929;
pub const SN_brainpoolP320t1: &[u8; 16] = b"brainpoolP320t1\0";
pub const NID_brainpoolP320t1: u32 = 930;
pub const SN_brainpoolP384r1: &[u8; 16] = b"brainpoolP384r1\0";
pub const NID_brainpoolP384r1: u32 = 931;
pub const SN_brainpoolP384t1: &[u8; 16] = b"brainpoolP384t1\0";
pub const NID_brainpoolP384t1: u32 = 932;
pub const SN_brainpoolP512r1: &[u8; 16] = b"brainpoolP512r1\0";
pub const NID_brainpoolP512r1: u32 = 933;
pub const SN_brainpoolP512t1: &[u8; 16] = b"brainpoolP512t1\0";
pub const NID_brainpoolP512t1: u32 = 934;
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme: &[u8; 34] = b"dhSinglePass-stdDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme: u32 = 936;
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme: &[u8; 36] = b"dhSinglePass-stdDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme: u32 = 937;
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme: &[u8; 36] = b"dhSinglePass-stdDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme: u32 = 938;
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme: &[u8; 36] = b"dhSinglePass-stdDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme: u32 = 939;
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme: &[u8; 36] = b"dhSinglePass-stdDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme: u32 = 940;
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme: &[u8; 39] = b"dhSinglePass-cofactorDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme: u32 = 941;
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme: &[u8; 41] = b"dhSinglePass-cofactorDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme: u32 = 942;
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme: &[u8; 41] = b"dhSinglePass-cofactorDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme: u32 = 943;
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme: &[u8; 41] = b"dhSinglePass-cofactorDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme: u32 = 944;
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme: &[u8; 41] = b"dhSinglePass-cofactorDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme: u32 = 945;
pub const SN_dh_std_kdf: &[u8; 11] = b"dh-std-kdf\0";
pub const NID_dh_std_kdf: u32 = 946;
pub const SN_dh_cofactor_kdf: &[u8; 16] = b"dh-cofactor-kdf\0";
pub const NID_dh_cofactor_kdf: u32 = 947;
pub const SN_ct_precert_scts: &[u8; 16] = b"ct_precert_scts\0";
pub const LN_ct_precert_scts: &[u8; 23] = b"CT Precertificate SCTs\0";
pub const NID_ct_precert_scts: u32 = 951;
pub const SN_ct_precert_poison: &[u8; 18] = b"ct_precert_poison\0";
pub const LN_ct_precert_poison: &[u8; 25] = b"CT Precertificate Poison\0";
pub const NID_ct_precert_poison: u32 = 952;
pub const SN_ct_precert_signer: &[u8; 18] = b"ct_precert_signer\0";
pub const LN_ct_precert_signer: &[u8; 25] = b"CT Precertificate Signer\0";
pub const NID_ct_precert_signer: u32 = 953;
pub const SN_ct_cert_scts: &[u8; 13] = b"ct_cert_scts\0";
pub const LN_ct_cert_scts: &[u8; 20] = b"CT Certificate SCTs\0";
pub const NID_ct_cert_scts: u32 = 954;
pub const SN_jurisdictionLocalityName: &[u8; 14] = b"jurisdictionL\0";
pub const LN_jurisdictionLocalityName: &[u8; 25] = b"jurisdictionLocalityName\0";
pub const NID_jurisdictionLocalityName: u32 = 955;
pub const SN_jurisdictionStateOrProvinceName: &[u8; 15] = b"jurisdictionST\0";
pub const LN_jurisdictionStateOrProvinceName: &[u8; 32] = b"jurisdictionStateOrProvinceName\0";
pub const NID_jurisdictionStateOrProvinceName: u32 = 956;
pub const SN_jurisdictionCountryName: &[u8; 14] = b"jurisdictionC\0";
pub const LN_jurisdictionCountryName: &[u8; 24] = b"jurisdictionCountryName\0";
pub const NID_jurisdictionCountryName: u32 = 957;
pub const SN_id_scrypt: &[u8; 10] = b"id-scrypt\0";
pub const LN_id_scrypt: &[u8; 7] = b"scrypt\0";
pub const NID_id_scrypt: u32 = 973;
pub const SN_tls1_prf: &[u8; 9] = b"TLS1-PRF\0";
pub const LN_tls1_prf: &[u8; 9] = b"tls1-prf\0";
pub const NID_tls1_prf: u32 = 1021;
pub const SN_hkdf: &[u8; 5] = b"HKDF\0";
pub const LN_hkdf: &[u8; 5] = b"hkdf\0";
pub const NID_hkdf: u32 = 1036;
pub const SN_sshkdf: &[u8; 7] = b"SSHKDF\0";
pub const LN_sshkdf: &[u8; 7] = b"sshkdf\0";
pub const NID_sshkdf: u32 = 1203;
pub const SN_sskdf: &[u8; 6] = b"SSKDF\0";
pub const LN_sskdf: &[u8; 6] = b"sskdf\0";
pub const NID_sskdf: u32 = 1205;
pub const SN_x942kdf: &[u8; 8] = b"X942KDF\0";
pub const LN_x942kdf: &[u8; 8] = b"x942kdf\0";
pub const NID_x942kdf: u32 = 1207;
pub const SN_x963kdf: &[u8; 8] = b"X963KDF\0";
pub const LN_x963kdf: &[u8; 8] = b"x963kdf\0";
pub const NID_x963kdf: u32 = 1206;
pub const SN_id_pkinit: &[u8; 10] = b"id-pkinit\0";
pub const NID_id_pkinit: u32 = 1031;
pub const SN_pkInitClientAuth: &[u8; 17] = b"pkInitClientAuth\0";
pub const LN_pkInitClientAuth: &[u8; 19] = b"PKINIT Client Auth\0";
pub const NID_pkInitClientAuth: u32 = 1032;
pub const SN_pkInitKDC: &[u8; 10] = b"pkInitKDC\0";
pub const LN_pkInitKDC: &[u8; 21] = b"Signing KDC Response\0";
pub const NID_pkInitKDC: u32 = 1033;
pub const SN_X25519: &[u8; 7] = b"X25519\0";
pub const NID_X25519: u32 = 1034;
pub const SN_X448: &[u8; 5] = b"X448\0";
pub const NID_X448: u32 = 1035;
pub const SN_ED25519: &[u8; 8] = b"ED25519\0";
pub const NID_ED25519: u32 = 1087;
pub const SN_ED448: &[u8; 6] = b"ED448\0";
pub const NID_ED448: u32 = 1088;
pub const SN_kx_rsa: &[u8; 6] = b"KxRSA\0";
pub const LN_kx_rsa: &[u8; 7] = b"kx-rsa\0";
pub const NID_kx_rsa: u32 = 1037;
pub const SN_kx_ecdhe: &[u8; 8] = b"KxECDHE\0";
pub const LN_kx_ecdhe: &[u8; 9] = b"kx-ecdhe\0";
pub const NID_kx_ecdhe: u32 = 1038;
pub const SN_kx_dhe: &[u8; 6] = b"KxDHE\0";
pub const LN_kx_dhe: &[u8; 7] = b"kx-dhe\0";
pub const NID_kx_dhe: u32 = 1039;
pub const SN_kx_ecdhe_psk: &[u8; 12] = b"KxECDHE-PSK\0";
pub const LN_kx_ecdhe_psk: &[u8; 13] = b"kx-ecdhe-psk\0";
pub const NID_kx_ecdhe_psk: u32 = 1040;
pub const SN_kx_dhe_psk: &[u8; 10] = b"KxDHE-PSK\0";
pub const LN_kx_dhe_psk: &[u8; 11] = b"kx-dhe-psk\0";
pub const NID_kx_dhe_psk: u32 = 1041;
pub const SN_kx_rsa_psk: &[u8; 10] = b"KxRSA_PSK\0";
pub const LN_kx_rsa_psk: &[u8; 11] = b"kx-rsa-psk\0";
pub const NID_kx_rsa_psk: u32 = 1042;
pub const SN_kx_psk: &[u8; 6] = b"KxPSK\0";
pub const LN_kx_psk: &[u8; 7] = b"kx-psk\0";
pub const NID_kx_psk: u32 = 1043;
pub const SN_kx_srp: &[u8; 6] = b"KxSRP\0";
pub const LN_kx_srp: &[u8; 7] = b"kx-srp\0";
pub const NID_kx_srp: u32 = 1044;
pub const SN_kx_gost: &[u8; 7] = b"KxGOST\0";
pub const LN_kx_gost: &[u8; 8] = b"kx-gost\0";
pub const NID_kx_gost: u32 = 1045;
pub const SN_kx_gost18: &[u8; 9] = b"KxGOST18\0";
pub const LN_kx_gost18: &[u8; 10] = b"kx-gost18\0";
pub const NID_kx_gost18: u32 = 1218;
pub const SN_kx_any: &[u8; 6] = b"KxANY\0";
pub const LN_kx_any: &[u8; 7] = b"kx-any\0";
pub const NID_kx_any: u32 = 1063;
pub const SN_auth_rsa: &[u8; 8] = b"AuthRSA\0";
pub const LN_auth_rsa: &[u8; 9] = b"auth-rsa\0";
pub const NID_auth_rsa: u32 = 1046;
pub const SN_auth_ecdsa: &[u8; 10] = b"AuthECDSA\0";
pub const LN_auth_ecdsa: &[u8; 11] = b"auth-ecdsa\0";
pub const NID_auth_ecdsa: u32 = 1047;
pub const SN_auth_psk: &[u8; 8] = b"AuthPSK\0";
pub const LN_auth_psk: &[u8; 9] = b"auth-psk\0";
pub const NID_auth_psk: u32 = 1048;
pub const SN_auth_dss: &[u8; 8] = b"AuthDSS\0";
pub const LN_auth_dss: &[u8; 9] = b"auth-dss\0";
pub const NID_auth_dss: u32 = 1049;
pub const SN_auth_gost01: &[u8; 11] = b"AuthGOST01\0";
pub const LN_auth_gost01: &[u8; 12] = b"auth-gost01\0";
pub const NID_auth_gost01: u32 = 1050;
pub const SN_auth_gost12: &[u8; 11] = b"AuthGOST12\0";
pub const LN_auth_gost12: &[u8; 12] = b"auth-gost12\0";
pub const NID_auth_gost12: u32 = 1051;
pub const SN_auth_srp: &[u8; 8] = b"AuthSRP\0";
pub const LN_auth_srp: &[u8; 9] = b"auth-srp\0";
pub const NID_auth_srp: u32 = 1052;
pub const SN_auth_null: &[u8; 9] = b"AuthNULL\0";
pub const LN_auth_null: &[u8; 10] = b"auth-null\0";
pub const NID_auth_null: u32 = 1053;
pub const SN_auth_any: &[u8; 8] = b"AuthANY\0";
pub const LN_auth_any: &[u8; 9] = b"auth-any\0";
pub const NID_auth_any: u32 = 1064;
pub const SN_poly1305: &[u8; 9] = b"Poly1305\0";
pub const LN_poly1305: &[u8; 9] = b"poly1305\0";
pub const NID_poly1305: u32 = 1061;
pub const SN_siphash: &[u8; 8] = b"SipHash\0";
pub const LN_siphash: &[u8; 8] = b"siphash\0";
pub const NID_siphash: u32 = 1062;
pub const SN_ffdhe2048: &[u8; 10] = b"ffdhe2048\0";
pub const NID_ffdhe2048: u32 = 1126;
pub const SN_ffdhe3072: &[u8; 10] = b"ffdhe3072\0";
pub const NID_ffdhe3072: u32 = 1127;
pub const SN_ffdhe4096: &[u8; 10] = b"ffdhe4096\0";
pub const NID_ffdhe4096: u32 = 1128;
pub const SN_ffdhe6144: &[u8; 10] = b"ffdhe6144\0";
pub const NID_ffdhe6144: u32 = 1129;
pub const SN_ffdhe8192: &[u8; 10] = b"ffdhe8192\0";
pub const NID_ffdhe8192: u32 = 1130;
pub const SN_modp_1536: &[u8; 10] = b"modp_1536\0";
pub const NID_modp_1536: u32 = 1212;
pub const SN_modp_2048: &[u8; 10] = b"modp_2048\0";
pub const NID_modp_2048: u32 = 1213;
pub const SN_modp_3072: &[u8; 10] = b"modp_3072\0";
pub const NID_modp_3072: u32 = 1214;
pub const SN_modp_4096: &[u8; 10] = b"modp_4096\0";
pub const NID_modp_4096: u32 = 1215;
pub const SN_modp_6144: &[u8; 10] = b"modp_6144\0";
pub const NID_modp_6144: u32 = 1216;
pub const SN_modp_8192: &[u8; 10] = b"modp_8192\0";
pub const NID_modp_8192: u32 = 1217;
pub const SN_ISO_UA: &[u8; 7] = b"ISO-UA\0";
pub const NID_ISO_UA: u32 = 1150;
pub const SN_ua_pki: &[u8; 7] = b"ua-pki\0";
pub const NID_ua_pki: u32 = 1151;
pub const SN_dstu28147: &[u8; 10] = b"dstu28147\0";
pub const LN_dstu28147: &[u8; 21] = b"DSTU Gost 28147-2009\0";
pub const NID_dstu28147: u32 = 1152;
pub const SN_dstu28147_ofb: &[u8; 14] = b"dstu28147-ofb\0";
pub const LN_dstu28147_ofb: &[u8; 30] = b"DSTU Gost 28147-2009 OFB mode\0";
pub const NID_dstu28147_ofb: u32 = 1153;
pub const SN_dstu28147_cfb: &[u8; 14] = b"dstu28147-cfb\0";
pub const LN_dstu28147_cfb: &[u8; 30] = b"DSTU Gost 28147-2009 CFB mode\0";
pub const NID_dstu28147_cfb: u32 = 1154;
pub const SN_dstu28147_wrap: &[u8; 15] = b"dstu28147-wrap\0";
pub const LN_dstu28147_wrap: &[u8; 30] = b"DSTU Gost 28147-2009 key wrap\0";
pub const NID_dstu28147_wrap: u32 = 1155;
pub const SN_hmacWithDstu34311: &[u8; 18] = b"hmacWithDstu34311\0";
pub const LN_hmacWithDstu34311: &[u8; 24] = b"HMAC DSTU Gost 34311-95\0";
pub const NID_hmacWithDstu34311: u32 = 1156;
pub const SN_dstu34311: &[u8; 10] = b"dstu34311\0";
pub const LN_dstu34311: &[u8; 19] = b"DSTU Gost 34311-95\0";
pub const NID_dstu34311: u32 = 1157;
pub const SN_dstu4145le: &[u8; 11] = b"dstu4145le\0";
pub const LN_dstu4145le: &[u8; 29] = b"DSTU 4145-2002 little endian\0";
pub const NID_dstu4145le: u32 = 1158;
pub const SN_dstu4145be: &[u8; 11] = b"dstu4145be\0";
pub const LN_dstu4145be: &[u8; 26] = b"DSTU 4145-2002 big endian\0";
pub const NID_dstu4145be: u32 = 1159;
pub const SN_uacurve0: &[u8; 9] = b"uacurve0\0";
pub const LN_uacurve0: &[u8; 13] = b"DSTU curve 0\0";
pub const NID_uacurve0: u32 = 1160;
pub const SN_uacurve1: &[u8; 9] = b"uacurve1\0";
pub const LN_uacurve1: &[u8; 13] = b"DSTU curve 1\0";
pub const NID_uacurve1: u32 = 1161;
pub const SN_uacurve2: &[u8; 9] = b"uacurve2\0";
pub const LN_uacurve2: &[u8; 13] = b"DSTU curve 2\0";
pub const NID_uacurve2: u32 = 1162;
pub const SN_uacurve3: &[u8; 9] = b"uacurve3\0";
pub const LN_uacurve3: &[u8; 13] = b"DSTU curve 3\0";
pub const NID_uacurve3: u32 = 1163;
pub const SN_uacurve4: &[u8; 9] = b"uacurve4\0";
pub const LN_uacurve4: &[u8; 13] = b"DSTU curve 4\0";
pub const NID_uacurve4: u32 = 1164;
pub const SN_uacurve5: &[u8; 9] = b"uacurve5\0";
pub const LN_uacurve5: &[u8; 13] = b"DSTU curve 5\0";
pub const NID_uacurve5: u32 = 1165;
pub const SN_uacurve6: &[u8; 9] = b"uacurve6\0";
pub const LN_uacurve6: &[u8; 13] = b"DSTU curve 6\0";
pub const NID_uacurve6: u32 = 1166;
pub const SN_uacurve7: &[u8; 9] = b"uacurve7\0";
pub const LN_uacurve7: &[u8; 13] = b"DSTU curve 7\0";
pub const NID_uacurve7: u32 = 1167;
pub const SN_uacurve8: &[u8; 9] = b"uacurve8\0";
pub const LN_uacurve8: &[u8; 13] = b"DSTU curve 8\0";
pub const NID_uacurve8: u32 = 1168;
pub const SN_uacurve9: &[u8; 9] = b"uacurve9\0";
pub const LN_uacurve9: &[u8; 13] = b"DSTU curve 9\0";
pub const NID_uacurve9: u32 = 1169;
pub const SN_aes_128_siv: &[u8; 12] = b"AES-128-SIV\0";
pub const LN_aes_128_siv: &[u8; 12] = b"aes-128-siv\0";
pub const NID_aes_128_siv: u32 = 1198;
pub const SN_aes_192_siv: &[u8; 12] = b"AES-192-SIV\0";
pub const LN_aes_192_siv: &[u8; 12] = b"aes-192-siv\0";
pub const NID_aes_192_siv: u32 = 1199;
pub const SN_aes_256_siv: &[u8; 12] = b"AES-256-SIV\0";
pub const LN_aes_256_siv: &[u8; 12] = b"aes-256-siv\0";
pub const NID_aes_256_siv: u32 = 1200;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm: &[u8; 16] = b"magma-ctr-acpkm\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm: u32 = 1174;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac: &[u8; 21] = b"magma-ctr-acpkm-omac\0";
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac: u32 = 1175;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm: &[u8; 21] = b"kuznyechik-ctr-acpkm\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm: u32 = 1177;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac: &[u8; 26] = b"kuznyechik-ctr-acpkm-omac\0";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac: u32 = 1178;
pub const SN_id_tc26_wrap_gostr3412_2015_magma_kexp15: &[u8; 13] = b"magma-kexp15\0";
pub const NID_id_tc26_wrap_gostr3412_2015_magma_kexp15: u32 = 1181;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15: &[u8; 18] = b"kuznyechik-kexp15\0";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15: u32 = 1183;
pub const SN_grasshopper_ecb: &[u8; 15] = b"kuznyechik-ecb\0";
pub const NID_grasshopper_ecb: u32 = 1012;
pub const SN_grasshopper_ctr: &[u8; 15] = b"kuznyechik-ctr\0";
pub const NID_grasshopper_ctr: u32 = 1013;
pub const SN_grasshopper_ofb: &[u8; 15] = b"kuznyechik-ofb\0";
pub const NID_grasshopper_ofb: u32 = 1014;
pub const SN_grasshopper_cbc: &[u8; 15] = b"kuznyechik-cbc\0";
pub const NID_grasshopper_cbc: u32 = 1015;
pub const SN_grasshopper_cfb: &[u8; 15] = b"kuznyechik-cfb\0";
pub const NID_grasshopper_cfb: u32 = 1016;
pub const SN_grasshopper_mac: &[u8; 15] = b"kuznyechik-mac\0";
pub const NID_grasshopper_mac: u32 = 1017;
pub const ASN1_R_ADDING_OBJECT: u32 = 171;
pub const ASN1_R_ASN1_PARSE_ERROR: u32 = 203;
pub const ASN1_R_ASN1_SIG_PARSE_ERROR: u32 = 204;
pub const ASN1_R_AUX_ERROR: u32 = 100;
pub const ASN1_R_BAD_OBJECT_HEADER: u32 = 102;
pub const ASN1_R_BAD_TEMPLATE: u32 = 230;
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH: u32 = 214;
pub const ASN1_R_BN_LIB: u32 = 105;
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH: u32 = 106;
pub const ASN1_R_BUFFER_TOO_SMALL: u32 = 107;
pub const ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 108;
pub const ASN1_R_CONTEXT_NOT_INITIALISED: u32 = 217;
pub const ASN1_R_DATA_IS_WRONG: u32 = 109;
pub const ASN1_R_DECODE_ERROR: u32 = 110;
pub const ASN1_R_DEPTH_EXCEEDED: u32 = 174;
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED: u32 = 198;
pub const ASN1_R_ENCODE_ERROR: u32 = 112;
pub const ASN1_R_ERROR_GETTING_TIME: u32 = 173;
pub const ASN1_R_ERROR_LOADING_SECTION: u32 = 172;
pub const ASN1_R_ERROR_SETTING_CIPHER_PARAMS: u32 = 114;
pub const ASN1_R_EXPECTING_AN_INTEGER: u32 = 115;
pub const ASN1_R_EXPECTING_AN_OBJECT: u32 = 116;
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH: u32 = 119;
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED: u32 = 120;
pub const ASN1_R_FIELD_MISSING: u32 = 121;
pub const ASN1_R_FIRST_NUM_TOO_LARGE: u32 = 122;
pub const ASN1_R_HEADER_TOO_LONG: u32 = 123;
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT: u32 = 175;
pub const ASN1_R_ILLEGAL_BOOLEAN: u32 = 176;
pub const ASN1_R_ILLEGAL_CHARACTERS: u32 = 124;
pub const ASN1_R_ILLEGAL_FORMAT: u32 = 177;
pub const ASN1_R_ILLEGAL_HEX: u32 = 178;
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG: u32 = 179;
pub const ASN1_R_ILLEGAL_INTEGER: u32 = 180;
pub const ASN1_R_ILLEGAL_NEGATIVE_VALUE: u32 = 226;
pub const ASN1_R_ILLEGAL_NESTED_TAGGING: u32 = 181;
pub const ASN1_R_ILLEGAL_NULL: u32 = 125;
pub const ASN1_R_ILLEGAL_NULL_VALUE: u32 = 182;
pub const ASN1_R_ILLEGAL_OBJECT: u32 = 183;
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY: u32 = 126;
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE: u32 = 170;
pub const ASN1_R_ILLEGAL_PADDING: u32 = 221;
pub const ASN1_R_ILLEGAL_TAGGED_ANY: u32 = 127;
pub const ASN1_R_ILLEGAL_TIME_VALUE: u32 = 184;
pub const ASN1_R_ILLEGAL_ZERO_CONTENT: u32 = 222;
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT: u32 = 185;
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG: u32 = 128;
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 220;
pub const ASN1_R_INVALID_BMPSTRING_LENGTH: u32 = 129;
pub const ASN1_R_INVALID_DIGIT: u32 = 130;
pub const ASN1_R_INVALID_MIME_TYPE: u32 = 205;
pub const ASN1_R_INVALID_MODIFIER: u32 = 186;
pub const ASN1_R_INVALID_NUMBER: u32 = 187;
pub const ASN1_R_INVALID_OBJECT_ENCODING: u32 = 216;
pub const ASN1_R_INVALID_SCRYPT_PARAMETERS: u32 = 227;
pub const ASN1_R_INVALID_SEPARATOR: u32 = 131;
pub const ASN1_R_INVALID_STRING_TABLE_VALUE: u32 = 218;
pub const ASN1_R_INVALID_UNIVERSALSTRING_LENGTH: u32 = 133;
pub const ASN1_R_INVALID_UTF8STRING: u32 = 134;
pub const ASN1_R_INVALID_VALUE: u32 = 219;
pub const ASN1_R_LENGTH_TOO_LONG: u32 = 231;
pub const ASN1_R_LIST_ERROR: u32 = 188;
pub const ASN1_R_MIME_NO_CONTENT_TYPE: u32 = 206;
pub const ASN1_R_MIME_PARSE_ERROR: u32 = 207;
pub const ASN1_R_MIME_SIG_PARSE_ERROR: u32 = 208;
pub const ASN1_R_MISSING_EOC: u32 = 137;
pub const ASN1_R_MISSING_SECOND_NUMBER: u32 = 138;
pub const ASN1_R_MISSING_VALUE: u32 = 189;
pub const ASN1_R_MSTRING_NOT_UNIVERSAL: u32 = 139;
pub const ASN1_R_MSTRING_WRONG_TAG: u32 = 140;
pub const ASN1_R_NESTED_ASN1_STRING: u32 = 197;
pub const ASN1_R_NESTED_TOO_DEEP: u32 = 201;
pub const ASN1_R_NON_HEX_CHARACTERS: u32 = 141;
pub const ASN1_R_NOT_ASCII_FORMAT: u32 = 190;
pub const ASN1_R_NOT_ENOUGH_DATA: u32 = 142;
pub const ASN1_R_NO_CONTENT_TYPE: u32 = 209;
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE: u32 = 143;
pub const ASN1_R_NO_MULTIPART_BODY_FAILURE: u32 = 210;
pub const ASN1_R_NO_MULTIPART_BOUNDARY: u32 = 211;
pub const ASN1_R_NO_SIG_CONTENT_TYPE: u32 = 212;
pub const ASN1_R_NULL_IS_WRONG_LENGTH: u32 = 144;
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT: u32 = 191;
pub const ASN1_R_ODD_NUMBER_OF_CHARS: u32 = 145;
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE: u32 = 147;
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH: u32 = 148;
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED: u32 = 149;
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG: u32 = 192;
pub const ASN1_R_SHORT_LINE: u32 = 150;
pub const ASN1_R_SIG_INVALID_MIME_TYPE: u32 = 213;
pub const ASN1_R_STREAMING_NOT_SUPPORTED: u32 = 202;
pub const ASN1_R_STRING_TOO_LONG: u32 = 151;
pub const ASN1_R_STRING_TOO_SHORT: u32 = 152;
pub const ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 154;
pub const ASN1_R_TIME_NOT_ASCII_FORMAT: u32 = 193;
pub const ASN1_R_TOO_LARGE: u32 = 223;
pub const ASN1_R_TOO_LONG: u32 = 155;
pub const ASN1_R_TOO_SMALL: u32 = 224;
pub const ASN1_R_TYPE_NOT_CONSTRUCTED: u32 = 156;
pub const ASN1_R_TYPE_NOT_PRIMITIVE: u32 = 195;
pub const ASN1_R_UNEXPECTED_EOC: u32 = 159;
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH: u32 = 215;
pub const ASN1_R_UNKNOWN_DIGEST: u32 = 229;
pub const ASN1_R_UNKNOWN_FORMAT: u32 = 160;
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM: u32 = 161;
pub const ASN1_R_UNKNOWN_OBJECT_TYPE: u32 = 162;
pub const ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE: u32 = 163;
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM: u32 = 199;
pub const ASN1_R_UNKNOWN_TAG: u32 = 194;
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE: u32 = 164;
pub const ASN1_R_UNSUPPORTED_CIPHER: u32 = 228;
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 167;
pub const ASN1_R_UNSUPPORTED_TYPE: u32 = 196;
pub const ASN1_R_WRONG_INTEGER_TYPE: u32 = 225;
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE: u32 = 200;
pub const ASN1_R_WRONG_TAG: u32 = 168;
pub const V_ASN1_UNIVERSAL: u32 = 0;
pub const V_ASN1_APPLICATION: u32 = 64;
pub const V_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const V_ASN1_PRIVATE: u32 = 192;
pub const V_ASN1_CONSTRUCTED: u32 = 32;
pub const V_ASN1_PRIMITIVE_TAG: u32 = 31;
pub const V_ASN1_PRIMATIVE_TAG: u32 = 31;
pub const V_ASN1_APP_CHOOSE: i32 = -2;
pub const V_ASN1_OTHER: i32 = -3;
pub const V_ASN1_ANY: i32 = -4;
pub const V_ASN1_UNDEF: i32 = -1;
pub const V_ASN1_EOC: u32 = 0;
pub const V_ASN1_BOOLEAN: u32 = 1;
pub const V_ASN1_INTEGER: u32 = 2;
pub const V_ASN1_BIT_STRING: u32 = 3;
pub const V_ASN1_OCTET_STRING: u32 = 4;
pub const V_ASN1_NULL: u32 = 5;
pub const V_ASN1_OBJECT: u32 = 6;
pub const V_ASN1_OBJECT_DESCRIPTOR: u32 = 7;
pub const V_ASN1_EXTERNAL: u32 = 8;
pub const V_ASN1_REAL: u32 = 9;
pub const V_ASN1_ENUMERATED: u32 = 10;
pub const V_ASN1_UTF8STRING: u32 = 12;
pub const V_ASN1_SEQUENCE: u32 = 16;
pub const V_ASN1_SET: u32 = 17;
pub const V_ASN1_NUMERICSTRING: u32 = 18;
pub const V_ASN1_PRINTABLESTRING: u32 = 19;
pub const V_ASN1_T61STRING: u32 = 20;
pub const V_ASN1_TELETEXSTRING: u32 = 20;
pub const V_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const V_ASN1_IA5STRING: u32 = 22;
pub const V_ASN1_UTCTIME: u32 = 23;
pub const V_ASN1_GENERALIZEDTIME: u32 = 24;
pub const V_ASN1_GRAPHICSTRING: u32 = 25;
pub const V_ASN1_ISO64STRING: u32 = 26;
pub const V_ASN1_VISIBLESTRING: u32 = 26;
pub const V_ASN1_GENERALSTRING: u32 = 27;
pub const V_ASN1_UNIVERSALSTRING: u32 = 28;
pub const V_ASN1_BMPSTRING: u32 = 30;
pub const V_ASN1_NEG: u32 = 256;
pub const V_ASN1_NEG_INTEGER: u32 = 258;
pub const V_ASN1_NEG_ENUMERATED: u32 = 266;
pub const B_ASN1_NUMERICSTRING: u32 = 1;
pub const B_ASN1_PRINTABLESTRING: u32 = 2;
pub const B_ASN1_T61STRING: u32 = 4;
pub const B_ASN1_TELETEXSTRING: u32 = 4;
pub const B_ASN1_VIDEOTEXSTRING: u32 = 8;
pub const B_ASN1_IA5STRING: u32 = 16;
pub const B_ASN1_GRAPHICSTRING: u32 = 32;
pub const B_ASN1_ISO64STRING: u32 = 64;
pub const B_ASN1_VISIBLESTRING: u32 = 64;
pub const B_ASN1_GENERALSTRING: u32 = 128;
pub const B_ASN1_UNIVERSALSTRING: u32 = 256;
pub const B_ASN1_OCTET_STRING: u32 = 512;
pub const B_ASN1_BIT_STRING: u32 = 1024;
pub const B_ASN1_BMPSTRING: u32 = 2048;
pub const B_ASN1_UNKNOWN: u32 = 4096;
pub const B_ASN1_UTF8STRING: u32 = 8192;
pub const B_ASN1_UTCTIME: u32 = 16384;
pub const B_ASN1_GENERALIZEDTIME: u32 = 32768;
pub const B_ASN1_SEQUENCE: u32 = 65536;
pub const MBSTRING_FLAG: u32 = 4096;
pub const MBSTRING_UTF8: u32 = 4096;
pub const MBSTRING_ASC: u32 = 4097;
pub const MBSTRING_BMP: u32 = 4098;
pub const MBSTRING_UNIV: u32 = 4100;
pub const SMIME_OLDMIME: u32 = 1024;
pub const SMIME_CRLFEOL: u32 = 2048;
pub const SMIME_STREAM: u32 = 4096;
pub const ASN1_STRING_FLAG_BITS_LEFT: u32 = 8;
pub const ASN1_STRING_FLAG_NDEF: u32 = 16;
pub const ASN1_STRING_FLAG_CONT: u32 = 32;
pub const ASN1_STRING_FLAG_MSTRING: u32 = 64;
pub const ASN1_STRING_FLAG_EMBED: u32 = 128;
pub const ASN1_STRING_FLAG_X509_TIME: u32 = 256;
pub const ASN1_LONG_UNDEF: u32 = 2147483647;
pub const STABLE_FLAGS_MALLOC: u32 = 1;
pub const STABLE_FLAGS_CLEAR: u32 = 1;
pub const STABLE_NO_MASK: u32 = 2;
pub const DIRSTRING_TYPE: u32 = 10246;
pub const PKCS9STRING_TYPE: u32 = 10262;
pub const ub_name: u32 = 32768;
pub const ub_common_name: u32 = 64;
pub const ub_locality_name: u32 = 128;
pub const ub_state_name: u32 = 128;
pub const ub_organization_name: u32 = 64;
pub const ub_organization_unit_name: u32 = 64;
pub const ub_title: u32 = 64;
pub const ub_email_address: u32 = 128;
pub const ASN1_STRFLGS_ESC_2253: u32 = 1;
pub const ASN1_STRFLGS_ESC_CTRL: u32 = 2;
pub const ASN1_STRFLGS_ESC_MSB: u32 = 4;
pub const ASN1_DTFLGS_TYPE_MASK: u32 = 15;
pub const ASN1_DTFLGS_RFC822: u32 = 0;
pub const ASN1_DTFLGS_ISO8601: u32 = 1;
pub const ASN1_STRFLGS_ESC_QUOTE: u32 = 8;
pub const CHARTYPE_PRINTABLESTRING: u32 = 16;
pub const CHARTYPE_FIRST_ESC_2253: u32 = 32;
pub const CHARTYPE_LAST_ESC_2253: u32 = 64;
pub const ASN1_STRFLGS_UTF8_CONVERT: u32 = 16;
pub const ASN1_STRFLGS_IGNORE_TYPE: u32 = 32;
pub const ASN1_STRFLGS_SHOW_TYPE: u32 = 64;
pub const ASN1_STRFLGS_DUMP_ALL: u32 = 128;
pub const ASN1_STRFLGS_DUMP_UNKNOWN: u32 = 256;
pub const ASN1_STRFLGS_DUMP_DER: u32 = 512;
pub const ASN1_STRFLGS_ESC_2254: u32 = 1024;
pub const ASN1_STRFLGS_RFC2253: u32 = 791;
pub const B_ASN1_TIME: u32 = 49152;
pub const B_ASN1_PRINTABLE: u32 = 81175;
pub const B_ASN1_DIRECTORYSTRING: u32 = 10502;
pub const B_ASN1_DISPLAYTEXT: u32 = 10320;
pub const ASN1_PCTX_FLAGS_SHOW_ABSENT: u32 = 1;
pub const ASN1_PCTX_FLAGS_SHOW_SEQUENCE: u32 = 2;
pub const ASN1_PCTX_FLAGS_SHOW_SSOF: u32 = 4;
pub const ASN1_PCTX_FLAGS_SHOW_TYPE: u32 = 8;
pub const ASN1_PCTX_FLAGS_NO_ANY_TYPE: u32 = 16;
pub const ASN1_PCTX_FLAGS_NO_MSTRING_TYPE: u32 = 32;
pub const ASN1_PCTX_FLAGS_NO_FIELD_NAME: u32 = 64;
pub const ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME: u32 = 128;
pub const ASN1_PCTX_FLAGS_NO_STRUCT_NAME: u32 = 256;
pub const OBJ_R_OID_EXISTS: u32 = 102;
pub const OBJ_R_UNKNOWN_NID: u32 = 101;
pub const OBJ_R_UNKNOWN_OBJECT_NAME: u32 = 103;
pub const OBJ_NAME_TYPE_UNDEF: u32 = 0;
pub const OBJ_NAME_TYPE_MD_METH: u32 = 1;
pub const OBJ_NAME_TYPE_CIPHER_METH: u32 = 2;
pub const OBJ_NAME_TYPE_PKEY_METH: u32 = 3;
pub const OBJ_NAME_TYPE_COMP_METH: u32 = 4;
pub const OBJ_NAME_TYPE_MAC_METH: u32 = 5;
pub const OBJ_NAME_TYPE_KDF_METH: u32 = 6;
pub const OBJ_NAME_TYPE_NUM: u32 = 7;
pub const OBJ_NAME_ALIAS: u32 = 32768;
pub const OBJ_BSEARCH_VALUE_ON_NOMATCH: u32 = 1;
pub const OBJ_BSEARCH_FIRST_VALUE_ON_MATCH: u32 = 2;
pub const EVP_PK_RSA: u32 = 1;
pub const EVP_PK_DSA: u32 = 2;
pub const EVP_PK_DH: u32 = 4;
pub const EVP_PK_EC: u32 = 8;
pub const EVP_PKT_SIGN: u32 = 16;
pub const EVP_PKT_ENC: u32 = 32;
pub const EVP_PKT_EXCH: u32 = 64;
pub const EVP_PKS_RSA: u32 = 256;
pub const EVP_PKS_DSA: u32 = 512;
pub const EVP_PKS_EC: u32 = 1024;
pub const EVP_PKEY_NONE: u32 = 0;
pub const EVP_PKEY_RSA: u32 = 6;
pub const EVP_PKEY_RSA2: u32 = 19;
pub const EVP_PKEY_RSA_PSS: u32 = 912;
pub const EVP_PKEY_DSA: u32 = 116;
pub const EVP_PKEY_DSA1: u32 = 67;
pub const EVP_PKEY_DSA2: u32 = 66;
pub const EVP_PKEY_DSA3: u32 = 113;
pub const EVP_PKEY_DSA4: u32 = 70;
pub const EVP_PKEY_DH: u32 = 28;
pub const EVP_PKEY_DHX: u32 = 920;
pub const EVP_PKEY_EC: u32 = 408;
pub const EVP_PKEY_SM2: u32 = 1172;
pub const EVP_PKEY_HMAC: u32 = 855;
pub const EVP_PKEY_CMAC: u32 = 894;
pub const EVP_PKEY_SCRYPT: u32 = 973;
pub const EVP_PKEY_TLS1_PRF: u32 = 1021;
pub const EVP_PKEY_HKDF: u32 = 1036;
pub const EVP_PKEY_POLY1305: u32 = 1061;
pub const EVP_PKEY_SIPHASH: u32 = 1062;
pub const EVP_PKEY_X25519: u32 = 1034;
pub const EVP_PKEY_ED25519: u32 = 1087;
pub const EVP_PKEY_X448: u32 = 1035;
pub const EVP_PKEY_ED448: u32 = 1088;
pub const EVP_PKEY_KEYMGMT: i32 = -1;
pub const EVP_PKEY_KEY_PARAMETERS: u32 = 132;
pub const EVP_PKEY_PRIVATE_KEY: u32 = 133;
pub const EVP_PKEY_PUBLIC_KEY: u32 = 134;
pub const EVP_PKEY_KEYPAIR: u32 = 135;
pub const EVP_PKEY_MO_SIGN: u32 = 1;
pub const EVP_PKEY_MO_VERIFY: u32 = 2;
pub const EVP_PKEY_MO_ENCRYPT: u32 = 4;
pub const EVP_PKEY_MO_DECRYPT: u32 = 8;
pub const EVP_MD_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_FLAG_XOF: u32 = 2;
pub const EVP_MD_FLAG_DIGALGID_MASK: u32 = 24;
pub const EVP_MD_FLAG_DIGALGID_NULL: u32 = 0;
pub const EVP_MD_FLAG_DIGALGID_ABSENT: u32 = 8;
pub const EVP_MD_FLAG_DIGALGID_CUSTOM: u32 = 24;
pub const EVP_MD_FLAG_FIPS: u32 = 1024;
pub const EVP_MD_CTRL_DIGALGID: u32 = 1;
pub const EVP_MD_CTRL_MICALG: u32 = 2;
pub const EVP_MD_CTRL_XOF_LEN: u32 = 3;
pub const EVP_MD_CTRL_TLSTREE: u32 = 4;
pub const EVP_MD_CTRL_ALG_CTRL: u32 = 4096;
pub const EVP_MD_CTX_FLAG_ONESHOT: u32 = 1;
pub const EVP_MD_CTX_FLAG_CLEANED: u32 = 2;
pub const EVP_MD_CTX_FLAG_REUSE: u32 = 4;
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW: u32 = 8;
pub const EVP_MD_CTX_FLAG_PAD_MASK: u32 = 240;
pub const EVP_MD_CTX_FLAG_PAD_PKCS1: u32 = 0;
pub const EVP_MD_CTX_FLAG_PAD_X931: u32 = 16;
pub const EVP_MD_CTX_FLAG_PAD_PSS: u32 = 32;
pub const EVP_MD_CTX_FLAG_NO_INIT: u32 = 256;
pub const EVP_MD_CTX_FLAG_FINALISE: u32 = 512;
pub const EVP_CIPH_STREAM_CIPHER: u32 = 0;
pub const EVP_CIPH_ECB_MODE: u32 = 1;
pub const EVP_CIPH_CBC_MODE: u32 = 2;
pub const EVP_CIPH_CFB_MODE: u32 = 3;
pub const EVP_CIPH_OFB_MODE: u32 = 4;
pub const EVP_CIPH_CTR_MODE: u32 = 5;
pub const EVP_CIPH_GCM_MODE: u32 = 6;
pub const EVP_CIPH_CCM_MODE: u32 = 7;
pub const EVP_CIPH_XTS_MODE: u32 = 65537;
pub const EVP_CIPH_WRAP_MODE: u32 = 65538;
pub const EVP_CIPH_OCB_MODE: u32 = 65539;
pub const EVP_CIPH_SIV_MODE: u32 = 65540;
pub const EVP_CIPH_MODE: u32 = 983047;
pub const EVP_CIPH_VARIABLE_LENGTH: u32 = 8;
pub const EVP_CIPH_CUSTOM_IV: u32 = 16;
pub const EVP_CIPH_ALWAYS_CALL_INIT: u32 = 32;
pub const EVP_CIPH_CTRL_INIT: u32 = 64;
pub const EVP_CIPH_CUSTOM_KEY_LENGTH: u32 = 128;
pub const EVP_CIPH_NO_PADDING: u32 = 256;
pub const EVP_CIPH_RAND_KEY: u32 = 512;
pub const EVP_CIPH_CUSTOM_COPY: u32 = 1024;
pub const EVP_CIPH_CUSTOM_IV_LENGTH: u32 = 2048;
pub const EVP_CIPH_FLAG_DEFAULT_ASN1: u32 = 0;
pub const EVP_CIPH_FLAG_LENGTH_BITS: u32 = 8192;
pub const EVP_CIPH_FLAG_FIPS: u32 = 0;
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW: u32 = 0;
pub const EVP_CIPH_FLAG_CTS: u32 = 16384;
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER: u32 = 1048576;
pub const EVP_CIPH_FLAG_AEAD_CIPHER: u32 = 2097152;
pub const EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK: u32 = 4194304;
pub const EVP_CIPH_FLAG_PIPELINE: u32 = 8388608;
pub const EVP_CIPH_FLAG_CUSTOM_ASN1: u32 = 16777216;
pub const EVP_CIPH_FLAG_CIPHER_WITH_MAC: u32 = 33554432;
pub const EVP_CIPH_FLAG_GET_WRAP_CIPHER: u32 = 67108864;
pub const EVP_CIPH_FLAG_INVERSE_CIPHER: u32 = 134217728;
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: u32 = 1;
pub const EVP_CTRL_INIT: u32 = 0;
pub const EVP_CTRL_SET_KEY_LENGTH: u32 = 1;
pub const EVP_CTRL_GET_RC2_KEY_BITS: u32 = 2;
pub const EVP_CTRL_SET_RC2_KEY_BITS: u32 = 3;
pub const EVP_CTRL_GET_RC5_ROUNDS: u32 = 4;
pub const EVP_CTRL_SET_RC5_ROUNDS: u32 = 5;
pub const EVP_CTRL_RAND_KEY: u32 = 6;
pub const EVP_CTRL_PBE_PRF_NID: u32 = 7;
pub const EVP_CTRL_COPY: u32 = 8;
pub const EVP_CTRL_AEAD_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_AEAD_GET_TAG: u32 = 16;
pub const EVP_CTRL_AEAD_SET_TAG: u32 = 17;
pub const EVP_CTRL_AEAD_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_GCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_GCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_GCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_IV_GEN: u32 = 19;
pub const EVP_CTRL_CCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_CCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_CCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_CCM_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_CCM_SET_L: u32 = 20;
pub const EVP_CTRL_CCM_SET_MSGLEN: u32 = 21;
pub const EVP_CTRL_AEAD_TLS1_AAD: u32 = 22;
pub const EVP_CTRL_AEAD_SET_MAC_KEY: u32 = 23;
pub const EVP_CTRL_GCM_SET_IV_INV: u32 = 24;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_AAD: u32 = 25;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT: u32 = 26;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT: u32 = 27;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE: u32 = 28;
pub const EVP_CTRL_SSL3_MASTER_SECRET: u32 = 29;
pub const EVP_CTRL_SET_SBOX: u32 = 30;
pub const EVP_CTRL_SBOX_USED: u32 = 31;
pub const EVP_CTRL_KEY_MESH: u32 = 32;
pub const EVP_CTRL_BLOCK_PADDING_MODE: u32 = 33;
pub const EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS: u32 = 34;
pub const EVP_CTRL_SET_PIPELINE_INPUT_BUFS: u32 = 35;
pub const EVP_CTRL_SET_PIPELINE_INPUT_LENS: u32 = 36;
pub const EVP_CTRL_GET_IVLEN: u32 = 37;
pub const EVP_CTRL_SET_SPEED: u32 = 39;
pub const EVP_CTRL_PROCESS_UNPROTECTED: u32 = 40;
pub const EVP_CTRL_GET_WRAP_CIPHER: u32 = 41;
pub const EVP_CTRL_TLSTREE: u32 = 42;
pub const EVP_PADDING_PKCS7: u32 = 1;
pub const EVP_PADDING_ISO7816_4: u32 = 2;
pub const EVP_PADDING_ANSI923: u32 = 3;
pub const EVP_PADDING_ISO10126: u32 = 4;
pub const EVP_PADDING_ZERO: u32 = 5;
pub const EVP_AEAD_TLS1_AAD_LEN: u32 = 13;
pub const EVP_GCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_GCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_CCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_CCM_TLS_IV_LEN: u32 = 12;
pub const EVP_CCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CCM8_TLS_TAG_LEN: u32 = 8;
pub const EVP_CHACHAPOLY_TLS_TAG_LEN: u32 = 16;
pub const EVP_RAND_STATE_UNINITIALISED: u32 = 0;
pub const EVP_RAND_STATE_READY: u32 = 1;
pub const EVP_RAND_STATE_ERROR: u32 = 2;
pub const EVP_PBE_TYPE_OUTER: u32 = 0;
pub const EVP_PBE_TYPE_PRF: u32 = 1;
pub const EVP_PBE_TYPE_KDF: u32 = 2;
pub const ASN1_PKEY_ALIAS: u32 = 1;
pub const ASN1_PKEY_DYNAMIC: u32 = 2;
pub const ASN1_PKEY_SIGPARAM_NULL: u32 = 4;
pub const ASN1_PKEY_CTRL_PKCS7_SIGN: u32 = 1;
pub const ASN1_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 2;
pub const ASN1_PKEY_CTRL_DEFAULT_MD_NID: u32 = 3;
pub const ASN1_PKEY_CTRL_CMS_SIGN: u32 = 5;
pub const ASN1_PKEY_CTRL_CMS_ENVELOPE: u32 = 7;
pub const ASN1_PKEY_CTRL_CMS_RI_TYPE: u32 = 8;
pub const ASN1_PKEY_CTRL_SET1_TLS_ENCPT: u32 = 9;
pub const ASN1_PKEY_CTRL_GET1_TLS_ENCPT: u32 = 10;
pub const ASN1_PKEY_CTRL_CMS_IS_RI_TYPE_SUPPORTED: u32 = 11;
pub const EVP_PKEY_OP_UNDEFINED: u32 = 0;
pub const EVP_PKEY_OP_PARAMGEN: u32 = 2;
pub const EVP_PKEY_OP_KEYGEN: u32 = 4;
pub const EVP_PKEY_OP_FROMDATA: u32 = 8;
pub const EVP_PKEY_OP_SIGN: u32 = 16;
pub const EVP_PKEY_OP_VERIFY: u32 = 32;
pub const EVP_PKEY_OP_VERIFYRECOVER: u32 = 64;
pub const EVP_PKEY_OP_SIGNCTX: u32 = 128;
pub const EVP_PKEY_OP_VERIFYCTX: u32 = 256;
pub const EVP_PKEY_OP_ENCRYPT: u32 = 512;
pub const EVP_PKEY_OP_DECRYPT: u32 = 1024;
pub const EVP_PKEY_OP_DERIVE: u32 = 2048;
pub const EVP_PKEY_OP_ENCAPSULATE: u32 = 4096;
pub const EVP_PKEY_OP_DECAPSULATE: u32 = 8192;
pub const EVP_PKEY_OP_TYPE_SIG: u32 = 496;
pub const EVP_PKEY_OP_TYPE_CRYPT: u32 = 1536;
pub const EVP_PKEY_OP_TYPE_NOGEN: u32 = 4080;
pub const EVP_PKEY_OP_TYPE_GEN: u32 = 6;
pub const EVP_PKEY_CTRL_MD: u32 = 1;
pub const EVP_PKEY_CTRL_PEER_KEY: u32 = 2;
pub const EVP_PKEY_CTRL_SET_MAC_KEY: u32 = 6;
pub const EVP_PKEY_CTRL_DIGESTINIT: u32 = 7;
pub const EVP_PKEY_CTRL_SET_IV: u32 = 8;
pub const EVP_PKEY_CTRL_PKCS7_ENCRYPT: u32 = 3;
pub const EVP_PKEY_CTRL_PKCS7_DECRYPT: u32 = 4;
pub const EVP_PKEY_CTRL_PKCS7_SIGN: u32 = 5;
pub const EVP_PKEY_CTRL_CMS_ENCRYPT: u32 = 9;
pub const EVP_PKEY_CTRL_CMS_DECRYPT: u32 = 10;
pub const EVP_PKEY_CTRL_CMS_SIGN: u32 = 11;
pub const EVP_PKEY_CTRL_CIPHER: u32 = 12;
pub const EVP_PKEY_CTRL_GET_MD: u32 = 13;
pub const EVP_PKEY_CTRL_SET_DIGEST_SIZE: u32 = 14;
pub const EVP_PKEY_CTRL_SET1_ID: u32 = 15;
pub const EVP_PKEY_CTRL_GET1_ID: u32 = 16;
pub const EVP_PKEY_CTRL_GET1_ID_LEN: u32 = 17;
pub const EVP_PKEY_ALG_CTRL: u32 = 4096;
pub const EVP_PKEY_FLAG_AUTOARGLEN: u32 = 2;
pub const EVP_PKEY_FLAG_SIGCTX_CUSTOM: u32 = 4;
pub const OPENSSL_EC_EXPLICIT_CURVE: u32 = 0;
pub const OPENSSL_EC_NAMED_CURVE: u32 = 1;
pub const EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID: u32 = 4097;
pub const EVP_PKEY_CTRL_EC_PARAM_ENC: u32 = 4098;
pub const EVP_PKEY_CTRL_EC_ECDH_COFACTOR: u32 = 4099;
pub const EVP_PKEY_CTRL_EC_KDF_TYPE: u32 = 4100;
pub const EVP_PKEY_CTRL_EC_KDF_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_EC_KDF_MD: u32 = 4102;
pub const EVP_PKEY_CTRL_EC_KDF_OUTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN: u32 = 4104;
pub const EVP_PKEY_CTRL_EC_KDF_UKM: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_EC_KDF_UKM: u32 = 4106;
pub const EVP_PKEY_ECDH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_ECDH_KDF_X9_63: u32 = 2;
pub const EVP_PKEY_ECDH_KDF_X9_62: u32 = 2;
pub const EC_R_ASN1_ERROR: u32 = 115;
pub const EC_R_BAD_SIGNATURE: u32 = 156;
pub const EC_R_BIGNUM_OUT_OF_RANGE: u32 = 144;
pub const EC_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EC_R_CANNOT_INVERT: u32 = 165;
pub const EC_R_COORDINATES_OUT_OF_RANGE: u32 = 146;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDH: u32 = 160;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA: u32 = 170;
pub const EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING: u32 = 159;
pub const EC_R_DECODE_ERROR: u32 = 142;
pub const EC_R_DISCRIMINANT_IS_ZERO: u32 = 118;
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE: u32 = 119;
pub const EC_R_EXPLICIT_PARAMS_NOT_SUPPORTED: u32 = 127;
pub const EC_R_FAILED_MAKING_PUBLIC_KEY: u32 = 166;
pub const EC_R_FIELD_TOO_LARGE: u32 = 143;
pub const EC_R_GF2M_NOT_SUPPORTED: u32 = 147;
pub const EC_R_GROUP2PKPARAMETERS_FAILURE: u32 = 120;
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE: u32 = 121;
pub const EC_R_INCOMPATIBLE_OBJECTS: u32 = 101;
pub const EC_R_INVALID_A: u32 = 168;
pub const EC_R_INVALID_ARGUMENT: u32 = 112;
pub const EC_R_INVALID_B: u32 = 169;
pub const EC_R_INVALID_COFACTOR: u32 = 171;
pub const EC_R_INVALID_COMPRESSED_POINT: u32 = 110;
pub const EC_R_INVALID_COMPRESSION_BIT: u32 = 109;
pub const EC_R_INVALID_CURVE: u32 = 141;
pub const EC_R_INVALID_DIGEST: u32 = 151;
pub const EC_R_INVALID_DIGEST_TYPE: u32 = 138;
pub const EC_R_INVALID_ENCODING: u32 = 102;
pub const EC_R_INVALID_FIELD: u32 = 103;
pub const EC_R_INVALID_FORM: u32 = 104;
pub const EC_R_INVALID_GENERATOR: u32 = 173;
pub const EC_R_INVALID_GROUP_ORDER: u32 = 122;
pub const EC_R_INVALID_KEY: u32 = 116;
pub const EC_R_INVALID_LENGTH: u32 = 117;
pub const EC_R_INVALID_NAMED_GROUP_CONVERSION: u32 = 174;
pub const EC_R_INVALID_OUTPUT_LENGTH: u32 = 161;
pub const EC_R_INVALID_P: u32 = 172;
pub const EC_R_INVALID_PEER_KEY: u32 = 133;
pub const EC_R_INVALID_PENTANOMIAL_BASIS: u32 = 132;
pub const EC_R_INVALID_PRIVATE_KEY: u32 = 123;
pub const EC_R_INVALID_SEED: u32 = 175;
pub const EC_R_INVALID_TRINOMIAL_BASIS: u32 = 137;
pub const EC_R_KDF_PARAMETER_ERROR: u32 = 148;
pub const EC_R_KEYS_NOT_SET: u32 = 140;
pub const EC_R_LADDER_POST_FAILURE: u32 = 136;
pub const EC_R_LADDER_PRE_FAILURE: u32 = 153;
pub const EC_R_LADDER_STEP_FAILURE: u32 = 162;
pub const EC_R_MISSING_OID: u32 = 167;
pub const EC_R_MISSING_PARAMETERS: u32 = 124;
pub const EC_R_MISSING_PRIVATE_KEY: u32 = 125;
pub const EC_R_NEED_NEW_SETUP_VALUES: u32 = 157;
pub const EC_R_NOT_A_NIST_PRIME: u32 = 135;
pub const EC_R_NOT_IMPLEMENTED: u32 = 126;
pub const EC_R_NOT_INITIALIZED: u32 = 111;
pub const EC_R_NO_PARAMETERS_SET: u32 = 139;
pub const EC_R_NO_PRIVATE_VALUE: u32 = 154;
pub const EC_R_OPERATION_NOT_SUPPORTED: u32 = 152;
pub const EC_R_PASSED_NULL_PARAMETER: u32 = 134;
pub const EC_R_PEER_KEY_ERROR: u32 = 149;
pub const EC_R_POINT_ARITHMETIC_FAILURE: u32 = 155;
pub const EC_R_POINT_AT_INFINITY: u32 = 106;
pub const EC_R_POINT_COORDINATES_BLIND_FAILURE: u32 = 163;
pub const EC_R_POINT_IS_NOT_ON_CURVE: u32 = 107;
pub const EC_R_RANDOM_NUMBER_GENERATION_FAILED: u32 = 158;
pub const EC_R_SHARED_INFO_ERROR: u32 = 150;
pub const EC_R_SLOT_FULL: u32 = 108;
pub const EC_R_TOO_MANY_RETRIES: u32 = 176;
pub const EC_R_UNDEFINED_GENERATOR: u32 = 113;
pub const EC_R_UNDEFINED_ORDER: u32 = 128;
pub const EC_R_UNKNOWN_COFACTOR: u32 = 164;
pub const EC_R_UNKNOWN_GROUP: u32 = 129;
pub const EC_R_UNKNOWN_ORDER: u32 = 114;
pub const EC_R_UNSUPPORTED_FIELD: u32 = 131;
pub const EC_R_WRONG_CURVE_PARAMETERS: u32 = 145;
pub const EC_R_WRONG_ORDER: u32 = 130;
pub const OPENSSL_ECC_MAX_FIELD_BITS: u32 = 661;
pub const EC_PKEY_NO_PARAMETERS: u32 = 1;
pub const EC_PKEY_NO_PUBKEY: u32 = 2;
pub const EC_FLAG_SM2_RANGE: u32 = 4;
pub const EC_FLAG_COFACTOR_ECDH: u32 = 4096;
pub const EC_FLAG_CHECK_NAMED_GROUP: u32 = 8192;
pub const EC_FLAG_CHECK_NAMED_GROUP_NIST: u32 = 16384;
pub const EC_FLAG_CHECK_NAMED_GROUP_MASK: u32 = 24576;
pub const EC_FLAG_NON_FIPS_ALLOW: u32 = 0;
pub const EC_FLAG_FIPS_CHECKED: u32 = 0;
pub const RSA_R_ALGORITHM_MISMATCH: u32 = 100;
pub const RSA_R_BAD_E_VALUE: u32 = 101;
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT: u32 = 102;
pub const RSA_R_BAD_PAD_BYTE_COUNT: u32 = 103;
pub const RSA_R_BAD_SIGNATURE: u32 = 104;
pub const RSA_R_BLOCK_TYPE_IS_NOT_01: u32 = 106;
pub const RSA_R_BLOCK_TYPE_IS_NOT_02: u32 = 107;
pub const RSA_R_DATA_GREATER_THAN_MOD_LEN: u32 = 108;
pub const RSA_R_DATA_TOO_LARGE: u32 = 109;
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 110;
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS: u32 = 132;
pub const RSA_R_DATA_TOO_SMALL: u32 = 111;
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE: u32 = 122;
pub const RSA_R_DIGEST_DOES_NOT_MATCH: u32 = 158;
pub const RSA_R_DIGEST_NOT_ALLOWED: u32 = 145;
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY: u32 = 112;
pub const RSA_R_DMP1_NOT_CONGRUENT_TO_D: u32 = 124;
pub const RSA_R_DMQ1_NOT_CONGRUENT_TO_D: u32 = 125;
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1: u32 = 123;
pub const RSA_R_FIRST_OCTET_INVALID: u32 = 133;
pub const RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE: u32 = 144;
pub const RSA_R_INVALID_DIGEST: u32 = 157;
pub const RSA_R_INVALID_DIGEST_LENGTH: u32 = 143;
pub const RSA_R_INVALID_HEADER: u32 = 137;
pub const RSA_R_INVALID_KEYPAIR: u32 = 171;
pub const RSA_R_INVALID_KEY_LENGTH: u32 = 173;
pub const RSA_R_INVALID_LABEL: u32 = 160;
pub const RSA_R_INVALID_LENGTH: u32 = 181;
pub const RSA_R_INVALID_MESSAGE_LENGTH: u32 = 131;
pub const RSA_R_INVALID_MGF1_MD: u32 = 156;
pub const RSA_R_INVALID_MODULUS: u32 = 174;
pub const RSA_R_INVALID_MULTI_PRIME_KEY: u32 = 167;
pub const RSA_R_INVALID_OAEP_PARAMETERS: u32 = 161;
pub const RSA_R_INVALID_PADDING: u32 = 138;
pub const RSA_R_INVALID_PADDING_MODE: u32 = 141;
pub const RSA_R_INVALID_PSS_PARAMETERS: u32 = 149;
pub const RSA_R_INVALID_PSS_SALTLEN: u32 = 146;
pub const RSA_R_INVALID_REQUEST: u32 = 175;
pub const RSA_R_INVALID_SALT_LENGTH: u32 = 150;
pub const RSA_R_INVALID_STRENGTH: u32 = 176;
pub const RSA_R_INVALID_TRAILER: u32 = 139;
pub const RSA_R_INVALID_X931_DIGEST: u32 = 142;
pub const RSA_R_IQMP_NOT_INVERSE_OF_Q: u32 = 126;
pub const RSA_R_KEY_PRIME_NUM_INVALID: u32 = 165;
pub const RSA_R_KEY_SIZE_TOO_SMALL: u32 = 120;
pub const RSA_R_LAST_OCTET_INVALID: u32 = 134;
pub const RSA_R_MGF1_DIGEST_NOT_ALLOWED: u32 = 152;
pub const RSA_R_MISSING_PRIVATE_KEY: u32 = 179;
pub const RSA_R_MODULUS_TOO_LARGE: u32 = 105;
pub const RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R: u32 = 168;
pub const RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D: u32 = 169;
pub const RSA_R_MP_R_NOT_PRIME: u32 = 170;
pub const RSA_R_NO_PUBLIC_EXPONENT: u32 = 140;
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING: u32 = 113;
pub const RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES: u32 = 172;
pub const RSA_R_N_DOES_NOT_EQUAL_P_Q: u32 = 127;
pub const RSA_R_OAEP_DECODING_ERROR: u32 = 121;
pub const RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 148;
pub const RSA_R_PADDING_CHECK_FAILED: u32 = 114;
pub const RSA_R_PAIRWISE_TEST_FAILURE: u32 = 177;
pub const RSA_R_PKCS_DECODING_ERROR: u32 = 159;
pub const RSA_R_PSS_SALTLEN_TOO_SMALL: u32 = 164;
pub const RSA_R_PUB_EXPONENT_OUT_OF_RANGE: u32 = 178;
pub const RSA_R_P_NOT_PRIME: u32 = 128;
pub const RSA_R_Q_NOT_PRIME: u32 = 129;
pub const RSA_R_RANDOMNESS_SOURCE_STRENGTH_INSUFFICIENT: u32 = 180;
pub const RSA_R_RSA_OPERATIONS_NOT_SUPPORTED: u32 = 130;
pub const RSA_R_SLEN_CHECK_FAILED: u32 = 136;
pub const RSA_R_SLEN_RECOVERY_FAILED: u32 = 135;
pub const RSA_R_SSLV3_ROLLBACK_ATTACK: u32 = 115;
pub const RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD: u32 = 116;
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE: u32 = 117;
pub const RSA_R_UNKNOWN_DIGEST: u32 = 166;
pub const RSA_R_UNKNOWN_MASK_DIGEST: u32 = 151;
pub const RSA_R_UNKNOWN_PADDING_TYPE: u32 = 118;
pub const RSA_R_UNSUPPORTED_ENCRYPTION_TYPE: u32 = 162;
pub const RSA_R_UNSUPPORTED_LABEL_SOURCE: u32 = 163;
pub const RSA_R_UNSUPPORTED_MASK_ALGORITHM: u32 = 153;
pub const RSA_R_UNSUPPORTED_MASK_PARAMETER: u32 = 154;
pub const RSA_R_UNSUPPORTED_SIGNATURE_TYPE: u32 = 155;
pub const RSA_R_VALUE_MISSING: u32 = 147;
pub const RSA_R_WRONG_SIGNATURE_LENGTH: u32 = 119;
pub const OPENSSL_RSA_MAX_MODULUS_BITS: u32 = 16384;
pub const RSA_3: u32 = 3;
pub const RSA_F4: u32 = 65537;
pub const OPENSSL_RSA_FIPS_MIN_MODULUS_BITS: u32 = 2048;
pub const OPENSSL_RSA_SMALL_MODULUS_BITS: u32 = 3072;
pub const OPENSSL_RSA_MAX_PUBEXP_BITS: u32 = 64;
pub const RSA_ASN1_VERSION_DEFAULT: u32 = 0;
pub const RSA_ASN1_VERSION_MULTI: u32 = 1;
pub const RSA_DEFAULT_PRIME_NUM: u32 = 2;
pub const RSA_METHOD_FLAG_NO_CHECK: u32 = 1;
pub const RSA_FLAG_CACHE_PUBLIC: u32 = 2;
pub const RSA_FLAG_CACHE_PRIVATE: u32 = 4;
pub const RSA_FLAG_BLINDING: u32 = 8;
pub const RSA_FLAG_THREAD_SAFE: u32 = 16;
pub const RSA_FLAG_EXT_PKEY: u32 = 32;
pub const RSA_FLAG_NO_BLINDING: u32 = 128;
pub const RSA_FLAG_NO_CONSTTIME: u32 = 0;
pub const RSA_FLAG_NO_EXP_CONSTTIME: u32 = 0;
pub const RSA_FLAG_TYPE_MASK: u32 = 61440;
pub const RSA_FLAG_TYPE_RSA: u32 = 0;
pub const RSA_FLAG_TYPE_RSASSAPSS: u32 = 4096;
pub const RSA_FLAG_TYPE_RSAESOAEP: u32 = 8192;
pub const RSA_PSS_SALTLEN_DIGEST: i32 = -1;
pub const RSA_PSS_SALTLEN_AUTO: i32 = -2;
pub const RSA_PSS_SALTLEN_MAX: i32 = -3;
pub const RSA_PSS_SALTLEN_AUTO_DIGEST_MAX: i32 = -4;
pub const RSA_PSS_SALTLEN_MAX_SIGN: i32 = -2;
pub const EVP_PKEY_CTRL_RSA_PADDING: u32 = 4097;
pub const EVP_PKEY_CTRL_RSA_PSS_SALTLEN: u32 = 4098;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_BITS: u32 = 4099;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP: u32 = 4100;
pub const EVP_PKEY_CTRL_RSA_MGF1_MD: u32 = 4101;
pub const EVP_PKEY_CTRL_GET_RSA_PADDING: u32 = 4102;
pub const EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_RSA_MGF1_MD: u32 = 4104;
pub const EVP_PKEY_CTRL_RSA_OAEP_MD: u32 = 4105;
pub const EVP_PKEY_CTRL_RSA_OAEP_LABEL: u32 = 4106;
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_MD: u32 = 4107;
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL: u32 = 4108;
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES: u32 = 4109;
pub const RSA_PKCS1_PADDING: u32 = 1;
pub const RSA_NO_PADDING: u32 = 3;
pub const RSA_PKCS1_OAEP_PADDING: u32 = 4;
pub const RSA_X931_PADDING: u32 = 5;
pub const RSA_PKCS1_PSS_PADDING: u32 = 6;
pub const RSA_PKCS1_WITH_TLS_PADDING: u32 = 7;
pub const RSA_PKCS1_PADDING_SIZE: u32 = 11;
pub const RSA_FLAG_FIPS_METHOD: u32 = 1024;
pub const RSA_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const RSA_FLAG_CHECKED: u32 = 2048;
pub const DH_PARAMGEN_TYPE_GENERATOR: u32 = 0;
pub const DH_PARAMGEN_TYPE_FIPS_186_2: u32 = 1;
pub const DH_PARAMGEN_TYPE_FIPS_186_4: u32 = 2;
pub const DH_PARAMGEN_TYPE_GROUP: u32 = 3;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN: u32 = 4097;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR: u32 = 4098;
pub const EVP_PKEY_CTRL_DH_RFC5114: u32 = 4099;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN: u32 = 4100;
pub const EVP_PKEY_CTRL_DH_PARAMGEN_TYPE: u32 = 4101;
pub const EVP_PKEY_CTRL_DH_KDF_TYPE: u32 = 4102;
pub const EVP_PKEY_CTRL_DH_KDF_MD: u32 = 4103;
pub const EVP_PKEY_CTRL_GET_DH_KDF_MD: u32 = 4104;
pub const EVP_PKEY_CTRL_DH_KDF_OUTLEN: u32 = 4105;
pub const EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN: u32 = 4106;
pub const EVP_PKEY_CTRL_DH_KDF_UKM: u32 = 4107;
pub const EVP_PKEY_CTRL_GET_DH_KDF_UKM: u32 = 4108;
pub const EVP_PKEY_CTRL_DH_KDF_OID: u32 = 4109;
pub const EVP_PKEY_CTRL_GET_DH_KDF_OID: u32 = 4110;
pub const EVP_PKEY_CTRL_DH_NID: u32 = 4111;
pub const EVP_PKEY_CTRL_DH_PAD: u32 = 4112;
pub const EVP_PKEY_DH_KDF_NONE: u32 = 1;
pub const EVP_PKEY_DH_KDF_X9_42: u32 = 2;
pub const DH_R_BAD_FFC_PARAMETERS: u32 = 127;
pub const DH_R_BAD_GENERATOR: u32 = 101;
pub const DH_R_BN_DECODE_ERROR: u32 = 109;
pub const DH_R_BN_ERROR: u32 = 106;
pub const DH_R_CHECK_INVALID_J_VALUE: u32 = 115;
pub const DH_R_CHECK_INVALID_Q_VALUE: u32 = 116;
pub const DH_R_CHECK_PUBKEY_INVALID: u32 = 122;
pub const DH_R_CHECK_PUBKEY_TOO_LARGE: u32 = 123;
pub const DH_R_CHECK_PUBKEY_TOO_SMALL: u32 = 124;
pub const DH_R_CHECK_P_NOT_PRIME: u32 = 117;
pub const DH_R_CHECK_P_NOT_SAFE_PRIME: u32 = 118;
pub const DH_R_CHECK_Q_NOT_PRIME: u32 = 119;
pub const DH_R_DECODE_ERROR: u32 = 104;
pub const DH_R_INVALID_PARAMETER_NAME: u32 = 110;
pub const DH_R_INVALID_PARAMETER_NID: u32 = 114;
pub const DH_R_INVALID_PUBKEY: u32 = 102;
pub const DH_R_INVALID_SECRET: u32 = 128;
pub const DH_R_KDF_PARAMETER_ERROR: u32 = 112;
pub const DH_R_KEYS_NOT_SET: u32 = 108;
pub const DH_R_MISSING_PUBKEY: u32 = 125;
pub const DH_R_MODULUS_TOO_LARGE: u32 = 103;
pub const DH_R_MODULUS_TOO_SMALL: u32 = 126;
pub const DH_R_NOT_SUITABLE_GENERATOR: u32 = 120;
pub const DH_R_NO_PARAMETERS_SET: u32 = 107;
pub const DH_R_NO_PRIVATE_VALUE: u32 = 100;
pub const DH_R_PARAMETER_ENCODING_ERROR: u32 = 105;
pub const DH_R_PEER_KEY_ERROR: u32 = 111;
pub const DH_R_Q_TOO_LARGE: u32 = 130;
pub const DH_R_SHARED_INFO_ERROR: u32 = 113;
pub const DH_R_UNABLE_TO_CHECK_GENERATOR: u32 = 121;
pub const OPENSSL_DH_MAX_MODULUS_BITS: u32 = 10000;
pub const OPENSSL_DH_CHECK_MAX_MODULUS_BITS: u32 = 32768;
pub const OPENSSL_DH_FIPS_MIN_MODULUS_BITS: u32 = 1024;
pub const DH_FLAG_CACHE_MONT_P: u32 = 1;
pub const DH_FLAG_TYPE_MASK: u32 = 61440;
pub const DH_FLAG_TYPE_DH: u32 = 0;
pub const DH_FLAG_TYPE_DHX: u32 = 4096;
pub const DH_FLAG_NO_EXP_CONSTTIME: u32 = 0;
pub const DH_FLAG_FIPS_METHOD: u32 = 1024;
pub const DH_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const DH_GENERATOR_2: u32 = 2;
pub const DH_GENERATOR_3: u32 = 3;
pub const DH_GENERATOR_5: u32 = 5;
pub const DH_CHECK_P_NOT_PRIME: u32 = 1;
pub const DH_CHECK_P_NOT_SAFE_PRIME: u32 = 2;
pub const DH_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_CHECK_Q_NOT_PRIME: u32 = 16;
pub const DH_CHECK_INVALID_Q_VALUE: u32 = 32;
pub const DH_CHECK_INVALID_J_VALUE: u32 = 64;
pub const DH_MODULUS_TOO_SMALL: u32 = 128;
pub const DH_MODULUS_TOO_LARGE: u32 = 256;
pub const DH_CHECK_PUBKEY_TOO_SMALL: u32 = 1;
pub const DH_CHECK_PUBKEY_TOO_LARGE: u32 = 2;
pub const DH_CHECK_PUBKEY_INVALID: u32 = 4;
pub const DH_CHECK_P_NOT_STRONG_PRIME: u32 = 2;
pub const DSA_R_BAD_FFC_PARAMETERS: u32 = 114;
pub const DSA_R_BAD_Q_VALUE: u32 = 102;
pub const DSA_R_BN_DECODE_ERROR: u32 = 108;
pub const DSA_R_BN_ERROR: u32 = 109;
pub const DSA_R_DECODE_ERROR: u32 = 104;
pub const DSA_R_INVALID_DIGEST_TYPE: u32 = 106;
pub const DSA_R_INVALID_PARAMETERS: u32 = 112;
pub const DSA_R_MISSING_PARAMETERS: u32 = 101;
pub const DSA_R_MISSING_PRIVATE_KEY: u32 = 111;
pub const DSA_R_MODULUS_TOO_LARGE: u32 = 103;
pub const DSA_R_NO_PARAMETERS_SET: u32 = 107;
pub const DSA_R_PARAMETER_ENCODING_ERROR: u32 = 105;
pub const DSA_R_P_NOT_PRIME: u32 = 115;
pub const DSA_R_Q_NOT_PRIME: u32 = 113;
pub const DSA_R_SEED_LEN_SMALL: u32 = 110;
pub const DSA_R_TOO_MANY_RETRIES: u32 = 116;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_BITS: u32 = 4097;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS: u32 = 4098;
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_MD: u32 = 4099;
pub const OPENSSL_DSA_MAX_MODULUS_BITS: u32 = 10000;
pub const OPENSSL_DSA_FIPS_MIN_MODULUS_BITS: u32 = 1024;
pub const DSA_FLAG_NO_EXP_CONSTTIME: u32 = 0;
pub const DSA_FLAG_CACHE_MONT_P: u32 = 1;
pub const DSA_FLAG_FIPS_METHOD: u32 = 1024;
pub const DSA_FLAG_NON_FIPS_ALLOW: u32 = 1024;
pub const DSA_FLAG_FIPS_CHECKED: u32 = 2048;
pub const DSS_prime_checks: u32 = 64;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA_LBLOCK: u32 = 16;
pub const SHA_CBLOCK: u32 = 64;
pub const SHA_LAST_BLOCK: u32 = 56;
pub const SHA256_CBLOCK: u32 = 64;
pub const SHA224_DIGEST_LENGTH: u32 = 28;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub const SHA512_CBLOCK: u32 = 128;
pub const X509_R_AKID_MISMATCH: u32 = 110;
pub const X509_R_BAD_SELECTOR: u32 = 133;
pub const X509_R_BAD_X509_FILETYPE: u32 = 100;
pub const X509_R_BASE64_DECODE_ERROR: u32 = 118;
pub const X509_R_CANT_CHECK_DH_KEY: u32 = 114;
pub const X509_R_CERTIFICATE_VERIFICATION_FAILED: u32 = 139;
pub const X509_R_CERT_ALREADY_IN_HASH_TABLE: u32 = 101;
pub const X509_R_CRL_ALREADY_DELTA: u32 = 127;
pub const X509_R_CRL_VERIFY_FAILURE: u32 = 131;
pub const X509_R_DUPLICATE_ATTRIBUTE: u32 = 140;
pub const X509_R_ERROR_GETTING_MD_BY_NID: u32 = 141;
pub const X509_R_ERROR_USING_SIGINF_SET: u32 = 142;
pub const X509_R_IDP_MISMATCH: u32 = 128;
pub const X509_R_INVALID_ATTRIBUTES: u32 = 138;
pub const X509_R_INVALID_DIRECTORY: u32 = 113;
pub const X509_R_INVALID_DISTPOINT: u32 = 143;
pub const X509_R_INVALID_FIELD_NAME: u32 = 119;
pub const X509_R_INVALID_TRUST: u32 = 123;
pub const X509_R_ISSUER_MISMATCH: u32 = 129;
pub const X509_R_KEY_TYPE_MISMATCH: u32 = 115;
pub const X509_R_KEY_VALUES_MISMATCH: u32 = 116;
pub const X509_R_LOADING_CERT_DIR: u32 = 103;
pub const X509_R_LOADING_DEFAULTS: u32 = 104;
pub const X509_R_METHOD_NOT_SUPPORTED: u32 = 124;
pub const X509_R_NAME_TOO_LONG: u32 = 134;
pub const X509_R_NEWER_CRL_NOT_NEWER: u32 = 132;
pub const X509_R_NO_CERTIFICATE_FOUND: u32 = 135;
pub const X509_R_NO_CERTIFICATE_OR_CRL_FOUND: u32 = 136;
pub const X509_R_NO_CERT_SET_FOR_US_TO_VERIFY: u32 = 105;
pub const X509_R_NO_CRL_FOUND: u32 = 137;
pub const X509_R_NO_CRL_NUMBER: u32 = 130;
pub const X509_R_PUBLIC_KEY_DECODE_ERROR: u32 = 125;
pub const X509_R_PUBLIC_KEY_ENCODE_ERROR: u32 = 126;
pub const X509_R_SHOULD_RETRY: u32 = 106;
pub const X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN: u32 = 107;
pub const X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY: u32 = 108;
pub const X509_R_UNKNOWN_KEY_TYPE: u32 = 117;
pub const X509_R_UNKNOWN_NID: u32 = 109;
pub const X509_R_UNKNOWN_PURPOSE_ID: u32 = 121;
pub const X509_R_UNKNOWN_SIGID_ALGS: u32 = 144;
pub const X509_R_UNKNOWN_TRUST_ID: u32 = 120;
pub const X509_R_UNSUPPORTED_ALGORITHM: u32 = 111;
pub const X509_R_WRONG_LOOKUP_TYPE: u32 = 112;
pub const X509_R_WRONG_TYPE: u32 = 122;
pub const X509_SIG_INFO_VALID: u32 = 1;
pub const X509_SIG_INFO_TLS: u32 = 2;
pub const X509_FILETYPE_PEM: u32 = 1;
pub const X509_FILETYPE_ASN1: u32 = 2;
pub const X509_FILETYPE_DEFAULT: u32 = 3;
pub const X509v3_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const X509v3_KU_NON_REPUDIATION: u32 = 64;
pub const X509v3_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const X509v3_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const X509v3_KU_KEY_AGREEMENT: u32 = 8;
pub const X509v3_KU_KEY_CERT_SIGN: u32 = 4;
pub const X509v3_KU_CRL_SIGN: u32 = 2;
pub const X509v3_KU_ENCIPHER_ONLY: u32 = 1;
pub const X509v3_KU_DECIPHER_ONLY: u32 = 32768;
pub const X509v3_KU_UNDEF: u32 = 65535;
pub const X509_EX_V_NETSCAPE_HACK: u32 = 32768;
pub const X509_EX_V_INIT: u32 = 1;
pub const X509_FLAG_COMPAT: u32 = 0;
pub const X509_FLAG_NO_HEADER: u32 = 1;
pub const X509_FLAG_NO_VERSION: u32 = 2;
pub const X509_FLAG_NO_SERIAL: u32 = 4;
pub const X509_FLAG_NO_SIGNAME: u32 = 8;
pub const X509_FLAG_NO_ISSUER: u32 = 16;
pub const X509_FLAG_NO_VALIDITY: u32 = 32;
pub const X509_FLAG_NO_SUBJECT: u32 = 64;
pub const X509_FLAG_NO_PUBKEY: u32 = 128;
pub const X509_FLAG_NO_EXTENSIONS: u32 = 256;
pub const X509_FLAG_NO_SIGDUMP: u32 = 512;
pub const X509_FLAG_NO_AUX: u32 = 1024;
pub const X509_FLAG_NO_ATTRIBUTES: u32 = 2048;
pub const X509_FLAG_NO_IDS: u32 = 4096;
pub const X509_FLAG_EXTENSIONS_ONLY_KID: u32 = 8192;
pub const XN_FLAG_SEP_MASK: u32 = 983040;
pub const XN_FLAG_COMPAT: u32 = 0;
pub const XN_FLAG_SEP_COMMA_PLUS: u32 = 65536;
pub const XN_FLAG_SEP_CPLUS_SPC: u32 = 131072;
pub const XN_FLAG_SEP_SPLUS_SPC: u32 = 196608;
pub const XN_FLAG_SEP_MULTILINE: u32 = 262144;
pub const XN_FLAG_DN_REV: u32 = 1048576;
pub const XN_FLAG_FN_MASK: u32 = 6291456;
pub const XN_FLAG_FN_SN: u32 = 0;
pub const XN_FLAG_FN_LN: u32 = 2097152;
pub const XN_FLAG_FN_OID: u32 = 4194304;
pub const XN_FLAG_FN_NONE: u32 = 6291456;
pub const XN_FLAG_SPC_EQ: u32 = 8388608;
pub const XN_FLAG_DUMP_UNKNOWN_FIELDS: u32 = 16777216;
pub const XN_FLAG_FN_ALIGN: u32 = 33554432;
pub const XN_FLAG_RFC2253: u32 = 17892119;
pub const XN_FLAG_ONELINE: u32 = 8520479;
pub const XN_FLAG_MULTILINE: u32 = 44302342;
pub const LH_LOAD_MULT: u32 = 256;
pub const X509_LU_RETRY: i32 = -1;
pub const X509_LU_FAIL: u32 = 0;
pub const X509_TRUST_DEFAULT: u32 = 0;
pub const X509_TRUST_COMPAT: u32 = 1;
pub const X509_TRUST_SSL_CLIENT: u32 = 2;
pub const X509_TRUST_SSL_SERVER: u32 = 3;
pub const X509_TRUST_EMAIL: u32 = 4;
pub const X509_TRUST_OBJECT_SIGN: u32 = 5;
pub const X509_TRUST_OCSP_SIGN: u32 = 6;
pub const X509_TRUST_OCSP_REQUEST: u32 = 7;
pub const X509_TRUST_TSA: u32 = 8;
pub const X509_TRUST_MIN: u32 = 1;
pub const X509_TRUST_MAX: u32 = 8;
pub const X509_TRUST_DYNAMIC: u32 = 1;
pub const X509_TRUST_DYNAMIC_NAME: u32 = 2;
pub const X509_TRUST_NO_SS_COMPAT: u32 = 4;
pub const X509_TRUST_DO_SS_COMPAT: u32 = 8;
pub const X509_TRUST_OK_ANY_EKU: u32 = 16;
pub const X509_TRUST_TRUSTED: u32 = 1;
pub const X509_TRUST_REJECTED: u32 = 2;
pub const X509_TRUST_UNTRUSTED: u32 = 3;
pub const X509_L_FILE_LOAD: u32 = 1;
pub const X509_L_ADD_DIR: u32 = 2;
pub const X509_L_ADD_STORE: u32 = 3;
pub const X509_L_LOAD_STORE: u32 = 4;
pub const X509_V_OK: u32 = 0;
pub const X509_V_ERR_UNSPECIFIED: u32 = 1;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: u32 = 2;
pub const X509_V_ERR_UNABLE_TO_GET_CRL: u32 = 3;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: u32 = 4;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: u32 = 5;
pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: u32 = 6;
pub const X509_V_ERR_CERT_SIGNATURE_FAILURE: u32 = 7;
pub const X509_V_ERR_CRL_SIGNATURE_FAILURE: u32 = 8;
pub const X509_V_ERR_CERT_NOT_YET_VALID: u32 = 9;
pub const X509_V_ERR_CERT_HAS_EXPIRED: u32 = 10;
pub const X509_V_ERR_CRL_NOT_YET_VALID: u32 = 11;
pub const X509_V_ERR_CRL_HAS_EXPIRED: u32 = 12;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: u32 = 13;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: u32 = 14;
pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: u32 = 15;
pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: u32 = 16;
pub const X509_V_ERR_OUT_OF_MEM: u32 = 17;
pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: u32 = 18;
pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: u32 = 19;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: u32 = 20;
pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: u32 = 21;
pub const X509_V_ERR_CERT_CHAIN_TOO_LONG: u32 = 22;
pub const X509_V_ERR_CERT_REVOKED: u32 = 23;
pub const X509_V_ERR_NO_ISSUER_PUBLIC_KEY: u32 = 24;
pub const X509_V_ERR_PATH_LENGTH_EXCEEDED: u32 = 25;
pub const X509_V_ERR_INVALID_PURPOSE: u32 = 26;
pub const X509_V_ERR_CERT_UNTRUSTED: u32 = 27;
pub const X509_V_ERR_CERT_REJECTED: u32 = 28;
pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH: u32 = 29;
pub const X509_V_ERR_AKID_SKID_MISMATCH: u32 = 30;
pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: u32 = 31;
pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN: u32 = 32;
pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER: u32 = 33;
pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION: u32 = 34;
pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN: u32 = 35;
pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: u32 = 36;
pub const X509_V_ERR_INVALID_NON_CA: u32 = 37;
pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED: u32 = 38;
pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: u32 = 39;
pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: u32 = 40;
pub const X509_V_ERR_INVALID_EXTENSION: u32 = 41;
pub const X509_V_ERR_INVALID_POLICY_EXTENSION: u32 = 42;
pub const X509_V_ERR_NO_EXPLICIT_POLICY: u32 = 43;
pub const X509_V_ERR_DIFFERENT_CRL_SCOPE: u32 = 44;
pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE: u32 = 45;
pub const X509_V_ERR_UNNESTED_RESOURCE: u32 = 46;
pub const X509_V_ERR_PERMITTED_VIOLATION: u32 = 47;
pub const X509_V_ERR_EXCLUDED_VIOLATION: u32 = 48;
pub const X509_V_ERR_SUBTREE_MINMAX: u32 = 49;
pub const X509_V_ERR_APPLICATION_VERIFICATION: u32 = 50;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: u32 = 51;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: u32 = 52;
pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX: u32 = 53;
pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR: u32 = 54;
pub const X509_V_ERR_PATH_LOOP: u32 = 55;
pub const X509_V_ERR_SUITE_B_INVALID_VERSION: u32 = 56;
pub const X509_V_ERR_SUITE_B_INVALID_ALGORITHM: u32 = 57;
pub const X509_V_ERR_SUITE_B_INVALID_CURVE: u32 = 58;
pub const X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM: u32 = 59;
pub const X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED: u32 = 60;
pub const X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256: u32 = 61;
pub const X509_V_ERR_HOSTNAME_MISMATCH: u32 = 62;
pub const X509_V_ERR_EMAIL_MISMATCH: u32 = 63;
pub const X509_V_ERR_IP_ADDRESS_MISMATCH: u32 = 64;
pub const X509_V_ERR_DANE_NO_MATCH: u32 = 65;
pub const X509_V_ERR_EE_KEY_TOO_SMALL: u32 = 66;
pub const X509_V_ERR_CA_KEY_TOO_SMALL: u32 = 67;
pub const X509_V_ERR_CA_MD_TOO_WEAK: u32 = 68;
pub const X509_V_ERR_INVALID_CALL: u32 = 69;
pub const X509_V_ERR_STORE_LOOKUP: u32 = 70;
pub const X509_V_ERR_NO_VALID_SCTS: u32 = 71;
pub const X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION: u32 = 72;
pub const X509_V_ERR_OCSP_VERIFY_NEEDED: u32 = 73;
pub const X509_V_ERR_OCSP_VERIFY_FAILED: u32 = 74;
pub const X509_V_ERR_OCSP_CERT_UNKNOWN: u32 = 75;
pub const X509_V_ERR_UNSUPPORTED_SIGNATURE_ALGORITHM: u32 = 76;
pub const X509_V_ERR_SIGNATURE_ALGORITHM_MISMATCH: u32 = 77;
pub const X509_V_ERR_SIGNATURE_ALGORITHM_INCONSISTENCY: u32 = 78;
pub const X509_V_ERR_INVALID_CA: u32 = 79;
pub const X509_V_ERR_PATHLEN_INVALID_FOR_NON_CA: u32 = 80;
pub const X509_V_ERR_PATHLEN_WITHOUT_KU_KEY_CERT_SIGN: u32 = 81;
pub const X509_V_ERR_KU_KEY_CERT_SIGN_INVALID_FOR_NON_CA: u32 = 82;
pub const X509_V_ERR_ISSUER_NAME_EMPTY: u32 = 83;
pub const X509_V_ERR_SUBJECT_NAME_EMPTY: u32 = 84;
pub const X509_V_ERR_MISSING_AUTHORITY_KEY_IDENTIFIER: u32 = 85;
pub const X509_V_ERR_MISSING_SUBJECT_KEY_IDENTIFIER: u32 = 86;
pub const X509_V_ERR_EMPTY_SUBJECT_ALT_NAME: u32 = 87;
pub const X509_V_ERR_EMPTY_SUBJECT_SAN_NOT_CRITICAL: u32 = 88;
pub const X509_V_ERR_CA_BCONS_NOT_CRITICAL: u32 = 89;
pub const X509_V_ERR_AUTHORITY_KEY_IDENTIFIER_CRITICAL: u32 = 90;
pub const X509_V_ERR_SUBJECT_KEY_IDENTIFIER_CRITICAL: u32 = 91;
pub const X509_V_ERR_CA_CERT_MISSING_KEY_USAGE: u32 = 92;
pub const X509_V_ERR_EXTENSIONS_REQUIRE_VERSION_3: u32 = 93;
pub const X509_V_ERR_EC_KEY_EXPLICIT_PARAMS: u32 = 94;
pub const X509_V_FLAG_CB_ISSUER_CHECK: u32 = 0;
pub const X509_V_FLAG_USE_CHECK_TIME: u32 = 2;
pub const X509_V_FLAG_CRL_CHECK: u32 = 4;
pub const X509_V_FLAG_CRL_CHECK_ALL: u32 = 8;
pub const X509_V_FLAG_IGNORE_CRITICAL: u32 = 16;
pub const X509_V_FLAG_X509_STRICT: u32 = 32;
pub const X509_V_FLAG_ALLOW_PROXY_CERTS: u32 = 64;
pub const X509_V_FLAG_POLICY_CHECK: u32 = 128;
pub const X509_V_FLAG_EXPLICIT_POLICY: u32 = 256;
pub const X509_V_FLAG_INHIBIT_ANY: u32 = 512;
pub const X509_V_FLAG_INHIBIT_MAP: u32 = 1024;
pub const X509_V_FLAG_NOTIFY_POLICY: u32 = 2048;
pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT: u32 = 4096;
pub const X509_V_FLAG_USE_DELTAS: u32 = 8192;
pub const X509_V_FLAG_CHECK_SS_SIGNATURE: u32 = 16384;
pub const X509_V_FLAG_TRUSTED_FIRST: u32 = 32768;
pub const X509_V_FLAG_SUITEB_128_LOS_ONLY: u32 = 65536;
pub const X509_V_FLAG_SUITEB_192_LOS: u32 = 131072;
pub const X509_V_FLAG_SUITEB_128_LOS: u32 = 196608;
pub const X509_V_FLAG_PARTIAL_CHAIN: u32 = 524288;
pub const X509_V_FLAG_NO_ALT_CHAINS: u32 = 1048576;
pub const X509_V_FLAG_NO_CHECK_TIME: u32 = 2097152;
pub const X509_VP_FLAG_DEFAULT: u32 = 1;
pub const X509_VP_FLAG_OVERWRITE: u32 = 2;
pub const X509_VP_FLAG_RESET_FLAGS: u32 = 4;
pub const X509_VP_FLAG_LOCKED: u32 = 8;
pub const X509_VP_FLAG_ONCE: u32 = 16;
pub const X509_V_FLAG_POLICY_MASK: u32 = 1920;
pub const DANE_FLAG_NO_DANE_EE_NAMECHECKS: u32 = 1;
pub const X509_PCY_TREE_FAILURE: i32 = -2;
pub const X509_PCY_TREE_INVALID: i32 = -1;
pub const X509_PCY_TREE_INTERNAL: u32 = 0;
pub const X509_PCY_TREE_VALID: u32 = 1;
pub const X509_PCY_TREE_EMPTY: u32 = 2;
pub const X509_PCY_TREE_EXPLICIT: u32 = 4;
pub const PKCS7_R_CERTIFICATE_VERIFY_ERROR: u32 = 117;
pub const PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 144;
pub const PKCS7_R_CIPHER_NOT_INITIALIZED: u32 = 116;
pub const PKCS7_R_CONTENT_AND_DATA_PRESENT: u32 = 118;
pub const PKCS7_R_CTRL_ERROR: u32 = 152;
pub const PKCS7_R_DECRYPT_ERROR: u32 = 119;
pub const PKCS7_R_DIGEST_FAILURE: u32 = 101;
pub const PKCS7_R_ENCRYPTION_CTRL_FAILURE: u32 = 149;
pub const PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE: u32 = 150;
pub const PKCS7_R_ERROR_ADDING_RECIPIENT: u32 = 120;
pub const PKCS7_R_ERROR_SETTING_CIPHER: u32 = 121;
pub const PKCS7_R_INVALID_NULL_POINTER: u32 = 143;
pub const PKCS7_R_INVALID_SIGNED_DATA_TYPE: u32 = 155;
pub const PKCS7_R_NO_CONTENT: u32 = 122;
pub const PKCS7_R_NO_DEFAULT_DIGEST: u32 = 151;
pub const PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND: u32 = 154;
pub const PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE: u32 = 115;
pub const PKCS7_R_NO_SIGNATURES_ON_DATA: u32 = 123;
pub const PKCS7_R_NO_SIGNERS: u32 = 142;
pub const PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE: u32 = 104;
pub const PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR: u32 = 124;
pub const PKCS7_R_PKCS7_ADD_SIGNER_ERROR: u32 = 153;
pub const PKCS7_R_PKCS7_DATASIGN: u32 = 145;
pub const PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE: u32 = 127;
pub const PKCS7_R_SIGNATURE_FAILURE: u32 = 105;
pub const PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND: u32 = 128;
pub const PKCS7_R_SIGNING_CTRL_FAILURE: u32 = 147;
pub const PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE: u32 = 148;
pub const PKCS7_R_SMIME_TEXT_ERROR: u32 = 129;
pub const PKCS7_R_UNABLE_TO_FIND_CERTIFICATE: u32 = 106;
pub const PKCS7_R_UNABLE_TO_FIND_MEM_BIO: u32 = 107;
pub const PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST: u32 = 108;
pub const PKCS7_R_UNKNOWN_DIGEST_TYPE: u32 = 109;
pub const PKCS7_R_UNKNOWN_OPERATION: u32 = 110;
pub const PKCS7_R_UNSUPPORTED_CIPHER_TYPE: u32 = 111;
pub const PKCS7_R_UNSUPPORTED_CONTENT_TYPE: u32 = 112;
pub const PKCS7_R_WRONG_CONTENT_TYPE: u32 = 113;
pub const PKCS7_R_WRONG_PKCS7_TYPE: u32 = 114;
pub const PKCS7_S_HEADER: u32 = 0;
pub const PKCS7_S_BODY: u32 = 1;
pub const PKCS7_S_TAIL: u32 = 2;
pub const PKCS7_OP_SET_DETACHED_SIGNATURE: u32 = 1;
pub const PKCS7_OP_GET_DETACHED_SIGNATURE: u32 = 2;
pub const PKCS7_TEXT: u32 = 1;
pub const PKCS7_NOCERTS: u32 = 2;
pub const PKCS7_NOSIGS: u32 = 4;
pub const PKCS7_NOCHAIN: u32 = 8;
pub const PKCS7_NOINTERN: u32 = 16;
pub const PKCS7_NOVERIFY: u32 = 32;
pub const PKCS7_DETACHED: u32 = 64;
pub const PKCS7_BINARY: u32 = 128;
pub const PKCS7_NOATTR: u32 = 256;
pub const PKCS7_NOSMIMECAP: u32 = 512;
pub const PKCS7_NOOLDMIMETYPE: u32 = 1024;
pub const PKCS7_CRLFEOL: u32 = 2048;
pub const PKCS7_STREAM: u32 = 4096;
pub const PKCS7_NOCRL: u32 = 8192;
pub const PKCS7_PARTIAL: u32 = 16384;
pub const PKCS7_REUSE_DIGEST: u32 = 32768;
pub const PKCS7_NO_DUAL_CONTENT: u32 = 65536;
pub const SMIME_TEXT: u32 = 1;
pub const SMIME_NOCERTS: u32 = 2;
pub const SMIME_NOSIGS: u32 = 4;
pub const SMIME_NOCHAIN: u32 = 8;
pub const SMIME_NOINTERN: u32 = 16;
pub const SMIME_NOVERIFY: u32 = 32;
pub const SMIME_DETACHED: u32 = 64;
pub const SMIME_BINARY: u32 = 128;
pub const SMIME_NOATTR: u32 = 256;
pub const SMIME_ASCIICRLF: u32 = 524288;
pub const X509_EXT_PACK_UNKNOWN: u32 = 1;
pub const X509_EXT_PACK_STRING: u32 = 2;
pub const CONF_R_ERROR_LOADING_DSO: u32 = 110;
pub const CONF_R_INVALID_PRAGMA: u32 = 122;
pub const CONF_R_LIST_CANNOT_BE_NULL: u32 = 115;
pub const CONF_R_MANDATORY_BRACES_IN_VARIABLE_EXPANSION: u32 = 123;
pub const CONF_R_MISSING_CLOSE_SQUARE_BRACKET: u32 = 100;
pub const CONF_R_MISSING_EQUAL_SIGN: u32 = 101;
pub const CONF_R_MISSING_INIT_FUNCTION: u32 = 112;
pub const CONF_R_MODULE_INITIALIZATION_ERROR: u32 = 109;
pub const CONF_R_NO_CLOSE_BRACE: u32 = 102;
pub const CONF_R_NO_CONF: u32 = 105;
pub const CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE: u32 = 106;
pub const CONF_R_NO_SECTION: u32 = 107;
pub const CONF_R_NO_SUCH_FILE: u32 = 114;
pub const CONF_R_NO_VALUE: u32 = 108;
pub const CONF_R_NUMBER_TOO_LARGE: u32 = 121;
pub const CONF_R_OPENSSL_CONF_REFERENCES_MISSING_SECTION: u32 = 124;
pub const CONF_R_RECURSIVE_DIRECTORY_INCLUDE: u32 = 111;
pub const CONF_R_RECURSIVE_SECTION_REFERENCE: u32 = 126;
pub const CONF_R_RELATIVE_PATH: u32 = 125;
pub const CONF_R_SSL_COMMAND_SECTION_EMPTY: u32 = 117;
pub const CONF_R_SSL_COMMAND_SECTION_NOT_FOUND: u32 = 118;
pub const CONF_R_SSL_SECTION_EMPTY: u32 = 119;
pub const CONF_R_SSL_SECTION_NOT_FOUND: u32 = 120;
pub const CONF_R_UNABLE_TO_CREATE_NEW_SECTION: u32 = 103;
pub const CONF_R_UNKNOWN_MODULE_NAME: u32 = 113;
pub const CONF_R_VARIABLE_EXPANSION_TOO_LONG: u32 = 116;
pub const CONF_R_VARIABLE_HAS_NO_VALUE: u32 = 104;
pub const CONF_MFLAGS_IGNORE_ERRORS: u32 = 1;
pub const CONF_MFLAGS_IGNORE_RETURN_CODES: u32 = 2;
pub const CONF_MFLAGS_SILENT: u32 = 4;
pub const CONF_MFLAGS_NO_DSO: u32 = 8;
pub const CONF_MFLAGS_IGNORE_MISSING_FILE: u32 = 16;
pub const CONF_MFLAGS_DEFAULT_SECTION: u32 = 32;
pub const OSSL_HTTP_NAME: &[u8; 5] = b"http\0";
pub const OSSL_HTTPS_NAME: &[u8; 6] = b"https\0";
pub const OSSL_HTTP_PREFIX: &[u8; 8] = b"http://\0";
pub const OSSL_HTTPS_PREFIX: &[u8; 9] = b"https://\0";
pub const OSSL_HTTP_PORT: &[u8; 3] = b"80\0";
pub const OSSL_HTTPS_PORT: &[u8; 4] = b"443\0";
pub const OPENSSL_NO_PROXY: &[u8; 9] = b"NO_PROXY\0";
pub const OPENSSL_HTTP_PROXY: &[u8; 11] = b"HTTP_PROXY\0";
pub const OPENSSL_HTTPS_PROXY: &[u8; 12] = b"HTTPS_PROXY\0";
pub const OSSL_HTTP_DEFAULT_MAX_LINE_LEN: u32 = 4096;
pub const OSSL_HTTP_DEFAULT_MAX_RESP_LEN: u32 = 102400;
pub const X509_VERSION_1: u32 = 0;
pub const X509_VERSION_2: u32 = 1;
pub const X509_VERSION_3: u32 = 2;
pub const X509_REQ_VERSION_1: u32 = 0;
pub const X509_CRL_VERSION_1: u32 = 0;
pub const X509_CRL_VERSION_2: u32 = 1;
pub const X509_ADD_FLAG_DEFAULT: u32 = 0;
pub const X509_ADD_FLAG_UP_REF: u32 = 1;
pub const X509_ADD_FLAG_PREPEND: u32 = 2;
pub const X509_ADD_FLAG_NO_DUP: u32 = 4;
pub const X509_ADD_FLAG_NO_SS: u32 = 8;
pub const PEM_R_BAD_BASE64_DECODE: u32 = 100;
pub const PEM_R_BAD_DECRYPT: u32 = 101;
pub const PEM_R_BAD_END_LINE: u32 = 102;
pub const PEM_R_BAD_IV_CHARS: u32 = 103;
pub const PEM_R_BAD_MAGIC_NUMBER: u32 = 116;
pub const PEM_R_BAD_PASSWORD_READ: u32 = 104;
pub const PEM_R_BAD_VERSION_NUMBER: u32 = 117;
pub const PEM_R_BIO_WRITE_FAILURE: u32 = 118;
pub const PEM_R_CIPHER_IS_NULL: u32 = 127;
pub const PEM_R_ERROR_CONVERTING_PRIVATE_KEY: u32 = 115;
pub const PEM_R_EXPECTING_DSS_KEY_BLOB: u32 = 131;
pub const PEM_R_EXPECTING_PRIVATE_KEY_BLOB: u32 = 119;
pub const PEM_R_EXPECTING_PUBLIC_KEY_BLOB: u32 = 120;
pub const PEM_R_EXPECTING_RSA_KEY_BLOB: u32 = 132;
pub const PEM_R_HEADER_TOO_LONG: u32 = 128;
pub const PEM_R_INCONSISTENT_HEADER: u32 = 121;
pub const PEM_R_KEYBLOB_HEADER_PARSE_ERROR: u32 = 122;
pub const PEM_R_KEYBLOB_TOO_SHORT: u32 = 123;
pub const PEM_R_MISSING_DEK_IV: u32 = 129;
pub const PEM_R_NOT_DEK_INFO: u32 = 105;
pub const PEM_R_NOT_ENCRYPTED: u32 = 106;
pub const PEM_R_NOT_PROC_TYPE: u32 = 107;
pub const PEM_R_NO_START_LINE: u32 = 108;
pub const PEM_R_PROBLEMS_GETTING_PASSWORD: u32 = 109;
pub const PEM_R_PVK_DATA_TOO_SHORT: u32 = 124;
pub const PEM_R_PVK_TOO_SHORT: u32 = 125;
pub const PEM_R_READ_KEY: u32 = 111;
pub const PEM_R_SHORT_HEADER: u32 = 112;
pub const PEM_R_UNEXPECTED_DEK_IV: u32 = 130;
pub const PEM_R_UNSUPPORTED_CIPHER: u32 = 113;
pub const PEM_R_UNSUPPORTED_ENCRYPTION: u32 = 114;
pub const PEM_R_UNSUPPORTED_KEY_COMPONENTS: u32 = 126;
pub const PEM_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 110;
pub const PEM_BUFSIZE: u32 = 1024;
pub const PEM_STRING_X509_OLD: &[u8; 17] = b"X509 CERTIFICATE\0";
pub const PEM_STRING_X509: &[u8; 12] = b"CERTIFICATE\0";
pub const PEM_STRING_X509_TRUSTED: &[u8; 20] = b"TRUSTED CERTIFICATE\0";
pub const PEM_STRING_X509_REQ_OLD: &[u8; 24] = b"NEW CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_REQ: &[u8; 20] = b"CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_CRL: &[u8; 9] = b"X509 CRL\0";
pub const PEM_STRING_EVP_PKEY: &[u8; 16] = b"ANY PRIVATE KEY\0";
pub const PEM_STRING_PUBLIC: &[u8; 11] = b"PUBLIC KEY\0";
pub const PEM_STRING_RSA: &[u8; 16] = b"RSA PRIVATE KEY\0";
pub const PEM_STRING_RSA_PUBLIC: &[u8; 15] = b"RSA PUBLIC KEY\0";
pub const PEM_STRING_DSA: &[u8; 16] = b"DSA PRIVATE KEY\0";
pub const PEM_STRING_DSA_PUBLIC: &[u8; 15] = b"DSA PUBLIC KEY\0";
pub const PEM_STRING_PKCS7: &[u8; 6] = b"PKCS7\0";
pub const PEM_STRING_PKCS7_SIGNED: &[u8; 20] = b"PKCS #7 SIGNED DATA\0";
pub const PEM_STRING_PKCS8: &[u8; 22] = b"ENCRYPTED PRIVATE KEY\0";
pub const PEM_STRING_PKCS8INF: &[u8; 12] = b"PRIVATE KEY\0";
pub const PEM_STRING_DHPARAMS: &[u8; 14] = b"DH PARAMETERS\0";
pub const PEM_STRING_DHXPARAMS: &[u8; 20] = b"X9.42 DH PARAMETERS\0";
pub const PEM_STRING_SSL_SESSION: &[u8; 23] = b"SSL SESSION PARAMETERS\0";
pub const PEM_STRING_DSAPARAMS: &[u8; 15] = b"DSA PARAMETERS\0";
pub const PEM_STRING_ECDSA_PUBLIC: &[u8; 17] = b"ECDSA PUBLIC KEY\0";
pub const PEM_STRING_ECPARAMETERS: &[u8; 14] = b"EC PARAMETERS\0";
pub const PEM_STRING_ECPRIVATEKEY: &[u8; 15] = b"EC PRIVATE KEY\0";
pub const PEM_STRING_PARAMETERS: &[u8; 11] = b"PARAMETERS\0";
pub const PEM_STRING_CMS: &[u8; 4] = b"CMS\0";
pub const PEM_TYPE_ENCRYPTED: u32 = 10;
pub const PEM_TYPE_MIC_ONLY: u32 = 20;
pub const PEM_TYPE_MIC_CLEAR: u32 = 30;
pub const PEM_TYPE_CLEAR: u32 = 40;
pub const PEM_FLAG_SECURE: u32 = 1;
pub const PEM_FLAG_EAY_COMPATIBLE: u32 = 2;
pub const PEM_FLAG_ONLY_B64: u32 = 4;
pub const HMAC_MAX_MD_CBLOCK: u32 = 200;
pub const OSSL_BAD_ASYNC_FD: i32 = -1;
pub const ASYNC_R_FAILED_TO_SET_POOL: u32 = 101;
pub const ASYNC_R_FAILED_TO_SWAP_CONTEXT: u32 = 102;
pub const ASYNC_R_INIT_FAILED: u32 = 105;
pub const ASYNC_R_INVALID_POOL_SIZE: u32 = 103;
pub const ASYNC_ERR: u32 = 0;
pub const ASYNC_NO_JOBS: u32 = 1;
pub const ASYNC_PAUSE: u32 = 2;
pub const ASYNC_FINISH: u32 = 3;
pub const ASYNC_STATUS_UNSUPPORTED: u32 = 0;
pub const ASYNC_STATUS_ERR: u32 = 1;
pub const ASYNC_STATUS_OK: u32 = 2;
pub const ASYNC_STATUS_EAGAIN: u32 = 3;
pub const CT_R_BASE64_DECODE_ERROR: u32 = 108;
pub const CT_R_INVALID_LOG_ID_LENGTH: u32 = 100;
pub const CT_R_LOG_CONF_INVALID: u32 = 109;
pub const CT_R_LOG_CONF_INVALID_KEY: u32 = 110;
pub const CT_R_LOG_CONF_MISSING_DESCRIPTION: u32 = 111;
pub const CT_R_LOG_CONF_MISSING_KEY: u32 = 112;
pub const CT_R_LOG_KEY_INVALID: u32 = 113;
pub const CT_R_SCT_FUTURE_TIMESTAMP: u32 = 116;
pub const CT_R_SCT_INVALID: u32 = 104;
pub const CT_R_SCT_INVALID_SIGNATURE: u32 = 107;
pub const CT_R_SCT_LIST_INVALID: u32 = 105;
pub const CT_R_SCT_LOG_ID_MISMATCH: u32 = 114;
pub const CT_R_SCT_NOT_SET: u32 = 106;
pub const CT_R_SCT_UNSUPPORTED_VERSION: u32 = 115;
pub const CT_R_UNRECOGNIZED_SIGNATURE_NID: u32 = 101;
pub const CT_R_UNSUPPORTED_ENTRY_TYPE: u32 = 102;
pub const CT_R_UNSUPPORTED_VERSION: u32 = 103;
pub const SCT_MIN_RSA_BITS: u32 = 2048;
pub const CT_V1_HASHLEN: u32 = 32;
pub const SSL_F_ADD_CLIENT_KEY_SHARE_EXT: u32 = 0;
pub const SSL_F_ADD_KEY_SHARE: u32 = 0;
pub const SSL_F_BYTES_TO_CIPHER_LIST: u32 = 0;
pub const SSL_F_CHECK_SUITEB_CIPHER_LIST: u32 = 0;
pub const SSL_F_CIPHERSUITE_CB: u32 = 0;
pub const SSL_F_CONSTRUCT_CA_NAMES: u32 = 0;
pub const SSL_F_CONSTRUCT_KEY_EXCHANGE_TBS: u32 = 0;
pub const SSL_F_CONSTRUCT_STATEFUL_TICKET: u32 = 0;
pub const SSL_F_CONSTRUCT_STATELESS_TICKET: u32 = 0;
pub const SSL_F_CREATE_SYNTHETIC_MESSAGE_HASH: u32 = 0;
pub const SSL_F_CREATE_TICKET_PREQUEL: u32 = 0;
pub const SSL_F_CT_MOVE_SCTS: u32 = 0;
pub const SSL_F_CT_STRICT: u32 = 0;
pub const SSL_F_CUSTOM_EXT_ADD: u32 = 0;
pub const SSL_F_CUSTOM_EXT_PARSE: u32 = 0;
pub const SSL_F_D2I_SSL_SESSION: u32 = 0;
pub const SSL_F_DANE_CTX_ENABLE: u32 = 0;
pub const SSL_F_DANE_MTYPE_SET: u32 = 0;
pub const SSL_F_DANE_TLSA_ADD: u32 = 0;
pub const SSL_F_DERIVE_SECRET_KEY_AND_IV: u32 = 0;
pub const SSL_F_DO_DTLS1_WRITE: u32 = 0;
pub const SSL_F_DO_SSL3_WRITE: u32 = 0;
pub const SSL_F_DTLS1_BUFFER_RECORD: u32 = 0;
pub const SSL_F_DTLS1_CHECK_TIMEOUT_NUM: u32 = 0;
pub const SSL_F_DTLS1_HEARTBEAT: u32 = 0;
pub const SSL_F_DTLS1_HM_FRAGMENT_NEW: u32 = 0;
pub const SSL_F_DTLS1_PREPROCESS_FRAGMENT: u32 = 0;
pub const SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS: u32 = 0;
pub const SSL_F_DTLS1_PROCESS_RECORD: u32 = 0;
pub const SSL_F_DTLS1_READ_BYTES: u32 = 0;
pub const SSL_F_DTLS1_READ_FAILED: u32 = 0;
pub const SSL_F_DTLS1_RETRANSMIT_MESSAGE: u32 = 0;
pub const SSL_F_DTLS1_WRITE_APP_DATA_BYTES: u32 = 0;
pub const SSL_F_DTLS1_WRITE_BYTES: u32 = 0;
pub const SSL_F_DTLSV1_LISTEN: u32 = 0;
pub const SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC: u32 = 0;
pub const SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST: u32 = 0;
pub const SSL_F_DTLS_GET_REASSEMBLED_MESSAGE: u32 = 0;
pub const SSL_F_DTLS_PROCESS_HELLO_VERIFY: u32 = 0;
pub const SSL_F_DTLS_RECORD_LAYER_NEW: u32 = 0;
pub const SSL_F_DTLS_WAIT_FOR_DRY: u32 = 0;
pub const SSL_F_EARLY_DATA_COUNT_OK: u32 = 0;
pub const SSL_F_FINAL_EARLY_DATA: u32 = 0;
pub const SSL_F_FINAL_EC_PT_FORMATS: u32 = 0;
pub const SSL_F_FINAL_EMS: u32 = 0;
pub const SSL_F_FINAL_KEY_SHARE: u32 = 0;
pub const SSL_F_FINAL_MAXFRAGMENTLEN: u32 = 0;
pub const SSL_F_FINAL_RENEGOTIATE: u32 = 0;
pub const SSL_F_FINAL_SERVER_NAME: u32 = 0;
pub const SSL_F_FINAL_SIG_ALGS: u32 = 0;
pub const SSL_F_GET_CERT_VERIFY_TBS_DATA: u32 = 0;
pub const SSL_F_NSS_KEYLOG_INT: u32 = 0;
pub const SSL_F_OPENSSL_INIT_SSL: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT13_READ_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT13_WRITE_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT_CONSTRUCT_MESSAGE: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT_POST_PROCESS_MESSAGE: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT_PROCESS_MESSAGE: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_CLIENT_WRITE_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER13_READ_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER13_WRITE_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_CONSTRUCT_MESSAGE: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_POST_PROCESS_MESSAGE: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_POST_WORK: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_PRE_WORK: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_PROCESS_MESSAGE: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_READ_TRANSITION: u32 = 0;
pub const SSL_F_OSSL_STATEM_SERVER_WRITE_TRANSITION: u32 = 0;
pub const SSL_F_PARSE_CA_NAMES: u32 = 0;
pub const SSL_F_PITEM_NEW: u32 = 0;
pub const SSL_F_PQUEUE_NEW: u32 = 0;
pub const SSL_F_PROCESS_KEY_SHARE_EXT: u32 = 0;
pub const SSL_F_READ_STATE_MACHINE: u32 = 0;
pub const SSL_F_SET_CLIENT_CIPHERSUITE: u32 = 0;
pub const SSL_F_SRP_GENERATE_CLIENT_MASTER_SECRET: u32 = 0;
pub const SSL_F_SRP_GENERATE_SERVER_MASTER_SECRET: u32 = 0;
pub const SSL_F_SRP_VERIFY_SERVER_PARAM: u32 = 0;
pub const SSL_F_SSL3_CHANGE_CIPHER_STATE: u32 = 0;
pub const SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM: u32 = 0;
pub const SSL_F_SSL3_CTRL: u32 = 0;
pub const SSL_F_SSL3_CTX_CTRL: u32 = 0;
pub const SSL_F_SSL3_DIGEST_CACHED_RECORDS: u32 = 0;
pub const SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC: u32 = 0;
pub const SSL_F_SSL3_ENC: u32 = 0;
pub const SSL_F_SSL3_FINAL_FINISH_MAC: u32 = 0;
pub const SSL_F_SSL3_FINISH_MAC: u32 = 0;
pub const SSL_F_SSL3_GENERATE_KEY_BLOCK: u32 = 0;
pub const SSL_F_SSL3_GENERATE_MASTER_SECRET: u32 = 0;
pub const SSL_F_SSL3_GET_RECORD: u32 = 0;
pub const SSL_F_SSL3_INIT_FINISHED_MAC: u32 = 0;
pub const SSL_F_SSL3_OUTPUT_CERT_CHAIN: u32 = 0;
pub const SSL_F_SSL3_READ_BYTES: u32 = 0;
pub const SSL_F_SSL3_READ_N: u32 = 0;
pub const SSL_F_SSL3_SETUP_KEY_BLOCK: u32 = 0;
pub const SSL_F_SSL3_SETUP_READ_BUFFER: u32 = 0;
pub const SSL_F_SSL3_SETUP_WRITE_BUFFER: u32 = 0;
pub const SSL_F_SSL3_WRITE_BYTES: u32 = 0;
pub const SSL_F_SSL3_WRITE_PENDING: u32 = 0;
pub const SSL_F_SSL_ADD_CERT_CHAIN: u32 = 0;
pub const SSL_F_SSL_ADD_CERT_TO_BUF: u32 = 0;
pub const SSL_F_SSL_ADD_CERT_TO_WPACKET: u32 = 0;
pub const SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT: u32 = 0;
pub const SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT: u32 = 0;
pub const SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK: u32 = 0;
pub const SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK: u32 = 0;
pub const SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT: u32 = 0;
pub const SSL_F_SSL_ADD_SERVERHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT: u32 = 0;
pub const SSL_F_SSL_BAD_METHOD: u32 = 0;
pub const SSL_F_SSL_BUILD_CERT_CHAIN: u32 = 0;
pub const SSL_F_SSL_BYTES_TO_CIPHER_LIST: u32 = 0;
pub const SSL_F_SSL_CACHE_CIPHERLIST: u32 = 0;
pub const SSL_F_SSL_CERT_ADD0_CHAIN_CERT: u32 = 0;
pub const SSL_F_SSL_CERT_DUP: u32 = 0;
pub const SSL_F_SSL_CERT_NEW: u32 = 0;
pub const SSL_F_SSL_CERT_SET0_CHAIN: u32 = 0;
pub const SSL_F_SSL_CHECK_PRIVATE_KEY: u32 = 0;
pub const SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_CHECK_SRP_EXT_CLIENTHELLO: u32 = 0;
pub const SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG: u32 = 0;
pub const SSL_F_SSL_CHOOSE_CLIENT_VERSION: u32 = 0;
pub const SSL_F_SSL_CIPHER_DESCRIPTION: u32 = 0;
pub const SSL_F_SSL_CIPHER_LIST_TO_BYTES: u32 = 0;
pub const SSL_F_SSL_CIPHER_PROCESS_RULESTR: u32 = 0;
pub const SSL_F_SSL_CIPHER_STRENGTH_SORT: u32 = 0;
pub const SSL_F_SSL_CLEAR: u32 = 0;
pub const SSL_F_SSL_CLIENT_HELLO_GET1_EXTENSIONS_PRESENT: u32 = 0;
pub const SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD: u32 = 0;
pub const SSL_F_SSL_CONF_CMD: u32 = 0;
pub const SSL_F_SSL_CREATE_CIPHER_LIST: u32 = 0;
pub const SSL_F_SSL_CTRL: u32 = 0;
pub const SSL_F_SSL_CTX_CHECK_PRIVATE_KEY: u32 = 0;
pub const SSL_F_SSL_CTX_ENABLE_CT: u32 = 0;
pub const SSL_F_SSL_CTX_MAKE_PROFILES: u32 = 0;
pub const SSL_F_SSL_CTX_NEW: u32 = 0;
pub const SSL_F_SSL_CTX_SET_ALPN_PROTOS: u32 = 0;
pub const SSL_F_SSL_CTX_SET_CIPHER_LIST: u32 = 0;
pub const SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE: u32 = 0;
pub const SSL_F_SSL_CTX_SET_CT_VALIDATION_CALLBACK: u32 = 0;
pub const SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT: u32 = 0;
pub const SSL_F_SSL_CTX_SET_SSL_VERSION: u32 = 0;
pub const SSL_F_SSL_CTX_SET_TLSEXT_MAX_FRAGMENT_LENGTH: u32 = 0;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE: u32 = 0;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1: u32 = 0;
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_FILE: u32 = 0;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY: u32 = 0;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1: u32 = 0;
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE: u32 = 0;
pub const SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT: u32 = 0;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY: u32 = 0;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1: u32 = 0;
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE: u32 = 0;
pub const SSL_F_SSL_CTX_USE_SERVERINFO: u32 = 0;
pub const SSL_F_SSL_CTX_USE_SERVERINFO_EX: u32 = 0;
pub const SSL_F_SSL_CTX_USE_SERVERINFO_FILE: u32 = 0;
pub const SSL_F_SSL_DANE_DUP: u32 = 0;
pub const SSL_F_SSL_DANE_ENABLE: u32 = 0;
pub const SSL_F_SSL_DERIVE: u32 = 0;
pub const SSL_F_SSL_DO_CONFIG: u32 = 0;
pub const SSL_F_SSL_DO_HANDSHAKE: u32 = 0;
pub const SSL_F_SSL_DUP_CA_LIST: u32 = 0;
pub const SSL_F_SSL_ENABLE_CT: u32 = 0;
pub const SSL_F_SSL_GENERATE_PKEY_GROUP: u32 = 0;
pub const SSL_F_SSL_GENERATE_SESSION_ID: u32 = 0;
pub const SSL_F_SSL_GET_NEW_SESSION: u32 = 0;
pub const SSL_F_SSL_GET_PREV_SESSION: u32 = 0;
pub const SSL_F_SSL_GET_SERVER_CERT_INDEX: u32 = 0;
pub const SSL_F_SSL_GET_SIGN_PKEY: u32 = 0;
pub const SSL_F_SSL_HANDSHAKE_HASH: u32 = 0;
pub const SSL_F_SSL_INIT_WBIO_BUFFER: u32 = 0;
pub const SSL_F_SSL_KEY_UPDATE: u32 = 0;
pub const SSL_F_SSL_LOAD_CLIENT_CA_FILE: u32 = 0;
pub const SSL_F_SSL_LOG_MASTER_SECRET: u32 = 0;
pub const SSL_F_SSL_LOG_RSA_CLIENT_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_SSL_MODULE_INIT: u32 = 0;
pub const SSL_F_SSL_NEW: u32 = 0;
pub const SSL_F_SSL_NEXT_PROTO_VALIDATE: u32 = 0;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT: u32 = 0;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT: u32 = 0;
pub const SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT: u32 = 0;
pub const SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT: u32 = 0;
pub const SSL_F_SSL_PEEK: u32 = 0;
pub const SSL_F_SSL_PEEK_EX: u32 = 0;
pub const SSL_F_SSL_PEEK_INTERNAL: u32 = 0;
pub const SSL_F_SSL_READ: u32 = 0;
pub const SSL_F_SSL_READ_EARLY_DATA: u32 = 0;
pub const SSL_F_SSL_READ_EX: u32 = 0;
pub const SSL_F_SSL_READ_INTERNAL: u32 = 0;
pub const SSL_F_SSL_RENEGOTIATE: u32 = 0;
pub const SSL_F_SSL_RENEGOTIATE_ABBREVIATED: u32 = 0;
pub const SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT: u32 = 0;
pub const SSL_F_SSL_SESSION_DUP: u32 = 0;
pub const SSL_F_SSL_SESSION_NEW: u32 = 0;
pub const SSL_F_SSL_SESSION_PRINT_FP: u32 = 0;
pub const SSL_F_SSL_SESSION_SET1_ID: u32 = 0;
pub const SSL_F_SSL_SESSION_SET1_ID_CONTEXT: u32 = 0;
pub const SSL_F_SSL_SET_ALPN_PROTOS: u32 = 0;
pub const SSL_F_SSL_SET_CERT: u32 = 0;
pub const SSL_F_SSL_SET_CERT_AND_KEY: u32 = 0;
pub const SSL_F_SSL_SET_CIPHER_LIST: u32 = 0;
pub const SSL_F_SSL_SET_CT_VALIDATION_CALLBACK: u32 = 0;
pub const SSL_F_SSL_SET_FD: u32 = 0;
pub const SSL_F_SSL_SET_PKEY: u32 = 0;
pub const SSL_F_SSL_SET_RFD: u32 = 0;
pub const SSL_F_SSL_SET_SESSION: u32 = 0;
pub const SSL_F_SSL_SET_SESSION_ID_CONTEXT: u32 = 0;
pub const SSL_F_SSL_SET_SESSION_TICKET_EXT: u32 = 0;
pub const SSL_F_SSL_SET_TLSEXT_MAX_FRAGMENT_LENGTH: u32 = 0;
pub const SSL_F_SSL_SET_WFD: u32 = 0;
pub const SSL_F_SSL_SHUTDOWN: u32 = 0;
pub const SSL_F_SSL_SRP_CTX_INIT: u32 = 0;
pub const SSL_F_SSL_START_ASYNC_JOB: u32 = 0;
pub const SSL_F_SSL_UNDEFINED_FUNCTION: u32 = 0;
pub const SSL_F_SSL_UNDEFINED_VOID_FUNCTION: u32 = 0;
pub const SSL_F_SSL_USE_CERTIFICATE: u32 = 0;
pub const SSL_F_SSL_USE_CERTIFICATE_ASN1: u32 = 0;
pub const SSL_F_SSL_USE_CERTIFICATE_FILE: u32 = 0;
pub const SSL_F_SSL_USE_PRIVATEKEY: u32 = 0;
pub const SSL_F_SSL_USE_PRIVATEKEY_ASN1: u32 = 0;
pub const SSL_F_SSL_USE_PRIVATEKEY_FILE: u32 = 0;
pub const SSL_F_SSL_USE_PSK_IDENTITY_HINT: u32 = 0;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY: u32 = 0;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1: u32 = 0;
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_FILE: u32 = 0;
pub const SSL_F_SSL_VALIDATE_CT: u32 = 0;
pub const SSL_F_SSL_VERIFY_CERT_CHAIN: u32 = 0;
pub const SSL_F_SSL_VERIFY_CLIENT_POST_HANDSHAKE: u32 = 0;
pub const SSL_F_SSL_WRITE: u32 = 0;
pub const SSL_F_SSL_WRITE_EARLY_DATA: u32 = 0;
pub const SSL_F_SSL_WRITE_EARLY_FINISH: u32 = 0;
pub const SSL_F_SSL_WRITE_EX: u32 = 0;
pub const SSL_F_SSL_WRITE_INTERNAL: u32 = 0;
pub const SSL_F_STATE_MACHINE: u32 = 0;
pub const SSL_F_TLS12_CHECK_PEER_SIGALG: u32 = 0;
pub const SSL_F_TLS12_COPY_SIGALGS: u32 = 0;
pub const SSL_F_TLS13_CHANGE_CIPHER_STATE: u32 = 0;
pub const SSL_F_TLS13_ENC: u32 = 0;
pub const SSL_F_TLS13_FINAL_FINISH_MAC: u32 = 0;
pub const SSL_F_TLS13_GENERATE_SECRET: u32 = 0;
pub const SSL_F_TLS13_HKDF_EXPAND: u32 = 0;
pub const SSL_F_TLS13_RESTORE_HANDSHAKE_DIGEST_FOR_PHA: u32 = 0;
pub const SSL_F_TLS13_SAVE_HANDSHAKE_DIGEST_FOR_PHA: u32 = 0;
pub const SSL_F_TLS13_SETUP_KEY_BLOCK: u32 = 0;
pub const SSL_F_TLS1_CHANGE_CIPHER_STATE: u32 = 0;
pub const SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS: u32 = 0;
pub const SSL_F_TLS1_ENC: u32 = 0;
pub const SSL_F_TLS1_EXPORT_KEYING_MATERIAL: u32 = 0;
pub const SSL_F_TLS1_GET_CURVELIST: u32 = 0;
pub const SSL_F_TLS1_PRF: u32 = 0;
pub const SSL_F_TLS1_SAVE_U16: u32 = 0;
pub const SSL_F_TLS1_SETUP_KEY_BLOCK: u32 = 0;
pub const SSL_F_TLS1_SET_GROUPS: u32 = 0;
pub const SSL_F_TLS1_SET_RAW_SIGALGS: u32 = 0;
pub const SSL_F_TLS1_SET_SERVER_SIGALGS: u32 = 0;
pub const SSL_F_TLS1_SET_SHARED_SIGALGS: u32 = 0;
pub const SSL_F_TLS1_SET_SIGALGS: u32 = 0;
pub const SSL_F_TLS_CHOOSE_SIGALG: u32 = 0;
pub const SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK: u32 = 0;
pub const SSL_F_TLS_COLLECT_EXTENSIONS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_AUTHORITIES: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_REQUEST: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS_BODY: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CERT_VERIFY: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CHANGE_CIPHER_SPEC: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CKE_DHE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CKE_ECDHE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CKE_GOST: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CKE_RSA: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CKE_SRP: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_HELLO: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_ALPN: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_COOKIE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_EARLY_DATA: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_EC_PT_FORMATS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_EMS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_ETM: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_HELLO: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_SHARE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_MAXFRAGMENTLEN: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_NPN: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_PADDING: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_POST_HANDSHAKE_AUTH: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK_KEX_MODES: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_RENEGOTIATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SCT: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SERVER_NAME: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SESSION_TICKET: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SIG_ALGS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SRP: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_STATUS_REQUEST: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_GROUPS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_VERSIONS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_USE_SRTP: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_CTOS_VERIFY: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_ENCRYPTED_EXTENSIONS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_END_OF_EARLY_DATA: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_EXTENSIONS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_FINISHED: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_HELLO_REQUEST: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_HELLO_RETRY_REQUEST: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_KEY_UPDATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_NEXT_PROTO: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_SERVER_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_SERVER_HELLO: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_ALPN: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_COOKIE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_CRYPTOPRO_BUG: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_DONE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA_INFO: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_EC_PT_FORMATS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_EMS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_ETM: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_HELLO: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_SHARE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_MAXFRAGMENTLEN: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_NEXT_PROTO_NEG: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_PSK: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_SERVER_NAME: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_SESSION_TICKET: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_STATUS_REQUEST: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_GROUPS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_VERSIONS: u32 = 0;
pub const SSL_F_TLS_CONSTRUCT_STOC_USE_SRTP: u32 = 0;
pub const SSL_F_TLS_EARLY_POST_PROCESS_CLIENT_HELLO: u32 = 0;
pub const SSL_F_TLS_FINISH_HANDSHAKE: u32 = 0;
pub const SSL_F_TLS_GET_MESSAGE_BODY: u32 = 0;
pub const SSL_F_TLS_GET_MESSAGE_HEADER: u32 = 0;
pub const SSL_F_TLS_HANDLE_ALPN: u32 = 0;
pub const SSL_F_TLS_HANDLE_STATUS_REQUEST: u32 = 0;
pub const SSL_F_TLS_PARSE_CERTIFICATE_AUTHORITIES: u32 = 0;
pub const SSL_F_TLS_PARSE_CLIENTHELLO_TLSEXT: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_ALPN: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_COOKIE: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_EARLY_DATA: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_EC_PT_FORMATS: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_EMS: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_KEY_SHARE: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_MAXFRAGMENTLEN: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_POST_HANDSHAKE_AUTH: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_PSK: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_PSK_KEX_MODES: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_RENEGOTIATE: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_SERVER_NAME: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_SESSION_TICKET: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS_CERT: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_SRP: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_STATUS_REQUEST: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_SUPPORTED_GROUPS: u32 = 0;
pub const SSL_F_TLS_PARSE_CTOS_USE_SRTP: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_ALPN: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_COOKIE: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA_INFO: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_EC_PT_FORMATS: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_KEY_SHARE: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_MAXFRAGMENTLEN: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_NPN: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_PSK: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_RENEGOTIATE: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_SCT: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_SERVER_NAME: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_SESSION_TICKET: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_STATUS_REQUEST: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_SUPPORTED_VERSIONS: u32 = 0;
pub const SSL_F_TLS_PARSE_STOC_USE_SRTP: u32 = 0;
pub const SSL_F_TLS_POST_PROCESS_CLIENT_HELLO: u32 = 0;
pub const SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_PROCESS_AS_HELLO_RETRY_REQUEST: u32 = 0;
pub const SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST: u32 = 0;
pub const SSL_F_TLS_PROCESS_CERT_STATUS: u32 = 0;
pub const SSL_F_TLS_PROCESS_CERT_STATUS_BODY: u32 = 0;
pub const SSL_F_TLS_PROCESS_CERT_VERIFY: u32 = 0;
pub const SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC: u32 = 0;
pub const SSL_F_TLS_PROCESS_CKE_DHE: u32 = 0;
pub const SSL_F_TLS_PROCESS_CKE_ECDHE: u32 = 0;
pub const SSL_F_TLS_PROCESS_CKE_GOST: u32 = 0;
pub const SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE: u32 = 0;
pub const SSL_F_TLS_PROCESS_CKE_RSA: u32 = 0;
pub const SSL_F_TLS_PROCESS_CKE_SRP: u32 = 0;
pub const SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_PROCESS_CLIENT_HELLO: u32 = 0;
pub const SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_PROCESS_ENCRYPTED_EXTENSIONS: u32 = 0;
pub const SSL_F_TLS_PROCESS_END_OF_EARLY_DATA: u32 = 0;
pub const SSL_F_TLS_PROCESS_FINISHED: u32 = 0;
pub const SSL_F_TLS_PROCESS_HELLO_REQ: u32 = 0;
pub const SSL_F_TLS_PROCESS_HELLO_RETRY_REQUEST: u32 = 0;
pub const SSL_F_TLS_PROCESS_INITIAL_SERVER_FLIGHT: u32 = 0;
pub const SSL_F_TLS_PROCESS_KEY_EXCHANGE: u32 = 0;
pub const SSL_F_TLS_PROCESS_KEY_UPDATE: u32 = 0;
pub const SSL_F_TLS_PROCESS_NEW_SESSION_TICKET: u32 = 0;
pub const SSL_F_TLS_PROCESS_NEXT_PROTO: u32 = 0;
pub const SSL_F_TLS_PROCESS_SERVER_CERTIFICATE: u32 = 0;
pub const SSL_F_TLS_PROCESS_SERVER_DONE: u32 = 0;
pub const SSL_F_TLS_PROCESS_SERVER_HELLO: u32 = 0;
pub const SSL_F_TLS_PROCESS_SKE_DHE: u32 = 0;
pub const SSL_F_TLS_PROCESS_SKE_ECDHE: u32 = 0;
pub const SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE: u32 = 0;
pub const SSL_F_TLS_PROCESS_SKE_SRP: u32 = 0;
pub const SSL_F_TLS_PSK_DO_BINDER: u32 = 0;
pub const SSL_F_TLS_SCAN_CLIENTHELLO_TLSEXT: u32 = 0;
pub const SSL_F_TLS_SETUP_HANDSHAKE: u32 = 0;
pub const SSL_F_USE_CERTIFICATE_CHAIN_FILE: u32 = 0;
pub const SSL_F_WPACKET_INTERN_INIT_LEN: u32 = 0;
pub const SSL_F_WPACKET_START_SUB_PACKET_LEN__: u32 = 0;
pub const SSL_F_WRITE_STATE_MACHINE: u32 = 0;
pub const SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY: u32 = 291;
pub const SSL_R_APP_DATA_IN_HANDSHAKE: u32 = 100;
pub const SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT: u32 = 272;
pub const SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE: u32 = 158;
pub const SSL_R_BAD_CHANGE_CIPHER_SPEC: u32 = 103;
pub const SSL_R_BAD_CIPHER: u32 = 186;
pub const SSL_R_BAD_DATA: u32 = 390;
pub const SSL_R_BAD_DATA_RETURNED_BY_CALLBACK: u32 = 106;
pub const SSL_R_BAD_DECOMPRESSION: u32 = 107;
pub const SSL_R_BAD_DH_VALUE: u32 = 102;
pub const SSL_R_BAD_DIGEST_LENGTH: u32 = 111;
pub const SSL_R_BAD_EARLY_DATA: u32 = 233;
pub const SSL_R_BAD_ECC_CERT: u32 = 304;
pub const SSL_R_BAD_ECPOINT: u32 = 306;
pub const SSL_R_BAD_EXTENSION: u32 = 110;
pub const SSL_R_BAD_HANDSHAKE_LENGTH: u32 = 332;
pub const SSL_R_BAD_HANDSHAKE_STATE: u32 = 236;
pub const SSL_R_BAD_HELLO_REQUEST: u32 = 105;
pub const SSL_R_BAD_HRR_VERSION: u32 = 263;
pub const SSL_R_BAD_KEY_SHARE: u32 = 108;
pub const SSL_R_BAD_KEY_UPDATE: u32 = 122;
pub const SSL_R_BAD_LEGACY_VERSION: u32 = 292;
pub const SSL_R_BAD_LENGTH: u32 = 271;
pub const SSL_R_BAD_PACKET: u32 = 240;
pub const SSL_R_BAD_PACKET_LENGTH: u32 = 115;
pub const SSL_R_BAD_PROTOCOL_VERSION_NUMBER: u32 = 116;
pub const SSL_R_BAD_PSK: u32 = 219;
pub const SSL_R_BAD_PSK_IDENTITY: u32 = 114;
pub const SSL_R_BAD_RECORD_TYPE: u32 = 443;
pub const SSL_R_BAD_RSA_ENCRYPT: u32 = 119;
pub const SSL_R_BAD_SIGNATURE: u32 = 123;
pub const SSL_R_BAD_SRP_A_LENGTH: u32 = 347;
pub const SSL_R_BAD_SRP_PARAMETERS: u32 = 371;
pub const SSL_R_BAD_SRTP_MKI_VALUE: u32 = 352;
pub const SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST: u32 = 353;
pub const SSL_R_BAD_SSL_FILETYPE: u32 = 124;
pub const SSL_R_BAD_VALUE: u32 = 384;
pub const SSL_R_BAD_WRITE_RETRY: u32 = 127;
pub const SSL_R_BINDER_DOES_NOT_VERIFY: u32 = 253;
pub const SSL_R_BIO_NOT_SET: u32 = 128;
pub const SSL_R_BLOCK_CIPHER_PAD_IS_WRONG: u32 = 129;
pub const SSL_R_BN_LIB: u32 = 130;
pub const SSL_R_CALLBACK_FAILED: u32 = 234;
pub const SSL_R_CANNOT_CHANGE_CIPHER: u32 = 109;
pub const SSL_R_CANNOT_GET_GROUP_NAME: u32 = 299;
pub const SSL_R_CA_DN_LENGTH_MISMATCH: u32 = 131;
pub const SSL_R_CA_KEY_TOO_SMALL: u32 = 397;
pub const SSL_R_CA_MD_TOO_WEAK: u32 = 398;
pub const SSL_R_CCS_RECEIVED_EARLY: u32 = 133;
pub const SSL_R_CERTIFICATE_VERIFY_FAILED: u32 = 134;
pub const SSL_R_CERT_CB_ERROR: u32 = 377;
pub const SSL_R_CERT_LENGTH_MISMATCH: u32 = 135;
pub const SSL_R_CIPHERSUITE_DIGEST_HAS_CHANGED: u32 = 218;
pub const SSL_R_CIPHER_CODE_WRONG_LENGTH: u32 = 137;
pub const SSL_R_CLIENTHELLO_TLSEXT: u32 = 226;
pub const SSL_R_COMPRESSED_LENGTH_TOO_LONG: u32 = 140;
pub const SSL_R_COMPRESSION_DISABLED: u32 = 343;
pub const SSL_R_COMPRESSION_FAILURE: u32 = 141;
pub const SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE: u32 = 307;
pub const SSL_R_COMPRESSION_LIBRARY_ERROR: u32 = 142;
pub const SSL_R_CONNECTION_TYPE_NOT_SET: u32 = 144;
pub const SSL_R_CONTEXT_NOT_DANE_ENABLED: u32 = 167;
pub const SSL_R_COOKIE_GEN_CALLBACK_FAILURE: u32 = 400;
pub const SSL_R_COOKIE_MISMATCH: u32 = 308;
pub const SSL_R_COPY_PARAMETERS_FAILED: u32 = 296;
pub const SSL_R_CUSTOM_EXT_HANDLER_ALREADY_INSTALLED: u32 = 206;
pub const SSL_R_DANE_ALREADY_ENABLED: u32 = 172;
pub const SSL_R_DANE_CANNOT_OVERRIDE_MTYPE_FULL: u32 = 173;
pub const SSL_R_DANE_NOT_ENABLED: u32 = 175;
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE: u32 = 180;
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE_USAGE: u32 = 184;
pub const SSL_R_DANE_TLSA_BAD_DATA_LENGTH: u32 = 189;
pub const SSL_R_DANE_TLSA_BAD_DIGEST_LENGTH: u32 = 192;
pub const SSL_R_DANE_TLSA_BAD_MATCHING_TYPE: u32 = 200;
pub const SSL_R_DANE_TLSA_BAD_PUBLIC_KEY: u32 = 201;
pub const SSL_R_DANE_TLSA_BAD_SELECTOR: u32 = 202;
pub const SSL_R_DANE_TLSA_NULL_DATA: u32 = 203;
pub const SSL_R_DATA_BETWEEN_CCS_AND_FINISHED: u32 = 145;
pub const SSL_R_DATA_LENGTH_TOO_LONG: u32 = 146;
pub const SSL_R_DECRYPTION_FAILED: u32 = 147;
pub const SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC: u32 = 281;
pub const SSL_R_DH_KEY_TOO_SMALL: u32 = 394;
pub const SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG: u32 = 148;
pub const SSL_R_DIGEST_CHECK_FAILED: u32 = 149;
pub const SSL_R_DTLS_MESSAGE_TOO_BIG: u32 = 334;
pub const SSL_R_DUPLICATE_COMPRESSION_ID: u32 = 309;
pub const SSL_R_ECC_CERT_NOT_FOR_SIGNING: u32 = 318;
pub const SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE: u32 = 374;
pub const SSL_R_EE_KEY_TOO_SMALL: u32 = 399;
pub const SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST: u32 = 354;
pub const SSL_R_ENCRYPTED_LENGTH_TOO_LONG: u32 = 150;
pub const SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST: u32 = 151;
pub const SSL_R_ERROR_SETTING_TLSA_BASE_DOMAIN: u32 = 204;
pub const SSL_R_EXCEEDS_MAX_FRAGMENT_SIZE: u32 = 194;
pub const SSL_R_EXCESSIVE_MESSAGE_SIZE: u32 = 152;
pub const SSL_R_EXTENSION_NOT_RECEIVED: u32 = 279;
pub const SSL_R_EXTRA_DATA_IN_MESSAGE: u32 = 153;
pub const SSL_R_EXT_LENGTH_MISMATCH: u32 = 163;
pub const SSL_R_FAILED_TO_INIT_ASYNC: u32 = 405;
pub const SSL_R_FRAGMENTED_CLIENT_HELLO: u32 = 401;
pub const SSL_R_GOT_A_FIN_BEFORE_A_CCS: u32 = 154;
pub const SSL_R_HTTPS_PROXY_REQUEST: u32 = 155;
pub const SSL_R_HTTP_REQUEST: u32 = 156;
pub const SSL_R_ILLEGAL_POINT_COMPRESSION: u32 = 162;
pub const SSL_R_ILLEGAL_SUITEB_DIGEST: u32 = 380;
pub const SSL_R_INAPPROPRIATE_FALLBACK: u32 = 373;
pub const SSL_R_INCONSISTENT_COMPRESSION: u32 = 340;
pub const SSL_R_INCONSISTENT_EARLY_DATA_ALPN: u32 = 222;
pub const SSL_R_INCONSISTENT_EARLY_DATA_SNI: u32 = 231;
pub const SSL_R_INCONSISTENT_EXTMS: u32 = 104;
pub const SSL_R_INSUFFICIENT_SECURITY: u32 = 241;
pub const SSL_R_INVALID_ALERT: u32 = 205;
pub const SSL_R_INVALID_CCS_MESSAGE: u32 = 260;
pub const SSL_R_INVALID_CERTIFICATE_OR_ALG: u32 = 238;
pub const SSL_R_INVALID_COMMAND: u32 = 280;
pub const SSL_R_INVALID_COMPRESSION_ALGORITHM: u32 = 341;
pub const SSL_R_INVALID_CONFIG: u32 = 283;
pub const SSL_R_INVALID_CONFIGURATION_NAME: u32 = 113;
pub const SSL_R_INVALID_CONTEXT: u32 = 282;
pub const SSL_R_INVALID_CT_VALIDATION_TYPE: u32 = 212;
pub const SSL_R_INVALID_KEY_UPDATE_TYPE: u32 = 120;
pub const SSL_R_INVALID_MAX_EARLY_DATA: u32 = 174;
pub const SSL_R_INVALID_NULL_CMD_NAME: u32 = 385;
pub const SSL_R_INVALID_SEQUENCE_NUMBER: u32 = 402;
pub const SSL_R_INVALID_SERVERINFO_DATA: u32 = 388;
pub const SSL_R_INVALID_SESSION_ID: u32 = 999;
pub const SSL_R_INVALID_SRP_USERNAME: u32 = 357;
pub const SSL_R_INVALID_STATUS_RESPONSE: u32 = 328;
pub const SSL_R_INVALID_TICKET_KEYS_LENGTH: u32 = 325;
pub const SSL_R_LEGACY_SIGALG_DISALLOWED_OR_UNSUPPORTED: u32 = 333;
pub const SSL_R_LENGTH_MISMATCH: u32 = 159;
pub const SSL_R_LENGTH_TOO_LONG: u32 = 404;
pub const SSL_R_LENGTH_TOO_SHORT: u32 = 160;
pub const SSL_R_LIBRARY_BUG: u32 = 274;
pub const SSL_R_LIBRARY_HAS_NO_CIPHERS: u32 = 161;
pub const SSL_R_MISSING_DSA_SIGNING_CERT: u32 = 165;
pub const SSL_R_MISSING_ECDSA_SIGNING_CERT: u32 = 381;
pub const SSL_R_MISSING_FATAL: u32 = 256;
pub const SSL_R_MISSING_PARAMETERS: u32 = 290;
pub const SSL_R_MISSING_PSK_KEX_MODES_EXTENSION: u32 = 310;
pub const SSL_R_MISSING_RSA_CERTIFICATE: u32 = 168;
pub const SSL_R_MISSING_RSA_ENCRYPTING_CERT: u32 = 169;
pub const SSL_R_MISSING_RSA_SIGNING_CERT: u32 = 170;
pub const SSL_R_MISSING_SIGALGS_EXTENSION: u32 = 112;
pub const SSL_R_MISSING_SIGNING_CERT: u32 = 221;
pub const SSL_R_MISSING_SRP_PARAM: u32 = 358;
pub const SSL_R_MISSING_SUPPORTED_GROUPS_EXTENSION: u32 = 209;
pub const SSL_R_MISSING_TMP_DH_KEY: u32 = 171;
pub const SSL_R_MISSING_TMP_ECDH_KEY: u32 = 311;
pub const SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA: u32 = 293;
pub const SSL_R_NOT_ON_RECORD_BOUNDARY: u32 = 182;
pub const SSL_R_NOT_REPLACING_CERTIFICATE: u32 = 289;
pub const SSL_R_NOT_SERVER: u32 = 284;
pub const SSL_R_NO_APPLICATION_PROTOCOL: u32 = 235;
pub const SSL_R_NO_CERTIFICATES_RETURNED: u32 = 176;
pub const SSL_R_NO_CERTIFICATE_ASSIGNED: u32 = 177;
pub const SSL_R_NO_CERTIFICATE_SET: u32 = 179;
pub const SSL_R_NO_CHANGE_FOLLOWING_HRR: u32 = 214;
pub const SSL_R_NO_CIPHERS_AVAILABLE: u32 = 181;
pub const SSL_R_NO_CIPHERS_SPECIFIED: u32 = 183;
pub const SSL_R_NO_CIPHER_MATCH: u32 = 185;
pub const SSL_R_NO_CLIENT_CERT_METHOD: u32 = 331;
pub const SSL_R_NO_COMPRESSION_SPECIFIED: u32 = 187;
pub const SSL_R_NO_COOKIE_CALLBACK_SET: u32 = 287;
pub const SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER: u32 = 330;
pub const SSL_R_NO_METHOD_SPECIFIED: u32 = 188;
pub const SSL_R_NO_PEM_EXTENSIONS: u32 = 389;
pub const SSL_R_NO_PRIVATE_KEY_ASSIGNED: u32 = 190;
pub const SSL_R_NO_PROTOCOLS_AVAILABLE: u32 = 191;
pub const SSL_R_NO_RENEGOTIATION: u32 = 339;
pub const SSL_R_NO_REQUIRED_DIGEST: u32 = 324;
pub const SSL_R_NO_SHARED_CIPHER: u32 = 193;
pub const SSL_R_NO_SHARED_GROUPS: u32 = 410;
pub const SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS: u32 = 376;
pub const SSL_R_NO_SRTP_PROFILES: u32 = 359;
pub const SSL_R_NO_SUITABLE_DIGEST_ALGORITHM: u32 = 297;
pub const SSL_R_NO_SUITABLE_GROUPS: u32 = 295;
pub const SSL_R_NO_SUITABLE_KEY_SHARE: u32 = 101;
pub const SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM: u32 = 118;
pub const SSL_R_NO_VALID_SCTS: u32 = 216;
pub const SSL_R_NO_VERIFY_COOKIE_CALLBACK: u32 = 403;
pub const SSL_R_NULL_SSL_CTX: u32 = 195;
pub const SSL_R_NULL_SSL_METHOD_PASSED: u32 = 196;
pub const SSL_R_OCSP_CALLBACK_FAILURE: u32 = 305;
pub const SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED: u32 = 197;
pub const SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED: u32 = 344;
pub const SSL_R_OVERFLOW_ERROR: u32 = 237;
pub const SSL_R_PACKET_LENGTH_TOO_LONG: u32 = 198;
pub const SSL_R_PARSE_TLSEXT: u32 = 227;
pub const SSL_R_PATH_TOO_LONG: u32 = 270;
pub const SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE: u32 = 199;
pub const SSL_R_PEM_NAME_BAD_PREFIX: u32 = 391;
pub const SSL_R_PEM_NAME_TOO_SHORT: u32 = 392;
pub const SSL_R_PIPELINE_FAILURE: u32 = 406;
pub const SSL_R_POST_HANDSHAKE_AUTH_ENCODING_ERR: u32 = 278;
pub const SSL_R_PRIVATE_KEY_MISMATCH: u32 = 288;
pub const SSL_R_PROTOCOL_IS_SHUTDOWN: u32 = 207;
pub const SSL_R_PSK_IDENTITY_NOT_FOUND: u32 = 223;
pub const SSL_R_PSK_NO_CLIENT_CB: u32 = 224;
pub const SSL_R_PSK_NO_SERVER_CB: u32 = 225;
pub const SSL_R_READ_BIO_NOT_SET: u32 = 211;
pub const SSL_R_READ_TIMEOUT_EXPIRED: u32 = 312;
pub const SSL_R_RECORD_LENGTH_MISMATCH: u32 = 213;
pub const SSL_R_RECORD_TOO_SMALL: u32 = 298;
pub const SSL_R_RENEGOTIATE_EXT_TOO_LONG: u32 = 335;
pub const SSL_R_RENEGOTIATION_ENCODING_ERR: u32 = 336;
pub const SSL_R_RENEGOTIATION_MISMATCH: u32 = 337;
pub const SSL_R_REQUEST_PENDING: u32 = 285;
pub const SSL_R_REQUEST_SENT: u32 = 286;
pub const SSL_R_REQUIRED_CIPHER_MISSING: u32 = 215;
pub const SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING: u32 = 342;
pub const SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING: u32 = 345;
pub const SSL_R_SCT_VERIFICATION_FAILED: u32 = 208;
pub const SSL_R_SERVERHELLO_TLSEXT: u32 = 275;
pub const SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED: u32 = 277;
pub const SSL_R_SHUTDOWN_WHILE_IN_INIT: u32 = 407;
pub const SSL_R_SIGNATURE_ALGORITHMS_ERROR: u32 = 360;
pub const SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE: u32 = 220;
pub const SSL_R_SRP_A_CALC: u32 = 361;
pub const SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES: u32 = 362;
pub const SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG: u32 = 363;
pub const SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE: u32 = 364;
pub const SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH: u32 = 232;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME: u32 = 319;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE: u32 = 320;
pub const SSL_R_SSL3_SESSION_ID_TOO_LONG: u32 = 300;
pub const SSL_R_SSLV3_ALERT_BAD_CERTIFICATE: u32 = 1042;
pub const SSL_R_SSLV3_ALERT_BAD_RECORD_MAC: u32 = 1020;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED: u32 = 1045;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED: u32 = 1044;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN: u32 = 1046;
pub const SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE: u32 = 1030;
pub const SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE: u32 = 1040;
pub const SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER: u32 = 1047;
pub const SSL_R_SSLV3_ALERT_NO_CERTIFICATE: u32 = 1041;
pub const SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE: u32 = 1010;
pub const SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE: u32 = 1043;
pub const SSL_R_SSL_COMMAND_SECTION_EMPTY: u32 = 117;
pub const SSL_R_SSL_COMMAND_SECTION_NOT_FOUND: u32 = 125;
pub const SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION: u32 = 228;
pub const SSL_R_SSL_HANDSHAKE_FAILURE: u32 = 229;
pub const SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS: u32 = 230;
pub const SSL_R_SSL_NEGATIVE_LENGTH: u32 = 372;
pub const SSL_R_SSL_SECTION_EMPTY: u32 = 126;
pub const SSL_R_SSL_SECTION_NOT_FOUND: u32 = 136;
pub const SSL_R_SSL_SESSION_ID_CALLBACK_FAILED: u32 = 301;
pub const SSL_R_SSL_SESSION_ID_CONFLICT: u32 = 302;
pub const SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG: u32 = 273;
pub const SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH: u32 = 303;
pub const SSL_R_SSL_SESSION_ID_TOO_LONG: u32 = 408;
pub const SSL_R_SSL_SESSION_VERSION_MISMATCH: u32 = 210;
pub const SSL_R_STILL_IN_INIT: u32 = 121;
pub const SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED: u32 = 1116;
pub const SSL_R_TLSV13_ALERT_MISSING_EXTENSION: u32 = 1109;
pub const SSL_R_TLSV1_ALERT_ACCESS_DENIED: u32 = 1049;
pub const SSL_R_TLSV1_ALERT_DECODE_ERROR: u32 = 1050;
pub const SSL_R_TLSV1_ALERT_DECRYPTION_FAILED: u32 = 1021;
pub const SSL_R_TLSV1_ALERT_DECRYPT_ERROR: u32 = 1051;
pub const SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION: u32 = 1060;
pub const SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK: u32 = 1086;
pub const SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY: u32 = 1071;
pub const SSL_R_TLSV1_ALERT_INTERNAL_ERROR: u32 = 1080;
pub const SSL_R_TLSV1_ALERT_NO_RENEGOTIATION: u32 = 1100;
pub const SSL_R_TLSV1_ALERT_PROTOCOL_VERSION: u32 = 1070;
pub const SSL_R_TLSV1_ALERT_RECORD_OVERFLOW: u32 = 1022;
pub const SSL_R_TLSV1_ALERT_UNKNOWN_CA: u32 = 1048;
pub const SSL_R_TLSV1_ALERT_USER_CANCELLED: u32 = 1090;
pub const SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE: u32 = 1114;
pub const SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 1113;
pub const SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE: u32 = 1111;
pub const SSL_R_TLSV1_UNRECOGNIZED_NAME: u32 = 1112;
pub const SSL_R_TLSV1_UNSUPPORTED_EXTENSION: u32 = 1110;
pub const SSL_R_TLS_ILLEGAL_EXPORTER_LABEL: u32 = 367;
pub const SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST: u32 = 157;
pub const SSL_R_TOO_MANY_KEY_UPDATES: u32 = 132;
pub const SSL_R_TOO_MANY_WARN_ALERTS: u32 = 409;
pub const SSL_R_TOO_MUCH_EARLY_DATA: u32 = 164;
pub const SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS: u32 = 314;
pub const SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS: u32 = 239;
pub const SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES: u32 = 242;
pub const SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES: u32 = 243;
pub const SSL_R_UNEXPECTED_CCS_MESSAGE: u32 = 262;
pub const SSL_R_UNEXPECTED_END_OF_EARLY_DATA: u32 = 178;
pub const SSL_R_UNEXPECTED_EOF_WHILE_READING: u32 = 294;
pub const SSL_R_UNEXPECTED_MESSAGE: u32 = 244;
pub const SSL_R_UNEXPECTED_RECORD: u32 = 245;
pub const SSL_R_UNINITIALIZED: u32 = 276;
pub const SSL_R_UNKNOWN_ALERT_TYPE: u32 = 246;
pub const SSL_R_UNKNOWN_CERTIFICATE_TYPE: u32 = 247;
pub const SSL_R_UNKNOWN_CIPHER_RETURNED: u32 = 248;
pub const SSL_R_UNKNOWN_CIPHER_TYPE: u32 = 249;
pub const SSL_R_UNKNOWN_CMD_NAME: u32 = 386;
pub const SSL_R_UNKNOWN_COMMAND: u32 = 139;
pub const SSL_R_UNKNOWN_DIGEST: u32 = 368;
pub const SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE: u32 = 250;
pub const SSL_R_UNKNOWN_PKEY_TYPE: u32 = 251;
pub const SSL_R_UNKNOWN_PROTOCOL: u32 = 252;
pub const SSL_R_UNKNOWN_SSL_VERSION: u32 = 254;
pub const SSL_R_UNKNOWN_STATE: u32 = 255;
pub const SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED: u32 = 338;
pub const SSL_R_UNSOLICITED_EXTENSION: u32 = 217;
pub const SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM: u32 = 257;
pub const SSL_R_UNSUPPORTED_ELLIPTIC_CURVE: u32 = 315;
pub const SSL_R_UNSUPPORTED_PROTOCOL: u32 = 258;
pub const SSL_R_UNSUPPORTED_SSL_VERSION: u32 = 259;
pub const SSL_R_UNSUPPORTED_STATUS_TYPE: u32 = 329;
pub const SSL_R_USE_SRTP_NOT_NEGOTIATED: u32 = 369;
pub const SSL_R_VERSION_TOO_HIGH: u32 = 166;
pub const SSL_R_VERSION_TOO_LOW: u32 = 396;
pub const SSL_R_WRONG_CERTIFICATE_TYPE: u32 = 383;
pub const SSL_R_WRONG_CIPHER_RETURNED: u32 = 261;
pub const SSL_R_WRONG_CURVE: u32 = 378;
pub const SSL_R_WRONG_SIGNATURE_LENGTH: u32 = 264;
pub const SSL_R_WRONG_SIGNATURE_SIZE: u32 = 265;
pub const SSL_R_WRONG_SIGNATURE_TYPE: u32 = 370;
pub const SSL_R_WRONG_SSL_VERSION: u32 = 266;
pub const SSL_R_WRONG_VERSION_NUMBER: u32 = 267;
pub const SSL_R_X509_LIB: u32 = 268;
pub const SSL_R_X509_VERIFICATION_SETUP_PROBLEMS: u32 = 269;
pub const SSL_MAX_MASTER_KEY_LENGTH: u32 = 48;
pub const SSL3_VERSION: u32 = 768;
pub const TLS1_VERSION: u32 = 769;
pub const TLS1_1_VERSION: u32 = 770;
pub const TLS1_2_VERSION: u32 = 771;
pub const TLS1_3_VERSION: u32 = 772;
pub const DTLS1_VERSION: u32 = 65279;
pub const DTLS1_2_VERSION: u32 = 65277;
pub const DTLS1_BAD_VER: u32 = 256;
pub const SSL_SESSION_ASN1_VERSION: u32 = 1;
pub const SSL_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL_MAX_SID_CTX_LENGTH: u32 = 32;
pub const SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES: u32 = 64;
pub const SSL_MAX_KEY_ARG_LENGTH: u32 = 8;
pub const SSL_MAX_PIPELINES: u32 = 32;
pub const SSL_TXT_LOW: &[u8; 4] = b"LOW\0";
pub const SSL_TXT_MEDIUM: &[u8; 7] = b"MEDIUM\0";
pub const SSL_TXT_HIGH: &[u8; 5] = b"HIGH\0";
pub const SSL_TXT_FIPS: &[u8; 5] = b"FIPS\0";
pub const SSL_TXT_aNULL: &[u8; 6] = b"aNULL\0";
pub const SSL_TXT_eNULL: &[u8; 6] = b"eNULL\0";
pub const SSL_TXT_NULL: &[u8; 5] = b"NULL\0";
pub const SSL_TXT_kRSA: &[u8; 5] = b"kRSA\0";
pub const SSL_TXT_kDHr: &[u8; 5] = b"kDHr\0";
pub const SSL_TXT_kDHd: &[u8; 5] = b"kDHd\0";
pub const SSL_TXT_kDH: &[u8; 4] = b"kDH\0";
pub const SSL_TXT_kEDH: &[u8; 5] = b"kEDH\0";
pub const SSL_TXT_kDHE: &[u8; 5] = b"kDHE\0";
pub const SSL_TXT_kECDHr: &[u8; 7] = b"kECDHr\0";
pub const SSL_TXT_kECDHe: &[u8; 7] = b"kECDHe\0";
pub const SSL_TXT_kECDH: &[u8; 6] = b"kECDH\0";
pub const SSL_TXT_kEECDH: &[u8; 7] = b"kEECDH\0";
pub const SSL_TXT_kECDHE: &[u8; 7] = b"kECDHE\0";
pub const SSL_TXT_kPSK: &[u8; 5] = b"kPSK\0";
pub const SSL_TXT_kRSAPSK: &[u8; 8] = b"kRSAPSK\0";
pub const SSL_TXT_kECDHEPSK: &[u8; 10] = b"kECDHEPSK\0";
pub const SSL_TXT_kDHEPSK: &[u8; 8] = b"kDHEPSK\0";
pub const SSL_TXT_kGOST: &[u8; 6] = b"kGOST\0";
pub const SSL_TXT_kGOST18: &[u8; 8] = b"kGOST18\0";
pub const SSL_TXT_kSRP: &[u8; 5] = b"kSRP\0";
pub const SSL_TXT_aRSA: &[u8; 5] = b"aRSA\0";
pub const SSL_TXT_aDSS: &[u8; 5] = b"aDSS\0";
pub const SSL_TXT_aDH: &[u8; 4] = b"aDH\0";
pub const SSL_TXT_aECDH: &[u8; 6] = b"aECDH\0";
pub const SSL_TXT_aECDSA: &[u8; 7] = b"aECDSA\0";
pub const SSL_TXT_aPSK: &[u8; 5] = b"aPSK\0";
pub const SSL_TXT_aGOST94: &[u8; 8] = b"aGOST94\0";
pub const SSL_TXT_aGOST01: &[u8; 8] = b"aGOST01\0";
pub const SSL_TXT_aGOST12: &[u8; 8] = b"aGOST12\0";
pub const SSL_TXT_aGOST: &[u8; 6] = b"aGOST\0";
pub const SSL_TXT_aSRP: &[u8; 5] = b"aSRP\0";
pub const SSL_TXT_DSS: &[u8; 4] = b"DSS\0";
pub const SSL_TXT_DH: &[u8; 3] = b"DH\0";
pub const SSL_TXT_DHE: &[u8; 4] = b"DHE\0";
pub const SSL_TXT_EDH: &[u8; 4] = b"EDH\0";
pub const SSL_TXT_ADH: &[u8; 4] = b"ADH\0";
pub const SSL_TXT_RSA: &[u8; 4] = b"RSA\0";
pub const SSL_TXT_ECDH: &[u8; 5] = b"ECDH\0";
pub const SSL_TXT_EECDH: &[u8; 6] = b"EECDH\0";
pub const SSL_TXT_ECDHE: &[u8; 6] = b"ECDHE\0";
pub const SSL_TXT_AECDH: &[u8; 6] = b"AECDH\0";
pub const SSL_TXT_ECDSA: &[u8; 6] = b"ECDSA\0";
pub const SSL_TXT_PSK: &[u8; 4] = b"PSK\0";
pub const SSL_TXT_SRP: &[u8; 4] = b"SRP\0";
pub const SSL_TXT_DES: &[u8; 4] = b"DES\0";
pub const SSL_TXT_3DES: &[u8; 5] = b"3DES\0";
pub const SSL_TXT_RC4: &[u8; 4] = b"RC4\0";
pub const SSL_TXT_RC2: &[u8; 4] = b"RC2\0";
pub const SSL_TXT_IDEA: &[u8; 5] = b"IDEA\0";
pub const SSL_TXT_SEED: &[u8; 5] = b"SEED\0";
pub const SSL_TXT_AES128: &[u8; 7] = b"AES128\0";
pub const SSL_TXT_AES256: &[u8; 7] = b"AES256\0";
pub const SSL_TXT_AES: &[u8; 4] = b"AES\0";
pub const SSL_TXT_AES_GCM: &[u8; 7] = b"AESGCM\0";
pub const SSL_TXT_AES_CCM: &[u8; 7] = b"AESCCM\0";
pub const SSL_TXT_AES_CCM_8: &[u8; 8] = b"AESCCM8\0";
pub const SSL_TXT_CAMELLIA128: &[u8; 12] = b"CAMELLIA128\0";
pub const SSL_TXT_CAMELLIA256: &[u8; 12] = b"CAMELLIA256\0";
pub const SSL_TXT_CAMELLIA: &[u8; 9] = b"CAMELLIA\0";
pub const SSL_TXT_CHACHA20: &[u8; 9] = b"CHACHA20\0";
pub const SSL_TXT_GOST: &[u8; 7] = b"GOST89\0";
pub const SSL_TXT_ARIA: &[u8; 5] = b"ARIA\0";
pub const SSL_TXT_ARIA_GCM: &[u8; 8] = b"ARIAGCM\0";
pub const SSL_TXT_ARIA128: &[u8; 8] = b"ARIA128\0";
pub const SSL_TXT_ARIA256: &[u8; 8] = b"ARIA256\0";
pub const SSL_TXT_GOST2012_GOST8912_GOST8912: &[u8; 27] = b"GOST2012-GOST8912-GOST8912\0";
pub const SSL_TXT_CBC: &[u8; 4] = b"CBC\0";
pub const SSL_TXT_MD5: &[u8; 4] = b"MD5\0";
pub const SSL_TXT_SHA1: &[u8; 5] = b"SHA1\0";
pub const SSL_TXT_SHA: &[u8; 4] = b"SHA\0";
pub const SSL_TXT_GOST94: &[u8; 7] = b"GOST94\0";
pub const SSL_TXT_GOST89MAC: &[u8; 10] = b"GOST89MAC\0";
pub const SSL_TXT_GOST12: &[u8; 7] = b"GOST12\0";
pub const SSL_TXT_GOST89MAC12: &[u8; 12] = b"GOST89MAC12\0";
pub const SSL_TXT_SHA256: &[u8; 7] = b"SHA256\0";
pub const SSL_TXT_SHA384: &[u8; 7] = b"SHA384\0";
pub const SSL_TXT_SSLV3: &[u8; 6] = b"SSLv3\0";
pub const SSL_TXT_TLSV1: &[u8; 6] = b"TLSv1\0";
pub const SSL_TXT_TLSV1_1: &[u8; 8] = b"TLSv1.1\0";
pub const SSL_TXT_TLSV1_2: &[u8; 8] = b"TLSv1.2\0";
pub const SSL_TXT_ALL: &[u8; 4] = b"ALL\0";
pub const SSL_TXT_CMPALL: &[u8; 16] = b"COMPLEMENTOFALL\0";
pub const SSL_TXT_CMPDEF: &[u8; 20] = b"COMPLEMENTOFDEFAULT\0";
pub const SSL_DEFAULT_CIPHER_LIST: &[u8; 32] = b"ALL:!COMPLEMENTOFDEFAULT:!eNULL\0";
pub const TLS_DEFAULT_CIPHERSUITES: &[u8; 75] =
    b"TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256\0";
pub const SSL_SENT_SHUTDOWN: u32 = 1;
pub const SSL_RECEIVED_SHUTDOWN: u32 = 2;
pub const SSL_FILETYPE_ASN1: u32 = 2;
pub const SSL_FILETYPE_PEM: u32 = 1;
pub const SSL_EXT_TLS_ONLY: u32 = 1;
pub const SSL_EXT_DTLS_ONLY: u32 = 2;
pub const SSL_EXT_TLS_IMPLEMENTATION_ONLY: u32 = 4;
pub const SSL_EXT_SSL3_ALLOWED: u32 = 8;
pub const SSL_EXT_TLS1_2_AND_BELOW_ONLY: u32 = 16;
pub const SSL_EXT_TLS1_3_ONLY: u32 = 32;
pub const SSL_EXT_IGNORE_ON_RESUMPTION: u32 = 64;
pub const SSL_EXT_CLIENT_HELLO: u32 = 128;
pub const SSL_EXT_TLS1_2_SERVER_HELLO: u32 = 256;
pub const SSL_EXT_TLS1_3_SERVER_HELLO: u32 = 512;
pub const SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS: u32 = 1024;
pub const SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST: u32 = 2048;
pub const SSL_EXT_TLS1_3_CERTIFICATE: u32 = 4096;
pub const SSL_EXT_TLS1_3_NEW_SESSION_TICKET: u32 = 8192;
pub const SSL_EXT_TLS1_3_CERTIFICATE_REQUEST: u32 = 16384;
pub const SSL_OP_MICROSOFT_SESS_ID_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: u32 = 0;
pub const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: u32 = 0;
pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: u32 = 0;
pub const SSL_OP_MSIE_SSLV2_RSA_PADDING: u32 = 0;
pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: u32 = 0;
pub const SSL_OP_TLS_D5_BUG: u32 = 0;
pub const SSL_OP_TLS_BLOCK_PADDING_BUG: u32 = 0;
pub const SSL_OP_SINGLE_ECDH_USE: u32 = 0;
pub const SSL_OP_SINGLE_DH_USE: u32 = 0;
pub const SSL_OP_EPHEMERAL_RSA: u32 = 0;
pub const SSL_OP_NO_SSLv2: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_1: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_2: u32 = 0;
pub const SSL_OP_NETSCAPE_CA_DN_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: u32 = 0;
pub const SSL_MODE_ENABLE_PARTIAL_WRITE: u32 = 1;
pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER: u32 = 2;
pub const SSL_MODE_AUTO_RETRY: u32 = 4;
pub const SSL_MODE_NO_AUTO_CHAIN: u32 = 8;
pub const SSL_MODE_RELEASE_BUFFERS: u32 = 16;
pub const SSL_MODE_SEND_CLIENTHELLO_TIME: u32 = 32;
pub const SSL_MODE_SEND_SERVERHELLO_TIME: u32 = 64;
pub const SSL_MODE_SEND_FALLBACK_SCSV: u32 = 128;
pub const SSL_MODE_ASYNC: u32 = 256;
pub const SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG: u32 = 1024;
pub const SSL_CERT_FLAG_TLS_STRICT: u32 = 1;
pub const SSL_CERT_FLAG_SUITEB_128_LOS_ONLY: u32 = 65536;
pub const SSL_CERT_FLAG_SUITEB_192_LOS: u32 = 131072;
pub const SSL_CERT_FLAG_SUITEB_128_LOS: u32 = 196608;
pub const SSL_CERT_FLAG_BROKEN_PROTOCOL: u32 = 268435456;
pub const SSL_BUILD_CHAIN_FLAG_UNTRUSTED: u32 = 1;
pub const SSL_BUILD_CHAIN_FLAG_NO_ROOT: u32 = 2;
pub const SSL_BUILD_CHAIN_FLAG_CHECK: u32 = 4;
pub const SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR: u32 = 8;
pub const SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR: u32 = 16;
pub const CERT_PKEY_VALID: u32 = 1;
pub const CERT_PKEY_SIGN: u32 = 2;
pub const CERT_PKEY_EE_SIGNATURE: u32 = 16;
pub const CERT_PKEY_CA_SIGNATURE: u32 = 32;
pub const CERT_PKEY_EE_PARAM: u32 = 64;
pub const CERT_PKEY_CA_PARAM: u32 = 128;
pub const CERT_PKEY_EXPLICIT_SIGN: u32 = 256;
pub const CERT_PKEY_ISSUER_NAME: u32 = 512;
pub const CERT_PKEY_CERT_TYPE: u32 = 1024;
pub const CERT_PKEY_SUITEB: u32 = 2048;
pub const SSL_CONF_FLAG_CMDLINE: u32 = 1;
pub const SSL_CONF_FLAG_FILE: u32 = 2;
pub const SSL_CONF_FLAG_CLIENT: u32 = 4;
pub const SSL_CONF_FLAG_SERVER: u32 = 8;
pub const SSL_CONF_FLAG_SHOW_ERRORS: u32 = 16;
pub const SSL_CONF_FLAG_CERTIFICATE: u32 = 32;
pub const SSL_CONF_FLAG_REQUIRE_PRIVATE: u32 = 64;
pub const SSL_CONF_TYPE_UNKNOWN: u32 = 0;
pub const SSL_CONF_TYPE_STRING: u32 = 1;
pub const SSL_CONF_TYPE_FILE: u32 = 2;
pub const SSL_CONF_TYPE_DIR: u32 = 3;
pub const SSL_CONF_TYPE_NONE: u32 = 4;
pub const SSL_CONF_TYPE_STORE: u32 = 5;
pub const SSL_COOKIE_LENGTH: u32 = 4096;
pub const SSL_MAX_CERT_LIST_DEFAULT: u32 = 102400;
pub const SSL_SESSION_CACHE_MAX_SIZE_DEFAULT: u32 = 20480;
pub const SSL_SESS_CACHE_OFF: u32 = 0;
pub const SSL_SESS_CACHE_CLIENT: u32 = 1;
pub const SSL_SESS_CACHE_SERVER: u32 = 2;
pub const SSL_SESS_CACHE_BOTH: u32 = 3;
pub const SSL_SESS_CACHE_NO_AUTO_CLEAR: u32 = 128;
pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP: u32 = 256;
pub const SSL_SESS_CACHE_NO_INTERNAL_STORE: u32 = 512;
pub const SSL_SESS_CACHE_NO_INTERNAL: u32 = 768;
pub const SSL_SESS_CACHE_UPDATE_TIME: u32 = 1024;
pub const OPENSSL_NPN_UNSUPPORTED: u32 = 0;
pub const OPENSSL_NPN_NEGOTIATED: u32 = 1;
pub const OPENSSL_NPN_NO_OVERLAP: u32 = 2;
pub const PSK_MAX_IDENTITY_LEN: u32 = 256;
pub const PSK_MAX_PSK_LEN: u32 = 512;
pub const SSL_NOTHING: u32 = 1;
pub const SSL_WRITING: u32 = 2;
pub const SSL_READING: u32 = 3;
pub const SSL_X509_LOOKUP: u32 = 4;
pub const SSL_ASYNC_PAUSED: u32 = 5;
pub const SSL_ASYNC_NO_JOBS: u32 = 6;
pub const SSL_CLIENT_HELLO_CB: u32 = 7;
pub const SSL_RETRY_VERIFY: u32 = 8;
pub const SSL_MAC_FLAG_READ_MAC_STREAM: u32 = 1;
pub const SSL_MAC_FLAG_WRITE_MAC_STREAM: u32 = 2;
pub const SSL_MAC_FLAG_READ_MAC_TLSTREE: u32 = 4;
pub const SSL_MAC_FLAG_WRITE_MAC_TLSTREE: u32 = 8;
pub const SSL2_VERSION: u32 = 2;
pub const SSL2_MT_CLIENT_HELLO: u32 = 1;
pub const SSL3_CK_SCSV: u32 = 50331903;
pub const SSL3_CK_FALLBACK_SCSV: u32 = 50353664;
pub const SSL3_CK_RSA_NULL_MD5: u32 = 50331649;
pub const SSL3_CK_RSA_NULL_SHA: u32 = 50331650;
pub const SSL3_CK_RSA_RC4_40_MD5: u32 = 50331651;
pub const SSL3_CK_RSA_RC4_128_MD5: u32 = 50331652;
pub const SSL3_CK_RSA_RC4_128_SHA: u32 = 50331653;
pub const SSL3_CK_RSA_RC2_40_MD5: u32 = 50331654;
pub const SSL3_CK_RSA_IDEA_128_SHA: u32 = 50331655;
pub const SSL3_CK_RSA_DES_40_CBC_SHA: u32 = 50331656;
pub const SSL3_CK_RSA_DES_64_CBC_SHA: u32 = 50331657;
pub const SSL3_CK_RSA_DES_192_CBC3_SHA: u32 = 50331658;
pub const SSL3_CK_DH_DSS_DES_40_CBC_SHA: u32 = 50331659;
pub const SSL3_CK_DH_DSS_DES_64_CBC_SHA: u32 = 50331660;
pub const SSL3_CK_DH_DSS_DES_192_CBC3_SHA: u32 = 50331661;
pub const SSL3_CK_DH_RSA_DES_40_CBC_SHA: u32 = 50331662;
pub const SSL3_CK_DH_RSA_DES_64_CBC_SHA: u32 = 50331663;
pub const SSL3_CK_DH_RSA_DES_192_CBC3_SHA: u32 = 50331664;
pub const SSL3_CK_DHE_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_EDH_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_DHE_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_EDH_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_DHE_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_EDH_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_DHE_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_EDH_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_DHE_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_EDH_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_DHE_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_EDH_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_ADH_RC4_40_MD5: u32 = 50331671;
pub const SSL3_CK_ADH_RC4_128_MD5: u32 = 50331672;
pub const SSL3_CK_ADH_DES_40_CBC_SHA: u32 = 50331673;
pub const SSL3_CK_ADH_DES_64_CBC_SHA: u32 = 50331674;
pub const SSL3_CK_ADH_DES_192_CBC_SHA: u32 = 50331675;
pub const SSL3_RFC_RSA_NULL_MD5: &[u8; 22] = b"TLS_RSA_WITH_NULL_MD5\0";
pub const SSL3_RFC_RSA_NULL_SHA: &[u8; 22] = b"TLS_RSA_WITH_NULL_SHA\0";
pub const SSL3_RFC_RSA_DES_192_CBC3_SHA: &[u8; 30] = b"TLS_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_DHE_DSS_DES_192_CBC3_SHA: &[u8; 34] = b"TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_DHE_RSA_DES_192_CBC3_SHA: &[u8; 34] = b"TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_ADH_DES_192_CBC_SHA: &[u8; 34] = b"TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\0";
pub const SSL3_RFC_RSA_IDEA_128_SHA: &[u8; 26] = b"TLS_RSA_WITH_IDEA_CBC_SHA\0";
pub const SSL3_RFC_RSA_RC4_128_MD5: &[u8; 25] = b"TLS_RSA_WITH_RC4_128_MD5\0";
pub const SSL3_RFC_RSA_RC4_128_SHA: &[u8; 25] = b"TLS_RSA_WITH_RC4_128_SHA\0";
pub const SSL3_RFC_ADH_RC4_128_MD5: &[u8; 29] = b"TLS_DH_anon_WITH_RC4_128_MD5\0";
pub const SSL3_TXT_RSA_NULL_MD5: &[u8; 9] = b"NULL-MD5\0";
pub const SSL3_TXT_RSA_NULL_SHA: &[u8; 9] = b"NULL-SHA\0";
pub const SSL3_TXT_RSA_RC4_40_MD5: &[u8; 12] = b"EXP-RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_MD5: &[u8; 8] = b"RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_SHA: &[u8; 8] = b"RC4-SHA\0";
pub const SSL3_TXT_RSA_RC2_40_MD5: &[u8; 16] = b"EXP-RC2-CBC-MD5\0";
pub const SSL3_TXT_RSA_IDEA_128_SHA: &[u8; 13] = b"IDEA-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_40_CBC_SHA: &[u8; 16] = b"EXP-DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_64_CBC_SHA: &[u8; 12] = b"DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_192_CBC3_SHA: &[u8; 13] = b"DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_40_CBC_SHA: &[u8; 23] = b"EXP-DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_64_CBC_SHA: &[u8; 19] = b"DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_192_CBC3_SHA: &[u8; 20] = b"DH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_40_CBC_SHA: &[u8; 23] = b"EXP-DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_64_CBC_SHA: &[u8; 19] = b"DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_192_CBC3_SHA: &[u8; 20] = b"DH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_40_CBC_SHA: &[u8; 24] = b"EXP-DHE-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_64_CBC_SHA: &[u8; 20] = b"DHE-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_DSS_DES_192_CBC3_SHA: &[u8; 21] = b"DHE-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_40_CBC_SHA: &[u8; 24] = b"EXP-DHE-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_64_CBC_SHA: &[u8; 20] = b"DHE-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DHE_RSA_DES_192_CBC3_SHA: &[u8; 21] = b"DHE-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_40_CBC_SHA: &[u8; 24] = b"EXP-EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_64_CBC_SHA: &[u8; 20] = b"EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA: &[u8; 21] = b"EDH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_40_CBC_SHA: &[u8; 24] = b"EXP-EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_64_CBC_SHA: &[u8; 20] = b"EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA: &[u8; 21] = b"EDH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_ADH_RC4_40_MD5: &[u8; 16] = b"EXP-ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_RC4_128_MD5: &[u8; 12] = b"ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_DES_40_CBC_SHA: &[u8; 20] = b"EXP-ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_64_CBC_SHA: &[u8; 16] = b"ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_192_CBC_SHA: &[u8; 17] = b"ADH-DES-CBC3-SHA\0";
pub const SSL3_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MASTER_SECRET_SIZE: u32 = 48;
pub const SSL3_RANDOM_SIZE: u32 = 32;
pub const SSL3_SESSION_ID_SIZE: u32 = 32;
pub const SSL3_RT_HEADER_LENGTH: u32 = 5;
pub const SSL3_HM_HEADER_LENGTH: u32 = 4;
pub const SSL3_ALIGN_PAYLOAD: u32 = 8;
pub const SSL3_RT_MAX_MD_SIZE: u32 = 64;
pub const SSL_RT_MAX_CIPHER_BLOCK_SIZE: u32 = 16;
pub const SSL3_RT_MAX_EXTRA: u32 = 16384;
pub const SSL3_RT_MAX_PLAIN_LENGTH: u32 = 16384;
pub const SSL3_RT_MAX_COMPRESSED_OVERHEAD: u32 = 1024;
pub const SSL3_RT_MAX_ENCRYPTED_OVERHEAD: u32 = 320;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_OVERHEAD: u32 = 256;
pub const SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD: u32 = 80;
pub const SSL3_RT_MAX_COMPRESSED_LENGTH: u32 = 17408;
pub const SSL3_RT_MAX_ENCRYPTED_LENGTH: u32 = 17728;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH: u32 = 16640;
pub const SSL3_RT_MAX_PACKET_SIZE: u32 = 17733;
pub const SSL3_MD_CLIENT_FINISHED_CONST: &[u8; 5] = b"CLNT\0";
pub const SSL3_MD_SERVER_FINISHED_CONST: &[u8; 5] = b"SRVR\0";
pub const SSL3_VERSION_MAJOR: u32 = 3;
pub const SSL3_VERSION_MINOR: u32 = 0;
pub const SSL3_RT_CHANGE_CIPHER_SPEC: u32 = 20;
pub const SSL3_RT_ALERT: u32 = 21;
pub const SSL3_RT_HANDSHAKE: u32 = 22;
pub const SSL3_RT_APPLICATION_DATA: u32 = 23;
pub const TLS1_RT_CRYPTO: u32 = 4096;
pub const TLS1_RT_CRYPTO_PREMASTER: u32 = 4097;
pub const TLS1_RT_CRYPTO_CLIENT_RANDOM: u32 = 4098;
pub const TLS1_RT_CRYPTO_SERVER_RANDOM: u32 = 4099;
pub const TLS1_RT_CRYPTO_MASTER: u32 = 4100;
pub const TLS1_RT_CRYPTO_READ: u32 = 0;
pub const TLS1_RT_CRYPTO_WRITE: u32 = 256;
pub const TLS1_RT_CRYPTO_MAC: u32 = 4101;
pub const TLS1_RT_CRYPTO_KEY: u32 = 4102;
pub const TLS1_RT_CRYPTO_IV: u32 = 4103;
pub const TLS1_RT_CRYPTO_FIXED_IV: u32 = 4104;
pub const SSL3_RT_HEADER: u32 = 256;
pub const SSL3_RT_INNER_CONTENT_TYPE: u32 = 257;
pub const SSL3_AL_WARNING: u32 = 1;
pub const SSL3_AL_FATAL: u32 = 2;
pub const SSL3_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL3_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL3_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL3_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL3_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL3_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL3_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL3_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL3_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL3_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL3_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL3_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const TLS1_HB_REQUEST: u32 = 1;
pub const TLS1_HB_RESPONSE: u32 = 2;
pub const SSL3_CT_RSA_SIGN: u32 = 1;
pub const SSL3_CT_DSS_SIGN: u32 = 2;
pub const SSL3_CT_RSA_FIXED_DH: u32 = 3;
pub const SSL3_CT_DSS_FIXED_DH: u32 = 4;
pub const SSL3_CT_RSA_EPHEMERAL_DH: u32 = 5;
pub const SSL3_CT_DSS_EPHEMERAL_DH: u32 = 6;
pub const SSL3_CT_FORTEZZA_DMS: u32 = 20;
pub const SSL3_CT_NUMBER: u32 = 12;
pub const SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS: u32 = 1;
pub const TLS1_FLAGS_TLS_PADDING_BUG: u32 = 0;
pub const TLS1_FLAGS_SKIP_CERT_VERIFY: u32 = 16;
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_READ: u32 = 256;
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC: u32 = 256;
pub const TLS1_FLAGS_RECEIVED_EXTMS: u32 = 512;
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE: u32 = 1024;
pub const TLS1_FLAGS_STATELESS: u32 = 2048;
pub const TLS1_FLAGS_REQUIRED_EXTMS: u32 = 4096;
pub const SSL3_MT_HELLO_REQUEST: u32 = 0;
pub const SSL3_MT_CLIENT_HELLO: u32 = 1;
pub const SSL3_MT_SERVER_HELLO: u32 = 2;
pub const SSL3_MT_NEWSESSION_TICKET: u32 = 4;
pub const SSL3_MT_END_OF_EARLY_DATA: u32 = 5;
pub const SSL3_MT_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const SSL3_MT_CERTIFICATE: u32 = 11;
pub const SSL3_MT_SERVER_KEY_EXCHANGE: u32 = 12;
pub const SSL3_MT_CERTIFICATE_REQUEST: u32 = 13;
pub const SSL3_MT_SERVER_DONE: u32 = 14;
pub const SSL3_MT_CERTIFICATE_VERIFY: u32 = 15;
pub const SSL3_MT_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const SSL3_MT_FINISHED: u32 = 20;
pub const SSL3_MT_CERTIFICATE_URL: u32 = 21;
pub const SSL3_MT_CERTIFICATE_STATUS: u32 = 22;
pub const SSL3_MT_SUPPLEMENTAL_DATA: u32 = 23;
pub const SSL3_MT_KEY_UPDATE: u32 = 24;
pub const SSL3_MT_NEXT_PROTO: u32 = 67;
pub const SSL3_MT_MESSAGE_HASH: u32 = 254;
pub const DTLS1_MT_HELLO_VERIFY_REQUEST: u32 = 3;
pub const SSL3_MT_CHANGE_CIPHER_SPEC: u32 = 257;
pub const SSL3_MT_CCS: u32 = 1;
pub const SSL3_CC_READ: u32 = 1;
pub const SSL3_CC_WRITE: u32 = 2;
pub const SSL3_CC_CLIENT: u32 = 16;
pub const SSL3_CC_SERVER: u32 = 32;
pub const SSL3_CC_EARLY: u32 = 64;
pub const SSL3_CC_HANDSHAKE: u32 = 128;
pub const SSL3_CC_APPLICATION: u32 = 256;
pub const SSL3_CHANGE_CIPHER_CLIENT_WRITE: u32 = 18;
pub const SSL3_CHANGE_CIPHER_SERVER_READ: u32 = 33;
pub const SSL3_CHANGE_CIPHER_CLIENT_READ: u32 = 17;
pub const SSL3_CHANGE_CIPHER_SERVER_WRITE: u32 = 34;
pub const OPENSSL_TLS_SECURITY_LEVEL: u32 = 1;
pub const TLS_MAX_VERSION: u32 = 772;
pub const TLS_ANY_VERSION: u32 = 65536;
pub const TLS1_VERSION_MAJOR: u32 = 3;
pub const TLS1_VERSION_MINOR: u32 = 1;
pub const TLS1_1_VERSION_MAJOR: u32 = 3;
pub const TLS1_1_VERSION_MINOR: u32 = 2;
pub const TLS1_2_VERSION_MAJOR: u32 = 3;
pub const TLS1_2_VERSION_MINOR: u32 = 3;
pub const TLS1_AD_DECRYPTION_FAILED: u32 = 21;
pub const TLS1_AD_RECORD_OVERFLOW: u32 = 22;
pub const TLS1_AD_UNKNOWN_CA: u32 = 48;
pub const TLS1_AD_ACCESS_DENIED: u32 = 49;
pub const TLS1_AD_DECODE_ERROR: u32 = 50;
pub const TLS1_AD_DECRYPT_ERROR: u32 = 51;
pub const TLS1_AD_EXPORT_RESTRICTION: u32 = 60;
pub const TLS1_AD_PROTOCOL_VERSION: u32 = 70;
pub const TLS1_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const TLS1_AD_INTERNAL_ERROR: u32 = 80;
pub const TLS1_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const TLS1_AD_USER_CANCELLED: u32 = 90;
pub const TLS1_AD_NO_RENEGOTIATION: u32 = 100;
pub const TLS13_AD_MISSING_EXTENSION: u32 = 109;
pub const TLS13_AD_CERTIFICATE_REQUIRED: u32 = 116;
pub const TLS1_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const TLS1_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const TLS1_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const TLS1_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const TLS1_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const TLS1_AD_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const TLSEXT_TYPE_server_name: u32 = 0;
pub const TLSEXT_TYPE_max_fragment_length: u32 = 1;
pub const TLSEXT_TYPE_client_certificate_url: u32 = 2;
pub const TLSEXT_TYPE_trusted_ca_keys: u32 = 3;
pub const TLSEXT_TYPE_truncated_hmac: u32 = 4;
pub const TLSEXT_TYPE_status_request: u32 = 5;
pub const TLSEXT_TYPE_user_mapping: u32 = 6;
pub const TLSEXT_TYPE_client_authz: u32 = 7;
pub const TLSEXT_TYPE_server_authz: u32 = 8;
pub const TLSEXT_TYPE_cert_type: u32 = 9;
pub const TLSEXT_TYPE_supported_groups: u32 = 10;
pub const TLSEXT_TYPE_elliptic_curves: u32 = 10;
pub const TLSEXT_TYPE_ec_point_formats: u32 = 11;
pub const TLSEXT_TYPE_srp: u32 = 12;
pub const TLSEXT_TYPE_signature_algorithms: u32 = 13;
pub const TLSEXT_TYPE_use_srtp: u32 = 14;
pub const TLSEXT_TYPE_application_layer_protocol_negotiation: u32 = 16;
pub const TLSEXT_TYPE_signed_certificate_timestamp: u32 = 18;
pub const TLSEXT_TYPE_padding: u32 = 21;
pub const TLSEXT_TYPE_encrypt_then_mac: u32 = 22;
pub const TLSEXT_TYPE_extended_master_secret: u32 = 23;
pub const TLSEXT_TYPE_session_ticket: u32 = 35;
pub const TLSEXT_TYPE_psk: u32 = 41;
pub const TLSEXT_TYPE_early_data: u32 = 42;
pub const TLSEXT_TYPE_supported_versions: u32 = 43;
pub const TLSEXT_TYPE_cookie: u32 = 44;
pub const TLSEXT_TYPE_psk_kex_modes: u32 = 45;
pub const TLSEXT_TYPE_certificate_authorities: u32 = 47;
pub const TLSEXT_TYPE_post_handshake_auth: u32 = 49;
pub const TLSEXT_TYPE_signature_algorithms_cert: u32 = 50;
pub const TLSEXT_TYPE_key_share: u32 = 51;
pub const TLSEXT_TYPE_renegotiate: u32 = 65281;
pub const TLSEXT_TYPE_next_proto_neg: u32 = 13172;
pub const TLSEXT_NAMETYPE_host_name: u32 = 0;
pub const TLSEXT_STATUSTYPE_ocsp: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_first: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_uncompressed: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2: u32 = 2;
pub const TLSEXT_ECPOINTFORMAT_last: u32 = 2;
pub const TLSEXT_signature_anonymous: u32 = 0;
pub const TLSEXT_signature_rsa: u32 = 1;
pub const TLSEXT_signature_dsa: u32 = 2;
pub const TLSEXT_signature_ecdsa: u32 = 3;
pub const TLSEXT_signature_gostr34102001: u32 = 237;
pub const TLSEXT_signature_gostr34102012_256: u32 = 238;
pub const TLSEXT_signature_gostr34102012_512: u32 = 239;
pub const TLSEXT_signature_num: u32 = 7;
pub const TLSEXT_hash_none: u32 = 0;
pub const TLSEXT_hash_md5: u32 = 1;
pub const TLSEXT_hash_sha1: u32 = 2;
pub const TLSEXT_hash_sha224: u32 = 3;
pub const TLSEXT_hash_sha256: u32 = 4;
pub const TLSEXT_hash_sha384: u32 = 5;
pub const TLSEXT_hash_sha512: u32 = 6;
pub const TLSEXT_hash_gostr3411: u32 = 237;
pub const TLSEXT_hash_gostr34112012_256: u32 = 238;
pub const TLSEXT_hash_gostr34112012_512: u32 = 239;
pub const TLSEXT_hash_num: u32 = 10;
pub const TLSEXT_nid_unknown: u32 = 16777216;
pub const TLSEXT_curve_P_256: u32 = 23;
pub const TLSEXT_curve_P_384: u32 = 24;
pub const TLSEXT_max_fragment_length_DISABLED: u32 = 0;
pub const TLSEXT_max_fragment_length_512: u32 = 1;
pub const TLSEXT_max_fragment_length_1024: u32 = 2;
pub const TLSEXT_max_fragment_length_2048: u32 = 3;
pub const TLSEXT_max_fragment_length_4096: u32 = 4;
pub const TLSEXT_MAXLEN_host_name: u32 = 255;
pub const SSL_TLSEXT_ERR_OK: u32 = 0;
pub const SSL_TLSEXT_ERR_ALERT_WARNING: u32 = 1;
pub const SSL_TLSEXT_ERR_ALERT_FATAL: u32 = 2;
pub const SSL_TLSEXT_ERR_NOACK: u32 = 3;
pub const TLS1_CK_PSK_WITH_RC4_128_SHA: u32 = 50331786;
pub const TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331787;
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA: u32 = 50331788;
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA: u32 = 50331789;
pub const TLS1_CK_DHE_PSK_WITH_RC4_128_SHA: u32 = 50331790;
pub const TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331791;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 50331792;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 50331793;
pub const TLS1_CK_RSA_PSK_WITH_RC4_128_SHA: u32 = 50331794;
pub const TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331795;
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 50331796;
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 50331797;
pub const TLS1_CK_PSK_WITH_AES_128_GCM_SHA256: u32 = 50331816;
pub const TLS1_CK_PSK_WITH_AES_256_GCM_SHA384: u32 = 50331817;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 50331818;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 50331819;
pub const TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 50331820;
pub const TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 50331821;
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA256: u32 = 50331822;
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA384: u32 = 50331823;
pub const TLS1_CK_PSK_WITH_NULL_SHA256: u32 = 50331824;
pub const TLS1_CK_PSK_WITH_NULL_SHA384: u32 = 50331825;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 50331826;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 50331827;
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA256: u32 = 50331828;
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA384: u32 = 50331829;
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 50331830;
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 50331831;
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA256: u32 = 50331832;
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA384: u32 = 50331833;
pub const TLS1_CK_PSK_WITH_NULL_SHA: u32 = 50331692;
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA: u32 = 50331693;
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA: u32 = 50331694;
pub const TLS1_CK_RSA_WITH_AES_128_SHA: u32 = 50331695;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA: u32 = 50331696;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA: u32 = 50331697;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA: u32 = 50331698;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA: u32 = 50331699;
pub const TLS1_CK_ADH_WITH_AES_128_SHA: u32 = 50331700;
pub const TLS1_CK_RSA_WITH_AES_256_SHA: u32 = 50331701;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA: u32 = 50331702;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA: u32 = 50331703;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA: u32 = 50331704;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA: u32 = 50331705;
pub const TLS1_CK_ADH_WITH_AES_256_SHA: u32 = 50331706;
pub const TLS1_CK_RSA_WITH_NULL_SHA256: u32 = 50331707;
pub const TLS1_CK_RSA_WITH_AES_128_SHA256: u32 = 50331708;
pub const TLS1_CK_RSA_WITH_AES_256_SHA256: u32 = 50331709;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA256: u32 = 50331710;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA256: u32 = 50331711;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: u32 = 50331712;
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331713;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331714;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331715;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331716;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331717;
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331718;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: u32 = 50331751;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA256: u32 = 50331752;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA256: u32 = 50331753;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: u32 = 50331754;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: u32 = 50331755;
pub const TLS1_CK_ADH_WITH_AES_128_SHA256: u32 = 50331756;
pub const TLS1_CK_ADH_WITH_AES_256_SHA256: u32 = 50331757;
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331780;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331781;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331782;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331783;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331784;
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331785;
pub const TLS1_CK_RSA_WITH_SEED_SHA: u32 = 50331798;
pub const TLS1_CK_DH_DSS_WITH_SEED_SHA: u32 = 50331799;
pub const TLS1_CK_DH_RSA_WITH_SEED_SHA: u32 = 50331800;
pub const TLS1_CK_DHE_DSS_WITH_SEED_SHA: u32 = 50331801;
pub const TLS1_CK_DHE_RSA_WITH_SEED_SHA: u32 = 50331802;
pub const TLS1_CK_ADH_WITH_SEED_SHA: u32 = 50331803;
pub const TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331804;
pub const TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331805;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331806;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331807;
pub const TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331808;
pub const TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331809;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331810;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331811;
pub const TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331812;
pub const TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331813;
pub const TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: u32 = 50331814;
pub const TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: u32 = 50331815;
pub const TLS1_CK_RSA_WITH_AES_128_CCM: u32 = 50380956;
pub const TLS1_CK_RSA_WITH_AES_256_CCM: u32 = 50380957;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM: u32 = 50380958;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM: u32 = 50380959;
pub const TLS1_CK_RSA_WITH_AES_128_CCM_8: u32 = 50380960;
pub const TLS1_CK_RSA_WITH_AES_256_CCM_8: u32 = 50380961;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8: u32 = 50380962;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8: u32 = 50380963;
pub const TLS1_CK_PSK_WITH_AES_128_CCM: u32 = 50380964;
pub const TLS1_CK_PSK_WITH_AES_256_CCM: u32 = 50380965;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM: u32 = 50380966;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM: u32 = 50380967;
pub const TLS1_CK_PSK_WITH_AES_128_CCM_8: u32 = 50380968;
pub const TLS1_CK_PSK_WITH_AES_256_CCM_8: u32 = 50380969;
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8: u32 = 50380970;
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8: u32 = 50380971;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 50380972;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 50380973;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 50380974;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 50380975;
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331834;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331835;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331836;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331837;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331838;
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50331839;
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331840;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331841;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331842;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331843;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331844;
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256: u32 = 50331845;
pub const TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: u32 = 50380801;
pub const TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 50380802;
pub const TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380803;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380804;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380805;
pub const TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 50380806;
pub const TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 50380807;
pub const TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380808;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380809;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380810;
pub const TLS1_CK_ECDH_RSA_WITH_NULL_SHA: u32 = 50380811;
pub const TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: u32 = 50380812;
pub const TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380813;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 50380814;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 50380815;
pub const TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: u32 = 50380816;
pub const TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 50380817;
pub const TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380818;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 50380819;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 50380820;
pub const TLS1_CK_ECDH_anon_WITH_NULL_SHA: u32 = 50380821;
pub const TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: u32 = 50380822;
pub const TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: u32 = 50380823;
pub const TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: u32 = 50380824;
pub const TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: u32 = 50380825;
pub const TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: u32 = 50380826;
pub const TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 50380827;
pub const TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 50380828;
pub const TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: u32 = 50380829;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: u32 = 50380830;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: u32 = 50380831;
pub const TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: u32 = 50380832;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: u32 = 50380833;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: u32 = 50380834;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: u32 = 50380835;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: u32 = 50380836;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: u32 = 50380837;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: u32 = 50380838;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: u32 = 50380839;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: u32 = 50380840;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: u32 = 50380841;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: u32 = 50380842;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380843;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380844;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380845;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380846;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380847;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380848;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380849;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380850;
pub const TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA: u32 = 50380851;
pub const TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50380852;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 50380853;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 50380854;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 50380855;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 50380856;
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA: u32 = 50380857;
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256: u32 = 50380858;
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384: u32 = 50380859;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380914;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380915;
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380916;
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380917;
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380918;
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380919;
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380920;
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380921;
pub const TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380948;
pub const TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380949;
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380950;
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380951;
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380952;
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380953;
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 50380954;
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 50380955;
pub const TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305: u32 = 50384040;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: u32 = 50384041;
pub const TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305: u32 = 50384042;
pub const TLS1_CK_PSK_WITH_CHACHA20_POLY1305: u32 = 50384043;
pub const TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305: u32 = 50384044;
pub const TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305: u32 = 50384045;
pub const TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305: u32 = 50384046;
pub const TLS1_3_CK_AES_128_GCM_SHA256: u32 = 50336513;
pub const TLS1_3_CK_AES_256_GCM_SHA384: u32 = 50336514;
pub const TLS1_3_CK_CHACHA20_POLY1305_SHA256: u32 = 50336515;
pub const TLS1_3_CK_AES_128_CCM_SHA256: u32 = 50336516;
pub const TLS1_3_CK_AES_128_CCM_8_SHA256: u32 = 50336517;
pub const TLS1_CK_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380880;
pub const TLS1_CK_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380881;
pub const TLS1_CK_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380882;
pub const TLS1_CK_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380883;
pub const TLS1_CK_DH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380884;
pub const TLS1_CK_DH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380885;
pub const TLS1_CK_DHE_DSS_WITH_ARIA_128_GCM_SHA256: u32 = 50380886;
pub const TLS1_CK_DHE_DSS_WITH_ARIA_256_GCM_SHA384: u32 = 50380887;
pub const TLS1_CK_DH_DSS_WITH_ARIA_128_GCM_SHA256: u32 = 50380888;
pub const TLS1_CK_DH_DSS_WITH_ARIA_256_GCM_SHA384: u32 = 50380889;
pub const TLS1_CK_DH_anon_WITH_ARIA_128_GCM_SHA256: u32 = 50380890;
pub const TLS1_CK_DH_anon_WITH_ARIA_256_GCM_SHA384: u32 = 50380891;
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380892;
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380893;
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380894;
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380895;
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380896;
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380897;
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 50380898;
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 50380899;
pub const TLS1_CK_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 50380906;
pub const TLS1_CK_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 50380907;
pub const TLS1_CK_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 50380908;
pub const TLS1_CK_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 50380909;
pub const TLS1_CK_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 50380910;
pub const TLS1_CK_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 50380911;
pub const TLS1_RFC_RSA_WITH_AES_128_SHA: &[u8; 29] = b"TLS_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA: &[u8; 33] = b"TLS_DHE_DSS_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA: &[u8; 33] = b"TLS_DHE_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA: &[u8; 33] = b"TLS_DH_anon_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA: &[u8; 29] = b"TLS_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA: &[u8; 33] = b"TLS_DHE_DSS_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA: &[u8; 33] = b"TLS_DHE_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA: &[u8; 33] = b"TLS_DH_anon_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_RSA_WITH_NULL_SHA256: &[u8; 25] = b"TLS_RSA_WITH_NULL_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_128_SHA256: &[u8; 32] = b"TLS_RSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA256: &[u8; 32] = b"TLS_RSA_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA256: &[u8; 36] = b"TLS_DHE_DSS_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA256: &[u8; 36] = b"TLS_DHE_RSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA256: &[u8; 36] = b"TLS_DHE_DSS_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA256: &[u8; 36] = b"TLS_DHE_RSA_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA256: &[u8; 36] = b"TLS_DH_anon_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA256: &[u8; 36] = b"TLS_DH_anon_WITH_AES_256_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_128_GCM_SHA256: &[u8; 32] = b"TLS_RSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_WITH_AES_256_GCM_SHA384: &[u8; 32] = b"TLS_RSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 36] = b"TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 36] = b"TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_GCM_SHA256: &[u8; 36] = b"TLS_DHE_DSS_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_GCM_SHA384: &[u8; 36] = b"TLS_DHE_DSS_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_ADH_WITH_AES_128_GCM_SHA256: &[u8; 36] = b"TLS_DH_anon_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_ADH_WITH_AES_256_GCM_SHA384: &[u8; 36] = b"TLS_DH_anon_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM: &[u8; 25] = b"TLS_RSA_WITH_AES_128_CCM\0";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM: &[u8; 25] = b"TLS_RSA_WITH_AES_256_CCM\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM: &[u8; 29] = b"TLS_DHE_RSA_WITH_AES_128_CCM\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM: &[u8; 29] = b"TLS_DHE_RSA_WITH_AES_256_CCM\0";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM_8: &[u8; 27] = b"TLS_RSA_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM_8: &[u8; 27] = b"TLS_RSA_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM_8: &[u8; 31] = b"TLS_DHE_RSA_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM_8: &[u8; 31] = b"TLS_DHE_RSA_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM: &[u8; 25] = b"TLS_PSK_WITH_AES_128_CCM\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM: &[u8; 25] = b"TLS_PSK_WITH_AES_256_CCM\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM: &[u8; 29] = b"TLS_DHE_PSK_WITH_AES_128_CCM\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM: &[u8; 29] = b"TLS_DHE_PSK_WITH_AES_256_CCM\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM_8: &[u8; 27] = b"TLS_PSK_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM_8: &[u8; 27] = b"TLS_PSK_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM_8: &[u8; 31] = b"TLS_PSK_DHE_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM_8: &[u8; 31] = b"TLS_PSK_DHE_WITH_AES_256_CCM_8\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM: &[u8; 33] = b"TLS_ECDHE_ECDSA_WITH_AES_128_CCM\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM: &[u8; 33] = b"TLS_ECDHE_ECDSA_WITH_AES_256_CCM\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM_8: &[u8; 35] = b"TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM_8: &[u8; 35] = b"TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8\0";
pub const TLS1_3_RFC_AES_128_GCM_SHA256: &[u8; 23] = b"TLS_AES_128_GCM_SHA256\0";
pub const TLS1_3_RFC_AES_256_GCM_SHA384: &[u8; 23] = b"TLS_AES_256_GCM_SHA384\0";
pub const TLS1_3_RFC_CHACHA20_POLY1305_SHA256: &[u8; 29] = b"TLS_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_3_RFC_AES_128_CCM_SHA256: &[u8; 23] = b"TLS_AES_128_CCM_SHA256\0";
pub const TLS1_3_RFC_AES_128_CCM_8_SHA256: &[u8; 25] = b"TLS_AES_128_CCM_8_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_NULL_SHA: &[u8; 30] = b"TLS_ECDHE_ECDSA_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 38] = b"TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 37] = b"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 37] = b"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_NULL_SHA: &[u8; 28] = b"TLS_ECDHE_RSA_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_DES_192_CBC3_SHA: &[u8; 36] = b"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_CBC_SHA: &[u8; 35] = b"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_CBC_SHA: &[u8; 35] = b"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_NULL_SHA: &[u8; 28] = b"TLS_ECDH_anon_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_DES_192_CBC3_SHA: &[u8; 36] = b"TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_AES_128_CBC_SHA: &[u8; 35] = b"TLS_ECDH_anon_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_AES_256_CBC_SHA: &[u8; 35] = b"TLS_ECDH_anon_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_SHA256: &[u8; 40] = b"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_SHA384: &[u8; 40] = b"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_SHA256: &[u8; 38] = b"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_SHA384: &[u8; 38] = b"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 40] = b"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 40] = b"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 38] = b"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 38] = b"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_PSK_WITH_NULL_SHA: &[u8; 22] = b"TLS_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA: &[u8; 26] = b"TLS_DHE_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA: &[u8; 26] = b"TLS_RSA_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 30] = b"TLS_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA: &[u8; 29] = b"TLS_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA: &[u8; 29] = b"TLS_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 34] = b"TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 33] = b"TLS_DHE_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 33] = b"TLS_DHE_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 34] = b"TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA: &[u8; 33] = b"TLS_RSA_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA: &[u8; 33] = b"TLS_RSA_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_PSK_WITH_AES_128_GCM_SHA256: &[u8; 32] = b"TLS_PSK_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_PSK_WITH_AES_256_GCM_SHA384: &[u8; 32] = b"TLS_PSK_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_GCM_SHA256: &[u8; 36] = b"TLS_DHE_PSK_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_GCM_SHA384: &[u8; 36] = b"TLS_DHE_PSK_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_GCM_SHA256: &[u8; 36] = b"TLS_RSA_PSK_WITH_AES_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_GCM_SHA384: &[u8; 36] = b"TLS_RSA_PSK_WITH_AES_256_GCM_SHA384\0";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA256: &[u8; 32] = b"TLS_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA384: &[u8; 32] = b"TLS_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_PSK_WITH_NULL_SHA256: &[u8; 25] = b"TLS_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_PSK_WITH_NULL_SHA384: &[u8; 25] = b"TLS_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 36] = b"TLS_DHE_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 36] = b"TLS_DHE_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA256: &[u8; 29] = b"TLS_DHE_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA384: &[u8; 29] = b"TLS_DHE_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA256: &[u8; 36] = b"TLS_RSA_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA384: &[u8; 36] = b"TLS_RSA_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA256: &[u8; 29] = b"TLS_RSA_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA384: &[u8; 29] = b"TLS_RSA_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 36] = b"TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 35] = b"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 35] = b"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 38] = b"TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 38] = b"TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA: &[u8; 28] = b"TLS_ECDHE_PSK_WITH_NULL_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA256: &[u8; 31] = b"TLS_ECDHE_PSK_WITH_NULL_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA384: &[u8; 31] = b"TLS_ECDHE_PSK_WITH_NULL_SHA384\0";
pub const TLS1_RFC_SRP_SHA_WITH_3DES_EDE_CBC_SHA: &[u8; 34] = b"TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 38] = b"TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: &[u8; 38] = b"TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_WITH_AES_128_CBC_SHA: &[u8; 33] = b"TLS_SRP_SHA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: &[u8; 37] = b"TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: &[u8; 37] = b"TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_WITH_AES_256_CBC_SHA: &[u8; 33] = b"TLS_SRP_SHA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: &[u8; 37] = b"TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: &[u8; 37] = b"TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 42] = b"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 44] = b"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: &[u8; 46] = b"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_PSK_WITH_CHACHA20_POLY1305: &[u8; 38] = b"TLS_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 44] = b"TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 42] = b"TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_CHACHA20_POLY1305: &[u8; 42] = b"TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 37] = b"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41] = b"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41] = b"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41] = b"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 37] = b"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 41] = b"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 41] = b"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 41] = b"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 34] = b"TLS_RSA_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 38] = b"TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 38] = b"TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA: &[u8; 38] = b"TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA\0";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 34] = b"TLS_RSA_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 38] = b"TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 38] = b"TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA: &[u8; 38] = b"TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 45] =
    b"TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 45] =
    b"TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 43] = b"TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 43] = b"TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 37] = b"TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 37] = b"TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41] = b"TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 41] = b"TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 41] = b"TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 41] = b"TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 43] = b"TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 43] = b"TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384\0";
pub const TLS1_RFC_RSA_WITH_SEED_SHA: &[u8; 26] = b"TLS_RSA_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_DHE_DSS_WITH_SEED_SHA: &[u8; 30] = b"TLS_DHE_DSS_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_DHE_RSA_WITH_SEED_SHA: &[u8; 30] = b"TLS_DHE_RSA_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_ADH_WITH_SEED_SHA: &[u8; 30] = b"TLS_DH_anon_WITH_SEED_CBC_SHA\0";
pub const TLS1_RFC_ECDHE_PSK_WITH_RC4_128_SHA: &[u8; 31] = b"TLS_ECDHE_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_ECDH_anon_WITH_RC4_128_SHA: &[u8; 31] = b"TLS_ECDH_anon_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_RC4_128_SHA: &[u8; 33] = b"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_RC4_128_SHA: &[u8; 31] = b"TLS_ECDHE_RSA_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_PSK_WITH_RC4_128_SHA: &[u8; 25] = b"TLS_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_RSA_PSK_WITH_RC4_128_SHA: &[u8; 29] = b"TLS_RSA_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_DHE_PSK_WITH_RC4_128_SHA: &[u8; 29] = b"TLS_DHE_PSK_WITH_RC4_128_SHA\0";
pub const TLS1_RFC_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 33] = b"TLS_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 33] = b"TLS_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 37] = b"TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 37] = b"TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 36] = b"TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 36] = b"TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 37] = b"TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 37] = b"TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 36] = b"TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 36] = b"TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DH_anon_WITH_ARIA_128_GCM_SHA256: &[u8; 37] = b"TLS_DH_anon_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DH_anon_WITH_ARIA_256_GCM_SHA384: &[u8; 37] = b"TLS_DH_anon_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 41] = b"TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 41] = b"TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 40] = b"TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 40] = b"TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 39] = b"TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 39] = b"TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 38] = b"TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 38] = b"TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 33] = b"TLS_PSK_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 33] = b"TLS_PSK_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 37] = b"TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 37] = b"TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 37] = b"TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256\0";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 37] = b"TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA: &[u8; 16] = b"DHE-DSS-RC4-SHA\0";
pub const TLS1_TXT_PSK_WITH_NULL_SHA: &[u8; 13] = b"PSK-NULL-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA: &[u8; 17] = b"DHE-PSK-NULL-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA: &[u8; 17] = b"RSA-PSK-NULL-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA: &[u8; 11] = b"AES128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA: &[u8; 18] = b"DH-DSS-AES128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA: &[u8; 18] = b"DH-RSA-AES128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA: &[u8; 19] = b"DHE-DSS-AES128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA: &[u8; 19] = b"DHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA: &[u8; 15] = b"ADH-AES128-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA: &[u8; 11] = b"AES256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA: &[u8; 18] = b"DH-DSS-AES256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA: &[u8; 18] = b"DH-RSA-AES256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA: &[u8; 19] = b"DHE-DSS-AES256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA: &[u8; 19] = b"DHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA: &[u8; 15] = b"ADH-AES256-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_NULL_SHA: &[u8; 20] = b"ECDH-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA: &[u8; 19] = b"ECDH-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 24] = b"ECDH-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 22] = b"ECDH-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 22] = b"ECDH-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_NULL_SHA: &[u8; 21] = b"ECDHE-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA: &[u8; 20] = b"ECDHE-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 25] = b"ECDHE-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 23] = b"ECDHE-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 23] = b"ECDHE-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_NULL_SHA: &[u8; 18] = b"ECDH-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA: &[u8; 17] = b"ECDH-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA: &[u8; 22] = b"ECDH-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_CBC_SHA: &[u8; 20] = b"ECDH-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_CBC_SHA: &[u8; 20] = b"ECDH-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_NULL_SHA: &[u8; 19] = b"ECDHE-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA: &[u8; 18] = b"ECDHE-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA: &[u8; 23] = b"ECDHE-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA: &[u8; 21] = b"ECDHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA: &[u8; 21] = b"ECDHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_NULL_SHA: &[u8; 15] = b"AECDH-NULL-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA: &[u8; 14] = b"AECDH-RC4-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA: &[u8; 19] = b"AECDH-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_128_CBC_SHA: &[u8; 17] = b"AECDH-AES128-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_256_CBC_SHA: &[u8; 17] = b"AECDH-AES256-SHA\0";
pub const TLS1_TXT_PSK_WITH_RC4_128_SHA: &[u8; 12] = b"PSK-RC4-SHA\0";
pub const TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 21] = b"PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA: &[u8; 19] = b"PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA: &[u8; 19] = b"PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_RC4_128_SHA: &[u8; 16] = b"DHE-PSK-RC4-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 25] = b"DHE-PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 23] = b"DHE-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 23] = b"DHE-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_RC4_128_SHA: &[u8; 16] = b"RSA-PSK-RC4-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 25] = b"RSA-PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA: &[u8; 23] = b"RSA-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA: &[u8; 23] = b"RSA-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_128_GCM_SHA256: &[u8; 22] = b"PSK-AES128-GCM-SHA256\0";
pub const TLS1_TXT_PSK_WITH_AES_256_GCM_SHA384: &[u8; 22] = b"PSK-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_GCM_SHA256: &[u8; 26] = b"DHE-PSK-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_GCM_SHA384: &[u8; 26] = b"DHE-PSK-AES256-GCM-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_GCM_SHA256: &[u8; 26] = b"RSA-PSK-AES128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_GCM_SHA384: &[u8; 26] = b"RSA-PSK-AES256-GCM-SHA384\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA256: &[u8; 22] = b"PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA384: &[u8; 22] = b"PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_PSK_WITH_NULL_SHA256: &[u8; 16] = b"PSK-NULL-SHA256\0";
pub const TLS1_TXT_PSK_WITH_NULL_SHA384: &[u8; 16] = b"PSK-NULL-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 26] = b"DHE-PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 26] = b"DHE-PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA256: &[u8; 20] = b"DHE-PSK-NULL-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA384: &[u8; 20] = b"DHE-PSK-NULL-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA256: &[u8; 26] = b"RSA-PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA384: &[u8; 26] = b"RSA-PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA256: &[u8; 20] = b"RSA-PSK-NULL-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA384: &[u8; 20] = b"RSA-PSK-NULL-SHA384\0";
pub const TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA: &[u8; 21] = b"SRP-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 25] = b"SRP-RSA-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: &[u8; 25] = b"SRP-DSS-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_128_CBC_SHA: &[u8; 20] = b"SRP-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: &[u8; 24] = b"SRP-RSA-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: &[u8; 24] = b"SRP-DSS-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_256_CBC_SHA: &[u8; 20] = b"SRP-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: &[u8; 24] = b"SRP-RSA-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: &[u8; 24] = b"SRP-DSS-AES-256-CBC-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 16] = b"CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 23] = b"DH-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 23] = b"DH-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 24] = b"DHE-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 24] = b"DHE-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA: &[u8; 20] = b"ADH-CAMELLIA128-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 16] = b"CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 23] = b"DH-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 23] = b"DH-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 24] = b"DHE-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 24] = b"DHE-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA: &[u8; 20] = b"ADH-CAMELLIA256-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 19] = b"CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 26] = b"DH-DSS-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 26] = b"DH-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27] = b"DHE-DSS-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27] = b"DHE-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 23] = b"ADH-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 19] = b"CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 26] = b"DH-DSS-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 26] = b"DH-RSA-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 27] = b"DHE-DSS-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 27] = b"DHE-RSA-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA256: &[u8; 23] = b"ADH-CAMELLIA256-SHA256\0";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 23] = b"PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 23] = b"PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27] = b"DHE-PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 27] = b"DHE-PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 27] = b"RSA-PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 27] = b"RSA-PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 29] = b"ECDHE-PSK-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 29] = b"ECDHE-PSK-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_RSA_WITH_SEED_SHA: &[u8; 9] = b"SEED-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_SEED_SHA: &[u8; 16] = b"DH-DSS-SEED-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_SEED_SHA: &[u8; 16] = b"DH-RSA-SEED-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_SEED_SHA: &[u8; 17] = b"DHE-DSS-SEED-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_SEED_SHA: &[u8; 17] = b"DHE-RSA-SEED-SHA\0";
pub const TLS1_TXT_ADH_WITH_SEED_SHA: &[u8; 13] = b"ADH-SEED-SHA\0";
pub const TLS1_TXT_RSA_WITH_NULL_SHA256: &[u8; 12] = b"NULL-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA256: &[u8; 14] = b"AES128-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA256: &[u8; 14] = b"AES256-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA256: &[u8; 21] = b"DH-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA256: &[u8; 21] = b"DH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA256: &[u8; 22] = b"DHE-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256: &[u8; 22] = b"DHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA256: &[u8; 21] = b"DH-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA256: &[u8; 21] = b"DH-RSA-AES256-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA256: &[u8; 22] = b"DHE-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256: &[u8; 22] = b"DHE-RSA-AES256-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA256: &[u8; 18] = b"ADH-AES128-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA256: &[u8; 18] = b"ADH-AES256-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_GCM_SHA256: &[u8; 18] = b"AES128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_GCM_SHA384: &[u8; 18] = b"AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 26] = b"DHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 26] = b"DHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_GCM_SHA256: &[u8; 25] = b"DH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_GCM_SHA384: &[u8; 25] = b"DH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_GCM_SHA256: &[u8; 26] = b"DHE-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_GCM_SHA384: &[u8; 26] = b"DHE-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_GCM_SHA256: &[u8; 25] = b"DH-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_GCM_SHA384: &[u8; 25] = b"DH-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ADH_WITH_AES_128_GCM_SHA256: &[u8; 22] = b"ADH-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_GCM_SHA384: &[u8; 22] = b"ADH-AES256-GCM-SHA384\0";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM: &[u8; 11] = b"AES128-CCM\0";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM: &[u8; 11] = b"AES256-CCM\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM: &[u8; 19] = b"DHE-RSA-AES128-CCM\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM: &[u8; 19] = b"DHE-RSA-AES256-CCM\0";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM_8: &[u8; 12] = b"AES128-CCM8\0";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM_8: &[u8; 12] = b"AES256-CCM8\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM_8: &[u8; 20] = b"DHE-RSA-AES128-CCM8\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM_8: &[u8; 20] = b"DHE-RSA-AES256-CCM8\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM: &[u8; 15] = b"PSK-AES128-CCM\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM: &[u8; 15] = b"PSK-AES256-CCM\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM: &[u8; 19] = b"DHE-PSK-AES128-CCM\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM: &[u8; 19] = b"DHE-PSK-AES256-CCM\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM_8: &[u8; 16] = b"PSK-AES128-CCM8\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM_8: &[u8; 16] = b"PSK-AES256-CCM8\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM_8: &[u8; 20] = b"DHE-PSK-AES128-CCM8\0";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM_8: &[u8; 20] = b"DHE-PSK-AES256-CCM8\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM: &[u8; 23] = b"ECDHE-ECDSA-AES128-CCM\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM: &[u8; 23] = b"ECDHE-ECDSA-AES256-CCM\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM_8: &[u8; 24] = b"ECDHE-ECDSA-AES128-CCM8\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM_8: &[u8; 24] = b"ECDHE-ECDSA-AES256-CCM8\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256: &[u8; 26] = b"ECDHE-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384: &[u8; 26] = b"ECDHE-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_SHA256: &[u8; 25] = b"ECDH-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_SHA384: &[u8; 25] = b"ECDH-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_SHA256: &[u8; 24] = b"ECDHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384: &[u8; 24] = b"ECDHE-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_SHA256: &[u8; 23] = b"ECDH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_SHA384: &[u8; 23] = b"ECDH-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 30] = b"ECDHE-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 30] = b"ECDHE-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 29] = b"ECDH-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 29] = b"ECDH-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 28] = b"ECDHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 28] = b"ECDHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256: &[u8; 27] = b"ECDH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384: &[u8; 27] = b"ECDH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_RC4_128_SHA: &[u8; 18] = b"ECDHE-PSK-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 27] = b"ECDHE-PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 25] = b"ECDHE-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 25] = b"ECDHE-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA256: &[u8; 28] = b"ECDHE-PSK-AES128-CBC-SHA256\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA384: &[u8; 28] = b"ECDHE-PSK-AES256-CBC-SHA384\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA: &[u8; 19] = b"ECDHE-PSK-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA256: &[u8; 22] = b"ECDHE-PSK-NULL-SHA256\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA384: &[u8; 22] = b"ECDHE-PSK-NULL-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 31] = b"ECDHE-ECDSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 31] = b"ECDHE-ECDSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 30] = b"ECDH-ECDSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 30] = b"ECDH-ECDSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 29] = b"ECDHE-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 29] = b"ECDHE-RSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: &[u8; 28] = b"ECDH-RSA-CAMELLIA128-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: &[u8; 28] = b"ECDH-RSA-CAMELLIA256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 28] = b"ECDHE-RSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: &[u8; 30] = b"ECDHE-ECDSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_DHE_RSA_WITH_CHACHA20_POLY1305: &[u8; 26] = b"DHE-RSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_PSK_WITH_CHACHA20_POLY1305: &[u8; 22] = b"PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 28] = b"ECDHE-PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_DHE_PSK_WITH_CHACHA20_POLY1305: &[u8; 26] = b"DHE-PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_RSA_PSK_WITH_CHACHA20_POLY1305: &[u8; 26] = b"RSA-PSK-CHACHA20-POLY1305\0";
pub const TLS1_TXT_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 19] = b"ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 19] = b"ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 27] = b"DHE-RSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 27] = b"DHE-RSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 26] = b"DH-RSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 26] = b"DH-RSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 27] = b"DHE-DSS-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 27] = b"DHE-DSS-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_128_GCM_SHA256: &[u8; 26] = b"DH-DSS-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_256_GCM_SHA384: &[u8; 26] = b"DH-DSS-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DH_anon_WITH_ARIA_128_GCM_SHA256: &[u8; 23] = b"ADH-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DH_anon_WITH_ARIA_256_GCM_SHA384: &[u8; 23] = b"ADH-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 31] = b"ECDHE-ECDSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 31] = b"ECDHE-ECDSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: &[u8; 30] = b"ECDH-ECDSA-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: &[u8; 30] = b"ECDH-ECDSA-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 25] = b"ECDHE-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 25] = b"ECDHE-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: &[u8; 24] = b"ECDH-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: &[u8; 24] = b"ECDH-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 23] = b"PSK-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 23] = b"PSK-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 27] = b"DHE-PSK-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 27] = b"DHE-PSK-ARIA256-GCM-SHA384\0";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_128_GCM_SHA256: &[u8; 27] = b"RSA-PSK-ARIA128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_256_GCM_SHA384: &[u8; 27] = b"RSA-PSK-ARIA256-GCM-SHA384\0";
pub const TLS_CT_RSA_SIGN: u32 = 1;
pub const TLS_CT_DSS_SIGN: u32 = 2;
pub const TLS_CT_RSA_FIXED_DH: u32 = 3;
pub const TLS_CT_DSS_FIXED_DH: u32 = 4;
pub const TLS_CT_ECDSA_SIGN: u32 = 64;
pub const TLS_CT_RSA_FIXED_ECDH: u32 = 65;
pub const TLS_CT_ECDSA_FIXED_ECDH: u32 = 66;
pub const TLS_CT_GOST01_SIGN: u32 = 22;
pub const TLS_CT_GOST12_IANA_SIGN: u32 = 67;
pub const TLS_CT_GOST12_IANA_512_SIGN: u32 = 68;
pub const TLS_CT_GOST12_LEGACY_SIGN: u32 = 238;
pub const TLS_CT_GOST12_LEGACY_512_SIGN: u32 = 239;
pub const TLS_CT_GOST12_SIGN: u32 = 238;
pub const TLS_CT_GOST12_512_SIGN: u32 = 239;
pub const TLS_CT_NUMBER: u32 = 12;
pub const TLS1_FINISH_MAC_LENGTH: u32 = 12;
pub const TLS_MD_MAX_CONST_SIZE: u32 = 22;
pub const TLS_MD_CLIENT_FINISH_CONST: &[u8; 16] = b"client finished\0";
pub const TLS_MD_CLIENT_FINISH_CONST_SIZE: u32 = 15;
pub const TLS_MD_SERVER_FINISH_CONST: &[u8; 16] = b"server finished\0";
pub const TLS_MD_SERVER_FINISH_CONST_SIZE: u32 = 15;
pub const TLS_MD_SERVER_WRITE_KEY_CONST: &[u8; 17] = b"server write key\0";
pub const TLS_MD_SERVER_WRITE_KEY_CONST_SIZE: u32 = 16;
pub const TLS_MD_KEY_EXPANSION_CONST: &[u8; 14] = b"key expansion\0";
pub const TLS_MD_KEY_EXPANSION_CONST_SIZE: u32 = 13;
pub const TLS_MD_CLIENT_WRITE_KEY_CONST: &[u8; 17] = b"client write key\0";
pub const TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE: u32 = 16;
pub const TLS_MD_IV_BLOCK_CONST: &[u8; 9] = b"IV block\0";
pub const TLS_MD_IV_BLOCK_CONST_SIZE: u32 = 8;
pub const TLS_MD_MASTER_SECRET_CONST: &[u8; 14] = b"master secret\0";
pub const TLS_MD_MASTER_SECRET_CONST_SIZE: u32 = 13;
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST: &[u8; 23] = b"extended master secret\0";
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE: u32 = 22;
pub const DTLS_MIN_VERSION: u32 = 65279;
pub const DTLS_MAX_VERSION: u32 = 65277;
pub const DTLS1_VERSION_MAJOR: u32 = 254;
pub const DTLS_ANY_VERSION: u32 = 131071;
pub const DTLS1_COOKIE_LENGTH: u32 = 255;
pub const DTLS1_RT_HEADER_LENGTH: u32 = 13;
pub const DTLS1_HM_HEADER_LENGTH: u32 = 12;
pub const DTLS1_HM_BAD_FRAGMENT: i32 = -2;
pub const DTLS1_HM_FRAGMENT_RETRY: i32 = -3;
pub const DTLS1_CCS_HEADER_LENGTH: u32 = 1;
pub const DTLS1_AL_HEADER_LENGTH: u32 = 2;
pub const DTLS1_TMO_ALERT_COUNT: u32 = 12;
pub const SRTP_AES128_CM_SHA1_80: u32 = 1;
pub const SRTP_AES128_CM_SHA1_32: u32 = 2;
pub const SRTP_AES128_F8_SHA1_80: u32 = 3;
pub const SRTP_AES128_F8_SHA1_32: u32 = 4;
pub const SRTP_NULL_SHA1_80: u32 = 5;
pub const SRTP_NULL_SHA1_32: u32 = 6;
pub const SRTP_AEAD_AES_128_GCM: u32 = 7;
pub const SRTP_AEAD_AES_256_GCM: u32 = 8;
pub const SSL_KEY_UPDATE_NONE: i32 = -1;
pub const SSL_KEY_UPDATE_NOT_REQUESTED: u32 = 0;
pub const SSL_KEY_UPDATE_REQUESTED: u32 = 1;
pub const SSL_ST_CONNECT: u32 = 4096;
pub const SSL_ST_ACCEPT: u32 = 8192;
pub const SSL_ST_MASK: u32 = 4095;
pub const SSL_CB_LOOP: u32 = 1;
pub const SSL_CB_EXIT: u32 = 2;
pub const SSL_CB_READ: u32 = 4;
pub const SSL_CB_WRITE: u32 = 8;
pub const SSL_CB_ALERT: u32 = 16384;
pub const SSL_CB_READ_ALERT: u32 = 16388;
pub const SSL_CB_WRITE_ALERT: u32 = 16392;
pub const SSL_CB_ACCEPT_LOOP: u32 = 8193;
pub const SSL_CB_ACCEPT_EXIT: u32 = 8194;
pub const SSL_CB_CONNECT_LOOP: u32 = 4097;
pub const SSL_CB_CONNECT_EXIT: u32 = 4098;
pub const SSL_CB_HANDSHAKE_START: u32 = 16;
pub const SSL_CB_HANDSHAKE_DONE: u32 = 32;
pub const SSL_ST_READ_HEADER: u32 = 240;
pub const SSL_ST_READ_BODY: u32 = 241;
pub const SSL_ST_READ_DONE: u32 = 242;
pub const SSL_VERIFY_NONE: u32 = 0;
pub const SSL_VERIFY_PEER: u32 = 1;
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT: u32 = 2;
pub const SSL_VERIFY_CLIENT_ONCE: u32 = 4;
pub const SSL_VERIFY_POST_HANDSHAKE: u32 = 8;
pub const SSL_AD_REASON_OFFSET: u32 = 1000;
pub const SSL_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL_AD_DECRYPTION_FAILED: u32 = 21;
pub const SSL_AD_RECORD_OVERFLOW: u32 = 22;
pub const SSL_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_AD_UNKNOWN_CA: u32 = 48;
pub const SSL_AD_ACCESS_DENIED: u32 = 49;
pub const SSL_AD_DECODE_ERROR: u32 = 50;
pub const SSL_AD_DECRYPT_ERROR: u32 = 51;
pub const SSL_AD_EXPORT_RESTRICTION: u32 = 60;
pub const SSL_AD_PROTOCOL_VERSION: u32 = 70;
pub const SSL_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const SSL_AD_INTERNAL_ERROR: u32 = 80;
pub const SSL_AD_USER_CANCELLED: u32 = 90;
pub const SSL_AD_NO_RENEGOTIATION: u32 = 100;
pub const SSL_AD_MISSING_EXTENSION: u32 = 109;
pub const SSL_AD_CERTIFICATE_REQUIRED: u32 = 116;
pub const SSL_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const SSL_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const SSL_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const SSL_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const SSL_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const SSL_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const SSL_AD_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const SSL_ERROR_NONE: u32 = 0;
pub const SSL_ERROR_SSL: u32 = 1;
pub const SSL_ERROR_WANT_READ: u32 = 2;
pub const SSL_ERROR_WANT_WRITE: u32 = 3;
pub const SSL_ERROR_WANT_X509_LOOKUP: u32 = 4;
pub const SSL_ERROR_SYSCALL: u32 = 5;
pub const SSL_ERROR_ZERO_RETURN: u32 = 6;
pub const SSL_ERROR_WANT_CONNECT: u32 = 7;
pub const SSL_ERROR_WANT_ACCEPT: u32 = 8;
pub const SSL_ERROR_WANT_ASYNC: u32 = 9;
pub const SSL_ERROR_WANT_ASYNC_JOB: u32 = 10;
pub const SSL_ERROR_WANT_CLIENT_HELLO_CB: u32 = 11;
pub const SSL_ERROR_WANT_RETRY_VERIFY: u32 = 12;
pub const SSL_CTRL_SET_TMP_DH: u32 = 3;
pub const SSL_CTRL_SET_TMP_ECDH: u32 = 4;
pub const SSL_CTRL_SET_TMP_DH_CB: u32 = 6;
pub const SSL_CTRL_GET_CLIENT_CERT_REQUEST: u32 = 9;
pub const SSL_CTRL_GET_NUM_RENEGOTIATIONS: u32 = 10;
pub const SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS: u32 = 11;
pub const SSL_CTRL_GET_TOTAL_RENEGOTIATIONS: u32 = 12;
pub const SSL_CTRL_GET_FLAGS: u32 = 13;
pub const SSL_CTRL_EXTRA_CHAIN_CERT: u32 = 14;
pub const SSL_CTRL_SET_MSG_CALLBACK: u32 = 15;
pub const SSL_CTRL_SET_MSG_CALLBACK_ARG: u32 = 16;
pub const SSL_CTRL_SET_MTU: u32 = 17;
pub const SSL_CTRL_SESS_NUMBER: u32 = 20;
pub const SSL_CTRL_SESS_CONNECT: u32 = 21;
pub const SSL_CTRL_SESS_CONNECT_GOOD: u32 = 22;
pub const SSL_CTRL_SESS_CONNECT_RENEGOTIATE: u32 = 23;
pub const SSL_CTRL_SESS_ACCEPT: u32 = 24;
pub const SSL_CTRL_SESS_ACCEPT_GOOD: u32 = 25;
pub const SSL_CTRL_SESS_ACCEPT_RENEGOTIATE: u32 = 26;
pub const SSL_CTRL_SESS_HIT: u32 = 27;
pub const SSL_CTRL_SESS_CB_HIT: u32 = 28;
pub const SSL_CTRL_SESS_MISSES: u32 = 29;
pub const SSL_CTRL_SESS_TIMEOUTS: u32 = 30;
pub const SSL_CTRL_SESS_CACHE_FULL: u32 = 31;
pub const SSL_CTRL_MODE: u32 = 33;
pub const SSL_CTRL_GET_READ_AHEAD: u32 = 40;
pub const SSL_CTRL_SET_READ_AHEAD: u32 = 41;
pub const SSL_CTRL_SET_SESS_CACHE_SIZE: u32 = 42;
pub const SSL_CTRL_GET_SESS_CACHE_SIZE: u32 = 43;
pub const SSL_CTRL_SET_SESS_CACHE_MODE: u32 = 44;
pub const SSL_CTRL_GET_SESS_CACHE_MODE: u32 = 45;
pub const SSL_CTRL_GET_MAX_CERT_LIST: u32 = 50;
pub const SSL_CTRL_SET_MAX_CERT_LIST: u32 = 51;
pub const SSL_CTRL_SET_MAX_SEND_FRAGMENT: u32 = 52;
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_CB: u32 = 53;
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG: u32 = 54;
pub const SSL_CTRL_SET_TLSEXT_HOSTNAME: u32 = 55;
pub const SSL_CTRL_SET_TLSEXT_DEBUG_CB: u32 = 56;
pub const SSL_CTRL_SET_TLSEXT_DEBUG_ARG: u32 = 57;
pub const SSL_CTRL_GET_TLSEXT_TICKET_KEYS: u32 = 58;
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEYS: u32 = 59;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB: u32 = 63;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG: u32 = 64;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE: u32 = 65;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS: u32 = 66;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS: u32 = 67;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS: u32 = 68;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS: u32 = 69;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP: u32 = 70;
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP: u32 = 71;
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB: u32 = 72;
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB: u32 = 75;
pub const SSL_CTRL_SET_SRP_VERIFY_PARAM_CB: u32 = 76;
pub const SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB: u32 = 77;
pub const SSL_CTRL_SET_SRP_ARG: u32 = 78;
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME: u32 = 79;
pub const SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH: u32 = 80;
pub const SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD: u32 = 81;
pub const DTLS_CTRL_GET_TIMEOUT: u32 = 73;
pub const DTLS_CTRL_HANDLE_TIMEOUT: u32 = 74;
pub const SSL_CTRL_GET_RI_SUPPORT: u32 = 76;
pub const SSL_CTRL_CLEAR_MODE: u32 = 78;
pub const SSL_CTRL_SET_NOT_RESUMABLE_SESS_CB: u32 = 79;
pub const SSL_CTRL_GET_EXTRA_CHAIN_CERTS: u32 = 82;
pub const SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS: u32 = 83;
pub const SSL_CTRL_CHAIN: u32 = 88;
pub const SSL_CTRL_CHAIN_CERT: u32 = 89;
pub const SSL_CTRL_GET_GROUPS: u32 = 90;
pub const SSL_CTRL_SET_GROUPS: u32 = 91;
pub const SSL_CTRL_SET_GROUPS_LIST: u32 = 92;
pub const SSL_CTRL_GET_SHARED_GROUP: u32 = 93;
pub const SSL_CTRL_SET_SIGALGS: u32 = 97;
pub const SSL_CTRL_SET_SIGALGS_LIST: u32 = 98;
pub const SSL_CTRL_CERT_FLAGS: u32 = 99;
pub const SSL_CTRL_CLEAR_CERT_FLAGS: u32 = 100;
pub const SSL_CTRL_SET_CLIENT_SIGALGS: u32 = 101;
pub const SSL_CTRL_SET_CLIENT_SIGALGS_LIST: u32 = 102;
pub const SSL_CTRL_GET_CLIENT_CERT_TYPES: u32 = 103;
pub const SSL_CTRL_SET_CLIENT_CERT_TYPES: u32 = 104;
pub const SSL_CTRL_BUILD_CERT_CHAIN: u32 = 105;
pub const SSL_CTRL_SET_VERIFY_CERT_STORE: u32 = 106;
pub const SSL_CTRL_SET_CHAIN_CERT_STORE: u32 = 107;
pub const SSL_CTRL_GET_PEER_SIGNATURE_NID: u32 = 108;
pub const SSL_CTRL_GET_PEER_TMP_KEY: u32 = 109;
pub const SSL_CTRL_GET_RAW_CIPHERLIST: u32 = 110;
pub const SSL_CTRL_GET_EC_POINT_FORMATS: u32 = 111;
pub const SSL_CTRL_GET_CHAIN_CERTS: u32 = 115;
pub const SSL_CTRL_SELECT_CURRENT_CERT: u32 = 116;
pub const SSL_CTRL_SET_CURRENT_CERT: u32 = 117;
pub const SSL_CTRL_SET_DH_AUTO: u32 = 118;
pub const DTLS_CTRL_SET_LINK_MTU: u32 = 120;
pub const DTLS_CTRL_GET_LINK_MIN_MTU: u32 = 121;
pub const SSL_CTRL_GET_EXTMS_SUPPORT: u32 = 122;
pub const SSL_CTRL_SET_MIN_PROTO_VERSION: u32 = 123;
pub const SSL_CTRL_SET_MAX_PROTO_VERSION: u32 = 124;
pub const SSL_CTRL_SET_SPLIT_SEND_FRAGMENT: u32 = 125;
pub const SSL_CTRL_SET_MAX_PIPELINES: u32 = 126;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE: u32 = 127;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB: u32 = 128;
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG: u32 = 129;
pub const SSL_CTRL_GET_MIN_PROTO_VERSION: u32 = 130;
pub const SSL_CTRL_GET_MAX_PROTO_VERSION: u32 = 131;
pub const SSL_CTRL_GET_SIGNATURE_NID: u32 = 132;
pub const SSL_CTRL_GET_TMP_KEY: u32 = 133;
pub const SSL_CTRL_GET_NEGOTIATED_GROUP: u32 = 134;
pub const SSL_CTRL_SET_RETRY_VERIFY: u32 = 136;
pub const SSL_CTRL_GET_VERIFY_CERT_STORE: u32 = 137;
pub const SSL_CTRL_GET_CHAIN_CERT_STORE: u32 = 138;
pub const SSL_CERT_SET_FIRST: u32 = 1;
pub const SSL_CERT_SET_NEXT: u32 = 2;
pub const SSL_CERT_SET_SERVER: u32 = 3;
pub const SSL_CTRL_GET_SERVER_TMP_KEY: u32 = 109;
pub const SSL_CTRL_GET_CURVES: u32 = 90;
pub const SSL_CTRL_SET_CURVES: u32 = 91;
pub const SSL_CTRL_SET_CURVES_LIST: u32 = 92;
pub const SSL_CTRL_GET_SHARED_CURVE: u32 = 93;
pub const SSL_SERVERINFOV1: u32 = 1;
pub const SSL_SERVERINFOV2: u32 = 2;
pub const SSL_CLIENT_HELLO_SUCCESS: u32 = 1;
pub const SSL_CLIENT_HELLO_ERROR: u32 = 0;
pub const SSL_CLIENT_HELLO_RETRY: i32 = -1;
pub const SSL_READ_EARLY_DATA_ERROR: u32 = 0;
pub const SSL_READ_EARLY_DATA_SUCCESS: u32 = 1;
pub const SSL_READ_EARLY_DATA_FINISH: u32 = 2;
pub const SSL_EARLY_DATA_NOT_SENT: u32 = 0;
pub const SSL_EARLY_DATA_REJECTED: u32 = 1;
pub const SSL_EARLY_DATA_ACCEPTED: u32 = 2;
pub const SSL_SECOP_OTHER_TYPE: u32 = 4294901760;
pub const SSL_SECOP_OTHER_NONE: u32 = 0;
pub const SSL_SECOP_OTHER_CIPHER: u32 = 65536;
pub const SSL_SECOP_OTHER_CURVE: u32 = 131072;
pub const SSL_SECOP_OTHER_DH: u32 = 196608;
pub const SSL_SECOP_OTHER_PKEY: u32 = 262144;
pub const SSL_SECOP_OTHER_SIGALG: u32 = 327680;
pub const SSL_SECOP_OTHER_CERT: u32 = 393216;
pub const SSL_SECOP_PEER: u32 = 4096;
pub const SSL_SECOP_CIPHER_SUPPORTED: u32 = 65537;
pub const SSL_SECOP_CIPHER_SHARED: u32 = 65538;
pub const SSL_SECOP_CIPHER_CHECK: u32 = 65539;
pub const SSL_SECOP_CURVE_SUPPORTED: u32 = 131076;
pub const SSL_SECOP_CURVE_SHARED: u32 = 131077;
pub const SSL_SECOP_CURVE_CHECK: u32 = 131078;
pub const SSL_SECOP_TMP_DH: u32 = 262151;
pub const SSL_SECOP_VERSION: u32 = 9;
pub const SSL_SECOP_TICKET: u32 = 10;
pub const SSL_SECOP_SIGALG_SUPPORTED: u32 = 327691;
pub const SSL_SECOP_SIGALG_SHARED: u32 = 327692;
pub const SSL_SECOP_SIGALG_CHECK: u32 = 327693;
pub const SSL_SECOP_SIGALG_MASK: u32 = 327694;
pub const SSL_SECOP_COMPRESSION: u32 = 15;
pub const SSL_SECOP_EE_KEY: u32 = 393232;
pub const SSL_SECOP_CA_KEY: u32 = 393233;
pub const SSL_SECOP_CA_MD: u32 = 393234;
pub const SSL_SECOP_PEER_EE_KEY: u32 = 397328;
pub const SSL_SECOP_PEER_CA_KEY: u32 = 397329;
pub const SSL_SECOP_PEER_CA_MD: u32 = 397330;
pub const OPENSSL_INIT_NO_LOAD_SSL_STRINGS: u32 = 1048576;
pub const OPENSSL_INIT_LOAD_SSL_STRINGS: u32 = 2097152;
pub const OPENSSL_INIT_SSL_DEFAULT: u32 = 2097154;
pub const SSL_TICKET_FATAL_ERR_MALLOC: u32 = 0;
pub const SSL_TICKET_FATAL_ERR_OTHER: u32 = 1;
pub const SSL_TICKET_NONE: u32 = 2;
pub const SSL_TICKET_EMPTY: u32 = 3;
pub const SSL_TICKET_NO_DECRYPT: u32 = 4;
pub const SSL_TICKET_SUCCESS: u32 = 5;
pub const SSL_TICKET_SUCCESS_RENEW: u32 = 6;
pub const SSL_TICKET_RETURN_ABORT: u32 = 0;
pub const SSL_TICKET_RETURN_IGNORE: u32 = 1;
pub const SSL_TICKET_RETURN_IGNORE_RENEW: u32 = 2;
pub const SSL_TICKET_RETURN_USE: u32 = 3;
pub const SSL_TICKET_RETURN_USE_RENEW: u32 = 4;
pub const ERR_TXT_MALLOCED: u32 = 1;
pub const ERR_TXT_STRING: u32 = 2;
pub const ERR_FLAG_MARK: u32 = 1;
pub const ERR_FLAG_CLEAR: u32 = 2;
pub const ERR_NUM_ERRORS: u32 = 16;
pub const ERR_LIB_NONE: u32 = 1;
pub const ERR_LIB_SYS: u32 = 2;
pub const ERR_LIB_BN: u32 = 3;
pub const ERR_LIB_RSA: u32 = 4;
pub const ERR_LIB_DH: u32 = 5;
pub const ERR_LIB_EVP: u32 = 6;
pub const ERR_LIB_BUF: u32 = 7;
pub const ERR_LIB_OBJ: u32 = 8;
pub const ERR_LIB_PEM: u32 = 9;
pub const ERR_LIB_DSA: u32 = 10;
pub const ERR_LIB_X509: u32 = 11;
pub const ERR_LIB_ASN1: u32 = 13;
pub const ERR_LIB_CONF: u32 = 14;
pub const ERR_LIB_CRYPTO: u32 = 15;
pub const ERR_LIB_EC: u32 = 16;
pub const ERR_LIB_SSL: u32 = 20;
pub const ERR_LIB_BIO: u32 = 32;
pub const ERR_LIB_PKCS7: u32 = 33;
pub const ERR_LIB_X509V3: u32 = 34;
pub const ERR_LIB_PKCS12: u32 = 35;
pub const ERR_LIB_RAND: u32 = 36;
pub const ERR_LIB_DSO: u32 = 37;
pub const ERR_LIB_ENGINE: u32 = 38;
pub const ERR_LIB_OCSP: u32 = 39;
pub const ERR_LIB_UI: u32 = 40;
pub const ERR_LIB_COMP: u32 = 41;
pub const ERR_LIB_ECDSA: u32 = 42;
pub const ERR_LIB_ECDH: u32 = 43;
pub const ERR_LIB_OSSL_STORE: u32 = 44;
pub const ERR_LIB_FIPS: u32 = 45;
pub const ERR_LIB_CMS: u32 = 46;
pub const ERR_LIB_TS: u32 = 47;
pub const ERR_LIB_HMAC: u32 = 48;
pub const ERR_LIB_CT: u32 = 50;
pub const ERR_LIB_ASYNC: u32 = 51;
pub const ERR_LIB_KDF: u32 = 52;
pub const ERR_LIB_SM2: u32 = 53;
pub const ERR_LIB_ESS: u32 = 54;
pub const ERR_LIB_PROP: u32 = 55;
pub const ERR_LIB_CRMF: u32 = 56;
pub const ERR_LIB_PROV: u32 = 57;
pub const ERR_LIB_CMP: u32 = 58;
pub const ERR_LIB_OSSL_ENCODER: u32 = 59;
pub const ERR_LIB_OSSL_DECODER: u32 = 60;
pub const ERR_LIB_HTTP: u32 = 61;
pub const ERR_LIB_USER: u32 = 128;
pub const ERR_LIB_OFFSET: u32 = 23;
pub const ERR_LIB_MASK: u32 = 255;
pub const ERR_RFLAGS_OFFSET: u32 = 18;
pub const ERR_RFLAGS_MASK: u32 = 31;
pub const ERR_REASON_MASK: u32 = 8388607;
pub const ERR_RFLAG_FATAL: u32 = 262144;
pub const ERR_RFLAG_COMMON: u32 = 524288;
pub const SYS_F_FOPEN: u32 = 0;
pub const SYS_F_CONNECT: u32 = 0;
pub const SYS_F_GETSERVBYNAME: u32 = 0;
pub const SYS_F_SOCKET: u32 = 0;
pub const SYS_F_IOCTLSOCKET: u32 = 0;
pub const SYS_F_BIND: u32 = 0;
pub const SYS_F_LISTEN: u32 = 0;
pub const SYS_F_ACCEPT: u32 = 0;
pub const SYS_F_WSASTARTUP: u32 = 0;
pub const SYS_F_OPENDIR: u32 = 0;
pub const SYS_F_FREAD: u32 = 0;
pub const SYS_F_GETADDRINFO: u32 = 0;
pub const SYS_F_GETNAMEINFO: u32 = 0;
pub const SYS_F_SETSOCKOPT: u32 = 0;
pub const SYS_F_GETSOCKOPT: u32 = 0;
pub const SYS_F_GETSOCKNAME: u32 = 0;
pub const SYS_F_GETHOSTBYNAME: u32 = 0;
pub const SYS_F_FFLUSH: u32 = 0;
pub const SYS_F_OPEN: u32 = 0;
pub const SYS_F_CLOSE: u32 = 0;
pub const SYS_F_IOCTL: u32 = 0;
pub const SYS_F_STAT: u32 = 0;
pub const SYS_F_FCNTL: u32 = 0;
pub const SYS_F_FSTAT: u32 = 0;
pub const SYS_F_SENDFILE: u32 = 0;
pub const ERR_R_SYS_LIB: u32 = 524290;
pub const ERR_R_BN_LIB: u32 = 524291;
pub const ERR_R_RSA_LIB: u32 = 524292;
pub const ERR_R_DH_LIB: u32 = 524293;
pub const ERR_R_EVP_LIB: u32 = 524294;
pub const ERR_R_BUF_LIB: u32 = 524295;
pub const ERR_R_OBJ_LIB: u32 = 524296;
pub const ERR_R_PEM_LIB: u32 = 524297;
pub const ERR_R_DSA_LIB: u32 = 524298;
pub const ERR_R_X509_LIB: u32 = 524299;
pub const ERR_R_ASN1_LIB: u32 = 524301;
pub const ERR_R_CONF_LIB: u32 = 524302;
pub const ERR_R_CRYPTO_LIB: u32 = 524303;
pub const ERR_R_EC_LIB: u32 = 524304;
pub const ERR_R_SSL_LIB: u32 = 524308;
pub const ERR_R_BIO_LIB: u32 = 524320;
pub const ERR_R_PKCS7_LIB: u32 = 524321;
pub const ERR_R_X509V3_LIB: u32 = 524322;
pub const ERR_R_PKCS12_LIB: u32 = 524323;
pub const ERR_R_RAND_LIB: u32 = 524324;
pub const ERR_R_DSO_LIB: u32 = 524325;
pub const ERR_R_ENGINE_LIB: u32 = 524326;
pub const ERR_R_UI_LIB: u32 = 524328;
pub const ERR_R_ECDSA_LIB: u32 = 524330;
pub const ERR_R_OSSL_STORE_LIB: u32 = 524332;
pub const ERR_R_CMS_LIB: u32 = 524334;
pub const ERR_R_TS_LIB: u32 = 524335;
pub const ERR_R_CT_LIB: u32 = 524338;
pub const ERR_R_PROV_LIB: u32 = 524345;
pub const ERR_R_ESS_LIB: u32 = 524342;
pub const ERR_R_CMP_LIB: u32 = 524346;
pub const ERR_R_OSSL_ENCODER_LIB: u32 = 524347;
pub const ERR_R_OSSL_DECODER_LIB: u32 = 524348;
pub const ERR_R_FATAL: u32 = 786432;
pub const ERR_R_MALLOC_FAILURE: u32 = 786688;
pub const ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED: u32 = 786689;
pub const ERR_R_PASSED_NULL_PARAMETER: u32 = 786690;
pub const ERR_R_INTERNAL_ERROR: u32 = 786691;
pub const ERR_R_DISABLED: u32 = 786692;
pub const ERR_R_INIT_FAIL: u32 = 786693;
pub const ERR_R_PASSED_INVALID_ARGUMENT: u32 = 524550;
pub const ERR_R_OPERATION_FAIL: u32 = 786695;
pub const ERR_R_INVALID_PROVIDER_FUNCTIONS: u32 = 786696;
pub const ERR_R_INTERRUPTED_OR_CANCELLED: u32 = 524553;
pub const ERR_R_NESTED_ASN1_ERROR: u32 = 524554;
pub const ERR_R_MISSING_ASN1_EOS: u32 = 524555;
pub const ERR_R_UNSUPPORTED: u32 = 524556;
pub const ERR_R_FETCH_FAILED: u32 = 524557;
pub const ERR_R_INVALID_PROPERTY_DEFINITION: u32 = 524558;
pub const ERR_R_UNABLE_TO_GET_READ_LOCK: u32 = 786703;
pub const ERR_R_UNABLE_TO_GET_WRITE_LOCK: u32 = 786704;
pub const ERR_MAX_DATA_SIZE: u32 = 1024;
pub const RAND_R_ADDITIONAL_INPUT_TOO_LONG: u32 = 102;
pub const RAND_R_ALREADY_INSTANTIATED: u32 = 103;
pub const RAND_R_ARGUMENT_OUT_OF_RANGE: u32 = 105;
pub const RAND_R_CANNOT_OPEN_FILE: u32 = 121;
pub const RAND_R_DRBG_ALREADY_INITIALIZED: u32 = 129;
pub const RAND_R_DRBG_NOT_INITIALISED: u32 = 104;
pub const RAND_R_ENTROPY_INPUT_TOO_LONG: u32 = 106;
pub const RAND_R_ENTROPY_OUT_OF_RANGE: u32 = 124;
pub const RAND_R_ERROR_ENTROPY_POOL_WAS_IGNORED: u32 = 127;
pub const RAND_R_ERROR_INITIALISING_DRBG: u32 = 107;
pub const RAND_R_ERROR_INSTANTIATING_DRBG: u32 = 108;
pub const RAND_R_ERROR_RETRIEVING_ADDITIONAL_INPUT: u32 = 109;
pub const RAND_R_ERROR_RETRIEVING_ENTROPY: u32 = 110;
pub const RAND_R_ERROR_RETRIEVING_NONCE: u32 = 111;
pub const RAND_R_FAILED_TO_CREATE_LOCK: u32 = 126;
pub const RAND_R_FUNC_NOT_IMPLEMENTED: u32 = 101;
pub const RAND_R_FWRITE_ERROR: u32 = 123;
pub const RAND_R_GENERATE_ERROR: u32 = 112;
pub const RAND_R_INSUFFICIENT_DRBG_STRENGTH: u32 = 139;
pub const RAND_R_INTERNAL_ERROR: u32 = 113;
pub const RAND_R_INVALID_PROPERTY_QUERY: u32 = 137;
pub const RAND_R_IN_ERROR_STATE: u32 = 114;
pub const RAND_R_NOT_A_REGULAR_FILE: u32 = 122;
pub const RAND_R_NOT_INSTANTIATED: u32 = 115;
pub const RAND_R_NO_DRBG_IMPLEMENTATION_SELECTED: u32 = 128;
pub const RAND_R_PARENT_LOCKING_NOT_ENABLED: u32 = 130;
pub const RAND_R_PARENT_STRENGTH_TOO_WEAK: u32 = 131;
pub const RAND_R_PERSONALISATION_STRING_TOO_LONG: u32 = 116;
pub const RAND_R_PREDICTION_RESISTANCE_NOT_SUPPORTED: u32 = 133;
pub const RAND_R_PRNG_NOT_SEEDED: u32 = 100;
pub const RAND_R_RANDOM_POOL_OVERFLOW: u32 = 125;
pub const RAND_R_RANDOM_POOL_UNDERFLOW: u32 = 134;
pub const RAND_R_REQUEST_TOO_LARGE_FOR_DRBG: u32 = 117;
pub const RAND_R_RESEED_ERROR: u32 = 118;
pub const RAND_R_SELFTEST_FAILURE: u32 = 119;
pub const RAND_R_TOO_LITTLE_NONCE_REQUESTED: u32 = 135;
pub const RAND_R_TOO_MUCH_NONCE_REQUESTED: u32 = 136;
pub const RAND_R_UNABLE_TO_CREATE_DRBG: u32 = 143;
pub const RAND_R_UNABLE_TO_FETCH_DRBG: u32 = 144;
pub const RAND_R_UNABLE_TO_GET_PARENT_RESEED_PROP_COUNTER: u32 = 141;
pub const RAND_R_UNABLE_TO_GET_PARENT_STRENGTH: u32 = 138;
pub const RAND_R_UNABLE_TO_LOCK_PARENT: u32 = 140;
pub const RAND_R_UNSUPPORTED_DRBG_FLAGS: u32 = 132;
pub const RAND_R_UNSUPPORTED_DRBG_TYPE: u32 = 120;
pub const RAND_DRBG_STRENGTH: u32 = 256;
pub const UI_R_COMMON_OK_AND_CANCEL_CHARACTERS: u32 = 104;
pub const UI_R_INDEX_TOO_LARGE: u32 = 102;
pub const UI_R_INDEX_TOO_SMALL: u32 = 103;
pub const UI_R_NO_RESULT_BUFFER: u32 = 105;
pub const UI_R_PROCESSING_ERROR: u32 = 107;
pub const UI_R_RESULT_TOO_LARGE: u32 = 100;
pub const UI_R_RESULT_TOO_SMALL: u32 = 101;
pub const UI_R_SYSASSIGN_ERROR: u32 = 109;
pub const UI_R_SYSDASSGN_ERROR: u32 = 110;
pub const UI_R_SYSQIOW_ERROR: u32 = 111;
pub const UI_R_UNKNOWN_CONTROL_COMMAND: u32 = 106;
pub const UI_R_UNKNOWN_TTYGET_ERRNO_VALUE: u32 = 108;
pub const UI_R_USER_DATA_DUPLICATION_UNSUPPORTED: u32 = 112;
pub const UI_INPUT_FLAG_ECHO: u32 = 1;
pub const UI_INPUT_FLAG_DEFAULT_PWD: u32 = 2;
pub const UI_INPUT_FLAG_USER_BASE: u32 = 16;
pub const UI_CTRL_PRINT_ERRORS: u32 = 1;
pub const UI_CTRL_IS_REDOABLE: u32 = 2;
pub const ENGINE_R_ALREADY_LOADED: u32 = 100;
pub const ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER: u32 = 133;
pub const ENGINE_R_CMD_NOT_EXECUTABLE: u32 = 134;
pub const ENGINE_R_COMMAND_TAKES_INPUT: u32 = 135;
pub const ENGINE_R_COMMAND_TAKES_NO_INPUT: u32 = 136;
pub const ENGINE_R_CONFLICTING_ENGINE_ID: u32 = 103;
pub const ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED: u32 = 119;
pub const ENGINE_R_DSO_FAILURE: u32 = 104;
pub const ENGINE_R_DSO_NOT_FOUND: u32 = 132;
pub const ENGINE_R_ENGINES_SECTION_ERROR: u32 = 148;
pub const ENGINE_R_ENGINE_CONFIGURATION_ERROR: u32 = 102;
pub const ENGINE_R_ENGINE_IS_NOT_IN_LIST: u32 = 105;
pub const ENGINE_R_ENGINE_SECTION_ERROR: u32 = 149;
pub const ENGINE_R_FAILED_LOADING_PRIVATE_KEY: u32 = 128;
pub const ENGINE_R_FAILED_LOADING_PUBLIC_KEY: u32 = 129;
pub const ENGINE_R_FINISH_FAILED: u32 = 106;
pub const ENGINE_R_ID_OR_NAME_MISSING: u32 = 108;
pub const ENGINE_R_INIT_FAILED: u32 = 109;
pub const ENGINE_R_INTERNAL_LIST_ERROR: u32 = 110;
pub const ENGINE_R_INVALID_ARGUMENT: u32 = 143;
pub const ENGINE_R_INVALID_CMD_NAME: u32 = 137;
pub const ENGINE_R_INVALID_CMD_NUMBER: u32 = 138;
pub const ENGINE_R_INVALID_INIT_VALUE: u32 = 151;
pub const ENGINE_R_INVALID_STRING: u32 = 150;
pub const ENGINE_R_NOT_INITIALISED: u32 = 117;
pub const ENGINE_R_NOT_LOADED: u32 = 112;
pub const ENGINE_R_NO_CONTROL_FUNCTION: u32 = 120;
pub const ENGINE_R_NO_INDEX: u32 = 144;
pub const ENGINE_R_NO_LOAD_FUNCTION: u32 = 125;
pub const ENGINE_R_NO_REFERENCE: u32 = 130;
pub const ENGINE_R_NO_SUCH_ENGINE: u32 = 116;
pub const ENGINE_R_UNIMPLEMENTED_CIPHER: u32 = 146;
pub const ENGINE_R_UNIMPLEMENTED_DIGEST: u32 = 147;
pub const ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD: u32 = 101;
pub const ENGINE_R_VERSION_INCOMPATIBILITY: u32 = 145;
pub const ENGINE_CTRL_SET_LOGSTREAM: u32 = 1;
pub const ENGINE_CTRL_SET_PASSWORD_CALLBACK: u32 = 2;
pub const ENGINE_CTRL_HUP: u32 = 3;
pub const ENGINE_CTRL_SET_USER_INTERFACE: u32 = 4;
pub const ENGINE_CTRL_SET_CALLBACK_DATA: u32 = 5;
pub const ENGINE_CTRL_LOAD_CONFIGURATION: u32 = 6;
pub const ENGINE_CTRL_LOAD_SECTION: u32 = 7;
pub const ENGINE_CTRL_HAS_CTRL_FUNCTION: u32 = 10;
pub const ENGINE_CTRL_GET_FIRST_CMD_TYPE: u32 = 11;
pub const ENGINE_CTRL_GET_NEXT_CMD_TYPE: u32 = 12;
pub const ENGINE_CTRL_GET_CMD_FROM_NAME: u32 = 13;
pub const ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: u32 = 14;
pub const ENGINE_CTRL_GET_NAME_FROM_CMD: u32 = 15;
pub const ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: u32 = 16;
pub const ENGINE_CTRL_GET_DESC_FROM_CMD: u32 = 17;
pub const ENGINE_CTRL_GET_CMD_FLAGS: u32 = 18;
pub const ENGINE_CMD_BASE: u32 = 200;
pub const ENGINE_CTRL_CHIL_SET_FORKCHECK: u32 = 100;
pub const ENGINE_CTRL_CHIL_NO_LOCKING: u32 = 101;
pub const OCSP_REVOKED_STATUS_NOSTATUS: i32 = -1;
pub const OCSP_REVOKED_STATUS_UNSPECIFIED: u32 = 0;
pub const OCSP_REVOKED_STATUS_KEYCOMPROMISE: u32 = 1;
pub const OCSP_REVOKED_STATUS_CACOMPROMISE: u32 = 2;
pub const OCSP_REVOKED_STATUS_AFFILIATIONCHANGED: u32 = 3;
pub const OCSP_REVOKED_STATUS_SUPERSEDED: u32 = 4;
pub const OCSP_REVOKED_STATUS_CESSATIONOFOPERATION: u32 = 5;
pub const OCSP_REVOKED_STATUS_CERTIFICATEHOLD: u32 = 6;
pub const OCSP_REVOKED_STATUS_REMOVEFROMCRL: u32 = 8;
pub const OCSP_REVOKED_STATUS_PRIVILEGEWITHDRAWN: u32 = 9;
pub const OCSP_REVOKED_STATUS_AACOMPROMISE: u32 = 10;
pub const X509V3_R_BAD_IP_ADDRESS: u32 = 118;
pub const X509V3_R_BAD_OBJECT: u32 = 119;
pub const X509V3_R_BN_DEC2BN_ERROR: u32 = 100;
pub const X509V3_R_BN_TO_ASN1_INTEGER_ERROR: u32 = 101;
pub const X509V3_R_DIRNAME_ERROR: u32 = 149;
pub const X509V3_R_DISTPOINT_ALREADY_SET: u32 = 160;
pub const X509V3_R_DUPLICATE_ZONE_ID: u32 = 133;
pub const X509V3_R_EMPTY_KEY_USAGE: u32 = 169;
pub const X509V3_R_ERROR_CONVERTING_ZONE: u32 = 131;
pub const X509V3_R_ERROR_CREATING_EXTENSION: u32 = 144;
pub const X509V3_R_ERROR_IN_EXTENSION: u32 = 128;
pub const X509V3_R_EXPECTED_A_SECTION_NAME: u32 = 137;
pub const X509V3_R_EXTENSION_EXISTS: u32 = 145;
pub const X509V3_R_EXTENSION_NAME_ERROR: u32 = 115;
pub const X509V3_R_EXTENSION_NOT_FOUND: u32 = 102;
pub const X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED: u32 = 103;
pub const X509V3_R_EXTENSION_VALUE_ERROR: u32 = 116;
pub const X509V3_R_ILLEGAL_EMPTY_EXTENSION: u32 = 151;
pub const X509V3_R_INCORRECT_POLICY_SYNTAX_TAG: u32 = 152;
pub const X509V3_R_INVALID_ASNUMBER: u32 = 162;
pub const X509V3_R_INVALID_ASRANGE: u32 = 163;
pub const X509V3_R_INVALID_BOOLEAN_STRING: u32 = 104;
pub const X509V3_R_INVALID_CERTIFICATE: u32 = 158;
pub const X509V3_R_INVALID_EMPTY_NAME: u32 = 108;
pub const X509V3_R_INVALID_EXTENSION_STRING: u32 = 105;
pub const X509V3_R_INVALID_INHERITANCE: u32 = 165;
pub const X509V3_R_INVALID_IPADDRESS: u32 = 166;
pub const X509V3_R_INVALID_MULTIPLE_RDNS: u32 = 161;
pub const X509V3_R_INVALID_NAME: u32 = 106;
pub const X509V3_R_INVALID_NULL_ARGUMENT: u32 = 107;
pub const X509V3_R_INVALID_NULL_VALUE: u32 = 109;
pub const X509V3_R_INVALID_NUMBER: u32 = 140;
pub const X509V3_R_INVALID_NUMBERS: u32 = 141;
pub const X509V3_R_INVALID_OBJECT_IDENTIFIER: u32 = 110;
pub const X509V3_R_INVALID_OPTION: u32 = 138;
pub const X509V3_R_INVALID_POLICY_IDENTIFIER: u32 = 134;
pub const X509V3_R_INVALID_PROXY_POLICY_SETTING: u32 = 153;
pub const X509V3_R_INVALID_PURPOSE: u32 = 146;
pub const X509V3_R_INVALID_SAFI: u32 = 164;
pub const X509V3_R_INVALID_SECTION: u32 = 135;
pub const X509V3_R_INVALID_SYNTAX: u32 = 143;
pub const X509V3_R_ISSUER_DECODE_ERROR: u32 = 126;
pub const X509V3_R_MISSING_VALUE: u32 = 124;
pub const X509V3_R_NEED_ORGANIZATION_AND_NUMBERS: u32 = 142;
pub const X509V3_R_NEGATIVE_PATHLEN: u32 = 168;
pub const X509V3_R_NO_CONFIG_DATABASE: u32 = 136;
pub const X509V3_R_NO_ISSUER_CERTIFICATE: u32 = 121;
pub const X509V3_R_NO_ISSUER_DETAILS: u32 = 127;
pub const X509V3_R_NO_POLICY_IDENTIFIER: u32 = 139;
pub const X509V3_R_NO_PROXY_CERT_POLICY_LANGUAGE_DEFINED: u32 = 154;
pub const X509V3_R_NO_PUBLIC_KEY: u32 = 114;
pub const X509V3_R_NO_SUBJECT_DETAILS: u32 = 125;
pub const X509V3_R_OPERATION_NOT_DEFINED: u32 = 148;
pub const X509V3_R_OTHERNAME_ERROR: u32 = 147;
pub const X509V3_R_POLICY_LANGUAGE_ALREADY_DEFINED: u32 = 155;
pub const X509V3_R_POLICY_PATH_LENGTH: u32 = 156;
pub const X509V3_R_POLICY_PATH_LENGTH_ALREADY_DEFINED: u32 = 157;
pub const X509V3_R_POLICY_WHEN_PROXY_LANGUAGE_REQUIRES_NO_POLICY: u32 = 159;
pub const X509V3_R_SECTION_NOT_FOUND: u32 = 150;
pub const X509V3_R_UNABLE_TO_GET_ISSUER_DETAILS: u32 = 122;
pub const X509V3_R_UNABLE_TO_GET_ISSUER_KEYID: u32 = 123;
pub const X509V3_R_UNKNOWN_BIT_STRING_ARGUMENT: u32 = 111;
pub const X509V3_R_UNKNOWN_EXTENSION: u32 = 129;
pub const X509V3_R_UNKNOWN_EXTENSION_NAME: u32 = 130;
pub const X509V3_R_UNKNOWN_OPTION: u32 = 120;
pub const X509V3_R_UNSUPPORTED_OPTION: u32 = 117;
pub const X509V3_R_UNSUPPORTED_TYPE: u32 = 167;
pub const X509V3_R_USER_TOO_LONG: u32 = 132;
pub const X509V3_CTX_TEST: u32 = 1;
pub const CTX_TEST: u32 = 1;
pub const X509V3_CTX_REPLACE: u32 = 2;
pub const X509V3_EXT_DYNAMIC: u32 = 1;
pub const X509V3_EXT_CTX_DEP: u32 = 2;
pub const X509V3_EXT_MULTILINE: u32 = 4;
pub const GEN_OTHERNAME: u32 = 0;
pub const GEN_EMAIL: u32 = 1;
pub const GEN_DNS: u32 = 2;
pub const GEN_X400: u32 = 3;
pub const GEN_DIRNAME: u32 = 4;
pub const GEN_EDIPARTY: u32 = 5;
pub const GEN_URI: u32 = 6;
pub const GEN_IPADD: u32 = 7;
pub const GEN_RID: u32 = 8;
pub const CRLDP_ALL_REASONS: u32 = 32895;
pub const CRL_REASON_NONE: i32 = -1;
pub const CRL_REASON_UNSPECIFIED: u32 = 0;
pub const CRL_REASON_KEY_COMPROMISE: u32 = 1;
pub const CRL_REASON_CA_COMPROMISE: u32 = 2;
pub const CRL_REASON_AFFILIATION_CHANGED: u32 = 3;
pub const CRL_REASON_SUPERSEDED: u32 = 4;
pub const CRL_REASON_CESSATION_OF_OPERATION: u32 = 5;
pub const CRL_REASON_CERTIFICATE_HOLD: u32 = 6;
pub const CRL_REASON_REMOVE_FROM_CRL: u32 = 8;
pub const CRL_REASON_PRIVILEGE_WITHDRAWN: u32 = 9;
pub const CRL_REASON_AA_COMPROMISE: u32 = 10;
pub const IDP_PRESENT: u32 = 1;
pub const IDP_INVALID: u32 = 2;
pub const IDP_ONLYUSER: u32 = 4;
pub const IDP_ONLYCA: u32 = 8;
pub const IDP_ONLYATTR: u32 = 16;
pub const IDP_INDIRECT: u32 = 32;
pub const IDP_REASONS: u32 = 64;
pub const EXFLAG_BCONS: u32 = 1;
pub const EXFLAG_KUSAGE: u32 = 2;
pub const EXFLAG_XKUSAGE: u32 = 4;
pub const EXFLAG_NSCERT: u32 = 8;
pub const EXFLAG_CA: u32 = 16;
pub const EXFLAG_SI: u32 = 32;
pub const EXFLAG_V1: u32 = 64;
pub const EXFLAG_INVALID: u32 = 128;
pub const EXFLAG_SET: u32 = 256;
pub const EXFLAG_CRITICAL: u32 = 512;
pub const EXFLAG_PROXY: u32 = 1024;
pub const EXFLAG_INVALID_POLICY: u32 = 2048;
pub const EXFLAG_FRESHEST: u32 = 4096;
pub const EXFLAG_SS: u32 = 8192;
pub const EXFLAG_BCONS_CRITICAL: u32 = 65536;
pub const EXFLAG_AKID_CRITICAL: u32 = 131072;
pub const EXFLAG_SKID_CRITICAL: u32 = 262144;
pub const EXFLAG_SAN_CRITICAL: u32 = 524288;
pub const EXFLAG_NO_FINGERPRINT: u32 = 1048576;
pub const KU_DIGITAL_SIGNATURE: u32 = 128;
pub const KU_NON_REPUDIATION: u32 = 64;
pub const KU_KEY_ENCIPHERMENT: u32 = 32;
pub const KU_DATA_ENCIPHERMENT: u32 = 16;
pub const KU_KEY_AGREEMENT: u32 = 8;
pub const KU_KEY_CERT_SIGN: u32 = 4;
pub const KU_CRL_SIGN: u32 = 2;
pub const KU_ENCIPHER_ONLY: u32 = 1;
pub const KU_DECIPHER_ONLY: u32 = 32768;
pub const NS_SSL_CLIENT: u32 = 128;
pub const NS_SSL_SERVER: u32 = 64;
pub const NS_SMIME: u32 = 32;
pub const NS_OBJSIGN: u32 = 16;
pub const NS_SSL_CA: u32 = 4;
pub const NS_SMIME_CA: u32 = 2;
pub const NS_OBJSIGN_CA: u32 = 1;
pub const NS_ANY_CA: u32 = 7;
pub const XKU_SSL_SERVER: u32 = 1;
pub const XKU_SSL_CLIENT: u32 = 2;
pub const XKU_SMIME: u32 = 4;
pub const XKU_CODE_SIGN: u32 = 8;
pub const XKU_SGC: u32 = 16;
pub const XKU_OCSP_SIGN: u32 = 32;
pub const XKU_TIMESTAMP: u32 = 64;
pub const XKU_DVCS: u32 = 128;
pub const XKU_ANYEKU: u32 = 256;
pub const X509_PURPOSE_DYNAMIC: u32 = 1;
pub const X509_PURPOSE_DYNAMIC_NAME: u32 = 2;
pub const X509_PURPOSE_SSL_CLIENT: u32 = 1;
pub const X509_PURPOSE_SSL_SERVER: u32 = 2;
pub const X509_PURPOSE_NS_SSL_SERVER: u32 = 3;
pub const X509_PURPOSE_SMIME_SIGN: u32 = 4;
pub const X509_PURPOSE_SMIME_ENCRYPT: u32 = 5;
pub const X509_PURPOSE_CRL_SIGN: u32 = 6;
pub const X509_PURPOSE_ANY: u32 = 7;
pub const X509_PURPOSE_OCSP_HELPER: u32 = 8;
pub const X509_PURPOSE_TIMESTAMP_SIGN: u32 = 9;
pub const X509_PURPOSE_MIN: u32 = 1;
pub const X509_PURPOSE_MAX: u32 = 9;
pub const X509V3_EXT_UNKNOWN_MASK: u32 = 983040;
pub const X509V3_EXT_DEFAULT: u32 = 0;
pub const X509V3_EXT_ERROR_UNKNOWN: u32 = 65536;
pub const X509V3_EXT_PARSE_UNKNOWN: u32 = 131072;
pub const X509V3_EXT_DUMP_UNKNOWN: u32 = 196608;
pub const X509V3_ADD_OP_MASK: u32 = 15;
pub const X509V3_ADD_DEFAULT: u32 = 0;
pub const X509V3_ADD_APPEND: u32 = 1;
pub const X509V3_ADD_REPLACE: u32 = 2;
pub const X509V3_ADD_REPLACE_EXISTING: u32 = 3;
pub const X509V3_ADD_KEEP_EXISTING: u32 = 4;
pub const X509V3_ADD_DELETE: u32 = 5;
pub const X509V3_ADD_SILENT: u32 = 16;
pub const X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT: u32 = 1;
pub const X509_CHECK_FLAG_NO_WILDCARDS: u32 = 2;
pub const X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS: u32 = 4;
pub const X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS: u32 = 8;
pub const X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS: u32 = 16;
pub const X509_CHECK_FLAG_NEVER_CHECK_SUBJECT: u32 = 32;
pub const _X509_CHECK_FLAG_DOT_SUBDOMAINS: u32 = 32768;
pub const ASIdOrRange_id: u32 = 0;
pub const ASIdOrRange_range: u32 = 1;
pub const ASIdentifierChoice_inherit: u32 = 0;
pub const ASIdentifierChoice_asIdsOrRanges: u32 = 1;
pub const IPAddressOrRange_addressPrefix: u32 = 0;
pub const IPAddressOrRange_addressRange: u32 = 1;
pub const IPAddressChoice_inherit: u32 = 0;
pub const IPAddressChoice_addressesOrRanges: u32 = 1;
pub const V3_ASID_ASNUM: u32 = 0;
pub const V3_ASID_RDI: u32 = 1;
pub const IANA_AFI_IPV4: u32 = 1;
pub const IANA_AFI_IPV6: u32 = 2;
pub const OCSP_R_CERTIFICATE_VERIFY_ERROR: u32 = 101;
pub const OCSP_R_DIGEST_ERR: u32 = 102;
pub const OCSP_R_DIGEST_NAME_ERR: u32 = 106;
pub const OCSP_R_DIGEST_SIZE_ERR: u32 = 107;
pub const OCSP_R_ERROR_IN_NEXTUPDATE_FIELD: u32 = 122;
pub const OCSP_R_ERROR_IN_THISUPDATE_FIELD: u32 = 123;
pub const OCSP_R_MISSING_OCSPSIGNING_USAGE: u32 = 103;
pub const OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE: u32 = 124;
pub const OCSP_R_NOT_BASIC_RESPONSE: u32 = 104;
pub const OCSP_R_NO_CERTIFICATES_IN_CHAIN: u32 = 105;
pub const OCSP_R_NO_RESPONSE_DATA: u32 = 108;
pub const OCSP_R_NO_REVOKED_TIME: u32 = 109;
pub const OCSP_R_NO_SIGNER_KEY: u32 = 130;
pub const OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE: u32 = 110;
pub const OCSP_R_REQUEST_NOT_SIGNED: u32 = 128;
pub const OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA: u32 = 111;
pub const OCSP_R_ROOT_CA_NOT_TRUSTED: u32 = 112;
pub const OCSP_R_SIGNATURE_FAILURE: u32 = 117;
pub const OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND: u32 = 118;
pub const OCSP_R_STATUS_EXPIRED: u32 = 125;
pub const OCSP_R_STATUS_NOT_YET_VALID: u32 = 126;
pub const OCSP_R_STATUS_TOO_OLD: u32 = 127;
pub const OCSP_R_UNKNOWN_MESSAGE_DIGEST: u32 = 119;
pub const OCSP_R_UNKNOWN_NID: u32 = 120;
pub const OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE: u32 = 129;
pub const OCSP_DEFAULT_NONCE_LENGTH: u32 = 16;
pub const OCSP_NOCERTS: u32 = 1;
pub const OCSP_NOINTERN: u32 = 2;
pub const OCSP_NOSIGS: u32 = 4;
pub const OCSP_NOCHAIN: u32 = 8;
pub const OCSP_NOVERIFY: u32 = 16;
pub const OCSP_NOEXPLICIT: u32 = 32;
pub const OCSP_NOCASIGN: u32 = 64;
pub const OCSP_NODELEGATED: u32 = 128;
pub const OCSP_NOCHECKS: u32 = 256;
pub const OCSP_TRUSTOTHER: u32 = 512;
pub const OCSP_RESPID_KEY: u32 = 1024;
pub const OCSP_NOTIME: u32 = 2048;
pub const OCSP_PARTIAL_CHAIN: u32 = 4096;
pub const OCSP_RESPONSE_STATUS_SUCCESSFUL: u32 = 0;
pub const OCSP_RESPONSE_STATUS_MALFORMEDREQUEST: u32 = 1;
pub const OCSP_RESPONSE_STATUS_INTERNALERROR: u32 = 2;
pub const OCSP_RESPONSE_STATUS_TRYLATER: u32 = 3;
pub const OCSP_RESPONSE_STATUS_SIGREQUIRED: u32 = 5;
pub const OCSP_RESPONSE_STATUS_UNAUTHORIZED: u32 = 6;
pub const V_OCSP_RESPID_NAME: u32 = 0;
pub const V_OCSP_RESPID_KEY: u32 = 1;
pub const V_OCSP_CERTSTATUS_GOOD: u32 = 0;
pub const V_OCSP_CERTSTATUS_REVOKED: u32 = 1;
pub const V_OCSP_CERTSTATUS_UNKNOWN: u32 = 2;
pub const PEM_STRING_OCSP_REQUEST: &[u8; 13] = b"OCSP REQUEST\0";
pub const PEM_STRING_OCSP_RESPONSE: &[u8; 14] = b"OCSP RESPONSE\0";
pub const NGX_SSL_NAME: &[u8; 8] = b"OpenSSL\0";
pub const NGX_SSL_NO_SCACHE: i32 = -2;
pub const NGX_SSL_NONE_SCACHE: i32 = -3;
pub const NGX_SSL_NO_BUILTIN_SCACHE: i32 = -4;
pub const NGX_SSL_DFLT_BUILTIN_SCACHE: i32 = -5;
pub const NGX_SSL_MAX_SESSION_SIZE: u32 = 4096;
pub const NGX_SSL_SSLv2: u32 = 2;
pub const NGX_SSL_SSLv3: u32 = 4;
pub const NGX_SSL_TLSv1: u32 = 8;
pub const NGX_SSL_TLSv1_1: u32 = 16;
pub const NGX_SSL_TLSv1_2: u32 = 32;
pub const NGX_SSL_TLSv1_3: u32 = 64;
pub const NGX_SSL_BUFFER: u32 = 1;
pub const NGX_SSL_CLIENT: u32 = 2;
pub const NGX_SSL_BUFSIZE: u32 = 16384;
pub const NGX_CMD_OPEN_CHANNEL: u32 = 1;
pub const NGX_CMD_CLOSE_CHANNEL: u32 = 2;
pub const NGX_CMD_QUIT: u32 = 3;
pub const NGX_CMD_TERMINATE: u32 = 4;
pub const NGX_CMD_REOPEN: u32 = 5;
pub const NGX_PROCESS_SINGLE: u32 = 0;
pub const NGX_PROCESS_MASTER: u32 = 1;
pub const NGX_PROCESS_SIGNALLER: u32 = 2;
pub const NGX_PROCESS_WORKER: u32 = 3;
pub const NGX_PROCESS_HELPER: u32 = 4;
pub const NGX_CONF_NOARGS: u32 = 1;
pub const NGX_CONF_TAKE1: u32 = 2;
pub const NGX_CONF_TAKE2: u32 = 4;
pub const NGX_CONF_TAKE3: u32 = 8;
pub const NGX_CONF_TAKE4: u32 = 16;
pub const NGX_CONF_TAKE5: u32 = 32;
pub const NGX_CONF_TAKE6: u32 = 64;
pub const NGX_CONF_TAKE7: u32 = 128;
pub const NGX_CONF_MAX_ARGS: u32 = 8;
pub const NGX_CONF_TAKE12: u32 = 6;
pub const NGX_CONF_TAKE13: u32 = 10;
pub const NGX_CONF_TAKE23: u32 = 12;
pub const NGX_CONF_TAKE123: u32 = 14;
pub const NGX_CONF_TAKE1234: u32 = 30;
pub const NGX_CONF_ARGS_NUMBER: u32 = 255;
pub const NGX_CONF_BLOCK: u32 = 256;
pub const NGX_CONF_FLAG: u32 = 512;
pub const NGX_CONF_ANY: u32 = 1024;
pub const NGX_CONF_1MORE: u32 = 2048;
pub const NGX_CONF_2MORE: u32 = 4096;
pub const NGX_DIRECT_CONF: u32 = 65536;
pub const NGX_MAIN_CONF: u32 = 16777216;
pub const NGX_ANY_CONF: u32 = 4278190080;
pub const NGX_CONF_UNSET: i32 = -1;
pub const NGX_CONF_BLOCK_START: u32 = 1;
pub const NGX_CONF_BLOCK_DONE: u32 = 2;
pub const NGX_CONF_FILE_DONE: u32 = 3;
pub const NGX_CORE_MODULE: u32 = 1163022147;
pub const NGX_CONF_MODULE: u32 = 1179537219;
pub const NGX_MAX_CONF_ERRSTR: u32 = 1024;
pub const NGX_CONF_BITMASK_SET: u32 = 1;
pub const nginx_version: u32 = 1021004;
pub const NGINX_VERSION: &[u8; 7] = b"1.21.4\0";
pub const NGINX_VER: &[u8; 19] = b"openresty/1.21.4.1\0";
pub const NGINX_VER_BUILD: &[u8; 19] = b"openresty/1.21.4.1\0";
pub const NGINX_VAR: &[u8; 6] = b"NGINX\0";
pub const NGX_OLDPID_EXT: &[u8; 8] = b".oldbin\0";
pub const NGX_MODULE_SIGNATURE_1: &[u8; 2] = b"0\0";
pub const NGX_MODULE_SIGNATURE_2: &[u8; 2] = b"0\0";
pub const NGX_MODULE_SIGNATURE_3: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_4: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_5: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_6: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_7: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_8: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_9: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_10: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_11: &[u8; 2] = b"0\0";
pub const NGX_MODULE_SIGNATURE_12: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_13: &[u8; 2] = b"0\0";
pub const NGX_MODULE_SIGNATURE_14: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_15: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_16: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_17: &[u8; 2] = b"0\0";
pub const NGX_MODULE_SIGNATURE_18: &[u8; 2] = b"0\0";
pub const NGX_MODULE_SIGNATURE_19: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_20: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_21: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_22: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_23: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_24: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_25: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_26: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_27: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_28: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_29: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_30: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_31: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_32: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_33: &[u8; 2] = b"1\0";
pub const NGX_MODULE_SIGNATURE_34: &[u8; 2] = b"1\0";
pub const NGX_OPEN_FILE_DIRECTIO_OFF: u64 = 9223372036854775807;
pub const NGX_IO_SENDFILE: u32 = 1;
pub const NGX_IOVS_PREALLOCATE: u32 = 64;
pub const KOAL_SSL_EXTENSION: u32 = 1;
pub const __UAPI_DEF_IF_IFCONF: u32 = 1;
pub const __UAPI_DEF_IF_IFMAP: u32 = 1;
pub const __UAPI_DEF_IF_IFNAMSIZ: u32 = 1;
pub const __UAPI_DEF_IF_IFREQ: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO: u32 = 1;
pub const __UAPI_DEF_IN_ADDR: u32 = 0;
pub const __UAPI_DEF_IN_IPPROTO: u32 = 0;
pub const __UAPI_DEF_IN_PKTINFO: u32 = 0;
pub const __UAPI_DEF_IP_MREQ: u32 = 0;
pub const __UAPI_DEF_SOCKADDR_IN: u32 = 0;
pub const __UAPI_DEF_IN_CLASS: u32 = 0;
pub const __UAPI_DEF_IN6_ADDR: u32 = 0;
pub const __UAPI_DEF_IN6_ADDR_ALT: u32 = 0;
pub const __UAPI_DEF_SOCKADDR_IN6: u32 = 0;
pub const __UAPI_DEF_IPV6_MREQ: u32 = 0;
pub const __UAPI_DEF_IPPROTO_V6: u32 = 0;
pub const __UAPI_DEF_IPV6_OPTIONS: u32 = 0;
pub const __UAPI_DEF_IN6_PKTINFO: u32 = 0;
pub const __UAPI_DEF_IP6_MTUINFO: u32 = 0;
pub const __UAPI_DEF_SOCKADDR_IPX: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_INTERFACE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_CONFIG_DATA: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEF: u32 = 1;
pub const __UAPI_DEF_XATTR: u32 = 1;
pub const _K_SS_MAXSIZE: u32 = 128;
pub const SOCK_SNDBUF_LOCK: u32 = 1;
pub const SOCK_RCVBUF_LOCK: u32 = 2;
pub const SOCK_BUF_LOCK_MASK: u32 = 3;
pub const SOCK_TXREHASH_DEFAULT: u32 = 255;
pub const SOCK_TXREHASH_DISABLED: u32 = 0;
pub const SOCK_TXREHASH_ENABLED: u32 = 1;
pub const IP_RECVRETOPTS: u32 = 7;
pub const IP_LOCAL_PORT_RANGE: u32 = 51;
pub const IP_PROTOCOL: u32 = 52;
pub const IPV6_FL_A_GET: u32 = 0;
pub const IPV6_FL_A_PUT: u32 = 1;
pub const IPV6_FL_A_RENEW: u32 = 2;
pub const IPV6_FL_F_CREATE: u32 = 1;
pub const IPV6_FL_F_EXCL: u32 = 2;
pub const IPV6_FL_F_REFLECT: u32 = 4;
pub const IPV6_FL_F_REMOTE: u32 = 8;
pub const IPV6_FL_S_NONE: u32 = 0;
pub const IPV6_FL_S_EXCL: u32 = 1;
pub const IPV6_FL_S_PROCESS: u32 = 2;
pub const IPV6_FL_S_USER: u32 = 3;
pub const IPV6_FL_S_ANY: u32 = 255;
pub const IPV6_FLOWINFO_FLOWLABEL: u32 = 1048575;
pub const IPV6_FLOWINFO_PRIORITY: u32 = 267386880;
pub const IPV6_PRIORITY_UNCHARACTERIZED: u32 = 0;
pub const IPV6_PRIORITY_FILLER: u32 = 256;
pub const IPV6_PRIORITY_UNATTENDED: u32 = 512;
pub const IPV6_PRIORITY_RESERVED1: u32 = 768;
pub const IPV6_PRIORITY_BULK: u32 = 1024;
pub const IPV6_PRIORITY_RESERVED2: u32 = 1280;
pub const IPV6_PRIORITY_INTERACTIVE: u32 = 1536;
pub const IPV6_PRIORITY_CONTROL: u32 = 1792;
pub const IPV6_PRIORITY_8: u32 = 2048;
pub const IPV6_PRIORITY_9: u32 = 2304;
pub const IPV6_PRIORITY_10: u32 = 2560;
pub const IPV6_PRIORITY_11: u32 = 2816;
pub const IPV6_PRIORITY_12: u32 = 3072;
pub const IPV6_PRIORITY_13: u32 = 3328;
pub const IPV6_PRIORITY_14: u32 = 3584;
pub const IPV6_PRIORITY_15: u32 = 3840;
pub const IPV6_TLV_PAD1: u32 = 0;
pub const IPV6_TLV_PADN: u32 = 1;
pub const IPV6_TLV_ROUTERALERT: u32 = 5;
pub const IPV6_TLV_CALIPSO: u32 = 7;
pub const IPV6_TLV_IOAM: u32 = 49;
pub const IPV6_TLV_JUMBO: u32 = 194;
pub const IPV6_TLV_HAO: u32 = 201;
pub const IPV6_PREFER_SRC_TMP: u32 = 1;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const IPV6_PREFER_SRC_COA: u32 = 4;
pub const IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const IPV6_PREFER_SRC_CGA: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const NF_DROP: u32 = 0;
pub const NF_ACCEPT: u32 = 1;
pub const NF_STOLEN: u32 = 2;
pub const NF_QUEUE: u32 = 3;
pub const NF_REPEAT: u32 = 4;
pub const NF_STOP: u32 = 5;
pub const NF_MAX_VERDICT: u32 = 5;
pub const NF_VERDICT_MASK: u32 = 255;
pub const NF_VERDICT_FLAG_QUEUE_BYPASS: u32 = 32768;
pub const NF_VERDICT_QMASK: u32 = 4294901760;
pub const NF_VERDICT_QBITS: u32 = 16;
pub const NF_VERDICT_BITS: u32 = 16;
pub const NF_IP_PRE_ROUTING: u32 = 0;
pub const NF_IP_LOCAL_IN: u32 = 1;
pub const NF_IP_FORWARD: u32 = 2;
pub const NF_IP_LOCAL_OUT: u32 = 3;
pub const NF_IP_POST_ROUTING: u32 = 4;
pub const NF_IP_NUMHOOKS: u32 = 5;
pub const SO_ORIGINAL_DST: u32 = 80;
pub const NGX_LOWLEVEL_BUFFERED: u32 = 15;
pub const NGX_SSL_BUFFERED: u32 = 1;
pub const NGX_HTTP_V2_BUFFERED: u32 = 2;
pub const LUA_NOREF: i32 = -2;
pub const NGX_PROXY_PROTOCOL_V1_MAX_HEADER: u32 = 107;
pub const NGX_PROXY_PROTOCOL_MAX_HEADER: u32 = 4096;
pub const CRLF: &[u8; 3] = b"\r\n\0";
pub const NGX_DISABLE_SYMLINKS_OFF: u32 = 0;
pub const NGX_DISABLE_SYMLINKS_ON: u32 = 1;
pub const NGX_DISABLE_SYMLINKS_NOTOWNER: u32 = 2;
pub const NGX_HTTP_VAR_CHANGEABLE: u32 = 1;
pub const NGX_HTTP_VAR_NOCACHEABLE: u32 = 2;
pub const NGX_HTTP_VAR_INDEXED: u32 = 4;
pub const NGX_HTTP_VAR_NOHASH: u32 = 8;
pub const NGX_HTTP_VAR_WEAK: u32 = 16;
pub const NGX_HTTP_VAR_PREFIX: u32 = 32;
pub const NGX_HTTP_MODULE: u32 = 1347703880;
pub const NGX_HTTP_MAIN_CONF: u32 = 33554432;
pub const NGX_HTTP_SRV_CONF: u32 = 67108864;
pub const NGX_HTTP_LOC_CONF: u32 = 134217728;
pub const NGX_HTTP_UPS_CONF: u32 = 268435456;
pub const NGX_HTTP_SIF_CONF: u32 = 536870912;
pub const NGX_HTTP_LIF_CONF: u32 = 1073741824;
pub const NGX_HTTP_LMT_CONF: u32 = 2147483648;
pub const NGX_HTTP_MAX_URI_CHANGES: u32 = 10;
pub const NGX_HTTP_MAX_SUBREQUESTS: u32 = 50;
pub const NGX_HTTP_LC_HEADER_LEN: u32 = 32;
pub const NGX_HTTP_DISCARD_BUFFER_SIZE: u32 = 4096;
pub const NGX_HTTP_LINGERING_BUFFER_SIZE: u32 = 4096;
pub const NGX_HTTP_VERSION_9: u32 = 9;
pub const NGX_HTTP_VERSION_10: u32 = 1000;
pub const NGX_HTTP_VERSION_11: u32 = 1001;
pub const NGX_HTTP_VERSION_20: u32 = 2000;
pub const NGX_HTTP_UNKNOWN: u32 = 1;
pub const NGX_HTTP_GET: u32 = 2;
pub const NGX_HTTP_HEAD: u32 = 4;
pub const NGX_HTTP_POST: u32 = 8;
pub const NGX_HTTP_PUT: u32 = 16;
pub const NGX_HTTP_DELETE: u32 = 32;
pub const NGX_HTTP_MKCOL: u32 = 64;
pub const NGX_HTTP_COPY: u32 = 128;
pub const NGX_HTTP_MOVE: u32 = 256;
pub const NGX_HTTP_OPTIONS: u32 = 512;
pub const NGX_HTTP_PROPFIND: u32 = 1024;
pub const NGX_HTTP_PROPPATCH: u32 = 2048;
pub const NGX_HTTP_LOCK: u32 = 4096;
pub const NGX_HTTP_UNLOCK: u32 = 8192;
pub const NGX_HTTP_PATCH: u32 = 16384;
pub const NGX_HTTP_TRACE: u32 = 32768;
pub const NGX_HTTP_CONNECT: u32 = 65536;
pub const NGX_HTTP_CONNECTION_CLOSE: u32 = 1;
pub const NGX_HTTP_CONNECTION_KEEP_ALIVE: u32 = 2;
pub const NGX_NONE: u32 = 1;
pub const NGX_HTTP_PARSE_HEADER_DONE: u32 = 1;
pub const NGX_HTTP_CLIENT_ERROR: u32 = 10;
pub const NGX_HTTP_PARSE_INVALID_METHOD: u32 = 10;
pub const NGX_HTTP_PARSE_INVALID_REQUEST: u32 = 11;
pub const NGX_HTTP_PARSE_INVALID_VERSION: u32 = 12;
pub const NGX_HTTP_PARSE_INVALID_09_METHOD: u32 = 13;
pub const NGX_HTTP_PARSE_INVALID_HEADER: u32 = 14;
pub const NGX_HTTP_SUBREQUEST_IN_MEMORY: u32 = 2;
pub const NGX_HTTP_SUBREQUEST_WAITED: u32 = 4;
pub const NGX_HTTP_SUBREQUEST_CLONE: u32 = 8;
pub const NGX_HTTP_SUBREQUEST_BACKGROUND: u32 = 16;
pub const NGX_HTTP_LOG_UNSAFE: u32 = 1;
pub const NGX_HTTP_CONTINUE: u32 = 100;
pub const NGX_HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const NGX_HTTP_PROCESSING: u32 = 102;
pub const NGX_HTTP_OK: u32 = 200;
pub const NGX_HTTP_CREATED: u32 = 201;
pub const NGX_HTTP_ACCEPTED: u32 = 202;
pub const NGX_HTTP_NO_CONTENT: u32 = 204;
pub const NGX_HTTP_PARTIAL_CONTENT: u32 = 206;
pub const NGX_HTTP_SPECIAL_RESPONSE: u32 = 300;
pub const NGX_HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const NGX_HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const NGX_HTTP_SEE_OTHER: u32 = 303;
pub const NGX_HTTP_NOT_MODIFIED: u32 = 304;
pub const NGX_HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const NGX_HTTP_PERMANENT_REDIRECT: u32 = 308;
pub const NGX_HTTP_BAD_REQUEST: u32 = 400;
pub const NGX_HTTP_UNAUTHORIZED: u32 = 401;
pub const NGX_HTTP_FORBIDDEN: u32 = 403;
pub const NGX_HTTP_NOT_FOUND: u32 = 404;
pub const NGX_HTTP_NOT_ALLOWED: u32 = 405;
pub const NGX_HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const NGX_HTTP_CONFLICT: u32 = 409;
pub const NGX_HTTP_LENGTH_REQUIRED: u32 = 411;
pub const NGX_HTTP_PRECONDITION_FAILED: u32 = 412;
pub const NGX_HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const NGX_HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const NGX_HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const NGX_HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const NGX_HTTP_MISDIRECTED_REQUEST: u32 = 421;
pub const NGX_HTTP_TOO_MANY_REQUESTS: u32 = 429;
pub const NGX_HTTP_CLOSE: u32 = 444;
pub const NGX_HTTPS_HANDSHAKE_ERROR: u32 = 490;
pub const NGX_HTTP_NGINX_CODES: u32 = 491;
pub const NGX_HTTPS_CERT_ERROR_NOT_YET_VALID: u32 = 491;
pub const NGX_HTTPS_CERT_ERROR_HAS_EXPIRED: u32 = 492;
pub const NGX_HTTPS_CERT_ERROR_REVOKED: u32 = 493;
pub const NGX_HTTP_REQUEST_HEADER_TOO_LARGE: u32 = 494;
pub const NGX_HTTPS_CERT_ERROR: u32 = 495;
pub const NGX_HTTPS_NO_CERT: u32 = 496;
pub const NGX_HTTP_TO_HTTPS: u32 = 497;
pub const NGX_HTTP_CLIENT_CLOSED_REQUEST: u32 = 499;
pub const NGX_HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const NGX_HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const NGX_HTTP_BAD_GATEWAY: u32 = 502;
pub const NGX_HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const NGX_HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const NGX_HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const NGX_HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const NGX_HTTP_LOWLEVEL_BUFFERED: u32 = 240;
pub const NGX_HTTP_WRITE_BUFFERED: u32 = 16;
pub const NGX_HTTP_GZIP_BUFFERED: u32 = 32;
pub const NGX_HTTP_SSI_BUFFERED: u32 = 1;
pub const NGX_HTTP_SUB_BUFFERED: u32 = 2;
pub const NGX_HTTP_COPY_BUFFERED: u32 = 4;
pub const NGX_INVALID_INDEX: u32 = 3503345872;
pub const NGX_USE_LEVEL_EVENT: u32 = 1;
pub const NGX_USE_ONESHOT_EVENT: u32 = 2;
pub const NGX_USE_CLEAR_EVENT: u32 = 4;
pub const NGX_USE_KQUEUE_EVENT: u32 = 8;
pub const NGX_USE_LOWAT_EVENT: u32 = 16;
pub const NGX_USE_GREEDY_EVENT: u32 = 32;
pub const NGX_USE_EPOLL_EVENT: u32 = 64;
pub const NGX_USE_RTSIG_EVENT: u32 = 128;
pub const NGX_USE_AIO_EVENT: u32 = 256;
pub const NGX_USE_IOCP_EVENT: u32 = 512;
pub const NGX_USE_FD_EVENT: u32 = 1024;
pub const NGX_USE_TIMER_EVENT: u32 = 2048;
pub const NGX_USE_EVENTPORT_EVENT: u32 = 4096;
pub const NGX_USE_VNODE_EVENT: u32 = 8192;
pub const NGX_CLOSE_EVENT: u32 = 1;
pub const NGX_DISABLE_EVENT: u32 = 2;
pub const NGX_FLUSH_EVENT: u32 = 4;
pub const NGX_LOWAT_EVENT: u32 = 0;
pub const NGX_VNODE_EVENT: u32 = 0;
pub const NGX_LEVEL_EVENT: u32 = 0;
pub const NGX_ONESHOT_EVENT: u32 = 1879048192;
pub const NGX_EVENT_MODULE: u32 = 1414420037;
pub const NGX_EVENT_CONF: u32 = 33554432;
pub const NGX_UPDATE_TIME: u32 = 1;
pub const NGX_POST_EVENTS: u32 = 2;
pub const NGX_TIMER_LAZY_DELAY: u32 = 300;
pub const NGX_PEER_KEEPALIVE: u32 = 1;
pub const NGX_PEER_NEXT: u32 = 2;
pub const NGX_PEER_FAILED: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FT_ERROR: u32 = 2;
pub const NGX_HTTP_UPSTREAM_FT_TIMEOUT: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FT_INVALID_HEADER: u32 = 8;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_500: u32 = 16;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_502: u32 = 32;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_503: u32 = 64;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_504: u32 = 128;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_403: u32 = 256;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_404: u32 = 512;
pub const NGX_HTTP_UPSTREAM_FT_HTTP_429: u32 = 1024;
pub const NGX_HTTP_UPSTREAM_FT_UPDATING: u32 = 2048;
pub const NGX_HTTP_UPSTREAM_FT_BUSY_LOCK: u32 = 4096;
pub const NGX_HTTP_UPSTREAM_FT_MAX_WAITING: u32 = 8192;
pub const NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT: u32 = 16384;
pub const NGX_HTTP_UPSTREAM_FT_NOLIVE: u32 = 1073741824;
pub const NGX_HTTP_UPSTREAM_FT_OFF: u32 = 2147483648;
pub const NGX_HTTP_UPSTREAM_FT_STATUS: u32 = 2032;
pub const NGX_HTTP_UPSTREAM_INVALID_HEADER: u32 = 40;
pub const NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT: u32 = 2;
pub const NGX_HTTP_UPSTREAM_IGN_XA_EXPIRES: u32 = 4;
pub const NGX_HTTP_UPSTREAM_IGN_EXPIRES: u32 = 8;
pub const NGX_HTTP_UPSTREAM_IGN_CACHE_CONTROL: u32 = 16;
pub const NGX_HTTP_UPSTREAM_IGN_SET_COOKIE: u32 = 32;
pub const NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE: u32 = 64;
pub const NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING: u32 = 128;
pub const NGX_HTTP_UPSTREAM_IGN_XA_CHARSET: u32 = 256;
pub const NGX_HTTP_UPSTREAM_IGN_VARY: u32 = 512;
pub const NGX_HTTP_UPSTREAM_CREATE: u32 = 1;
pub const NGX_HTTP_UPSTREAM_WEIGHT: u32 = 2;
pub const NGX_HTTP_UPSTREAM_MAX_FAILS: u32 = 4;
pub const NGX_HTTP_UPSTREAM_FAIL_TIMEOUT: u32 = 8;
pub const NGX_HTTP_UPSTREAM_DOWN: u32 = 16;
pub const NGX_HTTP_UPSTREAM_BACKUP: u32 = 32;
pub const NGX_HTTP_UPSTREAM_MAX_CONNS: u32 = 256;
pub const NGX_HTTP_UPSTREAM_SCHED_FAIR: u32 = 512;
pub const HAVE_NGX_UPSTREAM_TIMEOUT_FIELDS: u32 = 1;
pub const NGX_HTTP_GZIP_PROXIED_OFF: u32 = 2;
pub const NGX_HTTP_GZIP_PROXIED_EXPIRED: u32 = 4;
pub const NGX_HTTP_GZIP_PROXIED_NO_CACHE: u32 = 8;
pub const NGX_HTTP_GZIP_PROXIED_NO_STORE: u32 = 16;
pub const NGX_HTTP_GZIP_PROXIED_PRIVATE: u32 = 32;
pub const NGX_HTTP_GZIP_PROXIED_NO_LM: u32 = 64;
pub const NGX_HTTP_GZIP_PROXIED_NO_ETAG: u32 = 128;
pub const NGX_HTTP_GZIP_PROXIED_AUTH: u32 = 256;
pub const NGX_HTTP_GZIP_PROXIED_ANY: u32 = 512;
pub const NGX_HTTP_AIO_OFF: u32 = 0;
pub const NGX_HTTP_AIO_ON: u32 = 1;
pub const NGX_HTTP_AIO_THREADS: u32 = 2;
pub const NGX_HTTP_SATISFY_ALL: u32 = 0;
pub const NGX_HTTP_SATISFY_ANY: u32 = 1;
pub const NGX_HTTP_LINGERING_OFF: u32 = 0;
pub const NGX_HTTP_LINGERING_ON: u32 = 1;
pub const NGX_HTTP_LINGERING_ALWAYS: u32 = 2;
pub const NGX_HTTP_IMS_OFF: u32 = 0;
pub const NGX_HTTP_IMS_EXACT: u32 = 1;
pub const NGX_HTTP_IMS_BEFORE: u32 = 2;
pub const NGX_HTTP_KEEPALIVE_DISABLE_NONE: u32 = 2;
pub const NGX_HTTP_KEEPALIVE_DISABLE_MSIE6: u32 = 4;
pub const NGX_HTTP_KEEPALIVE_DISABLE_SAFARI: u32 = 8;
pub const NGX_HTTP_SERVER_TOKENS_OFF: u32 = 0;
pub const NGX_HTTP_SERVER_TOKENS_ON: u32 = 1;
pub const NGX_HTTP_SERVER_TOKENS_BUILD: u32 = 2;
pub const NGX_HTTP_V2_ALPN_PROTO: &[u8; 4] = b"\x02h2\0";
pub const NGX_HTTP_V2_STATE_BUFFER_SIZE: u32 = 16;
pub const NGX_HTTP_V2_DEFAULT_FRAME_SIZE: u32 = 16384;
pub const NGX_HTTP_V2_MAX_FRAME_SIZE: u32 = 16777215;
pub const NGX_HTTP_V2_INT_OCTETS: u32 = 4;
pub const NGX_HTTP_V2_MAX_FIELD: u32 = 2097278;
pub const NGX_HTTP_V2_STREAM_ID_SIZE: u32 = 4;
pub const NGX_HTTP_V2_FRAME_HEADER_SIZE: u32 = 9;
pub const NGX_HTTP_V2_DATA_FRAME: u32 = 0;
pub const NGX_HTTP_V2_HEADERS_FRAME: u32 = 1;
pub const NGX_HTTP_V2_PRIORITY_FRAME: u32 = 2;
pub const NGX_HTTP_V2_RST_STREAM_FRAME: u32 = 3;
pub const NGX_HTTP_V2_SETTINGS_FRAME: u32 = 4;
pub const NGX_HTTP_V2_PUSH_PROMISE_FRAME: u32 = 5;
pub const NGX_HTTP_V2_PING_FRAME: u32 = 6;
pub const NGX_HTTP_V2_GOAWAY_FRAME: u32 = 7;
pub const NGX_HTTP_V2_WINDOW_UPDATE_FRAME: u32 = 8;
pub const NGX_HTTP_V2_CONTINUATION_FRAME: u32 = 9;
pub const NGX_HTTP_V2_NO_FLAG: u32 = 0;
pub const NGX_HTTP_V2_ACK_FLAG: u32 = 1;
pub const NGX_HTTP_V2_END_STREAM_FLAG: u32 = 1;
pub const NGX_HTTP_V2_END_HEADERS_FLAG: u32 = 4;
pub const NGX_HTTP_V2_PADDED_FLAG: u32 = 8;
pub const NGX_HTTP_V2_PRIORITY_FLAG: u32 = 32;
pub const NGX_HTTP_V2_MAX_WINDOW: u32 = 2147483647;
pub const NGX_HTTP_V2_DEFAULT_WINDOW: u32 = 65535;
pub const NGX_HTTP_V2_DEFAULT_WEIGHT: u32 = 16;
pub const NGX_HTTP_V2_ENCODE_RAW: u32 = 0;
pub const NGX_HTTP_V2_ENCODE_HUFF: u32 = 128;
pub const NGX_HTTP_V2_AUTHORITY_INDEX: u32 = 1;
pub const NGX_HTTP_V2_METHOD_INDEX: u32 = 2;
pub const NGX_HTTP_V2_METHOD_GET_INDEX: u32 = 2;
pub const NGX_HTTP_V2_METHOD_POST_INDEX: u32 = 3;
pub const NGX_HTTP_V2_PATH_INDEX: u32 = 4;
pub const NGX_HTTP_V2_PATH_ROOT_INDEX: u32 = 4;
pub const NGX_HTTP_V2_SCHEME_HTTP_INDEX: u32 = 6;
pub const NGX_HTTP_V2_SCHEME_HTTPS_INDEX: u32 = 7;
pub const NGX_HTTP_V2_STATUS_INDEX: u32 = 8;
pub const NGX_HTTP_V2_STATUS_200_INDEX: u32 = 8;
pub const NGX_HTTP_V2_STATUS_204_INDEX: u32 = 9;
pub const NGX_HTTP_V2_STATUS_206_INDEX: u32 = 10;
pub const NGX_HTTP_V2_STATUS_304_INDEX: u32 = 11;
pub const NGX_HTTP_V2_STATUS_400_INDEX: u32 = 12;
pub const NGX_HTTP_V2_STATUS_404_INDEX: u32 = 13;
pub const NGX_HTTP_V2_STATUS_500_INDEX: u32 = 14;
pub const NGX_HTTP_V2_ACCEPT_ENCODING_INDEX: u32 = 16;
pub const NGX_HTTP_V2_ACCEPT_LANGUAGE_INDEX: u32 = 17;
pub const NGX_HTTP_V2_CONTENT_LENGTH_INDEX: u32 = 28;
pub const NGX_HTTP_V2_CONTENT_TYPE_INDEX: u32 = 31;
pub const NGX_HTTP_V2_DATE_INDEX: u32 = 33;
pub const NGX_HTTP_V2_LAST_MODIFIED_INDEX: u32 = 44;
pub const NGX_HTTP_V2_LOCATION_INDEX: u32 = 46;
pub const NGX_HTTP_V2_SERVER_INDEX: u32 = 54;
pub const NGX_HTTP_V2_USER_AGENT_INDEX: u32 = 58;
pub const NGX_HTTP_V2_VARY_INDEX: u32 = 59;
pub const NGX_HTTP_CACHE_MISS: u32 = 1;
pub const NGX_HTTP_CACHE_BYPASS: u32 = 2;
pub const NGX_HTTP_CACHE_EXPIRED: u32 = 3;
pub const NGX_HTTP_CACHE_STALE: u32 = 4;
pub const NGX_HTTP_CACHE_UPDATING: u32 = 5;
pub const NGX_HTTP_CACHE_REVALIDATED: u32 = 6;
pub const NGX_HTTP_CACHE_HIT: u32 = 7;
pub const NGX_HTTP_CACHE_SCARCE: u32 = 8;
pub const NGX_HTTP_CACHE_KEY_LEN: u32 = 16;
pub const NGX_HTTP_CACHE_ETAG_LEN: u32 = 128;
pub const NGX_HTTP_CACHE_VARY_LEN: u32 = 128;
pub const NGX_HTTP_CACHE_VERSION: u32 = 5;
pub const NGX_HTTP_SSI_MAX_PARAMS: u32 = 16;
pub const NGX_HTTP_SSI_COMMAND_LEN: u32 = 32;
pub const NGX_HTTP_SSI_PARAM_LEN: u32 = 32;
pub const NGX_HTTP_SSI_PARAMS_N: u32 = 4;
pub const NGX_HTTP_SSI_COND_IF: u32 = 1;
pub const NGX_HTTP_SSI_COND_ELSE: u32 = 2;
pub const NGX_HTTP_SSI_NO_ENCODING: u32 = 0;
pub const NGX_HTTP_SSI_URL_ENCODING: u32 = 1;
pub const NGX_HTTP_SSI_ENTITY_ENCODING: u32 = 2;
pub const NGX_HTTP_LAST: u32 = 1;
pub const NGX_HTTP_FLUSH: u32 = 2;
pub type __u_char = ::aya_ebpf::cty::c_uchar;
pub type __u_short = ::aya_ebpf::cty::c_ushort;
pub type __u_int = ::aya_ebpf::cty::c_uint;
pub type __u_long = ::aya_ebpf::cty::c_ulong;
pub type __int8_t = ::aya_ebpf::cty::c_schar;
pub type __uint8_t = ::aya_ebpf::cty::c_uchar;
pub type __int16_t = ::aya_ebpf::cty::c_short;
pub type __uint16_t = ::aya_ebpf::cty::c_ushort;
pub type __int32_t = ::aya_ebpf::cty::c_int;
pub type __uint32_t = ::aya_ebpf::cty::c_uint;
pub type __int64_t = ::aya_ebpf::cty::c_long;
pub type __uint64_t = ::aya_ebpf::cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::aya_ebpf::cty::c_long;
pub type __u_quad_t = ::aya_ebpf::cty::c_ulong;
pub type __intmax_t = ::aya_ebpf::cty::c_long;
pub type __uintmax_t = ::aya_ebpf::cty::c_ulong;
pub type __dev_t = ::aya_ebpf::cty::c_ulong;
pub type __uid_t = ::aya_ebpf::cty::c_uint;
pub type __gid_t = ::aya_ebpf::cty::c_uint;
pub type __ino_t = ::aya_ebpf::cty::c_ulong;
pub type __ino64_t = ::aya_ebpf::cty::c_ulong;
pub type __mode_t = ::aya_ebpf::cty::c_uint;
pub type __nlink_t = ::aya_ebpf::cty::c_ulong;
pub type __off_t = ::aya_ebpf::cty::c_long;
pub type __off64_t = ::aya_ebpf::cty::c_long;
pub type __pid_t = ::aya_ebpf::cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::aya_ebpf::cty::c_int; 2usize],
}
pub type __clock_t = ::aya_ebpf::cty::c_long;
pub type __rlim_t = ::aya_ebpf::cty::c_ulong;
pub type __rlim64_t = ::aya_ebpf::cty::c_ulong;
pub type __id_t = ::aya_ebpf::cty::c_uint;
pub type __time_t = ::aya_ebpf::cty::c_long;
pub type __useconds_t = ::aya_ebpf::cty::c_uint;
pub type __suseconds_t = ::aya_ebpf::cty::c_long;
pub type __suseconds64_t = ::aya_ebpf::cty::c_long;
pub type __daddr_t = ::aya_ebpf::cty::c_int;
pub type __key_t = ::aya_ebpf::cty::c_int;
pub type __clockid_t = ::aya_ebpf::cty::c_int;
pub type __timer_t = *mut ::aya_ebpf::cty::c_void;
pub type __blksize_t = ::aya_ebpf::cty::c_long;
pub type __blkcnt_t = ::aya_ebpf::cty::c_long;
pub type __blkcnt64_t = ::aya_ebpf::cty::c_long;
pub type __fsblkcnt_t = ::aya_ebpf::cty::c_ulong;
pub type __fsblkcnt64_t = ::aya_ebpf::cty::c_ulong;
pub type __fsfilcnt_t = ::aya_ebpf::cty::c_ulong;
pub type __fsfilcnt64_t = ::aya_ebpf::cty::c_ulong;
pub type __fsword_t = ::aya_ebpf::cty::c_long;
pub type __ssize_t = ::aya_ebpf::cty::c_long;
pub type __syscall_slong_t = ::aya_ebpf::cty::c_long;
pub type __syscall_ulong_t = ::aya_ebpf::cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::aya_ebpf::cty::c_char;
pub type __intptr_t = ::aya_ebpf::cty::c_long;
pub type __socklen_t = ::aya_ebpf::cty::c_uint;
pub type __sig_atomic_t = ::aya_ebpf::cty::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino64_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off64_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::aya_ebpf::cty::c_ulong;
pub type ushort = ::aya_ebpf::cty::c_ushort;
pub type uint = ::aya_ebpf::cty::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::aya_ebpf::cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::aya_ebpf::cty::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type __fd_mask = ::aya_ebpf::cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::aya_ebpf::cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::aya_ebpf::cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt64_t;
pub type fsblkcnt_t = __fsblkcnt64_t;
pub type fsfilcnt_t = __fsfilcnt64_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::aya_ebpf::cty::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::aya_ebpf::cty::c_uint,
    pub __high: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::aya_ebpf::cty::c_int,
    pub __count: ::aya_ebpf::cty::c_uint,
    pub __owner: ::aya_ebpf::cty::c_int,
    pub __nusers: ::aya_ebpf::cty::c_uint,
    pub __kind: ::aya_ebpf::cty::c_int,
    pub __spins: ::aya_ebpf::cty::c_short,
    pub __elision: ::aya_ebpf::cty::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::aya_ebpf::cty::c_uint,
    pub __writers: ::aya_ebpf::cty::c_uint,
    pub __wrphase_futex: ::aya_ebpf::cty::c_uint,
    pub __writers_futex: ::aya_ebpf::cty::c_uint,
    pub __pad3: ::aya_ebpf::cty::c_uint,
    pub __pad4: ::aya_ebpf::cty::c_uint,
    pub __cur_writer: ::aya_ebpf::cty::c_int,
    pub __shared: ::aya_ebpf::cty::c_int,
    pub __rwelision: ::aya_ebpf::cty::c_schar,
    pub __pad1: [::aya_ebpf::cty::c_uchar; 7usize],
    pub __pad2: ::aya_ebpf::cty::c_ulong,
    pub __flags: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::aya_ebpf::cty::c_uint; 2usize],
    pub __g_size: [::aya_ebpf::cty::c_uint; 2usize],
    pub __g1_orig_size: ::aya_ebpf::cty::c_uint,
    pub __wrefs: ::aya_ebpf::cty::c_uint,
    pub __g_signals: [::aya_ebpf::cty::c_uint; 2usize],
}
pub type __tss_t = ::aya_ebpf::cty::c_uint;
pub type __thrd_t = ::aya_ebpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::aya_ebpf::cty::c_int,
}
pub type pthread_t = ::aya_ebpf::cty::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::aya_ebpf::cty::c_char; 4usize],
    pub __align: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::aya_ebpf::cty::c_char; 4usize],
    pub __align: ::aya_ebpf::cty::c_int,
}
pub type pthread_key_t = ::aya_ebpf::cty::c_uint;
pub type pthread_once_t = ::aya_ebpf::cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::aya_ebpf::cty::c_char; 56usize],
    pub __align: ::aya_ebpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::aya_ebpf::cty::c_char; 40usize],
    pub __align: ::aya_ebpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::aya_ebpf::cty::c_char; 48usize],
    pub __align: ::aya_ebpf::cty::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::aya_ebpf::cty::c_char; 56usize],
    pub __align: ::aya_ebpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::aya_ebpf::cty::c_char; 8usize],
    pub __align: ::aya_ebpf::cty::c_long,
}
pub type pthread_spinlock_t = ::aya_ebpf::cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::aya_ebpf::cty::c_char; 32usize],
    pub __align: ::aya_ebpf::cty::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::aya_ebpf::cty::c_char; 4usize],
    pub __align: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::aya_ebpf::cty::c_int,
    pub tz_dsttime: ::aya_ebpf::cty::c_int,
}
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::aya_ebpf::cty::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub use self::__itimer_which as __itimer_which_t;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn utimes(__file: *const ::aya_ebpf::cty::c_char, __tvp: *const timeval) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const ::aya_ebpf::cty::c_char, __tvp: *const timeval) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::aya_ebpf::cty::c_int, __tvp: *const timeval) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn futimesat(
        __fd: ::aya_ebpf::cty::c_int,
        __file: *const ::aya_ebpf::cty::c_char,
        __tvp: *const timeval,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const ::aya_ebpf::cty::c_char, __type: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn euidaccess(__name: *const ::aya_ebpf::cty::c_char, __type: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn eaccess(__name: *const ::aya_ebpf::cty::c_char, __type: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execveat(
        __fd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __argv: *const *mut ::aya_ebpf::cty::c_char,
        __envp: *const *mut ::aya_ebpf::cty::c_char,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::aya_ebpf::cty::c_int,
        __file: *const ::aya_ebpf::cty::c_char,
        __type: ::aya_ebpf::cty::c_int,
        __flag: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}lseek64"]
    pub fn lseek(__fd: ::aya_ebpf::cty::c_int, __offset: __off64_t, __whence: ::aya_ebpf::cty::c_int) -> __off64_t;
}
extern "C" {
    pub fn close(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn read(__fd: ::aya_ebpf::cty::c_int, __buf: *mut ::aya_ebpf::cty::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: ::aya_ebpf::cty::c_int, __buf: *const ::aya_ebpf::cty::c_void, __n: usize) -> isize;
}
extern "C" {
    #[link_name = "\u{1}pread64"]
    pub fn pread(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}pwrite64"]
    pub fn pwrite(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *const ::aya_ebpf::cty::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pipe2(__pipedes: *mut ::aya_ebpf::cty::c_int, __flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pause() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn chown(__file: *const ::aya_ebpf::cty::c_char, __owner: __uid_t, __group: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fchown(__fd: ::aya_ebpf::cty::c_int, __owner: __uid_t, __group: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn lchown(__file: *const ::aya_ebpf::cty::c_char, __owner: __uid_t, __group: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::aya_ebpf::cty::c_int,
        __file: *const ::aya_ebpf::cty::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::aya_ebpf::cty::c_char, __size: usize) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn get_current_dir_name() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn dup(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::aya_ebpf::cty::c_int, __fd2: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn dup3(
        __fd: ::aya_ebpf::cty::c_int,
        __fd2: ::aya_ebpf::cty::c_int,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut environ: *mut *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::aya_ebpf::cty::c_char,
        __argv: *const *mut ::aya_ebpf::cty::c_char,
        __envp: *const *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::aya_ebpf::cty::c_int,
        __argv: *const *mut ::aya_ebpf::cty::c_char,
        __envp: *const *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::aya_ebpf::cty::c_char,
        __argv: *const *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::aya_ebpf::cty::c_char,
        __arg: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::aya_ebpf::cty::c_char,
        __arg: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::aya_ebpf::cty::c_char,
        __argv: *const *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::aya_ebpf::cty::c_char,
        __arg: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn execvpe(
        __file: *const ::aya_ebpf::cty::c_char,
        __argv: *const *mut ::aya_ebpf::cty::c_char,
        __envp: *const *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn nice(__inc: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn _exit(__status: ::aya_ebpf::cty::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::aya_ebpf::cty::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::aya_ebpf::cty::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn pathconf(__path: *const ::aya_ebpf::cty::c_char, __name: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: ::aya_ebpf::cty::c_int, __name: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn confstr(__name: ::aya_ebpf::cty::c_int, __buf: *mut ::aya_ebpf::cty::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::aya_ebpf::cty::c_int, __list: *mut __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn group_member(__gid: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getresuid(__ruid: *mut __uid_t, __euid: *mut __uid_t, __suid: *mut __uid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getresgid(__rgid: *mut __gid_t, __egid: *mut __gid_t, __sgid: *mut __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn _Fork() -> __pid_t;
}
extern "C" {
    pub fn ttyname(__fd: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn link(__from: *const ::aya_ebpf::cty::c_char, __to: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::aya_ebpf::cty::c_int,
        __from: *const ::aya_ebpf::cty::c_char,
        __tofd: ::aya_ebpf::cty::c_int,
        __to: *const ::aya_ebpf::cty::c_char,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn symlink(__from: *const ::aya_ebpf::cty::c_char, __to: *const ::aya_ebpf::cty::c_char)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn readlink(__path: *const ::aya_ebpf::cty::c_char, __buf: *mut ::aya_ebpf::cty::c_char, __len: usize) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::aya_ebpf::cty::c_char,
        __tofd: ::aya_ebpf::cty::c_int,
        __to: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::aya_ebpf::cty::c_int,
        __name: *const ::aya_ebpf::cty::c_char,
        __flag: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::aya_ebpf::cty::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::aya_ebpf::cty::c_int, __pgrp_id: __pid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut ::aya_ebpf::cty::c_char, __name_len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut optind: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut opterr: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut optopt: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::aya_ebpf::cty::c_int,
        ___argv: *const *mut ::aya_ebpf::cty::c_char,
        __shortopts: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::aya_ebpf::cty::c_char, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const ::aya_ebpf::cty::c_char, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut ::aya_ebpf::cty::c_char, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const ::aya_ebpf::cty::c_char, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vhangup() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::aya_ebpf::cty::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: ::aya_ebpf::cty::c_int, __noclose: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn syncfs(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gethostid() -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}truncate64"]
    pub fn truncate(__file: *const ::aya_ebpf::cty::c_char, __length: __off64_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}ftruncate64"]
    pub fn ftruncate(__fd: ::aya_ebpf::cty::c_int, __length: __off64_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::aya_ebpf::cty::c_long, ...) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    #[link_name = "\u{1}lockf64"]
    pub fn lockf(__fd: ::aya_ebpf::cty::c_int, __cmd: ::aya_ebpf::cty::c_int, __len: __off64_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn copy_file_range(
        __infd: ::aya_ebpf::cty::c_int,
        __pinoff: *mut __off64_t,
        __outfd: ::aya_ebpf::cty::c_int,
        __poutoff: *mut __off64_t,
        __length: usize,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn fdatasync(__fildes: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::aya_ebpf::cty::c_char,
        __salt: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn swab(__from: *const ::aya_ebpf::cty::c_void, __to: *mut ::aya_ebpf::cty::c_void, __n: isize);
}
extern "C" {
    pub fn getentropy(__buffer: *mut ::aya_ebpf::cty::c_void, __length: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn close_range(
        __fd: ::aya_ebpf::cty::c_uint,
        __max_fd: ::aya_ebpf::cty::c_uint,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gettid() -> __pid_t;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::aya_ebpf::cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::aya_ebpf::cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::aya_ebpf::cty::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::aya_ebpf::cty::c_uint,
    pub __wchb: [::aya_ebpf::cty::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::aya_ebpf::cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::aya_ebpf::cty::c_int,
    pub _IO_read_ptr: *mut ::aya_ebpf::cty::c_char,
    pub _IO_read_end: *mut ::aya_ebpf::cty::c_char,
    pub _IO_read_base: *mut ::aya_ebpf::cty::c_char,
    pub _IO_write_base: *mut ::aya_ebpf::cty::c_char,
    pub _IO_write_ptr: *mut ::aya_ebpf::cty::c_char,
    pub _IO_write_end: *mut ::aya_ebpf::cty::c_char,
    pub _IO_buf_base: *mut ::aya_ebpf::cty::c_char,
    pub _IO_buf_end: *mut ::aya_ebpf::cty::c_char,
    pub _IO_save_base: *mut ::aya_ebpf::cty::c_char,
    pub _IO_backup_base: *mut ::aya_ebpf::cty::c_char,
    pub _IO_save_end: *mut ::aya_ebpf::cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::aya_ebpf::cty::c_int,
    pub _flags2: ::aya_ebpf::cty::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::aya_ebpf::cty::c_ushort,
    pub _vtable_offset: ::aya_ebpf::cty::c_schar,
    pub _shortbuf: [::aya_ebpf::cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::aya_ebpf::cty::c_void,
    pub __pad5: usize,
    pub _mode: ::aya_ebpf::cty::c_int,
    pub _unused2: [::aya_ebpf::cty::c_char; 20usize],
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::aya_ebpf::cty::c_void,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::aya_ebpf::cty::c_void,
        __buf: *const ::aya_ebpf::cty::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::aya_ebpf::cty::c_void,
        __pos: *mut __off64_t,
        __w: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type cookie_close_function_t =
    ::core::option::Option<unsafe extern "C" fn(__cookie: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos64_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::aya_ebpf::cty::c_char, __new: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::aya_ebpf::cty::c_int,
        __old: *const ::aya_ebpf::cty::c_char,
        __newfd: ::aya_ebpf::cty::c_int,
        __new: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::aya_ebpf::cty::c_int,
        __old: *const ::aya_ebpf::cty::c_char,
        __newfd: ::aya_ebpf::cty::c_int,
        __new: *const ::aya_ebpf::cty::c_char,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}tmpfile64"]
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::aya_ebpf::cty::c_char,
        __pfx: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}fopen64"]
    pub fn fopen(__filename: *const ::aya_ebpf::cty::c_char, __modes: *const ::aya_ebpf::cty::c_char) -> *mut FILE;
}
extern "C" {
    #[link_name = "\u{1}freopen64"]
    pub fn freopen(
        __filename: *const ::aya_ebpf::cty::c_char,
        __modes: *const ::aya_ebpf::cty::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::aya_ebpf::cty::c_int, __modes: *const ::aya_ebpf::cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::aya_ebpf::cty::c_void,
        __modes: *const ::aya_ebpf::cty::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __modes: *const ::aya_ebpf::cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::aya_ebpf::cty::c_char, __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __modes: ::aya_ebpf::cty::c_int,
        __n: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::aya_ebpf::cty::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::aya_ebpf::cty::c_char,
        __format: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::aya_ebpf::cty::c_char, __arg: *mut __va_list_tag) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::aya_ebpf::cty::c_char,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::aya_ebpf::cty::c_char,
        __maxlen: ::aya_ebpf::cty::c_ulong,
        __format: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::aya_ebpf::cty::c_char,
        __maxlen: ::aya_ebpf::cty::c_ulong,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::aya_ebpf::cty::c_char,
        __f: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::aya_ebpf::cty::c_char,
        __fmt: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::aya_ebpf::cty::c_char,
        __fmt: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::aya_ebpf::cty::c_int,
        __fmt: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::aya_ebpf::cty::c_int, __fmt: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::aya_ebpf::cty::c_char,
        __format: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::aya_ebpf::cty::c_char,
        __format: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::aya_ebpf::cty::c_char, __arg: *mut __va_list_tag) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::aya_ebpf::cty::c_char,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::aya_ebpf::cty::c_char, __arg: *mut __va_list_tag) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::aya_ebpf::cty::c_char,
        __format: *const ::aya_ebpf::cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getchar() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fputc(__c: ::aya_ebpf::cty::c_int, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn putc(__c: ::aya_ebpf::cty::c_int, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn putchar(__c: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::aya_ebpf::cty::c_int, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::aya_ebpf::cty::c_int, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn putw(__w: ::aya_ebpf::cty::c_int, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_int,
        __stream: *mut FILE,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_int,
        __stream: *mut FILE,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::aya_ebpf::cty::c_char,
        __n: *mut usize,
        __delimiter: ::aya_ebpf::cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::aya_ebpf::cty::c_char,
        __n: *mut usize,
        __delimiter: ::aya_ebpf::cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::aya_ebpf::cty::c_char, __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::aya_ebpf::cty::c_char, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::aya_ebpf::cty::c_int, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::aya_ebpf::cty::c_void,
        __size: ::aya_ebpf::cty::c_ulong,
        __n: ::aya_ebpf::cty::c_ulong,
        __stream: *mut FILE,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::aya_ebpf::cty::c_void,
        __size: ::aya_ebpf::cty::c_ulong,
        __n: ::aya_ebpf::cty::c_ulong,
        __s: *mut FILE,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn fputs_unlocked(__s: *const ::aya_ebpf::cty::c_char, __stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::aya_ebpf::cty::c_void, __size: usize, __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::aya_ebpf::cty::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::aya_ebpf::cty::c_long,
        __whence: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    #[link_name = "\u{1}fseeko64"]
    pub fn fseeko(__stream: *mut FILE, __off: __off64_t, __whence: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}ftello64"]
    pub fn ftello(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    #[link_name = "\u{1}fgetpos64"]
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}fsetpos64"]
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::aya_ebpf::cty::c_char, __modes: *const ::aya_ebpf::cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::aya_ebpf::cty::c_char,
        __args: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::aya_ebpf::cty::c_int,
    pub rem: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::aya_ebpf::cty::c_long,
    pub rem: ::aya_ebpf::cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::aya_ebpf::cty::c_longlong,
    pub rem: ::aya_ebpf::cty::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::aya_ebpf::cty::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> u128;
}
extern "C" {
    pub fn strtof32(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> _Float32;
}
extern "C" {
    pub fn strtof64(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> _Float64;
}
extern "C" {
    pub fn strtof32x(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> _Float32x;
}
extern "C" {
    pub fn strtof64x(__nptr: *const ::aya_ebpf::cty::c_char, __endptr: *mut *mut ::aya_ebpf::cty::c_char) -> _Float64x;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulonglong;
}
extern "C" {
    pub fn strfromd(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: f64,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfromf(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: f32,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfroml(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: u128,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfromf32(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: _Float32,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfromf64(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: _Float64,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: _Float32x,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __size: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __f: _Float64x,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::aya_ebpf::cty::c_ushort,
    pub __ctype_tolower: *const ::aya_ebpf::cty::c_int,
    pub __ctype_toupper: *const ::aya_ebpf::cty::c_int,
    pub __names: [*const ::aya_ebpf::cty::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
        __loc: locale_t,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
        __loc: locale_t,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
        __loc: locale_t,
    ) -> ::aya_ebpf::cty::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
        __loc: locale_t,
    ) -> ::aya_ebpf::cty::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtold_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> u128;
}
extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
extern "C" {
    pub fn l64a(__n: ::aya_ebpf::cty::c_long) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn random() -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::aya_ebpf::cty::c_uint,
        __statebuf: *mut ::aya_ebpf::cty::c_char,
        __statelen: usize,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::aya_ebpf::cty::c_int,
    pub rand_deg: ::aya_ebpf::cty::c_int,
    pub rand_sep: ::aya_ebpf::cty::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::aya_ebpf::cty::c_uint, __buf: *mut random_data) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::aya_ebpf::cty::c_uint,
        __statebuf: *mut ::aya_ebpf::cty::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::aya_ebpf::cty::c_char, __buf: *mut random_data) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rand() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn srand(__seed: ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::aya_ebpf::cty::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::aya_ebpf::cty::c_ushort) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn mrand48() -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::aya_ebpf::cty::c_ushort) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::aya_ebpf::cty::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::aya_ebpf::cty::c_ushort) -> *mut ::aya_ebpf::cty::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::aya_ebpf::cty::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::aya_ebpf::cty::c_ushort; 3usize],
    pub __old_x: [::aya_ebpf::cty::c_ushort; 3usize],
    pub __c: ::aya_ebpf::cty::c_ushort,
    pub __init: ::aya_ebpf::cty::c_ushort,
    pub __a: ::aya_ebpf::cty::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::aya_ebpf::cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::aya_ebpf::cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::aya_ebpf::cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::aya_ebpf::cty::c_long, __buffer: *mut drand48_data) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::aya_ebpf::cty::c_ushort, __buffer: *mut drand48_data) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::aya_ebpf::cty::c_ushort, __buffer: *mut drand48_data) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::aya_ebpf::cty::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::aya_ebpf::cty::c_ulong) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: ::aya_ebpf::cty::c_ulong, __size: ::aya_ebpf::cty::c_ulong) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::aya_ebpf::cty::c_void, __size: ::aya_ebpf::cty::c_ulong) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::aya_ebpf::cty::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn alloca(__size: ::aya_ebpf::cty::c_ulong) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::aya_ebpf::cty::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::aya_ebpf::cty::c_ulong,
        __size: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: ::aya_ebpf::cty::c_int, __arg: *mut ::aya_ebpf::cty::c_void),
        >,
        __arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn exit(__status: ::aya_ebpf::cty::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::aya_ebpf::cty::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::aya_ebpf::cty::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::aya_ebpf::cty::c_char,
        __value: *const ::aya_ebpf::cty::c_char,
        __replace: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clearenv() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}mkstemp64"]
    pub fn mkstemp(__template: *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}mkstemps64"]
    pub fn mkstemps(
        __template: *mut ::aya_ebpf::cty::c_char,
        __suffixlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}mkostemp64"]
    pub fn mkostemp(__template: *mut ::aya_ebpf::cty::c_char, __flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}mkostemps64"]
    pub fn mkostemps(
        __template: *mut ::aya_ebpf::cty::c_char,
        __suffixlen: ::aya_ebpf::cty::c_int,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn system(__command: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(__name: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn realpath(
        __name: *const ::aya_ebpf::cty::c_char,
        __resolved: *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_ebpf::cty::c_void,
        arg2: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_ebpf::cty::c_void,
        arg2: *const ::aya_ebpf::cty::c_void,
        arg3: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::aya_ebpf::cty::c_void,
        __base: *const ::aya_ebpf::cty::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::aya_ebpf::cty::c_void, __nmemb: usize, __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::aya_ebpf::cty::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn abs(__x: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn labs(__x: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn llabs(__x: ::aya_ebpf::cty::c_longlong) -> ::aya_ebpf::cty::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::aya_ebpf::cty::c_int, __denom: ::aya_ebpf::cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::aya_ebpf::cty::c_long, __denom: ::aya_ebpf::cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::aya_ebpf::cty::c_longlong, __denom: ::aya_ebpf::cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::aya_ebpf::cty::c_int,
        __decpt: *mut ::aya_ebpf::cty::c_int,
        __sign: *mut ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::aya_ebpf::cty::c_char, __n: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::aya_ebpf::cty::c_char, __n: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::aya_ebpf::cty::c_char, __wchar: wchar_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::aya_ebpf::cty::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::aya_ebpf::cty::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::aya_ebpf::cty::c_char,
        __tokens: *const *mut ::aya_ebpf::cty::c_char,
        __valuep: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn posix_openpt(__oflag: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpt() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
pub const _ISupper: _bindgen_ty_4 = 256;
pub const _ISlower: _bindgen_ty_4 = 512;
pub const _ISalpha: _bindgen_ty_4 = 1024;
pub const _ISdigit: _bindgen_ty_4 = 2048;
pub const _ISxdigit: _bindgen_ty_4 = 4096;
pub const _ISspace: _bindgen_ty_4 = 8192;
pub const _ISprint: _bindgen_ty_4 = 16384;
pub const _ISgraph: _bindgen_ty_4 = 32768;
pub const _ISblank: _bindgen_ty_4 = 1;
pub const _IScntrl: _bindgen_ty_4 = 2;
pub const _ISpunct: _bindgen_ty_4 = 4;
pub const _ISalnum: _bindgen_ty_4 = 8;
pub type _bindgen_ty_4 = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::aya_ebpf::cty::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn islower(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn tolower(__c: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn toupper(__c: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isctype(__c: ::aya_ebpf::cty::c_int, __mask: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isascii(__c: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn toascii(__c: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::aya_ebpf::cty::c_int, arg2: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::aya_ebpf::cty::c_int, __l: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::aya_ebpf::cty::c_int, __l: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::aya_ebpf::cty::c_int, __l: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::aya_ebpf::cty::c_int, __l: locale_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut program_invocation_name: *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut program_invocation_short_name: *mut ::aya_ebpf::cty::c_char;
}
pub type error_t = ::aya_ebpf::cty::c_int;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::aya_ebpf::cty::c_void,
        __src: *const ::aya_ebpf::cty::c_void,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::aya_ebpf::cty::c_void,
        __src: *const ::aya_ebpf::cty::c_void,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::aya_ebpf::cty::c_void,
        __src: *const ::aya_ebpf::cty::c_void,
        __c: ::aya_ebpf::cty::c_int,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::aya_ebpf::cty::c_void,
        __c: ::aya_ebpf::cty::c_int,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::aya_ebpf::cty::c_void,
        __s2: *const ::aya_ebpf::cty::c_void,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::aya_ebpf::cty::c_void,
        __s2: *const ::aya_ebpf::cty::c_void,
        __n: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::aya_ebpf::cty::c_void,
        __c: ::aya_ebpf::cty::c_int,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn rawmemchr(__s: *const ::aya_ebpf::cty::c_void, __c: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::aya_ebpf::cty::c_void,
        __c: ::aya_ebpf::cty::c_int,
        __n: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::aya_ebpf::cty::c_char, __s2: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::aya_ebpf::cty::c_char, __s2: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
        __l: locale_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::aya_ebpf::cty::c_char, __c: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::aya_ebpf::cty::c_char, __c: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strchrnul(__s: *const ::aya_ebpf::cty::c_char, __c: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::aya_ebpf::cty::c_char,
        __reject: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::aya_ebpf::cty::c_char,
        __accept: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::aya_ebpf::cty::c_char,
        __accept: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::aya_ebpf::cty::c_char,
        __needle: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::aya_ebpf::cty::c_char,
        __delim: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::aya_ebpf::cty::c_char,
        __delim: *const ::aya_ebpf::cty::c_char,
        __save_ptr: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::aya_ebpf::cty::c_char,
        __delim: *const ::aya_ebpf::cty::c_char,
        __save_ptr: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::aya_ebpf::cty::c_char,
        __needle: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::aya_ebpf::cty::c_void,
        __haystacklen: usize,
        __needle: *const ::aya_ebpf::cty::c_void,
        __needlelen: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::aya_ebpf::cty::c_void,
        __src: *const ::aya_ebpf::cty::c_void,
        __n: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::aya_ebpf::cty::c_void,
        __src: *const ::aya_ebpf::cty::c_void,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::aya_ebpf::cty::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strerrordesc_np(__err: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strerrorname_np(__err: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strerror_l(__errnum: ::aya_ebpf::cty::c_int, __l: locale_t) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::aya_ebpf::cty::c_void,
        __s2: *const ::aya_ebpf::cty::c_void,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::aya_ebpf::cty::c_void, __dest: *mut ::aya_ebpf::cty::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::aya_ebpf::cty::c_void, __n: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn index(__s: *const ::aya_ebpf::cty::c_char, __c: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::aya_ebpf::cty::c_char, __c: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ffs(__i: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::aya_ebpf::cty::c_longlong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
        __loc: locale_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::aya_ebpf::cty::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::aya_ebpf::cty::c_char,
        __delim: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn sigabbrev_np(__sig: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn sigdescr_np(__sig: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
        __n: usize,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::aya_ebpf::cty::c_char,
        __src: *const ::aya_ebpf::cty::c_char,
        __n: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::aya_ebpf::cty::c_char,
        __s2: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::aya_ebpf::cty::c_void, __n: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::aya_ebpf::cty::c_int,
    pub sival_ptr: *mut ::aya_ebpf::cty::c_void,
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::aya_ebpf::cty::c_int,
    pub si_errno: ::aya_ebpf::cty::c_int,
    pub si_code: ::aya_ebpf::cty::c_int,
    pub __pad0: ::aya_ebpf::cty::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::aya_ebpf::cty::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::aya_ebpf::cty::c_int,
    pub si_overrun: ::aya_ebpf::cty::c_int,
    pub si_sigval: __sigval_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::aya_ebpf::cty::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::aya_ebpf::cty::c_void,
    pub si_addr_lsb: ::aya_ebpf::cty::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::aya_ebpf::cty::c_void,
    pub _upper: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::aya_ebpf::cty::c_long,
    pub si_fd: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::aya_ebpf::cty::c_void,
    pub _syscall: ::aya_ebpf::cty::c_int,
    pub _arch: ::aya_ebpf::cty::c_uint,
}
pub const SI_ASYNCNL: _bindgen_ty_5 = -60;
pub const SI_DETHREAD: _bindgen_ty_5 = -7;
pub const SI_TKILL: _bindgen_ty_5 = -6;
pub const SI_SIGIO: _bindgen_ty_5 = -5;
pub const SI_ASYNCIO: _bindgen_ty_5 = -4;
pub const SI_MESGQ: _bindgen_ty_5 = -3;
pub const SI_TIMER: _bindgen_ty_5 = -2;
pub const SI_QUEUE: _bindgen_ty_5 = -1;
pub const SI_USER: _bindgen_ty_5 = 0;
pub const SI_KERNEL: _bindgen_ty_5 = 128;
pub type _bindgen_ty_5 = ::aya_ebpf::cty::c_int;
pub const ILL_ILLOPC: _bindgen_ty_6 = 1;
pub const ILL_ILLOPN: _bindgen_ty_6 = 2;
pub const ILL_ILLADR: _bindgen_ty_6 = 3;
pub const ILL_ILLTRP: _bindgen_ty_6 = 4;
pub const ILL_PRVOPC: _bindgen_ty_6 = 5;
pub const ILL_PRVREG: _bindgen_ty_6 = 6;
pub const ILL_COPROC: _bindgen_ty_6 = 7;
pub const ILL_BADSTK: _bindgen_ty_6 = 8;
pub const ILL_BADIADDR: _bindgen_ty_6 = 9;
pub type _bindgen_ty_6 = ::aya_ebpf::cty::c_uint;
pub const FPE_INTDIV: _bindgen_ty_7 = 1;
pub const FPE_INTOVF: _bindgen_ty_7 = 2;
pub const FPE_FLTDIV: _bindgen_ty_7 = 3;
pub const FPE_FLTOVF: _bindgen_ty_7 = 4;
pub const FPE_FLTUND: _bindgen_ty_7 = 5;
pub const FPE_FLTRES: _bindgen_ty_7 = 6;
pub const FPE_FLTINV: _bindgen_ty_7 = 7;
pub const FPE_FLTSUB: _bindgen_ty_7 = 8;
pub const FPE_FLTUNK: _bindgen_ty_7 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_7 = 15;
pub type _bindgen_ty_7 = ::aya_ebpf::cty::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_8 = 1;
pub const SEGV_ACCERR: _bindgen_ty_8 = 2;
pub const SEGV_BNDERR: _bindgen_ty_8 = 3;
pub const SEGV_PKUERR: _bindgen_ty_8 = 4;
pub const SEGV_ACCADI: _bindgen_ty_8 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_8 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_8 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_8 = 8;
pub const SEGV_MTESERR: _bindgen_ty_8 = 9;
pub type _bindgen_ty_8 = ::aya_ebpf::cty::c_uint;
pub const BUS_ADRALN: _bindgen_ty_9 = 1;
pub const BUS_ADRERR: _bindgen_ty_9 = 2;
pub const BUS_OBJERR: _bindgen_ty_9 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_9 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_9 = 5;
pub type _bindgen_ty_9 = ::aya_ebpf::cty::c_uint;
pub const TRAP_BRKPT: _bindgen_ty_10 = 1;
pub const TRAP_TRACE: _bindgen_ty_10 = 2;
pub const TRAP_BRANCH: _bindgen_ty_10 = 3;
pub const TRAP_HWBKPT: _bindgen_ty_10 = 4;
pub const TRAP_UNK: _bindgen_ty_10 = 5;
pub type _bindgen_ty_10 = ::aya_ebpf::cty::c_uint;
pub const CLD_EXITED: _bindgen_ty_11 = 1;
pub const CLD_KILLED: _bindgen_ty_11 = 2;
pub const CLD_DUMPED: _bindgen_ty_11 = 3;
pub const CLD_TRAPPED: _bindgen_ty_11 = 4;
pub const CLD_STOPPED: _bindgen_ty_11 = 5;
pub const CLD_CONTINUED: _bindgen_ty_11 = 6;
pub type _bindgen_ty_11 = ::aya_ebpf::cty::c_uint;
pub const POLL_IN: _bindgen_ty_12 = 1;
pub const POLL_OUT: _bindgen_ty_12 = 2;
pub const POLL_MSG: _bindgen_ty_12 = 3;
pub const POLL_ERR: _bindgen_ty_12 = 4;
pub const POLL_PRI: _bindgen_ty_12 = 5;
pub const POLL_HUP: _bindgen_ty_12 = 6;
pub type _bindgen_ty_12 = ::aya_ebpf::cty::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::aya_ebpf::cty::c_int,
    pub sigev_notify: ::aya_ebpf::cty::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::aya_ebpf::cty::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_13 = 0;
pub const SIGEV_NONE: _bindgen_ty_13 = 1;
pub const SIGEV_THREAD: _bindgen_ty_13 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_13 = 4;
pub type _bindgen_ty_13 = ::aya_ebpf::cty::c_uint;
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::aya_ebpf::cty::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::aya_ebpf::cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn sysv_signal(__sig: ::aya_ebpf::cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::aya_ebpf::cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn raise(__sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::aya_ebpf::cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::aya_ebpf::cty::c_int, __s: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    #[link_name = "\u{1}__xpg_sigpause"]
    pub fn sigpause(__sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigblock(__mask: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::aya_ebpf::cty::c_int;
}
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigisemptyset(__set: *const sigset_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigandset(__set: *mut sigset_t, __left: *const sigset_t, __right: *const sigset_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigorset(__set: *mut sigset_t, __left: *const sigset_t, __right: *const sigset_t) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::aya_ebpf::cty::c_int,
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::aya_ebpf::cty::c_int, arg2: *mut siginfo_t, arg3: *mut ::aya_ebpf::cty::c_void),
    >,
}
extern "C" {
    pub fn sigprocmask(
        __how: ::aya_ebpf::cty::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::aya_ebpf::cty::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::aya_ebpf::cty::c_int, __val: sigval) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::aya_ebpf::cty::c_ushort; 4usize],
    pub exponent: ::aya_ebpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::aya_ebpf::cty::c_ushort; 4usize],
    pub exponent: ::aya_ebpf::cty::c_ushort,
    pub __glibc_reserved1: [::aya_ebpf::cty::c_ushort; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::aya_ebpf::cty::c_ushort,
    pub gs: ::aya_ebpf::cty::c_ushort,
    pub fs: ::aya_ebpf::cty::c_ushort,
    pub __pad0: ::aya_ebpf::cty::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::aya_ebpf::cty::c_void,
    pub ss_flags: ::aya_ebpf::cty::c_int,
    pub ss_size: usize,
}
pub type greg_t = ::aya_ebpf::cty::c_longlong;
pub type gregset_t = [greg_t; 23usize];
pub const REG_R8: _bindgen_ty_14 = 0;
pub const REG_R9: _bindgen_ty_14 = 1;
pub const REG_R10: _bindgen_ty_14 = 2;
pub const REG_R11: _bindgen_ty_14 = 3;
pub const REG_R12: _bindgen_ty_14 = 4;
pub const REG_R13: _bindgen_ty_14 = 5;
pub const REG_R14: _bindgen_ty_14 = 6;
pub const REG_R15: _bindgen_ty_14 = 7;
pub const REG_RDI: _bindgen_ty_14 = 8;
pub const REG_RSI: _bindgen_ty_14 = 9;
pub const REG_RBP: _bindgen_ty_14 = 10;
pub const REG_RBX: _bindgen_ty_14 = 11;
pub const REG_RDX: _bindgen_ty_14 = 12;
pub const REG_RAX: _bindgen_ty_14 = 13;
pub const REG_RCX: _bindgen_ty_14 = 14;
pub const REG_RSP: _bindgen_ty_14 = 15;
pub const REG_RIP: _bindgen_ty_14 = 16;
pub const REG_EFL: _bindgen_ty_14 = 17;
pub const REG_CSGSFS: _bindgen_ty_14 = 18;
pub const REG_ERR: _bindgen_ty_14 = 19;
pub const REG_TRAPNO: _bindgen_ty_14 = 20;
pub const REG_OLDMASK: _bindgen_ty_14 = 21;
pub const REG_CR2: _bindgen_ty_14 = 22;
pub type _bindgen_ty_14 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::aya_ebpf::cty::c_ushort; 4usize],
    pub exponent: ::aya_ebpf::cty::c_ushort,
    pub __glibc_reserved1: [::aya_ebpf::cty::c_ushort; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::aya_ebpf::cty::c_ulonglong; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::aya_ebpf::cty::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::aya_ebpf::cty::c_ulonglong; 4usize],
}
extern "C" {
    pub fn siginterrupt(__sig: ::aya_ebpf::cty::c_int, __interrupt: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_15 = 1;
pub const SS_DISABLE: _bindgen_ty_15 = 2;
pub type _bindgen_ty_15 = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::aya_ebpf::cty::c_void,
    pub ss_onstack: ::aya_ebpf::cty::c_int,
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sighold(__sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigrelse(__sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigignore(__sig: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sigset(__sig: ::aya_ebpf::cty::c_int, __disp: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::aya_ebpf::cty::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_sigqueue(
        __threadid: pthread_t,
        __signo: ::aya_ebpf::cty::c_int,
        __value: sigval,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn tgkill(__tgid: __pid_t, __tid: __pid_t, __signal: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::aya_ebpf::cty::c_char,
    pub pw_passwd: *mut ::aya_ebpf::cty::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::aya_ebpf::cty::c_char,
    pub pw_dir: *mut ::aya_ebpf::cty::c_char,
    pub pw_shell: *mut ::aya_ebpf::cty::c_char,
}
extern "C" {
    pub fn setpwent();
}
extern "C" {
    pub fn endpwent();
}
extern "C" {
    pub fn getpwent() -> *mut passwd;
}
extern "C" {
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
}
extern "C" {
    pub fn putpwent(__p: *const passwd, __f: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
}
extern "C" {
    pub fn getpwnam(__name: *const ::aya_ebpf::cty::c_char) -> *mut passwd;
}
extern "C" {
    pub fn getpwent_r(
        __resultbuf: *mut passwd,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpwuid_r(
        __uid: __uid_t,
        __resultbuf: *mut passwd,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpwnam_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __resultbuf: *mut passwd,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fgetpwent_r(
        __stream: *mut FILE,
        __resultbuf: *mut passwd,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpw(__uid: __uid_t, __buffer: *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group {
    pub gr_name: *mut ::aya_ebpf::cty::c_char,
    pub gr_passwd: *mut ::aya_ebpf::cty::c_char,
    pub gr_gid: __gid_t,
    pub gr_mem: *mut *mut ::aya_ebpf::cty::c_char,
}
extern "C" {
    pub fn setgrent();
}
extern "C" {
    pub fn endgrent();
}
extern "C" {
    pub fn getgrent() -> *mut group;
}
extern "C" {
    pub fn fgetgrent(__stream: *mut FILE) -> *mut group;
}
extern "C" {
    pub fn putgrent(__p: *const group, __f: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getgrgid(__gid: __gid_t) -> *mut group;
}
extern "C" {
    pub fn getgrnam(__name: *const ::aya_ebpf::cty::c_char) -> *mut group;
}
extern "C" {
    pub fn getgrent_r(
        __resultbuf: *mut group,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut group,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getgrgid_r(
        __gid: __gid_t,
        __resultbuf: *mut group,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut group,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getgrnam_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __resultbuf: *mut group,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut group,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fgetgrent_r(
        __stream: *mut FILE,
        __resultbuf: *mut group,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut group,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setgroups(__n: usize, __groups: *const __gid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getgrouplist(
        __user: *const ::aya_ebpf::cty::c_char,
        __group: __gid_t,
        __groups: *mut __gid_t,
        __ngroups: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn initgroups(__user: *const ::aya_ebpf::cty::c_char, __group: __gid_t) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: ::aya_ebpf::cty::c_ushort,
    pub d_type: ::aya_ebpf::cty::c_uchar,
    pub d_name: [::aya_ebpf::cty::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent64 {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: ::aya_ebpf::cty::c_ushort,
    pub d_type: ::aya_ebpf::cty::c_uchar,
    pub d_name: [::aya_ebpf::cty::c_char; 256usize],
}
pub const DT_UNKNOWN: _bindgen_ty_16 = 0;
pub const DT_FIFO: _bindgen_ty_16 = 1;
pub const DT_CHR: _bindgen_ty_16 = 2;
pub const DT_DIR: _bindgen_ty_16 = 4;
pub const DT_BLK: _bindgen_ty_16 = 6;
pub const DT_REG: _bindgen_ty_16 = 8;
pub const DT_LNK: _bindgen_ty_16 = 10;
pub const DT_SOCK: _bindgen_ty_16 = 12;
pub const DT_WHT: _bindgen_ty_16 = 14;
pub type _bindgen_ty_16 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn opendir(__name: *const ::aya_ebpf::cty::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::aya_ebpf::cty::c_int) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}readdir64"]
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    #[link_name = "\u{1}readdir64_r"]
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut dirent, __result: *mut *mut dirent) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::aya_ebpf::cty::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __sysconf(__name: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    #[link_name = "\u{1}scandir64"]
    pub fn scandir(
        __dir: *const ::aya_ebpf::cty::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::core::option::Option<unsafe extern "C" fn(arg1: *const dirent) -> ::aya_ebpf::cty::c_int>,
        __cmp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}scandirat64"]
    pub fn scandirat(
        __dfd: ::aya_ebpf::cty::c_int,
        __dir: *const ::aya_ebpf::cty::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::core::option::Option<unsafe extern "C" fn(arg1: *const dirent) -> ::aya_ebpf::cty::c_int>,
        __cmp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}alphasort64"]
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}getdirentries64"]
    pub fn getdirentries(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __nbytes: usize,
        __basep: *mut __off64_t,
    ) -> __ssize_t;
}
extern "C" {
    #[link_name = "\u{1}versionsort64"]
    pub fn versionsort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getdents64(__fd: ::aya_ebpf::cty::c_int, __buffer: *mut ::aya_ebpf::cty::c_void, __length: usize)
        -> __ssize_t;
}
pub type __size_t = ::aya_ebpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glob_t {
    pub gl_pathc: __size_t,
    pub gl_pathv: *mut *mut ::aya_ebpf::cty::c_char,
    pub gl_offs: __size_t,
    pub gl_flags: ::aya_ebpf::cty::c_int,
    pub gl_closedir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    pub gl_readdir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> *mut dirent>,
    pub gl_opendir:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_void>,
    pub gl_lstat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char, arg2: *mut stat) -> ::aya_ebpf::cty::c_int,
    >,
    pub gl_stat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char, arg2: *mut stat) -> ::aya_ebpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glob64_t {
    pub gl_pathc: __size_t,
    pub gl_pathv: *mut *mut ::aya_ebpf::cty::c_char,
    pub gl_offs: __size_t,
    pub gl_flags: ::aya_ebpf::cty::c_int,
    pub gl_closedir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    pub gl_readdir: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> *mut dirent64>,
    pub gl_opendir:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_void>,
    pub gl_lstat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char, arg2: *mut stat64) -> ::aya_ebpf::cty::c_int,
    >,
    pub gl_stat: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char, arg2: *mut stat64) -> ::aya_ebpf::cty::c_int,
    >,
}
extern "C" {
    #[link_name = "\u{1}glob64"]
    pub fn glob(
        __pattern: *const ::aya_ebpf::cty::c_char,
        __flags: ::aya_ebpf::cty::c_int,
        __errfunc: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_char,
                arg2: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        __pglob: *mut glob_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}globfree64"]
    pub fn globfree(__pglob: *mut glob_t);
}
extern "C" {
    pub fn glob_pattern_p(
        __pattern: *const ::aya_ebpf::cty::c_char,
        __quote: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statfs {
    pub f_type: __fsword_t,
    pub f_bsize: __fsword_t,
    pub f_blocks: __fsblkcnt64_t,
    pub f_bfree: __fsblkcnt64_t,
    pub f_bavail: __fsblkcnt64_t,
    pub f_files: __fsfilcnt64_t,
    pub f_ffree: __fsfilcnt64_t,
    pub f_fsid: __fsid_t,
    pub f_namelen: __fsword_t,
    pub f_frsize: __fsword_t,
    pub f_flags: __fsword_t,
    pub f_spare: [__fsword_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statfs64 {
    pub f_type: __fsword_t,
    pub f_bsize: __fsword_t,
    pub f_blocks: __fsblkcnt64_t,
    pub f_bfree: __fsblkcnt64_t,
    pub f_bavail: __fsblkcnt64_t,
    pub f_files: __fsfilcnt64_t,
    pub f_ffree: __fsfilcnt64_t,
    pub f_fsid: __fsid_t,
    pub f_namelen: __fsword_t,
    pub f_frsize: __fsword_t,
    pub f_flags: __fsword_t,
    pub f_spare: [__fsword_t; 4usize],
}
extern "C" {
    #[link_name = "\u{1}statfs64"]
    pub fn statfs(__file: *const ::aya_ebpf::cty::c_char, __buf: *mut statfs) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}fstatfs64"]
    pub fn fstatfs(__fildes: ::aya_ebpf::cty::c_int, __buf: *mut statfs) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::aya_ebpf::cty::c_void,
    pub iov_len: usize,
}
extern "C" {
    pub fn readv(__fd: ::aya_ebpf::cty::c_int, __iovec: *const iovec, __count: ::aya_ebpf::cty::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::aya_ebpf::cty::c_int, __iovec: *const iovec, __count: ::aya_ebpf::cty::c_int) -> isize;
}
extern "C" {
    #[link_name = "\u{1}preadv64"]
    pub fn preadv(
        __fd: ::aya_ebpf::cty::c_int,
        __iovec: *const iovec,
        __count: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}pwritev64"]
    pub fn pwritev(
        __fd: ::aya_ebpf::cty::c_int,
        __iovec: *const iovec,
        __count: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}pwritev64v2"]
    pub fn pwritev2(
        __fd: ::aya_ebpf::cty::c_int,
        __iovec: *const iovec,
        __count: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}preadv64v2"]
    pub fn preadv2(
        __fd: ::aya_ebpf::cty::c_int,
        __iovec: *const iovec,
        __count: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> isize;
}
extern "C" {
    pub fn process_vm_readv(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::aya_ebpf::cty::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::aya_ebpf::cty::c_ulong,
        __flags: ::aya_ebpf::cty::c_ulong,
    ) -> isize;
}
extern "C" {
    pub fn process_vm_writev(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: ::aya_ebpf::cty::c_ulong,
        __rvec: *const iovec,
        __riovcnt: ::aya_ebpf::cty::c_ulong,
        __flags: ::aya_ebpf::cty::c_ulong,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::aya_ebpf::cty::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    pub st_dev: __dev_t,
    pub st_ino: __ino64_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::aya_ebpf::cty::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
extern "C" {
    #[link_name = "\u{1}stat64"]
    pub fn stat(__file: *const ::aya_ebpf::cty::c_char, __buf: *mut stat) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}fstat64"]
    pub fn fstat(__fd: ::aya_ebpf::cty::c_int, __buf: *mut stat) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}fstatat64"]
    pub fn fstatat(
        __fd: ::aya_ebpf::cty::c_int,
        __file: *const ::aya_ebpf::cty::c_char,
        __buf: *mut stat,
        __flag: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}lstat64"]
    pub fn lstat(__file: *const ::aya_ebpf::cty::c_char, __buf: *mut stat) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::aya_ebpf::cty::c_char, __mode: __mode_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::aya_ebpf::cty::c_char, __mode: __mode_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::aya_ebpf::cty::c_int, __mode: __mode_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::aya_ebpf::cty::c_int,
        __file: *const ::aya_ebpf::cty::c_char,
        __mode: __mode_t,
        __flag: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn getumask() -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::aya_ebpf::cty::c_char, __mode: __mode_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __mode: __mode_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mknod(__path: *const ::aya_ebpf::cty::c_char, __mode: __mode_t, __dev: __dev_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::aya_ebpf::cty::c_char, __mode: __mode_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __mode: __mode_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __times: *const timespec,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::aya_ebpf::cty::c_int, __times: *const timespec) -> ::aya_ebpf::cty::c_int;
}
pub type __s8 = ::aya_ebpf::cty::c_schar;
pub type __u8 = ::aya_ebpf::cty::c_uchar;
pub type __s16 = ::aya_ebpf::cty::c_short;
pub type __u16 = ::aya_ebpf::cty::c_ushort;
pub type __s32 = ::aya_ebpf::cty::c_int;
pub type __u32 = ::aya_ebpf::cty::c_uint;
pub type __s64 = ::aya_ebpf::cty::c_longlong;
pub type __u64 = ::aya_ebpf::cty::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::aya_ebpf::cty::c_ulong; 16usize],
}
pub type __kernel_sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::aya_ebpf::cty::c_int)>;
pub type __kernel_key_t = ::aya_ebpf::cty::c_int;
pub type __kernel_mqd_t = ::aya_ebpf::cty::c_int;
pub type __kernel_old_uid_t = ::aya_ebpf::cty::c_ushort;
pub type __kernel_old_gid_t = ::aya_ebpf::cty::c_ushort;
pub type __kernel_old_dev_t = ::aya_ebpf::cty::c_ulong;
pub type __kernel_long_t = ::aya_ebpf::cty::c_long;
pub type __kernel_ulong_t = ::aya_ebpf::cty::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::aya_ebpf::cty::c_uint;
pub type __kernel_pid_t = ::aya_ebpf::cty::c_int;
pub type __kernel_ipc_pid_t = ::aya_ebpf::cty::c_int;
pub type __kernel_uid_t = ::aya_ebpf::cty::c_uint;
pub type __kernel_gid_t = ::aya_ebpf::cty::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::aya_ebpf::cty::c_int;
pub type __kernel_uid32_t = ::aya_ebpf::cty::c_uint;
pub type __kernel_gid32_t = ::aya_ebpf::cty::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::aya_ebpf::cty::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::aya_ebpf::cty::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::aya_ebpf::cty::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::aya_ebpf::cty::c_int;
pub type __kernel_clockid_t = ::aya_ebpf::cty::c_int;
pub type __kernel_caddr_t = *mut ::aya_ebpf::cty::c_char;
pub type __kernel_uid16_t = ::aya_ebpf::cty::c_ushort;
pub type __kernel_gid16_t = ::aya_ebpf::cty::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub stx_dio_mem_align: __u32,
    pub stx_dio_offset_align: __u32,
    pub __spare3: [__u64; 12usize],
}
extern "C" {
    pub fn statx(
        __dirfd: ::aya_ebpf::cty::c_int,
        __path: *const ::aya_ebpf::cty::c_char,
        __flags: ::aya_ebpf::cty::c_int,
        __mask: ::aya_ebpf::cty::c_uint,
        __buf: *mut statx,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::aya_ebpf::cty::c_short,
    pub l_whence: ::aya_ebpf::cty::c_short,
    pub l_start: __off64_t,
    pub l_len: __off64_t,
    pub l_pid: __pid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::aya_ebpf::cty::c_short,
    pub l_whence: ::aya_ebpf::cty::c_short,
    pub l_start: __off64_t,
    pub l_len: __off64_t,
    pub l_pid: __pid_t,
}
pub const __pid_type_F_OWNER_TID: __pid_type = 0;
pub const __pid_type_F_OWNER_PID: __pid_type = 1;
pub const __pid_type_F_OWNER_PGRP: __pid_type = 2;
pub const __pid_type_F_OWNER_GID: __pid_type = 2;
pub type __pid_type = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: __pid_type,
    pub pid: __pid_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct file_handle {
    pub handle_bytes: ::aya_ebpf::cty::c_uint,
    pub handle_type: ::aya_ebpf::cty::c_int,
    pub f_handle: __IncompleteArrayField<::aya_ebpf::cty::c_uchar>,
}
extern "C" {
    pub fn readahead(__fd: ::aya_ebpf::cty::c_int, __offset: __off64_t, __count: usize) -> __ssize_t;
}
extern "C" {
    pub fn sync_file_range(
        __fd: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
        __count: __off64_t,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn vmsplice(
        __fdout: ::aya_ebpf::cty::c_int,
        __iov: *const iovec,
        __count: usize,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    pub fn splice(
        __fdin: ::aya_ebpf::cty::c_int,
        __offin: *mut __off64_t,
        __fdout: ::aya_ebpf::cty::c_int,
        __offout: *mut __off64_t,
        __len: usize,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    pub fn tee(
        __fdin: ::aya_ebpf::cty::c_int,
        __fdout: ::aya_ebpf::cty::c_int,
        __len: usize,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    #[link_name = "\u{1}fallocate64"]
    pub fn fallocate(
        __fd: ::aya_ebpf::cty::c_int,
        __mode: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
        __len: __off64_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn name_to_handle_at(
        __dfd: ::aya_ebpf::cty::c_int,
        __name: *const ::aya_ebpf::cty::c_char,
        __handle: *mut file_handle,
        __mnt_id: *mut ::aya_ebpf::cty::c_int,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn open_by_handle_at(
        __mountdirfd: ::aya_ebpf::cty::c_int,
        __handle: *mut file_handle,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}fcntl64"]
    pub fn fcntl(__fd: ::aya_ebpf::cty::c_int, __cmd: ::aya_ebpf::cty::c_int, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}open64"]
    pub fn open(__file: *const ::aya_ebpf::cty::c_char, __oflag: ::aya_ebpf::cty::c_int, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}openat64"]
    pub fn openat(
        __fd: ::aya_ebpf::cty::c_int,
        __file: *const ::aya_ebpf::cty::c_char,
        __oflag: ::aya_ebpf::cty::c_int,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}creat64"]
    pub fn creat(__file: *const ::aya_ebpf::cty::c_char, __mode: mode_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}posix_fadvise64"]
    pub fn posix_fadvise(
        __fd: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
        __len: __off64_t,
        __advise: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}posix_fallocate64"]
    pub fn posix_fallocate(__fd: ::aya_ebpf::cty::c_int, __offset: __off64_t, __len: __off64_t)
        -> ::aya_ebpf::cty::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub const idtype_t_P_PIDFD: idtype_t = 3;
pub type idtype_t = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn wait(__stat_loc: *mut ::aya_ebpf::cty::c_int) -> __pid_t;
}
extern "C" {
    pub fn waitpid(__pid: __pid_t, __stat_loc: *mut ::aya_ebpf::cty::c_int, __options: ::aya_ebpf::cty::c_int)
        -> __pid_t;
}
extern "C" {
    pub fn waitid(
        __idtype: idtype_t,
        __id: __id_t,
        __infop: *mut siginfo_t,
        __options: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn wait3(
        __stat_loc: *mut ::aya_ebpf::cty::c_int,
        __options: ::aya_ebpf::cty::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
extern "C" {
    pub fn wait4(
        __pid: __pid_t,
        __stat_loc: *mut ::aya_ebpf::cty::c_int,
        __options: ::aya_ebpf::cty::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
}
extern "C" {
    pub fn memfd_create(
        __name: *const ::aya_ebpf::cty::c_char,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mlock2(
        __addr: *const ::aya_ebpf::cty::c_void,
        __length: usize,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pkey_alloc(
        __flags: ::aya_ebpf::cty::c_uint,
        __access_rights: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pkey_set(__key: ::aya_ebpf::cty::c_int, __access_rights: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pkey_get(__key: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pkey_free(__key: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pkey_mprotect(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __prot: ::aya_ebpf::cty::c_int,
        __pkey: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}mmap64"]
    pub fn mmap(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __prot: ::aya_ebpf::cty::c_int,
        __flags: ::aya_ebpf::cty::c_int,
        __fd: ::aya_ebpf::cty::c_int,
        __offset: __off64_t,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn munmap(__addr: *mut ::aya_ebpf::cty::c_void, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mprotect(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __prot: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn msync(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn madvise(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __advice: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn posix_madvise(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __advice: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mlock(__addr: *const ::aya_ebpf::cty::c_void, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn munlock(__addr: *const ::aya_ebpf::cty::c_void, __len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mlockall(__flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn munlockall() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mincore(
        __start: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
        __vec: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn mremap(
        __addr: *mut ::aya_ebpf::cty::c_void,
        __old_len: usize,
        __new_len: usize,
        __flags: ::aya_ebpf::cty::c_int,
        ...
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn remap_file_pages(
        __start: *mut ::aya_ebpf::cty::c_void,
        __size: usize,
        __prot: ::aya_ebpf::cty::c_int,
        __pgoff: usize,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn shm_open(
        __name: *const ::aya_ebpf::cty::c_char,
        __oflag: ::aya_ebpf::cty::c_int,
        __mode: mode_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn shm_unlink(__name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn process_madvise(
        __pid_fd: ::aya_ebpf::cty::c_int,
        __iov: *const iovec,
        __count: usize,
        __advice: ::aya_ebpf::cty::c_int,
        __flags: ::aya_ebpf::cty::c_uint,
    ) -> __ssize_t;
}
extern "C" {
    pub fn process_mrelease(pidfd: ::aya_ebpf::cty::c_int, flags: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
pub const __rlimit_resource_RLIMIT_CPU: __rlimit_resource = 0;
pub const __rlimit_resource_RLIMIT_FSIZE: __rlimit_resource = 1;
pub const __rlimit_resource_RLIMIT_DATA: __rlimit_resource = 2;
pub const __rlimit_resource_RLIMIT_STACK: __rlimit_resource = 3;
pub const __rlimit_resource_RLIMIT_CORE: __rlimit_resource = 4;
pub const __rlimit_resource___RLIMIT_RSS: __rlimit_resource = 5;
pub const __rlimit_resource_RLIMIT_NOFILE: __rlimit_resource = 7;
pub const __rlimit_resource___RLIMIT_OFILE: __rlimit_resource = 7;
pub const __rlimit_resource_RLIMIT_AS: __rlimit_resource = 9;
pub const __rlimit_resource___RLIMIT_NPROC: __rlimit_resource = 6;
pub const __rlimit_resource___RLIMIT_MEMLOCK: __rlimit_resource = 8;
pub const __rlimit_resource___RLIMIT_LOCKS: __rlimit_resource = 10;
pub const __rlimit_resource___RLIMIT_SIGPENDING: __rlimit_resource = 11;
pub const __rlimit_resource___RLIMIT_MSGQUEUE: __rlimit_resource = 12;
pub const __rlimit_resource___RLIMIT_NICE: __rlimit_resource = 13;
pub const __rlimit_resource___RLIMIT_RTPRIO: __rlimit_resource = 14;
pub const __rlimit_resource___RLIMIT_RTTIME: __rlimit_resource = 15;
pub const __rlimit_resource___RLIMIT_NLIMITS: __rlimit_resource = 16;
pub const __rlimit_resource___RLIM_NLIMITS: __rlimit_resource = 16;
pub type __rlimit_resource = ::aya_ebpf::cty::c_uint;
pub type rlim_t = __rlim64_t;
pub type rlim64_t = __rlim64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: rlim64_t,
    pub rlim_max: rlim64_t,
}
pub const __rusage_who_RUSAGE_SELF: __rusage_who = 0;
pub const __rusage_who_RUSAGE_CHILDREN: __rusage_who = -1;
pub const __rusage_who_RUSAGE_THREAD: __rusage_who = 1;
pub type __rusage_who = ::aya_ebpf::cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub __bindgen_anon_1: rusage__bindgen_ty_1,
    pub __bindgen_anon_2: rusage__bindgen_ty_2,
    pub __bindgen_anon_3: rusage__bindgen_ty_3,
    pub __bindgen_anon_4: rusage__bindgen_ty_4,
    pub __bindgen_anon_5: rusage__bindgen_ty_5,
    pub __bindgen_anon_6: rusage__bindgen_ty_6,
    pub __bindgen_anon_7: rusage__bindgen_ty_7,
    pub __bindgen_anon_8: rusage__bindgen_ty_8,
    pub __bindgen_anon_9: rusage__bindgen_ty_9,
    pub __bindgen_anon_10: rusage__bindgen_ty_10,
    pub __bindgen_anon_11: rusage__bindgen_ty_11,
    pub __bindgen_anon_12: rusage__bindgen_ty_12,
    pub __bindgen_anon_13: rusage__bindgen_ty_13,
    pub __bindgen_anon_14: rusage__bindgen_ty_14,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_1 {
    pub ru_maxrss: ::aya_ebpf::cty::c_long,
    pub __ru_maxrss_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_2 {
    pub ru_ixrss: ::aya_ebpf::cty::c_long,
    pub __ru_ixrss_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_3 {
    pub ru_idrss: ::aya_ebpf::cty::c_long,
    pub __ru_idrss_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_4 {
    pub ru_isrss: ::aya_ebpf::cty::c_long,
    pub __ru_isrss_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_5 {
    pub ru_minflt: ::aya_ebpf::cty::c_long,
    pub __ru_minflt_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_6 {
    pub ru_majflt: ::aya_ebpf::cty::c_long,
    pub __ru_majflt_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_7 {
    pub ru_nswap: ::aya_ebpf::cty::c_long,
    pub __ru_nswap_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_8 {
    pub ru_inblock: ::aya_ebpf::cty::c_long,
    pub __ru_inblock_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_9 {
    pub ru_oublock: ::aya_ebpf::cty::c_long,
    pub __ru_oublock_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_10 {
    pub ru_msgsnd: ::aya_ebpf::cty::c_long,
    pub __ru_msgsnd_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_11 {
    pub ru_msgrcv: ::aya_ebpf::cty::c_long,
    pub __ru_msgrcv_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_12 {
    pub ru_nsignals: ::aya_ebpf::cty::c_long,
    pub __ru_nsignals_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_13 {
    pub ru_nvcsw: ::aya_ebpf::cty::c_long,
    pub __ru_nvcsw_word: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rusage__bindgen_ty_14 {
    pub ru_nivcsw: ::aya_ebpf::cty::c_long,
    pub __ru_nivcsw_word: __syscall_slong_t,
}
pub const __priority_which_PRIO_PROCESS: __priority_which = 0;
pub const __priority_which_PRIO_PGRP: __priority_which = 1;
pub const __priority_which_PRIO_USER: __priority_which = 2;
pub type __priority_which = ::aya_ebpf::cty::c_uint;
extern "C" {
    #[link_name = "\u{1}prlimit64"]
    pub fn prlimit(
        __pid: __pid_t,
        __resource: __rlimit_resource,
        __new_limit: *const rlimit,
        __old_limit: *mut rlimit,
    ) -> ::aya_ebpf::cty::c_int;
}
pub use self::__priority_which as __priority_which_t;
pub use self::__rlimit_resource as __rlimit_resource_t;
pub use self::__rusage_who as __rusage_who_t;
extern "C" {
    #[link_name = "\u{1}getrlimit64"]
    pub fn getrlimit(__resource: __rlimit_resource_t, __rlimits: *mut rlimit) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}setrlimit64"]
    pub fn setrlimit(__resource: __rlimit_resource_t, __rlimits: *const rlimit) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpriority(__which: __priority_which_t, __who: id_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setpriority(
        __which: __priority_which_t,
        __who: id_t,
        __prio: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::aya_ebpf::cty::c_int,
}
extern "C" {
    pub fn clone(
        __fn: ::core::option::Option<unsafe extern "C" fn(__arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>,
        __child_stack: *mut ::aya_ebpf::cty::c_void,
        __flags: ::aya_ebpf::cty::c_int,
        __arg: *mut ::aya_ebpf::cty::c_void,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn unshare(__flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_getcpu() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getcpu(arg1: *mut ::aya_ebpf::cty::c_uint, arg2: *mut ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setns(__fd: ::aya_ebpf::cty::c_int, __nstype: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
pub type __cpu_mask = ::aya_ebpf::cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::aya_ebpf::cty::c_int,
        __param: *const sched_param,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_setaffinity(__pid: __pid_t, __cpusetsize: usize, __cpuset: *const cpu_set_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sched_getaffinity(__pid: __pid_t, __cpusetsize: usize, __cpuset: *mut cpu_set_t) -> ::aya_ebpf::cty::c_int;
}
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::aya_ebpf::cty::c_uint;
pub type sa_family_t = ::aya_ebpf::cty::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::aya_ebpf::cty::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::aya_ebpf::cty::c_char; 118usize],
    pub __ss_align: ::aya_ebpf::cty::c_ulong,
}
pub const MSG_OOB: _bindgen_ty_17 = 1;
pub const MSG_PEEK: _bindgen_ty_17 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_17 = 4;
pub const MSG_TRYHARD: _bindgen_ty_17 = 4;
pub const MSG_CTRUNC: _bindgen_ty_17 = 8;
pub const MSG_PROXY: _bindgen_ty_17 = 16;
pub const MSG_TRUNC: _bindgen_ty_17 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_17 = 64;
pub const MSG_EOR: _bindgen_ty_17 = 128;
pub const MSG_WAITALL: _bindgen_ty_17 = 256;
pub const MSG_FIN: _bindgen_ty_17 = 512;
pub const MSG_SYN: _bindgen_ty_17 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_17 = 2048;
pub const MSG_RST: _bindgen_ty_17 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_17 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_17 = 16384;
pub const MSG_MORE: _bindgen_ty_17 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_17 = 65536;
pub const MSG_BATCH: _bindgen_ty_17 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_17 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_17 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_17 = 1073741824;
pub type _bindgen_ty_17 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::aya_ebpf::cty::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::aya_ebpf::cty::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::aya_ebpf::cty::c_int,
    pub cmsg_type: ::aya_ebpf::cty::c_int,
    pub __cmsg_data: __IncompleteArrayField<::aya_ebpf::cty::c_uchar>,
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_18 = 1;
pub const SCM_CREDENTIALS: _bindgen_ty_18 = 2;
pub type _bindgen_ty_18 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::aya_ebpf::cty::c_int,
    pub l_linger: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::aya_ebpf::cty::c_ushort,
    pub sa_data: [::aya_ebpf::cty::c_uchar; 14usize],
}
pub const SHUT_RD: _bindgen_ty_19 = 0;
pub const SHUT_WR: _bindgen_ty_19 = 1;
pub const SHUT_RDWR: _bindgen_ty_19 = 2;
pub type _bindgen_ty_19 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::aya_ebpf::cty::c_uint,
}
extern "C" {
    pub fn socket(
        __domain: ::aya_ebpf::cty::c_int,
        __type: ::aya_ebpf::cty::c_int,
        __protocol: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::aya_ebpf::cty::c_int,
        __type: ::aya_ebpf::cty::c_int,
        __protocol: ::aya_ebpf::cty::c_int,
        __fds: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn bind(__fd: ::aya_ebpf::cty::c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::aya_ebpf::cty::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::aya_ebpf::cty::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::aya_ebpf::cty::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *const ::aya_ebpf::cty::c_void,
        __n: usize,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_void,
        __n: usize,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *const ::aya_ebpf::cty::c_void,
        __n: usize,
        __flags: ::aya_ebpf::cty::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_void,
        __n: usize,
        __flags: ::aya_ebpf::cty::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(__fd: ::aya_ebpf::cty::c_int, __message: *const msghdr, __flags: ::aya_ebpf::cty::c_int) -> isize;
}
extern "C" {
    pub fn sendmmsg(
        __fd: ::aya_ebpf::cty::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::aya_ebpf::cty::c_uint,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn recvmsg(__fd: ::aya_ebpf::cty::c_int, __message: *mut msghdr, __flags: ::aya_ebpf::cty::c_int) -> isize;
}
extern "C" {
    pub fn recvmmsg(
        __fd: ::aya_ebpf::cty::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::aya_ebpf::cty::c_uint,
        __flags: ::aya_ebpf::cty::c_int,
        __tmo: *mut timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::aya_ebpf::cty::c_int,
        __level: ::aya_ebpf::cty::c_int,
        __optname: ::aya_ebpf::cty::c_int,
        __optval: *mut ::aya_ebpf::cty::c_void,
        __optlen: *mut socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::aya_ebpf::cty::c_int,
        __level: ::aya_ebpf::cty::c_int,
        __optname: ::aya_ebpf::cty::c_int,
        __optval: *const ::aya_ebpf::cty::c_void,
        __optlen: socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn listen(__fd: ::aya_ebpf::cty::c_int, __n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::aya_ebpf::cty::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn accept4(
        __fd: ::aya_ebpf::cty::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn shutdown(__fd: ::aya_ebpf::cty::c_int, __how: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn isfdtype(__fd: ::aya_ebpf::cty::c_int, __fdtype: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::aya_ebpf::cty::c_char; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::aya_ebpf::cty::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
pub const IPPROTO_IP: _bindgen_ty_20 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_20 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_20 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_20 = 4;
pub const IPPROTO_TCP: _bindgen_ty_20 = 6;
pub const IPPROTO_EGP: _bindgen_ty_20 = 8;
pub const IPPROTO_PUP: _bindgen_ty_20 = 12;
pub const IPPROTO_UDP: _bindgen_ty_20 = 17;
pub const IPPROTO_IDP: _bindgen_ty_20 = 22;
pub const IPPROTO_TP: _bindgen_ty_20 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_20 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_20 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_20 = 46;
pub const IPPROTO_GRE: _bindgen_ty_20 = 47;
pub const IPPROTO_ESP: _bindgen_ty_20 = 50;
pub const IPPROTO_AH: _bindgen_ty_20 = 51;
pub const IPPROTO_MTP: _bindgen_ty_20 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_20 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_20 = 98;
pub const IPPROTO_PIM: _bindgen_ty_20 = 103;
pub const IPPROTO_COMP: _bindgen_ty_20 = 108;
pub const IPPROTO_L2TP: _bindgen_ty_20 = 115;
pub const IPPROTO_SCTP: _bindgen_ty_20 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_20 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_20 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_20 = 143;
pub const IPPROTO_RAW: _bindgen_ty_20 = 255;
pub const IPPROTO_MPTCP: _bindgen_ty_20 = 262;
pub const IPPROTO_MAX: _bindgen_ty_20 = 263;
pub type _bindgen_ty_20 = ::aya_ebpf::cty::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_21 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_21 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_21 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_21 = 58;
pub const IPPROTO_NONE: _bindgen_ty_21 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_21 = 60;
pub const IPPROTO_MH: _bindgen_ty_21 = 135;
pub type _bindgen_ty_21 = ::aya_ebpf::cty::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_22 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_22 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_22 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_22 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_22 = 15;
pub const IPPORT_FTP: _bindgen_ty_22 = 21;
pub const IPPORT_TELNET: _bindgen_ty_22 = 23;
pub const IPPORT_SMTP: _bindgen_ty_22 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_22 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_22 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_22 = 43;
pub const IPPORT_MTP: _bindgen_ty_22 = 57;
pub const IPPORT_TFTP: _bindgen_ty_22 = 69;
pub const IPPORT_RJE: _bindgen_ty_22 = 77;
pub const IPPORT_FINGER: _bindgen_ty_22 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_22 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_22 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_22 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_22 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_22 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_22 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_22 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_22 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_22 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_22 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_22 = 5000;
pub type _bindgen_ty_22 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::aya_ebpf::cty::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(__sockfd: ::aya_ebpf::cty::c_int, __sock_in: *mut sockaddr_in) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn bindresvport6(__sockfd: ::aya_ebpf::cty::c_int, __sock_in: *mut sockaddr_in6) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
extern "C" {
    pub fn inet6_option_space(__nbytes: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        __bp: *mut ::aya_ebpf::cty::c_void,
        __cmsgp: *mut *mut cmsghdr,
        __type: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        __cmsg: *mut cmsghdr,
        __typep: *const u8,
        __multx: ::aya_ebpf::cty::c_int,
        __plusy: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        __cmsg: *mut cmsghdr,
        __datalen: ::aya_ebpf::cty::c_int,
        __multx: ::aya_ebpf::cty::c_int,
        __plusy: ::aya_ebpf::cty::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn inet6_option_next(__cmsg: *const cmsghdr, __tptrp: *mut *mut u8) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
        __type: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_init(__extbuf: *mut ::aya_ebpf::cty::c_void, __extlen: socklen_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        __extbuf: *mut ::aya_ebpf::cty::c_void,
        __extlen: socklen_t,
        __offset: ::aya_ebpf::cty::c_int,
        __type: u8,
        __len: socklen_t,
        __align: u8,
        __databufp: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        __extbuf: *mut ::aya_ebpf::cty::c_void,
        __extlen: socklen_t,
        __offset: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        __databuf: *mut ::aya_ebpf::cty::c_void,
        __offset: ::aya_ebpf::cty::c_int,
        __val: *mut ::aya_ebpf::cty::c_void,
        __vallen: socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        __extbuf: *mut ::aya_ebpf::cty::c_void,
        __extlen: socklen_t,
        __offset: ::aya_ebpf::cty::c_int,
        __typep: *mut u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        __extbuf: *mut ::aya_ebpf::cty::c_void,
        __extlen: socklen_t,
        __offset: ::aya_ebpf::cty::c_int,
        __type: u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        __databuf: *mut ::aya_ebpf::cty::c_void,
        __offset: ::aya_ebpf::cty::c_int,
        __val: *mut ::aya_ebpf::cty::c_void,
        __vallen: socklen_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_rth_space(__type: ::aya_ebpf::cty::c_int, __segments: ::aya_ebpf::cty::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        __bp: *mut ::aya_ebpf::cty::c_void,
        __bp_len: socklen_t,
        __type: ::aya_ebpf::cty::c_int,
        __segments: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn inet6_rth_add(__bp: *mut ::aya_ebpf::cty::c_void, __addr: *const in6_addr) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        __in: *const ::aya_ebpf::cty::c_void,
        __out: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(__bp: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(__bp: *const ::aya_ebpf::cty::c_void, __index: ::aya_ebpf::cty::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn getipv4sourcefilter(
        __s: ::aya_ebpf::cty::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut in_addr,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setipv4sourcefilter(
        __s: ::aya_ebpf::cty::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const in_addr,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        __s: ::aya_ebpf::cty::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut sockaddr_storage,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        __s: ::aya_ebpf::cty::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const sockaddr_storage,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::aya_ebpf::cty::c_schar;
pub type int_fast16_t = ::aya_ebpf::cty::c_long;
pub type int_fast32_t = ::aya_ebpf::cty::c_long;
pub type int_fast64_t = ::aya_ebpf::cty::c_long;
pub type uint_fast8_t = ::aya_ebpf::cty::c_uchar;
pub type uint_fast16_t = ::aya_ebpf::cty::c_ulong;
pub type uint_fast32_t = ::aya_ebpf::cty::c_ulong;
pub type uint_fast64_t = ::aya_ebpf::cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type tcp_seq = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::core::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::core::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::core::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const TCP_ESTABLISHED: _bindgen_ty_23 = 1;
pub const TCP_SYN_SENT: _bindgen_ty_23 = 2;
pub const TCP_SYN_RECV: _bindgen_ty_23 = 3;
pub const TCP_FIN_WAIT1: _bindgen_ty_23 = 4;
pub const TCP_FIN_WAIT2: _bindgen_ty_23 = 5;
pub const TCP_TIME_WAIT: _bindgen_ty_23 = 6;
pub const TCP_CLOSE: _bindgen_ty_23 = 7;
pub const TCP_CLOSE_WAIT: _bindgen_ty_23 = 8;
pub const TCP_LAST_ACK: _bindgen_ty_23 = 9;
pub const TCP_LISTEN: _bindgen_ty_23 = 10;
pub const TCP_CLOSING: _bindgen_ty_23 = 11;
pub type _bindgen_ty_23 = ::aya_ebpf::cty::c_uint;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    pub tcpi_last_data_sent: u32,
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(tcpi_snd_wscale: u8, tcpi_rcv_wscale: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub tcpm_flags: u8,
    pub tcpm_prefixlen: u8,
    pub tcpm_keylen: u16,
    pub __tcpm_pad: u32,
    pub tcpm_key: [u8; 80usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
pub const TCP_NO_QUEUE: _bindgen_ty_24 = 0;
pub const TCP_RECV_QUEUE: _bindgen_ty_24 = 1;
pub const TCP_SEND_QUEUE: _bindgen_ty_24 = 2;
pub const TCP_QUEUES_NR: _bindgen_ty_24 = 3;
pub type _bindgen_ty_24 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: u64,
    pub length: u32,
    pub recv_skip_hint: u32,
}
extern "C" {
    pub fn inet_addr(__cp: *const ::aya_ebpf::cty::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(__cp: *const ::aya_ebpf::cty::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(__in: in_addr) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn inet_pton(
        __af: ::aya_ebpf::cty::c_int,
        __cp: *const ::aya_ebpf::cty::c_char,
        __buf: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet_ntop(
        __af: ::aya_ebpf::cty::c_int,
        __cp: *const ::aya_ebpf::cty::c_void,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: socklen_t,
    ) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn inet_aton(__cp: *const ::aya_ebpf::cty::c_char, __inp: *mut in_addr) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet_neta(__net: in_addr_t, __buf: *mut ::aya_ebpf::cty::c_char, __len: usize)
        -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn inet_net_ntop(
        __af: ::aya_ebpf::cty::c_int,
        __cp: *const ::aya_ebpf::cty::c_void,
        __bits: ::aya_ebpf::cty::c_int,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __len: usize,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn inet_net_pton(
        __af: ::aya_ebpf::cty::c_int,
        __cp: *const ::aya_ebpf::cty::c_char,
        __buf: *mut ::aya_ebpf::cty::c_void,
        __len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn inet_nsap_addr(
        __cp: *const ::aya_ebpf::cty::c_char,
        __buf: *mut ::aya_ebpf::cty::c_uchar,
        __len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(
        __len: ::aya_ebpf::cty::c_int,
        __cp: *const ::aya_ebpf::cty::c_uchar,
        __buf: *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::aya_ebpf::cty::c_char,
    pub r_aliases: *mut *mut ::aya_ebpf::cty::c_char,
    pub r_number: ::aya_ebpf::cty::c_int,
}
extern "C" {
    pub fn setrpcent(__stayopen: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn getrpcbyname(__name: *const ::aya_ebpf::cty::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(__number: ::aya_ebpf::cty::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbyname_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __result_buf: *mut rpcent,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getrpcbynumber_r(
        __number: ::aya_ebpf::cty::c_int,
        __result_buf: *mut rpcent,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getrpcent_r(
        __result_buf: *mut rpcent,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::aya_ebpf::cty::c_char,
    pub n_aliases: *mut *mut ::aya_ebpf::cty::c_char,
    pub n_addrtype: ::aya_ebpf::cty::c_int,
    pub n_net: u32,
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn herror(__str: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn hstrerror(__err_num: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::aya_ebpf::cty::c_char,
    pub h_aliases: *mut *mut ::aya_ebpf::cty::c_char,
    pub h_addrtype: ::aya_ebpf::cty::c_int,
    pub h_length: ::aya_ebpf::cty::c_int,
    pub h_addr_list: *mut *mut ::aya_ebpf::cty::c_char,
}
extern "C" {
    pub fn sethostent(__stay_open: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(
        __addr: *const ::aya_ebpf::cty::c_void,
        __len: __socklen_t,
        __type: ::aya_ebpf::cty::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::aya_ebpf::cty::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2(__name: *const ::aya_ebpf::cty::c_char, __af: ::aya_ebpf::cty::c_int) -> *mut hostent;
}
extern "C" {
    pub fn gethostent_r(
        __result_buf: *mut hostent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gethostbyaddr_r(
        __addr: *const ::aya_ebpf::cty::c_void,
        __len: __socklen_t,
        __type: ::aya_ebpf::cty::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gethostbyname_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __result_buf: *mut hostent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __af: ::aya_ebpf::cty::c_int,
        __result_buf: *mut hostent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setnetent(__stay_open: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::aya_ebpf::cty::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::aya_ebpf::cty::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent_r(
        __result_buf: *mut netent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getnetbyaddr_r(
        __net: u32,
        __type: ::aya_ebpf::cty::c_int,
        __result_buf: *mut netent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getnetbyname_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __result_buf: *mut netent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::aya_ebpf::cty::c_char,
    pub s_aliases: *mut *mut ::aya_ebpf::cty::c_char,
    pub s_port: ::aya_ebpf::cty::c_int,
    pub s_proto: *mut ::aya_ebpf::cty::c_char,
}
extern "C" {
    pub fn setservent(__stay_open: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(__name: *const ::aya_ebpf::cty::c_char, __proto: *const ::aya_ebpf::cty::c_char)
        -> *mut servent;
}
extern "C" {
    pub fn getservbyport(__port: ::aya_ebpf::cty::c_int, __proto: *const ::aya_ebpf::cty::c_char) -> *mut servent;
}
extern "C" {
    pub fn getservent_r(
        __result_buf: *mut servent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getservbyname_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __proto: *const ::aya_ebpf::cty::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getservbyport_r(
        __port: ::aya_ebpf::cty::c_int,
        __proto: *const ::aya_ebpf::cty::c_char,
        __result_buf: *mut servent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::aya_ebpf::cty::c_char,
    pub p_aliases: *mut *mut ::aya_ebpf::cty::c_char,
    pub p_proto: ::aya_ebpf::cty::c_int,
}
extern "C" {
    pub fn setprotoent(__stay_open: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(__name: *const ::aya_ebpf::cty::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::aya_ebpf::cty::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent_r(
        __result_buf: *mut protoent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getprotobyname_r(
        __name: *const ::aya_ebpf::cty::c_char,
        __result_buf: *mut protoent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getprotobynumber_r(
        __proto: ::aya_ebpf::cty::c_int,
        __result_buf: *mut protoent,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn setnetgrent(__netgroup: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn getnetgrent(
        __hostp: *mut *mut ::aya_ebpf::cty::c_char,
        __userp: *mut *mut ::aya_ebpf::cty::c_char,
        __domainp: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn innetgr(
        __netgroup: *const ::aya_ebpf::cty::c_char,
        __host: *const ::aya_ebpf::cty::c_char,
        __user: *const ::aya_ebpf::cty::c_char,
        __domain: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getnetgrent_r(
        __hostp: *mut *mut ::aya_ebpf::cty::c_char,
        __userp: *mut *mut ::aya_ebpf::cty::c_char,
        __domainp: *mut *mut ::aya_ebpf::cty::c_char,
        __buffer: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rcmd(
        __ahost: *mut *mut ::aya_ebpf::cty::c_char,
        __rport: ::aya_ebpf::cty::c_ushort,
        __locuser: *const ::aya_ebpf::cty::c_char,
        __remuser: *const ::aya_ebpf::cty::c_char,
        __cmd: *const ::aya_ebpf::cty::c_char,
        __fd2p: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rcmd_af(
        __ahost: *mut *mut ::aya_ebpf::cty::c_char,
        __rport: ::aya_ebpf::cty::c_ushort,
        __locuser: *const ::aya_ebpf::cty::c_char,
        __remuser: *const ::aya_ebpf::cty::c_char,
        __cmd: *const ::aya_ebpf::cty::c_char,
        __fd2p: *mut ::aya_ebpf::cty::c_int,
        __af: sa_family_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rexec(
        __ahost: *mut *mut ::aya_ebpf::cty::c_char,
        __rport: ::aya_ebpf::cty::c_int,
        __name: *const ::aya_ebpf::cty::c_char,
        __pass: *const ::aya_ebpf::cty::c_char,
        __cmd: *const ::aya_ebpf::cty::c_char,
        __fd2p: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rexec_af(
        __ahost: *mut *mut ::aya_ebpf::cty::c_char,
        __rport: ::aya_ebpf::cty::c_int,
        __name: *const ::aya_ebpf::cty::c_char,
        __pass: *const ::aya_ebpf::cty::c_char,
        __cmd: *const ::aya_ebpf::cty::c_char,
        __fd2p: *mut ::aya_ebpf::cty::c_int,
        __af: sa_family_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ruserok(
        __rhost: *const ::aya_ebpf::cty::c_char,
        __suser: ::aya_ebpf::cty::c_int,
        __remuser: *const ::aya_ebpf::cty::c_char,
        __locuser: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ruserok_af(
        __rhost: *const ::aya_ebpf::cty::c_char,
        __suser: ::aya_ebpf::cty::c_int,
        __remuser: *const ::aya_ebpf::cty::c_char,
        __locuser: *const ::aya_ebpf::cty::c_char,
        __af: sa_family_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn iruserok(
        __raddr: u32,
        __suser: ::aya_ebpf::cty::c_int,
        __remuser: *const ::aya_ebpf::cty::c_char,
        __locuser: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn iruserok_af(
        __raddr: *const ::aya_ebpf::cty::c_void,
        __suser: ::aya_ebpf::cty::c_int,
        __remuser: *const ::aya_ebpf::cty::c_char,
        __locuser: *const ::aya_ebpf::cty::c_char,
        __af: sa_family_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn rresvport_af(__alport: *mut ::aya_ebpf::cty::c_int, __af: sa_family_t) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::aya_ebpf::cty::c_int,
    pub ai_family: ::aya_ebpf::cty::c_int,
    pub ai_socktype: ::aya_ebpf::cty::c_int,
    pub ai_protocol: ::aya_ebpf::cty::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::aya_ebpf::cty::c_char,
    pub ai_next: *mut addrinfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gaicb {
    pub ar_name: *const ::aya_ebpf::cty::c_char,
    pub ar_service: *const ::aya_ebpf::cty::c_char,
    pub ar_request: *const addrinfo,
    pub ar_result: *mut addrinfo,
    pub __return: ::aya_ebpf::cty::c_int,
    pub __glibc_reserved: [::aya_ebpf::cty::c_int; 5usize],
}
extern "C" {
    pub fn getaddrinfo(
        __name: *const ::aya_ebpf::cty::c_char,
        __service: *const ::aya_ebpf::cty::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(__ecode: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut ::aya_ebpf::cty::c_char,
        __hostlen: socklen_t,
        __serv: *mut ::aya_ebpf::cty::c_char,
        __servlen: socklen_t,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getaddrinfo_a(
        __mode: ::aya_ebpf::cty::c_int,
        __list: *mut *mut gaicb,
        __ent: ::aya_ebpf::cty::c_int,
        __sig: *mut sigevent,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gai_suspend(
        __list: *const *const gaicb,
        __ent: ::aya_ebpf::cty::c_int,
        __timeout: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gai_error(__req: *mut gaicb) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn gai_cancel(__gaicbp: *mut gaicb) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::aya_ebpf::cty::c_char; 108usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: ::aya_ebpf::cty::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: ::aya_ebpf::cty::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: ::aya_ebpf::cty::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: ::aya_ebpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
extern "C" {
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::aya_ebpf::cty::c_int,
    pub tm_min: ::aya_ebpf::cty::c_int,
    pub tm_hour: ::aya_ebpf::cty::c_int,
    pub tm_mday: ::aya_ebpf::cty::c_int,
    pub tm_mon: ::aya_ebpf::cty::c_int,
    pub tm_year: ::aya_ebpf::cty::c_int,
    pub tm_wday: ::aya_ebpf::cty::c_int,
    pub tm_yday: ::aya_ebpf::cty::c_int,
    pub tm_isdst: ::aya_ebpf::cty::c_int,
    pub tm_gmtoff: ::aya_ebpf::cty::c_long,
    pub tm_zone: *const ::aya_ebpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::aya_ebpf::cty::c_char,
        __maxsize: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        __s: *const ::aya_ebpf::cty::c_char,
        __fmt: *const ::aya_ebpf::cty::c_char,
        __tp: *mut tm,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::aya_ebpf::cty::c_char,
        __maxsize: usize,
        __format: *const ::aya_ebpf::cty::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strptime_l(
        __s: *const ::aya_ebpf::cty::c_char,
        __fmt: *const ::aya_ebpf::cty::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::aya_ebpf::cty::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut __timezone: ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::aya_ebpf::cty::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut timezone: ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::aya_ebpf::cty::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent, __timerid: *mut timer_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::aya_ebpf::cty::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn timespec_getres(__ts: *mut timespec, __base: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut getdate_err: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn getdate(__string: *const ::aya_ebpf::cty::c_char) -> *mut tm;
}
extern "C" {
    pub fn getdate_r(__string: *const ::aya_ebpf::cty::c_char, __resbufp: *mut tm) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn memalign(
        __alignment: ::aya_ebpf::cty::c_ulong,
        __size: ::aya_ebpf::cty::c_ulong,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn pvalloc(__size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: ::aya_ebpf::cty::c_int,
    pub ordblks: ::aya_ebpf::cty::c_int,
    pub smblks: ::aya_ebpf::cty::c_int,
    pub hblks: ::aya_ebpf::cty::c_int,
    pub hblkhd: ::aya_ebpf::cty::c_int,
    pub usmblks: ::aya_ebpf::cty::c_int,
    pub fsmblks: ::aya_ebpf::cty::c_int,
    pub uordblks: ::aya_ebpf::cty::c_int,
    pub fordblks: ::aya_ebpf::cty::c_int,
    pub keepcost: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo2 {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn mallinfo2() -> mallinfo2;
}
extern "C" {
    pub fn mallopt(__param: ::aya_ebpf::cty::c_int, __val: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn malloc_trim(__pad: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn malloc_usable_size(__ptr: *mut ::aya_ebpf::cty::c_void) -> usize;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn malloc_info(__options: ::aya_ebpf::cty::c_int, __fp: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::aya_ebpf::cty::c_ushort,
    pub ws_col: ::aya_ebpf::cty::c_ushort,
    pub ws_xpixel: ::aya_ebpf::cty::c_ushort,
    pub ws_ypixel: ::aya_ebpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termio {
    pub c_iflag: ::aya_ebpf::cty::c_ushort,
    pub c_oflag: ::aya_ebpf::cty::c_ushort,
    pub c_cflag: ::aya_ebpf::cty::c_ushort,
    pub c_lflag: ::aya_ebpf::cty::c_ushort,
    pub c_line: ::aya_ebpf::cty::c_uchar,
    pub c_cc: [::aya_ebpf::cty::c_uchar; 8usize],
}
extern "C" {
    pub fn ioctl(__fd: ::aya_ebpf::cty::c_int, __request: ::aya_ebpf::cty::c_ulong, ...) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypt_data {
    pub output: [::aya_ebpf::cty::c_char; 384usize],
    pub setting: [::aya_ebpf::cty::c_char; 384usize],
    pub input: [::aya_ebpf::cty::c_char; 512usize],
    pub reserved: [::aya_ebpf::cty::c_char; 767usize],
    pub initialized: ::aya_ebpf::cty::c_char,
    pub internal: [::aya_ebpf::cty::c_char; 30720usize],
}
extern "C" {
    pub fn crypt_r(
        __phrase: *const ::aya_ebpf::cty::c_char,
        __setting: *const ::aya_ebpf::cty::c_char,
        __data: *mut crypt_data,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn crypt_rn(
        __phrase: *const ::aya_ebpf::cty::c_char,
        __setting: *const ::aya_ebpf::cty::c_char,
        __data: *mut ::aya_ebpf::cty::c_void,
        __size: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn crypt_ra(
        __phrase: *const ::aya_ebpf::cty::c_char,
        __setting: *const ::aya_ebpf::cty::c_char,
        __data: *mut *mut ::aya_ebpf::cty::c_void,
        __size: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn crypt_gensalt(
        __prefix: *const ::aya_ebpf::cty::c_char,
        __count: ::aya_ebpf::cty::c_ulong,
        __rbytes: *const ::aya_ebpf::cty::c_char,
        __nrbytes: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn crypt_gensalt_rn(
        __prefix: *const ::aya_ebpf::cty::c_char,
        __count: ::aya_ebpf::cty::c_ulong,
        __rbytes: *const ::aya_ebpf::cty::c_char,
        __nrbytes: ::aya_ebpf::cty::c_int,
        __output: *mut ::aya_ebpf::cty::c_char,
        __output_size: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn crypt_gensalt_ra(
        __prefix: *const ::aya_ebpf::cty::c_char,
        __count: ::aya_ebpf::cty::c_ulong,
        __rbytes: *const ::aya_ebpf::cty::c_char,
        __nrbytes: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn crypt_checksalt(__setting: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn crypt_preferred_method() -> *const ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utsname {
    pub sysname: [::aya_ebpf::cty::c_char; 65usize],
    pub nodename: [::aya_ebpf::cty::c_char; 65usize],
    pub release: [::aya_ebpf::cty::c_char; 65usize],
    pub version: [::aya_ebpf::cty::c_char; 65usize],
    pub machine: [::aya_ebpf::cty::c_char; 65usize],
    pub domainname: [::aya_ebpf::cty::c_char; 65usize],
}
extern "C" {
    pub fn uname(__name: *mut utsname) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn _dl_mcount_wrapper_check(__selfpc: *mut ::aya_ebpf::cty::c_void);
}
pub type Lmid_t = ::aya_ebpf::cty::c_long;
extern "C" {
    pub fn dlopen(__file: *const ::aya_ebpf::cty::c_char, __mode: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn dlclose(__handle: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn dlsym(
        __handle: *mut ::aya_ebpf::cty::c_void,
        __name: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn dlmopen(
        __nsid: Lmid_t,
        __file: *const ::aya_ebpf::cty::c_char,
        __mode: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn dlvsym(
        __handle: *mut ::aya_ebpf::cty::c_void,
        __name: *const ::aya_ebpf::cty::c_char,
        __version: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn dlerror() -> *mut ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_info {
    pub dli_fname: *const ::aya_ebpf::cty::c_char,
    pub dli_fbase: *mut ::aya_ebpf::cty::c_void,
    pub dli_sname: *const ::aya_ebpf::cty::c_char,
    pub dli_saddr: *mut ::aya_ebpf::cty::c_void,
}
extern "C" {
    pub fn dladdr(__address: *const ::aya_ebpf::cty::c_void, __info: *mut Dl_info) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn dladdr1(
        __address: *const ::aya_ebpf::cty::c_void,
        __info: *mut Dl_info,
        __extra_info: *mut *mut ::aya_ebpf::cty::c_void,
        __flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
pub const RTLD_DL_SYMENT: _bindgen_ty_25 = 1;
pub const RTLD_DL_LINKMAP: _bindgen_ty_25 = 2;
pub type _bindgen_ty_25 = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn dlinfo(
        __handle: *mut ::aya_ebpf::cty::c_void,
        __request: ::aya_ebpf::cty::c_int,
        __arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
pub const RTLD_DI_LMID: _bindgen_ty_26 = 1;
pub const RTLD_DI_LINKMAP: _bindgen_ty_26 = 2;
pub const RTLD_DI_CONFIGADDR: _bindgen_ty_26 = 3;
pub const RTLD_DI_SERINFO: _bindgen_ty_26 = 4;
pub const RTLD_DI_SERINFOSIZE: _bindgen_ty_26 = 5;
pub const RTLD_DI_ORIGIN: _bindgen_ty_26 = 6;
pub const RTLD_DI_PROFILENAME: _bindgen_ty_26 = 7;
pub const RTLD_DI_PROFILEOUT: _bindgen_ty_26 = 8;
pub const RTLD_DI_TLS_MODID: _bindgen_ty_26 = 9;
pub const RTLD_DI_TLS_DATA: _bindgen_ty_26 = 10;
pub const RTLD_DI_PHDR: _bindgen_ty_26 = 11;
pub const RTLD_DI_MAX: _bindgen_ty_26 = 11;
pub type _bindgen_ty_26 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dl_serpath {
    pub dls_name: *mut ::aya_ebpf::cty::c_char,
    pub dls_flags: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
pub struct Dl_serinfo {
    pub dls_size: usize,
    pub dls_cnt: ::aya_ebpf::cty::c_uint,
    pub __bindgen_anon_1: Dl_serinfo__bindgen_ty_1,
}
#[repr(C)]
pub struct Dl_serinfo__bindgen_ty_1 {
    pub dls_serpath: __BindgenUnionField<[Dl_serpath; 0usize]>,
    pub __dls_serpath_pad: __BindgenUnionField<[Dl_serpath; 1usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dl_find_object {
    pub dlfo_flags: ::aya_ebpf::cty::c_ulonglong,
    pub dlfo_map_start: *mut ::aya_ebpf::cty::c_void,
    pub dlfo_map_end: *mut ::aya_ebpf::cty::c_void,
    pub dlfo_link_map: *mut link_map,
    pub dlfo_eh_frame: *mut ::aya_ebpf::cty::c_void,
    pub __dflo_reserved: [::aya_ebpf::cty::c_ulonglong; 7usize],
}
extern "C" {
    pub fn _dl_find_object(
        __address: *mut ::aya_ebpf::cty::c_void,
        __result: *mut dl_find_object,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::aya_ebpf::cty::c_char; 32usize],
    pub __align: ::aya_ebpf::cty::c_long,
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::aya_ebpf::cty::c_int,
        __value: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_open(__name: *const ::aya_ebpf::cty::c_char, __oflag: ::aya_ebpf::cty::c_int, ...) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_clockwait(__sem: *mut sem_t, clock: clockid_t, __abstime: *const timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn sem_getvalue(__sem: *mut sem_t, __sval: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prctl_mm_map {
    pub start_code: __u64,
    pub end_code: __u64,
    pub start_data: __u64,
    pub end_data: __u64,
    pub start_brk: __u64,
    pub brk: __u64,
    pub start_stack: __u64,
    pub arg_start: __u64,
    pub arg_end: __u64,
    pub env_start: __u64,
    pub env_end: __u64,
    pub auxv: *mut __u64,
    pub auxv_size: __u32,
    pub exe_fd: __u32,
}
extern "C" {
    pub fn prctl(__option: ::aya_ebpf::cty::c_int, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}sendfile64"]
    pub fn sendfile(
        __out_fd: ::aya_ebpf::cty::c_int,
        __in_fd: ::aya_ebpf::cty::c_int,
        __offset: *mut __off64_t,
        __count: usize,
    ) -> isize;
}
pub const EPOLL_CLOEXEC: _bindgen_ty_27 = 524288;
pub type _bindgen_ty_27 = ::aya_ebpf::cty::c_uint;
pub const EPOLL_EVENTS_EPOLLIN: EPOLL_EVENTS = 1;
pub const EPOLL_EVENTS_EPOLLPRI: EPOLL_EVENTS = 2;
pub const EPOLL_EVENTS_EPOLLOUT: EPOLL_EVENTS = 4;
pub const EPOLL_EVENTS_EPOLLRDNORM: EPOLL_EVENTS = 64;
pub const EPOLL_EVENTS_EPOLLRDBAND: EPOLL_EVENTS = 128;
pub const EPOLL_EVENTS_EPOLLWRNORM: EPOLL_EVENTS = 256;
pub const EPOLL_EVENTS_EPOLLWRBAND: EPOLL_EVENTS = 512;
pub const EPOLL_EVENTS_EPOLLMSG: EPOLL_EVENTS = 1024;
pub const EPOLL_EVENTS_EPOLLERR: EPOLL_EVENTS = 8;
pub const EPOLL_EVENTS_EPOLLHUP: EPOLL_EVENTS = 16;
pub const EPOLL_EVENTS_EPOLLRDHUP: EPOLL_EVENTS = 8192;
pub const EPOLL_EVENTS_EPOLLEXCLUSIVE: EPOLL_EVENTS = 268435456;
pub const EPOLL_EVENTS_EPOLLWAKEUP: EPOLL_EVENTS = 536870912;
pub const EPOLL_EVENTS_EPOLLONESHOT: EPOLL_EVENTS = 1073741824;
pub const EPOLL_EVENTS_EPOLLET: EPOLL_EVENTS = 2147483648;
pub type EPOLL_EVENTS = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union epoll_data {
    pub ptr: *mut ::aya_ebpf::cty::c_void,
    pub fd: ::aya_ebpf::cty::c_int,
    pub u32_: u32,
    pub u64_: u64,
}
pub type epoll_data_t = epoll_data;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct epoll_event {
    pub events: u32,
    pub data: epoll_data_t,
}
extern "C" {
    pub fn epoll_create(__size: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn epoll_create1(__flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn epoll_ctl(
        __epfd: ::aya_ebpf::cty::c_int,
        __op: ::aya_ebpf::cty::c_int,
        __fd: ::aya_ebpf::cty::c_int,
        __event: *mut epoll_event,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn epoll_wait(
        __epfd: ::aya_ebpf::cty::c_int,
        __events: *mut epoll_event,
        __maxevents: ::aya_ebpf::cty::c_int,
        __timeout: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn epoll_pwait(
        __epfd: ::aya_ebpf::cty::c_int,
        __events: *mut epoll_event,
        __maxevents: ::aya_ebpf::cty::c_int,
        __timeout: ::aya_ebpf::cty::c_int,
        __ss: *const __sigset_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn epoll_pwait2(
        __epfd: ::aya_ebpf::cty::c_int,
        __events: *mut epoll_event,
        __maxevents: ::aya_ebpf::cty::c_int,
        __timeout: *const timespec,
        __ss: *const __sigset_t,
    ) -> ::aya_ebpf::cty::c_int;
}
pub const EFD_SEMAPHORE: _bindgen_ty_28 = 1;
pub const EFD_CLOEXEC: _bindgen_ty_28 = 524288;
pub const EFD_NONBLOCK: _bindgen_ty_28 = 2048;
pub type _bindgen_ty_28 = ::aya_ebpf::cty::c_uint;
pub type eventfd_t = u64;
extern "C" {
    pub fn eventfd(__count: ::aya_ebpf::cty::c_uint, __flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn eventfd_read(__fd: ::aya_ebpf::cty::c_int, __value: *mut eventfd_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn eventfd_write(__fd: ::aya_ebpf::cty::c_int, __value: eventfd_t) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v1 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub master_key_descriptor: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_key {
    pub mode: __u32,
    pub raw: [__u8; 64usize],
    pub size: __u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_policy_v2 {
    pub version: __u8,
    pub contents_encryption_mode: __u8,
    pub filenames_encryption_mode: __u8,
    pub flags: __u8,
    pub __reserved: [__u8; 4usize],
    pub master_key_identifier: [__u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_get_policy_ex_arg {
    pub policy_size: __u64,
    pub policy: fscrypt_get_policy_ex_arg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_get_policy_ex_arg__bindgen_ty_1 {
    pub version: __u8,
    pub v1: fscrypt_policy_v1,
    pub v2: fscrypt_policy_v2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_key_specifier {
    pub type_: __u32,
    pub __reserved: __u32,
    pub u: fscrypt_key_specifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fscrypt_key_specifier__bindgen_ty_1 {
    pub __reserved: [__u8; 32usize],
    pub descriptor: [__u8; 8usize],
    pub identifier: [__u8; 16usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct fscrypt_provisioning_key_payload {
    pub type_: __u32,
    pub __reserved: __u32,
    pub raw: __IncompleteArrayField<__u8>,
}
#[repr(C)]
pub struct fscrypt_add_key_arg {
    pub key_spec: fscrypt_key_specifier,
    pub raw_size: __u32,
    pub key_id: __u32,
    pub __reserved: [__u32; 8usize],
    pub raw: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_remove_key_arg {
    pub key_spec: fscrypt_key_specifier,
    pub removal_status_flags: __u32,
    pub __reserved: [__u32; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_get_key_status_arg {
    pub key_spec: fscrypt_key_specifier,
    pub __reserved: [__u32; 6usize],
    pub status: __u32,
    pub status_flags: __u32,
    pub user_count: __u32,
    pub __out_reserved: [__u32; 13usize],
}
pub const fsconfig_command_FSCONFIG_SET_FLAG: fsconfig_command = 0;
pub const fsconfig_command_FSCONFIG_SET_STRING: fsconfig_command = 1;
pub const fsconfig_command_FSCONFIG_SET_BINARY: fsconfig_command = 2;
pub const fsconfig_command_FSCONFIG_SET_PATH: fsconfig_command = 3;
pub const fsconfig_command_FSCONFIG_SET_PATH_EMPTY: fsconfig_command = 4;
pub const fsconfig_command_FSCONFIG_SET_FD: fsconfig_command = 5;
pub const fsconfig_command_FSCONFIG_CMD_CREATE: fsconfig_command = 6;
pub const fsconfig_command_FSCONFIG_CMD_RECONFIGURE: fsconfig_command = 7;
pub const fsconfig_command_FSCONFIG_CMD_CREATE_EXCL: fsconfig_command = 8;
pub type fsconfig_command = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount_attr {
    pub attr_set: __u64,
    pub attr_clr: __u64,
    pub propagation: __u64,
    pub userns_fd: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_clone_range {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstrim_range {
    pub start: __u64,
    pub len: __u64,
    pub minlen: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_dedupe_range_info {
    pub dest_fd: __s64,
    pub dest_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct file_dedupe_range {
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<file_dedupe_range_info>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_stat_struct {
    pub nr_files: ::aya_ebpf::cty::c_ulong,
    pub nr_free_files: ::aya_ebpf::cty::c_ulong,
    pub max_files: ::aya_ebpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inodes_stat_t {
    pub nr_inodes: ::aya_ebpf::cty::c_long,
    pub nr_unused: ::aya_ebpf::cty::c_long,
    pub dummy: [::aya_ebpf::cty::c_long; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsxattr {
    pub fsx_xflags: __u32,
    pub fsx_extsize: __u32,
    pub fsx_nextents: __u32,
    pub fsx_projid: __u32,
    pub fsx_cowextsize: __u32,
    pub fsx_pad: [::aya_ebpf::cty::c_uchar; 8usize],
}
pub type __kernel_rwf_t = ::aya_ebpf::cty::c_int;
pub type aio_context_t = __kernel_ulong_t;
pub const IOCB_CMD_PREAD: _bindgen_ty_29 = 0;
pub const IOCB_CMD_PWRITE: _bindgen_ty_29 = 1;
pub const IOCB_CMD_FSYNC: _bindgen_ty_29 = 2;
pub const IOCB_CMD_FDSYNC: _bindgen_ty_29 = 3;
pub const IOCB_CMD_POLL: _bindgen_ty_29 = 5;
pub const IOCB_CMD_NOOP: _bindgen_ty_29 = 6;
pub const IOCB_CMD_PREADV: _bindgen_ty_29 = 7;
pub const IOCB_CMD_PWRITEV: _bindgen_ty_29 = 8;
pub type _bindgen_ty_29 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_event {
    pub data: __u64,
    pub obj: __u64,
    pub res: __s64,
    pub res2: __s64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iocb {
    pub aio_data: __u64,
    pub aio_key: __u32,
    pub aio_rw_flags: __kernel_rwf_t,
    pub aio_lio_opcode: __u16,
    pub aio_reqprio: __s16,
    pub aio_fildes: __u32,
    pub aio_buf: __u64,
    pub aio_nbytes: __u64,
    pub aio_offset: __s64,
    pub aio_reserved2: __u64,
    pub aio_flags: __u32,
    pub aio_resfd: __u32,
}
pub type ngx_aiocb_t = iocb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __user_cap_header_struct {
    pub version: __u32,
    pub pid: ::aya_ebpf::cty::c_int,
}
pub type cap_user_header_t = *mut __user_cap_header_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __user_cap_data_struct {
    pub effective: __u32,
    pub permitted: __u32,
    pub inheritable: __u32,
}
pub type cap_user_data_t = *mut __user_cap_data_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_ns_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __le32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
pub type ngx_int_t = isize;
pub type ngx_uint_t = usize;
pub type ngx_flag_t = isize;
pub type ngx_module_t = ngx_module_s;
pub type ngx_conf_t = ngx_conf_s;
pub type ngx_cycle_t = ngx_cycle_s;
pub type ngx_pool_t = ngx_pool_s;
pub type ngx_chain_t = ngx_chain_s;
pub type ngx_log_t = ngx_log_s;
pub type ngx_open_file_t = ngx_open_file_s;
pub type ngx_command_t = ngx_command_s;
pub type ngx_file_t = ngx_file_s;
pub type ngx_event_t = ngx_event_s;
pub type ngx_event_aio_t = ngx_event_aio_s;
pub type ngx_connection_t = ngx_connection_s;
pub type ngx_thread_task_t = ngx_thread_task_s;
pub type ngx_ssl_t = ngx_ssl_s;
pub type ngx_proxy_protocol_t = ngx_proxy_protocol_s;
pub type ngx_ssl_connection_t = ngx_ssl_connection_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_udp_connection_s {
    _unused: [u8; 0],
}
pub type ngx_udp_connection_t = ngx_udp_connection_s;
pub type ngx_event_handler_pt = ::core::option::Option<unsafe extern "C" fn(ev: *mut ngx_event_t)>;
pub type ngx_connection_handler_pt = ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t)>;
pub type ngx_err_t = ::aya_ebpf::cty::c_int;
extern "C" {
    pub fn ngx_strerror(err: ngx_err_t, errstr: *mut u_char, size: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strerror_init() -> ngx_int_t;
}
pub type ngx_atomic_int_t = ::aya_ebpf::cty::c_long;
pub type ngx_atomic_uint_t = ::aya_ebpf::cty::c_ulong;
pub type ngx_atomic_t = ngx_atomic_uint_t;
extern "C" {
    pub fn ngx_spinlock(lock: *mut ngx_atomic_t, value: ngx_atomic_int_t, spin: ngx_uint_t);
}
pub type __jmp_buf = [::aya_ebpf::cty::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::aya_ebpf::cty::c_int,
    pub __saved_mask: __sigset_t,
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_30 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_30 = 1;
pub type _bindgen_ty_30 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_31 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_31 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_31 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_31 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_31 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_31 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_31 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_31 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_31 = 0;
pub type _bindgen_ty_31 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_32 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_32 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_32 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_32 = 1;
pub type _bindgen_ty_32 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_33 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_33 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_33 = 2;
pub type _bindgen_ty_33 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_34 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_34 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_34 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_34 = 0;
pub type _bindgen_ty_34 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_35 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_35 = 1;
pub type _bindgen_ty_35 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_36 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_36 = 1;
pub type _bindgen_ty_36 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_37 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_37 = 1;
pub type _bindgen_ty_37 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    pub __arg: *mut ::aya_ebpf::cty::c_void,
    pub __canceltype: ::aya_ebpf::cty::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_38 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_38 = 1;
pub type _bindgen_ty_38 = ::aya_ebpf::cty::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_39 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_39 = 1;
pub type _bindgen_ty_39 = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void,
        >,
        __arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::aya_ebpf::cty::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::aya_ebpf::cty::c_void,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut ::aya_ebpf::cty::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t, __guardsize: *mut usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t, __guardsize: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t, __scope: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t, __stacksize: *mut usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t, __stacksize: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::aya_ebpf::cty::c_void,
        __stacksize: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::aya_ebpf::cty::c_void,
        __stacksize: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setsigmask_np(__attr: *mut pthread_attr_t, sigmask: *const __sigset_t)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getsigmask_np(__attr: *const pthread_attr_t, sigmask: *mut __sigset_t)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getattr_np(__th: pthread_t, __attr: *mut pthread_attr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::aya_ebpf::cty::c_int,
        __param: *const sched_param,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::aya_ebpf::cty::c_int,
        __param: *mut sched_param,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut ::aya_ebpf::cty::c_char,
        __buflen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(__level: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_yield() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::aya_ebpf::cty::c_int,
        __oldstate: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::aya_ebpf::cty::c_int,
        __oldtype: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::aya_ebpf::cty::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    pub __cancel_arg: *mut ::aya_ebpf::cty::c_void,
    pub __do_it: ::aya_ebpf::cty::c_int,
    pub __cancel_type: ::aya_ebpf::cty::c_int,
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_register_cancel_defer(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel_restore(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t, __abstime: *const timespec) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::aya_ebpf::cty::c_int,
        __old_ceiling: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t, __mutex: *mut pthread_mutex_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t, __clock_id: __clockid_t)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t, __pointer: *const ::aya_ebpf::cty::c_void)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t, __clock_id: *mut __clockid_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type ngx_thread_mutex_t = pthread_mutex_t;
extern "C" {
    pub fn ngx_thread_mutex_create(mtx: *mut ngx_thread_mutex_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_thread_mutex_destroy(mtx: *mut ngx_thread_mutex_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_thread_mutex_lock(mtx: *mut ngx_thread_mutex_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_thread_mutex_unlock(mtx: *mut ngx_thread_mutex_t, log: *mut ngx_log_t) -> ngx_int_t;
}
pub type ngx_thread_cond_t = pthread_cond_t;
extern "C" {
    pub fn ngx_thread_cond_create(cond: *mut ngx_thread_cond_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_thread_cond_destroy(cond: *mut ngx_thread_cond_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_thread_cond_signal(cond: *mut ngx_thread_cond_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_thread_cond_wait(
        cond: *mut ngx_thread_cond_t,
        mtx: *mut ngx_thread_mutex_t,
        log: *mut ngx_log_t,
    ) -> ngx_int_t;
}
pub type ngx_tid_t = pid_t;
extern "C" {
    pub fn ngx_thread_tid() -> ngx_tid_t;
}
pub type ngx_rbtree_key_t = ngx_uint_t;
pub type ngx_rbtree_key_int_t = ngx_int_t;
pub type ngx_rbtree_node_t = ngx_rbtree_node_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_rbtree_node_s {
    pub key: ngx_rbtree_key_t,
    pub left: *mut ngx_rbtree_node_t,
    pub right: *mut ngx_rbtree_node_t,
    pub parent: *mut ngx_rbtree_node_t,
    pub color: u_char,
    pub data: u_char,
}
pub type ngx_rbtree_t = ngx_rbtree_s;
pub type ngx_rbtree_insert_pt = ::core::option::Option<
    unsafe extern "C" fn(root: *mut ngx_rbtree_node_t, node: *mut ngx_rbtree_node_t, sentinel: *mut ngx_rbtree_node_t),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_rbtree_s {
    pub root: *mut ngx_rbtree_node_t,
    pub sentinel: *mut ngx_rbtree_node_t,
    pub insert: ngx_rbtree_insert_pt,
}
extern "C" {
    pub fn ngx_rbtree_insert(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t);
}
extern "C" {
    pub fn ngx_rbtree_delete(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t);
}
extern "C" {
    pub fn ngx_rbtree_insert_value(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_rbtree_insert_timer_value(
        root: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_rbtree_next(tree: *mut ngx_rbtree_t, node: *mut ngx_rbtree_node_t) -> *mut ngx_rbtree_node_t;
}
pub type ngx_msec_t = ngx_rbtree_key_t;
pub type ngx_msec_int_t = ngx_rbtree_key_int_t;
pub type ngx_tm_t = tm;
extern "C" {
    pub fn ngx_timezone_update();
}
extern "C" {
    pub fn ngx_localtime(s: time_t, tm: *mut ngx_tm_t);
}
extern "C" {
    pub fn ngx_libc_localtime(s: time_t, tm: *mut tm);
}
extern "C" {
    pub fn ngx_libc_gmtime(s: time_t, tm: *mut tm);
}
pub type ngx_socket_t = ::aya_ebpf::cty::c_int;
extern "C" {
    pub fn ngx_nonblocking(s: ngx_socket_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ngx_blocking(s: ngx_socket_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ngx_tcp_nopush(s: ngx_socket_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ngx_tcp_push(s: ngx_socket_t) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_str_t {
    pub len: usize,
    pub data: *mut u_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_keyval_t {
    pub key: ngx_str_t,
    pub value: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_variable_value_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub data: *mut u_char,
}
impl ngx_variable_value_t {
    #[inline]
    pub fn len(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn valid(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cacheable(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cacheable(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn not_found(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_not_found(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escape(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escape(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        len: ::aya_ebpf::cty::c_uint,
        valid: ::aya_ebpf::cty::c_uint,
        no_cacheable: ::aya_ebpf::cty::c_uint,
        not_found: ::aya_ebpf::cty::c_uint,
        escape: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let len: u32 = unsafe { ::core::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let valid: u32 = unsafe { ::core::mem::transmute(valid) };
            valid as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let no_cacheable: u32 = unsafe { ::core::mem::transmute(no_cacheable) };
            no_cacheable as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let not_found: u32 = unsafe { ::core::mem::transmute(not_found) };
            not_found as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let escape: u32 = unsafe { ::core::mem::transmute(escape) };
            escape as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_strlow(dst: *mut u_char, src: *mut u_char, n: usize);
}
extern "C" {
    pub fn ngx_strnlen(p: *mut u_char, n: usize) -> usize;
}
extern "C" {
    pub fn ngx_explicit_memzero(buf: *mut ::aya_ebpf::cty::c_void, n: usize);
}
extern "C" {
    pub fn ngx_cpystrn(dst: *mut u_char, src: *mut u_char, n: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_pstrdup(pool: *mut ngx_pool_t, src: *mut ngx_str_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_sprintf(buf: *mut u_char, fmt: *const ::aya_ebpf::cty::c_char, ...) -> *mut u_char;
}
extern "C" {
    pub fn ngx_snprintf(buf: *mut u_char, max: usize, fmt: *const ::aya_ebpf::cty::c_char, ...) -> *mut u_char;
}
extern "C" {
    pub fn ngx_slprintf(buf: *mut u_char, last: *mut u_char, fmt: *const ::aya_ebpf::cty::c_char, ...) -> *mut u_char;
}
extern "C" {
    pub fn ngx_vslprintf(
        buf: *mut u_char,
        last: *mut u_char,
        fmt: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strcasecmp(s1: *mut u_char, s2: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_strncasecmp(s1: *mut u_char, s2: *mut u_char, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_strnstr(s1: *mut u_char, s2: *mut ::aya_ebpf::cty::c_char, n: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strstrn(s1: *mut u_char, s2: *mut ::aya_ebpf::cty::c_char, n: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strcasestrn(s1: *mut u_char, s2: *mut ::aya_ebpf::cty::c_char, n: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_strlcasestrn(s1: *mut u_char, last: *mut u_char, s2: *mut u_char, n: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_rstrncmp(s1: *mut u_char, s2: *mut u_char, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_rstrncasecmp(s1: *mut u_char, s2: *mut u_char, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_memn2cmp(s1: *mut u_char, s2: *mut u_char, n1: usize, n2: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_dns_strcmp(s1: *mut u_char, s2: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_filename_cmp(s1: *mut u_char, s2: *mut u_char, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atoi(line: *mut u_char, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atofp(line: *mut u_char, n: usize, point: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_atosz(line: *mut u_char, n: usize) -> isize;
}
extern "C" {
    pub fn ngx_atoof(line: *mut u_char, n: usize) -> off_t;
}
extern "C" {
    pub fn ngx_atotm(line: *mut u_char, n: usize) -> time_t;
}
extern "C" {
    pub fn ngx_hextoi(line: *mut u_char, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hex_dump(dst: *mut u_char, src: *mut u_char, len: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_encode_base64(dst: *mut ngx_str_t, src: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_encode_base64url(dst: *mut ngx_str_t, src: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_decode_base64(dst: *mut ngx_str_t, src: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_decode_base64url(dst: *mut ngx_str_t, src: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_utf8_decode(p: *mut *mut u_char, n: usize) -> u32;
}
extern "C" {
    pub fn ngx_utf8_length(p: *mut u_char, n: usize) -> usize;
}
extern "C" {
    pub fn ngx_utf8_cpystrn(dst: *mut u_char, src: *mut u_char, n: usize, len: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_escape_uri(dst: *mut u_char, src: *mut u_char, size: usize, type_: ngx_uint_t) -> usize;
}
extern "C" {
    pub fn ngx_unescape_uri(dst: *mut *mut u_char, src: *mut *mut u_char, size: usize, type_: ngx_uint_t);
}
extern "C" {
    pub fn ngx_escape_html(dst: *mut u_char, src: *mut u_char, size: usize) -> usize;
}
extern "C" {
    pub fn ngx_escape_json(dst: *mut u_char, src: *mut u_char, size: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_str_node_t {
    pub node: ngx_rbtree_node_t,
    pub str_: ngx_str_t,
}
extern "C" {
    pub fn ngx_str_rbtree_insert_value(
        temp: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_str_rbtree_lookup(rbtree: *mut ngx_rbtree_t, name: *mut ngx_str_t, hash: u32) -> *mut ngx_str_node_t;
}
extern "C" {
    pub fn ngx_sort(
        base: *mut ::aya_ebpf::cty::c_void,
        n: usize,
        size: usize,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_void, arg2: *const ::aya_ebpf::cty::c_void) -> ngx_int_t,
        >,
    );
}
pub type ngx_fd_t = ::aya_ebpf::cty::c_int;
pub type ngx_file_info_t = stat;
pub type ngx_file_uniq_t = ino_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_file_mapping_t {
    pub name: *mut u_char,
    pub size: usize,
    pub addr: *mut ::aya_ebpf::cty::c_void,
    pub fd: ngx_fd_t,
    pub log: *mut ngx_log_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_dir_t {
    pub dir: *mut DIR,
    pub de: *mut dirent,
    pub info: stat,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_dir_t {
    #[inline]
    pub fn type_(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_info(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_info(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::aya_ebpf::cty::c_uint,
        valid_info: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let valid_info: u32 = unsafe { ::core::mem::transmute(valid_info) };
            valid_info as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_glob_t {
    pub n: usize,
    pub pglob: glob_t,
    pub pattern: *mut u_char,
    pub log: *mut ngx_log_t,
    pub test: ngx_uint_t,
}
extern "C" {
    pub fn ngx_open_tempfile(name: *mut u_char, persistent: ngx_uint_t, access: ngx_uint_t) -> ngx_fd_t;
}
extern "C" {
    pub fn ngx_read_file(file: *mut ngx_file_t, buf: *mut u_char, size: usize, offset: off_t) -> isize;
}
extern "C" {
    pub fn ngx_write_file(file: *mut ngx_file_t, buf: *mut u_char, size: usize, offset: off_t) -> isize;
}
extern "C" {
    pub fn ngx_write_chain_to_file(
        file: *mut ngx_file_t,
        ce: *mut ngx_chain_t,
        offset: off_t,
        pool: *mut ngx_pool_t,
    ) -> isize;
}
extern "C" {
    pub fn ngx_set_file_time(name: *mut u_char, fd: ngx_fd_t, s: time_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_file_mapping(fm: *mut ngx_file_mapping_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_close_file_mapping(fm: *mut ngx_file_mapping_t);
}
extern "C" {
    pub fn ngx_open_dir(name: *mut ngx_str_t, dir: *mut ngx_dir_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_read_dir(dir: *mut ngx_dir_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_open_glob(gl: *mut ngx_glob_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_read_glob(gl: *mut ngx_glob_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_close_glob(gl: *mut ngx_glob_t);
}
extern "C" {
    pub fn ngx_trylock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_lock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_unlock_fd(fd: ngx_fd_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_read_ahead(fd: ngx_fd_t, n: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_directio_on(fd: ngx_fd_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_directio_off(fd: ngx_fd_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_fs_bsize(name: *mut u_char) -> usize;
}
extern "C" {
    pub fn ngx_fs_available(name: *mut u_char) -> off_t;
}
extern "C" {
    pub fn ngx_file_aio_init(file: *mut ngx_file_t, pool: *mut ngx_pool_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_file_aio_read(
        file: *mut ngx_file_t,
        buf: *mut u_char,
        size: usize,
        offset: off_t,
        pool: *mut ngx_pool_t,
    ) -> isize;
}
extern "C" {
    pub static mut ngx_file_aio: ngx_uint_t;
}
extern "C" {
    pub fn ngx_thread_read(
        file: *mut ngx_file_t,
        buf: *mut u_char,
        size: usize,
        offset: off_t,
        pool: *mut ngx_pool_t,
    ) -> isize;
}
extern "C" {
    pub fn ngx_thread_write_chain_to_file(
        file: *mut ngx_file_t,
        cl: *mut ngx_chain_t,
        offset: off_t,
        pool: *mut ngx_pool_t,
    ) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_shm_t {
    pub addr: *mut u_char,
    pub size: usize,
    pub name: ngx_str_t,
    pub log: *mut ngx_log_t,
    pub exists: ngx_uint_t,
}
extern "C" {
    pub fn ngx_shm_alloc(shm: *mut ngx_shm_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_shm_free(shm: *mut ngx_shm_t);
}
pub type ngx_cpuset_t = cpu_set_t;
extern "C" {
    pub fn ngx_setaffinity(cpu_affinity: *mut ngx_cpuset_t, log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_init_setproctitle(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_setproctitle(title: *mut ::aya_ebpf::cty::c_char);
}
pub type ngx_pid_t = pid_t;
pub type ngx_spawn_proc_pt =
    ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t, data: *mut ::aya_ebpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_process_t {
    pub pid: ngx_pid_t,
    pub status: ::aya_ebpf::cty::c_int,
    pub channel: [ngx_socket_t; 2usize],
    pub proc_: ngx_spawn_proc_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_process_t {
    #[inline]
    pub fn respawn(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_respawn(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn just_spawn(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_just_spawn(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn detached(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_detached(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exiting(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exiting(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exited(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exited(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        respawn: ::aya_ebpf::cty::c_uint,
        just_spawn: ::aya_ebpf::cty::c_uint,
        detached: ::aya_ebpf::cty::c_uint,
        exiting: ::aya_ebpf::cty::c_uint,
        exited: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let respawn: u32 = unsafe { ::core::mem::transmute(respawn) };
            respawn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let just_spawn: u32 = unsafe { ::core::mem::transmute(just_spawn) };
            just_spawn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let detached: u32 = unsafe { ::core::mem::transmute(detached) };
            detached as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exiting: u32 = unsafe { ::core::mem::transmute(exiting) };
            exiting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exited: u32 = unsafe { ::core::mem::transmute(exited) };
            exited as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_exec_ctx_t {
    pub path: *mut ::aya_ebpf::cty::c_char,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub argv: *const *mut ::aya_ebpf::cty::c_char,
    pub envp: *const *mut ::aya_ebpf::cty::c_char,
}
extern "C" {
    pub fn ngx_spawn_process(
        cycle: *mut ngx_cycle_t,
        proc_: ngx_spawn_proc_pt,
        data: *mut ::aya_ebpf::cty::c_void,
        name: *mut ::aya_ebpf::cty::c_char,
        respawn: ngx_int_t,
    ) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_execute(cycle: *mut ngx_cycle_t, ctx: *mut ngx_exec_ctx_t) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_init_signals(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_debug_point();
}
extern "C" {
    pub static mut ngx_argc: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_argv: *mut *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_os_argv: *mut *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_pid: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_parent: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_channel: ngx_socket_t;
}
extern "C" {
    pub static mut ngx_process_slot: ngx_int_t;
}
extern "C" {
    pub static mut ngx_last_process: ngx_int_t;
}
extern "C" {
    pub static mut ngx_processes: [ngx_process_t; 1024usize];
}
pub type ngx_uid_t = uid_t;
pub type ngx_gid_t = gid_t;
extern "C" {
    pub fn ngx_libc_crypt(
        pool: *mut ngx_pool_t,
        key: *mut u_char,
        salt: *mut u_char,
        encrypted: *mut *mut u_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_dlerror() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_parse_size(line: *mut ngx_str_t) -> isize;
}
extern "C" {
    pub fn ngx_parse_offset(line: *mut ngx_str_t) -> off_t;
}
extern "C" {
    pub fn ngx_parse_time(line: *mut ngx_str_t, is_sec: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_http_time(value: *mut u_char, len: usize) -> time_t;
}
pub type ngx_log_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(log: *mut ngx_log_t, buf: *mut u_char, len: usize) -> *mut u_char>;
pub type ngx_log_writer_pt =
    ::core::option::Option<unsafe extern "C" fn(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_log_s {
    pub log_level: ngx_uint_t,
    pub file: *mut ngx_open_file_t,
    pub connection: ngx_atomic_uint_t,
    pub disk_full_time: time_t,
    pub handler: ngx_log_handler_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub writer: ngx_log_writer_pt,
    pub wdata: *mut ::aya_ebpf::cty::c_void,
    pub action: *mut ::aya_ebpf::cty::c_char,
    pub next: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_log_error_core(
        level: ngx_uint_t,
        log: *mut ngx_log_t,
        err: ngx_err_t,
        fmt: *const ::aya_ebpf::cty::c_char,
        ...
    );
}
extern "C" {
    pub fn ngx_log_init(prefix: *mut u_char, error_log: *mut u_char) -> *mut ngx_log_t;
}
extern "C" {
    pub fn ngx_log_abort(err: ngx_err_t, fmt: *const ::aya_ebpf::cty::c_char, ...);
}
extern "C" {
    pub fn ngx_log_stderr(err: ngx_err_t, fmt: *const ::aya_ebpf::cty::c_char, ...);
}
extern "C" {
    pub fn ngx_log_errno(buf: *mut u_char, last: *mut u_char, err: ngx_err_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_log_open_default(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_log_redirect_stderr(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_log_get_file_log(head: *mut ngx_log_t) -> *mut ngx_log_t;
}
extern "C" {
    pub fn ngx_log_set_log(cf: *mut ngx_conf_t, head: *mut *mut ngx_log_t) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_errlog_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_use_stderr: ngx_uint_t;
}
extern "C" {
    pub fn ngx_alloc(size: usize, log: *mut ngx_log_t) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_calloc(size: usize, log: *mut ngx_log_t) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_memalign(alignment: usize, size: usize, log: *mut ngx_log_t) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub static mut ngx_pagesize: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_pagesize_shift: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_cacheline_size: ngx_uint_t;
}
pub type ngx_pool_cleanup_pt = ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void)>;
pub type ngx_pool_cleanup_t = ngx_pool_cleanup_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_cleanup_s {
    pub handler: ngx_pool_cleanup_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub next: *mut ngx_pool_cleanup_t,
}
pub type ngx_pool_large_t = ngx_pool_large_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_large_s {
    pub next: *mut ngx_pool_large_t,
    pub alloc: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_data_t {
    pub last: *mut u_char,
    pub end: *mut u_char,
    pub next: *mut ngx_pool_t,
    pub failed: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_s {
    pub d: ngx_pool_data_t,
    pub max: usize,
    pub current: *mut ngx_pool_t,
    pub chain: *mut ngx_chain_t,
    pub large: *mut ngx_pool_large_t,
    pub cleanup: *mut ngx_pool_cleanup_t,
    pub log: *mut ngx_log_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_pool_cleanup_file_t {
    pub fd: ngx_fd_t,
    pub name: *mut u_char,
    pub log: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_create_pool(size: usize, log: *mut ngx_log_t) -> *mut ngx_pool_t;
}
extern "C" {
    pub fn ngx_destroy_pool(pool: *mut ngx_pool_t);
}
extern "C" {
    pub fn ngx_reset_pool(pool: *mut ngx_pool_t);
}
extern "C" {
    pub fn ngx_palloc(pool: *mut ngx_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pnalloc(pool: *mut ngx_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pcalloc(pool: *mut ngx_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pmemalign(pool: *mut ngx_pool_t, size: usize, alignment: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_pfree(pool: *mut ngx_pool_t, p: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_pool_cleanup_add(p: *mut ngx_pool_t, size: usize) -> *mut ngx_pool_cleanup_t;
}
extern "C" {
    pub fn ngx_pool_run_cleanup_file(p: *mut ngx_pool_t, fd: ngx_fd_t);
}
extern "C" {
    pub fn ngx_pool_cleanup_file(data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn ngx_pool_delete_file(data: *mut ::aya_ebpf::cty::c_void);
}
pub type ngx_buf_tag_t = *mut ::aya_ebpf::cty::c_void;
pub type ngx_buf_t = ngx_buf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_buf_s {
    pub pos: *mut u_char,
    pub last: *mut u_char,
    pub file_pos: off_t,
    pub file_last: off_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
    pub tag: ngx_buf_tag_t,
    pub file: *mut ngx_file_t,
    pub shadow: *mut ngx_buf_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub num: ::aya_ebpf::cty::c_int,
}
impl ngx_buf_s {
    #[inline]
    pub fn temporary(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temporary(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memory(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memory(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmap(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mmap(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recycled(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_recycled(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sync(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sync(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_buf(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_buf(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_in_chain(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_in_chain(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_shadow(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_shadow(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temp_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        temporary: ::aya_ebpf::cty::c_uint,
        memory: ::aya_ebpf::cty::c_uint,
        mmap: ::aya_ebpf::cty::c_uint,
        recycled: ::aya_ebpf::cty::c_uint,
        in_file: ::aya_ebpf::cty::c_uint,
        flush: ::aya_ebpf::cty::c_uint,
        sync: ::aya_ebpf::cty::c_uint,
        last_buf: ::aya_ebpf::cty::c_uint,
        last_in_chain: ::aya_ebpf::cty::c_uint,
        last_shadow: ::aya_ebpf::cty::c_uint,
        temp_file: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let temporary: u32 = unsafe { ::core::mem::transmute(temporary) };
            temporary as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let memory: u32 = unsafe { ::core::mem::transmute(memory) };
            memory as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mmap: u32 = unsafe { ::core::mem::transmute(mmap) };
            mmap as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let recycled: u32 = unsafe { ::core::mem::transmute(recycled) };
            recycled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let in_file: u32 = unsafe { ::core::mem::transmute(in_file) };
            in_file as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flush: u32 = unsafe { ::core::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sync: u32 = unsafe { ::core::mem::transmute(sync) };
            sync as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let last_buf: u32 = unsafe { ::core::mem::transmute(last_buf) };
            last_buf as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let last_in_chain: u32 = unsafe { ::core::mem::transmute(last_in_chain) };
            last_in_chain as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let last_shadow: u32 = unsafe { ::core::mem::transmute(last_shadow) };
            last_shadow as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let temp_file: u32 = unsafe { ::core::mem::transmute(temp_file) };
            temp_file as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_chain_s {
    pub buf: *mut ngx_buf_t,
    pub next: *mut ngx_chain_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_bufs_t {
    pub num: ngx_int_t,
    pub size: usize,
}
pub type ngx_output_chain_ctx_t = ngx_output_chain_ctx_s;
pub type ngx_output_chain_filter_pt =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, in_: *mut ngx_chain_t) -> ngx_int_t>;
pub type ngx_output_chain_aio_pt =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ngx_output_chain_ctx_t, file: *mut ngx_file_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_output_chain_ctx_s {
    pub buf: *mut ngx_buf_t,
    pub in_: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub aio_handler: ngx_output_chain_aio_pt,
    pub aio_preload: ::core::option::Option<unsafe extern "C" fn(file: *mut ngx_buf_t) -> isize>,
    pub thread_handler:
        ::core::option::Option<unsafe extern "C" fn(task: *mut ngx_thread_task_t, file: *mut ngx_file_t) -> ngx_int_t>,
    pub thread_task: *mut ngx_thread_task_t,
    pub alignment: off_t,
    pub pool: *mut ngx_pool_t,
    pub allocated: ngx_int_t,
    pub bufs: ngx_bufs_t,
    pub tag: ngx_buf_tag_t,
    pub output_filter: ngx_output_chain_filter_pt,
    pub filter_ctx: *mut ::aya_ebpf::cty::c_void,
}
impl ngx_output_chain_ctx_s {
    #[inline]
    pub fn sendfile(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unaligned(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unaligned(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_in_memory(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_in_memory(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn need_in_temp(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_in_temp(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sendfile: ::aya_ebpf::cty::c_uint,
        directio: ::aya_ebpf::cty::c_uint,
        unaligned: ::aya_ebpf::cty::c_uint,
        need_in_memory: ::aya_ebpf::cty::c_uint,
        need_in_temp: ::aya_ebpf::cty::c_uint,
        aio: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sendfile: u32 = unsafe { ::core::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let directio: u32 = unsafe { ::core::mem::transmute(directio) };
            directio as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let unaligned: u32 = unsafe { ::core::mem::transmute(unaligned) };
            unaligned as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let need_in_memory: u32 = unsafe { ::core::mem::transmute(need_in_memory) };
            need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let need_in_temp: u32 = unsafe { ::core::mem::transmute(need_in_temp) };
            need_in_temp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let aio: u32 = unsafe { ::core::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_chain_writer_ctx_t {
    pub out: *mut ngx_chain_t,
    pub last: *mut *mut ngx_chain_t,
    pub connection: *mut ngx_connection_t,
    pub pool: *mut ngx_pool_t,
    pub limit: off_t,
}
extern "C" {
    pub fn ngx_create_temp_buf(pool: *mut ngx_pool_t, size: usize) -> *mut ngx_buf_t;
}
extern "C" {
    pub fn ngx_create_chain_of_bufs(pool: *mut ngx_pool_t, bufs: *mut ngx_bufs_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_alloc_chain_link(pool: *mut ngx_pool_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_output_chain(ctx: *mut ngx_output_chain_ctx_t, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_writer(ctx: *mut ::aya_ebpf::cty::c_void, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_add_copy(pool: *mut ngx_pool_t, chain: *mut *mut ngx_chain_t, in_: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_chain_get_free_buf(p: *mut ngx_pool_t, free: *mut *mut ngx_chain_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_chain_update_chains(
        p: *mut ngx_pool_t,
        free: *mut *mut ngx_chain_t,
        busy: *mut *mut ngx_chain_t,
        out: *mut *mut ngx_chain_t,
        tag: ngx_buf_tag_t,
    );
}
extern "C" {
    pub fn ngx_chain_coalesce_file(in_: *mut *mut ngx_chain_t, limit: off_t) -> off_t;
}
extern "C" {
    pub fn ngx_chain_update_sent(in_: *mut ngx_chain_t, sent: off_t) -> *mut ngx_chain_t;
}
pub type ngx_queue_t = ngx_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_queue_s {
    pub prev: *mut ngx_queue_t,
    pub next: *mut ngx_queue_t,
}
extern "C" {
    pub fn ngx_queue_middle(queue: *mut ngx_queue_t) -> *mut ngx_queue_t;
}
extern "C" {
    pub fn ngx_queue_sort(
        queue: *mut ngx_queue_t,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ngx_queue_t, arg2: *const ngx_queue_t) -> ngx_int_t,
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_array_t {
    pub elts: *mut ::aya_ebpf::cty::c_void,
    pub nelts: ngx_uint_t,
    pub size: usize,
    pub nalloc: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
}
extern "C" {
    pub fn ngx_array_create(p: *mut ngx_pool_t, n: ngx_uint_t, size: usize) -> *mut ngx_array_t;
}
extern "C" {
    pub fn ngx_array_destroy(a: *mut ngx_array_t);
}
extern "C" {
    pub fn ngx_array_push(a: *mut ngx_array_t) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_array_push_n(a: *mut ngx_array_t, n: ngx_uint_t) -> *mut ::aya_ebpf::cty::c_void;
}
pub type ngx_list_part_t = ngx_list_part_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_list_part_s {
    pub elts: *mut ::aya_ebpf::cty::c_void,
    pub nelts: ngx_uint_t,
    pub next: *mut ngx_list_part_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_list_t {
    pub last: *mut ngx_list_part_t,
    pub part: ngx_list_part_t,
    pub size: usize,
    pub nalloc: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
}
extern "C" {
    pub fn ngx_list_create(pool: *mut ngx_pool_t, n: ngx_uint_t, size: usize) -> *mut ngx_list_t;
}
extern "C" {
    pub fn ngx_list_push(list: *mut ngx_list_t) -> *mut ::aya_ebpf::cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_elt_t {
    pub value: *mut ::aya_ebpf::cty::c_void,
    pub len: u_short,
    pub name: [u_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_t {
    pub buckets: *mut *mut ngx_hash_elt_t,
    pub size: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_wildcard_t {
    pub hash: ngx_hash_t,
    pub value: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_key_t {
    pub key: ngx_str_t,
    pub key_hash: ngx_uint_t,
    pub value: *mut ::aya_ebpf::cty::c_void,
}
pub type ngx_hash_key_pt = ::core::option::Option<unsafe extern "C" fn(data: *mut u_char, len: usize) -> ngx_uint_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_combined_t {
    pub hash: ngx_hash_t,
    pub wc_head: *mut ngx_hash_wildcard_t,
    pub wc_tail: *mut ngx_hash_wildcard_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_init_t {
    pub hash: *mut ngx_hash_t,
    pub key: ngx_hash_key_pt,
    pub max_size: ngx_uint_t,
    pub bucket_size: ngx_uint_t,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_hash_keys_arrays_t {
    pub hsize: ngx_uint_t,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
    pub keys: ngx_array_t,
    pub keys_hash: *mut ngx_array_t,
    pub dns_wc_head: ngx_array_t,
    pub dns_wc_head_hash: *mut ngx_array_t,
    pub dns_wc_tail: ngx_array_t,
    pub dns_wc_tail_hash: *mut ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_table_elt_t {
    pub hash: ngx_uint_t,
    pub key: ngx_str_t,
    pub value: ngx_str_t,
    pub lowcase_key: *mut u_char,
}
extern "C" {
    pub fn ngx_hash_find(
        hash: *mut ngx_hash_t,
        key: ngx_uint_t,
        name: *mut u_char,
        len: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_find_wc_head(
        hwc: *mut ngx_hash_wildcard_t,
        name: *mut u_char,
        len: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_find_wc_tail(
        hwc: *mut ngx_hash_wildcard_t,
        name: *mut u_char,
        len: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_find_combined(
        hash: *mut ngx_hash_combined_t,
        key: ngx_uint_t,
        name: *mut u_char,
        len: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_hash_init(hinit: *mut ngx_hash_init_t, names: *mut ngx_hash_key_t, nelts: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_wildcard_init(
        hinit: *mut ngx_hash_init_t,
        names: *mut ngx_hash_key_t,
        nelts: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_key(data: *mut u_char, len: usize) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_key_lc(data: *mut u_char, len: usize) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_strlow(dst: *mut u_char, src: *mut u_char, n: usize) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_hash_keys_array_init(ha: *mut ngx_hash_keys_arrays_t, type_: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_hash_add_key(
        ha: *mut ngx_hash_keys_arrays_t,
        key: *mut ngx_str_t,
        value: *mut ::aya_ebpf::cty::c_void,
        flags: ngx_uint_t,
    ) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_file_s {
    pub fd: ngx_fd_t,
    pub name: ngx_str_t,
    pub info: ngx_file_info_t,
    pub offset: off_t,
    pub sys_offset: off_t,
    pub log: *mut ngx_log_t,
    pub thread_handler:
        ::core::option::Option<unsafe extern "C" fn(task: *mut ngx_thread_task_t, file: *mut ngx_file_t) -> ngx_int_t>,
    pub thread_ctx: *mut ::aya_ebpf::cty::c_void,
    pub thread_task: *mut ngx_thread_task_t,
    pub aio: *mut ngx_event_aio_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_file_s {
    #[inline]
    pub fn valid_info(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_info(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_directio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        valid_info: ::aya_ebpf::cty::c_uint,
        directio: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let valid_info: u32 = unsafe { ::core::mem::transmute(valid_info) };
            valid_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let directio: u32 = unsafe { ::core::mem::transmute(directio) };
            directio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_path_manager_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void) -> ngx_msec_t>;
pub type ngx_path_purger_pt =
    ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void) -> ngx_msec_t>;
pub type ngx_path_loader_pt = ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_path_t {
    pub name: ngx_str_t,
    pub len: usize,
    pub level: [usize; 3usize],
    pub manager: ngx_path_manager_pt,
    pub purger: ngx_path_purger_pt,
    pub loader: ngx_path_loader_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub conf_file: *mut u_char,
    pub line: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_path_init_t {
    pub name: ngx_str_t,
    pub level: [usize; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_temp_file_t {
    pub file: ngx_file_t,
    pub offset: off_t,
    pub path: *mut ngx_path_t,
    pub pool: *mut ngx_pool_t,
    pub warn: *mut ::aya_ebpf::cty::c_char,
    pub access: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_temp_file_t {
    #[inline]
    pub fn log_level(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_level(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn persistent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_persistent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clean(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clean(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thread_write(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thread_write(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log_level: ::aya_ebpf::cty::c_uint,
        persistent: ::aya_ebpf::cty::c_uint,
        clean: ::aya_ebpf::cty::c_uint,
        thread_write: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log_level: u32 = unsafe { ::core::mem::transmute(log_level) };
            log_level as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let persistent: u32 = unsafe { ::core::mem::transmute(persistent) };
            persistent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let clean: u32 = unsafe { ::core::mem::transmute(clean) };
            clean as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let thread_write: u32 = unsafe { ::core::mem::transmute(thread_write) };
            thread_write as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ext_rename_file_t {
    pub access: ngx_uint_t,
    pub path_access: ngx_uint_t,
    pub time: time_t,
    pub fd: ngx_fd_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log: *mut ngx_log_t,
}
impl ngx_ext_rename_file_t {
    #[inline]
    pub fn create_path(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_create_path(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delete_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delete_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        create_path: ::aya_ebpf::cty::c_uint,
        delete_file: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let create_path: u32 = unsafe { ::core::mem::transmute(create_path) };
            create_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let delete_file: u32 = unsafe { ::core::mem::transmute(delete_file) };
            delete_file as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_copy_file_t {
    pub size: off_t,
    pub buf_size: usize,
    pub access: ngx_uint_t,
    pub time: time_t,
    pub log: *mut ngx_log_t,
}
pub type ngx_tree_ctx_t = ngx_tree_ctx_s;
pub type ngx_tree_init_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, prev: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t,
>;
pub type ngx_tree_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ngx_tree_ctx_t, name: *mut ngx_str_t) -> ngx_int_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_tree_ctx_s {
    pub size: off_t,
    pub fs_size: off_t,
    pub access: ngx_uint_t,
    pub mtime: time_t,
    pub init_handler: ngx_tree_init_handler_pt,
    pub file_handler: ngx_tree_handler_pt,
    pub pre_tree_handler: ngx_tree_handler_pt,
    pub post_tree_handler: ngx_tree_handler_pt,
    pub spec_handler: ngx_tree_handler_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub alloc: usize,
    pub log: *mut ngx_log_t,
}
extern "C" {
    pub fn ngx_get_full_name(pool: *mut ngx_pool_t, prefix: *mut ngx_str_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_write_chain_to_temp_file(tf: *mut ngx_temp_file_t, chain: *mut ngx_chain_t) -> isize;
}
extern "C" {
    pub fn ngx_create_temp_file(
        file: *mut ngx_file_t,
        path: *mut ngx_path_t,
        pool: *mut ngx_pool_t,
        persistent: ngx_uint_t,
        clean: ngx_uint_t,
        access: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_hashed_filename(path: *mut ngx_path_t, file: *mut u_char, len: usize);
}
extern "C" {
    pub fn ngx_create_path(file: *mut ngx_file_t, path: *mut ngx_path_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_full_path(dir: *mut u_char, access: ngx_uint_t) -> ngx_err_t;
}
extern "C" {
    pub fn ngx_add_path(cf: *mut ngx_conf_t, slot: *mut *mut ngx_path_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_create_paths(cycle: *mut ngx_cycle_t, user: ngx_uid_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ext_rename_file(src: *mut ngx_str_t, to: *mut ngx_str_t, ext: *mut ngx_ext_rename_file_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_copy_file(from: *mut u_char, to: *mut u_char, cf: *mut ngx_copy_file_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_walk_tree(ctx: *mut ngx_tree_ctx_t, tree: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_next_temp_number(collision: ngx_uint_t) -> ngx_atomic_uint_t;
}
extern "C" {
    pub fn ngx_conf_set_path_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_merge_path_value(
        cf: *mut ngx_conf_t,
        path: *mut *mut ngx_path_t,
        prev: *mut ngx_path_t,
        init: *mut ngx_path_init_t,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_access_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_temp_number: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_random_number: ngx_atomic_int_t;
}
extern "C" {
    pub static mut ngx_crc32_table_short: *mut u32;
}
extern "C" {
    pub static mut ngx_crc32_table256: [u32; 0usize];
}
extern "C" {
    pub fn ngx_crc32_table_init() -> ngx_int_t;
}
extern "C" {
    pub fn ngx_murmur_hash2(data: *mut u_char, len: usize) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre {
    _unused: [u8; 0],
}
pub type pcre = real_pcre;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre16 {
    _unused: [u8; 0],
}
pub type pcre16 = real_pcre16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre32 {
    _unused: [u8; 0],
}
pub type pcre32 = real_pcre32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre_jit_stack {
    _unused: [u8; 0],
}
pub type pcre_jit_stack = real_pcre_jit_stack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre16_jit_stack {
    _unused: [u8; 0],
}
pub type pcre16_jit_stack = real_pcre16_jit_stack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_pcre32_jit_stack {
    _unused: [u8; 0],
}
pub type pcre32_jit_stack = real_pcre32_jit_stack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre_extra {
    pub flags: ::aya_ebpf::cty::c_ulong,
    pub study_data: *mut ::aya_ebpf::cty::c_void,
    pub match_limit: ::aya_ebpf::cty::c_ulong,
    pub callout_data: *mut ::aya_ebpf::cty::c_void,
    pub tables: *const ::aya_ebpf::cty::c_uchar,
    pub match_limit_recursion: ::aya_ebpf::cty::c_ulong,
    pub mark: *mut *mut ::aya_ebpf::cty::c_uchar,
    pub executable_jit: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre16_extra {
    pub flags: ::aya_ebpf::cty::c_ulong,
    pub study_data: *mut ::aya_ebpf::cty::c_void,
    pub match_limit: ::aya_ebpf::cty::c_ulong,
    pub callout_data: *mut ::aya_ebpf::cty::c_void,
    pub tables: *const ::aya_ebpf::cty::c_uchar,
    pub match_limit_recursion: ::aya_ebpf::cty::c_ulong,
    pub mark: *mut *mut ::aya_ebpf::cty::c_ushort,
    pub executable_jit: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre32_extra {
    pub flags: ::aya_ebpf::cty::c_ulong,
    pub study_data: *mut ::aya_ebpf::cty::c_void,
    pub match_limit: ::aya_ebpf::cty::c_ulong,
    pub callout_data: *mut ::aya_ebpf::cty::c_void,
    pub tables: *const ::aya_ebpf::cty::c_uchar,
    pub match_limit_recursion: ::aya_ebpf::cty::c_ulong,
    pub mark: *mut *mut ::aya_ebpf::cty::c_uint,
    pub executable_jit: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre_callout_block {
    pub version: ::aya_ebpf::cty::c_int,
    pub callout_number: ::aya_ebpf::cty::c_int,
    pub offset_vector: *mut ::aya_ebpf::cty::c_int,
    pub subject: *const ::aya_ebpf::cty::c_char,
    pub subject_length: ::aya_ebpf::cty::c_int,
    pub start_match: ::aya_ebpf::cty::c_int,
    pub current_position: ::aya_ebpf::cty::c_int,
    pub capture_top: ::aya_ebpf::cty::c_int,
    pub capture_last: ::aya_ebpf::cty::c_int,
    pub callout_data: *mut ::aya_ebpf::cty::c_void,
    pub pattern_position: ::aya_ebpf::cty::c_int,
    pub next_item_length: ::aya_ebpf::cty::c_int,
    pub mark: *const ::aya_ebpf::cty::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre16_callout_block {
    pub version: ::aya_ebpf::cty::c_int,
    pub callout_number: ::aya_ebpf::cty::c_int,
    pub offset_vector: *mut ::aya_ebpf::cty::c_int,
    pub subject: *const ::aya_ebpf::cty::c_ushort,
    pub subject_length: ::aya_ebpf::cty::c_int,
    pub start_match: ::aya_ebpf::cty::c_int,
    pub current_position: ::aya_ebpf::cty::c_int,
    pub capture_top: ::aya_ebpf::cty::c_int,
    pub capture_last: ::aya_ebpf::cty::c_int,
    pub callout_data: *mut ::aya_ebpf::cty::c_void,
    pub pattern_position: ::aya_ebpf::cty::c_int,
    pub next_item_length: ::aya_ebpf::cty::c_int,
    pub mark: *const ::aya_ebpf::cty::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcre32_callout_block {
    pub version: ::aya_ebpf::cty::c_int,
    pub callout_number: ::aya_ebpf::cty::c_int,
    pub offset_vector: *mut ::aya_ebpf::cty::c_int,
    pub subject: *const ::aya_ebpf::cty::c_uint,
    pub subject_length: ::aya_ebpf::cty::c_int,
    pub start_match: ::aya_ebpf::cty::c_int,
    pub current_position: ::aya_ebpf::cty::c_int,
    pub capture_top: ::aya_ebpf::cty::c_int,
    pub capture_last: ::aya_ebpf::cty::c_int,
    pub callout_data: *mut ::aya_ebpf::cty::c_void,
    pub pattern_position: ::aya_ebpf::cty::c_int,
    pub next_item_length: ::aya_ebpf::cty::c_int,
    pub mark: *const ::aya_ebpf::cty::c_uint,
}
extern "C" {
    pub static mut pcre_malloc: ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::aya_ebpf::cty::c_void>;
}
extern "C" {
    pub static mut pcre_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub static mut pcre_stack_malloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::aya_ebpf::cty::c_void>;
}
extern "C" {
    pub static mut pcre_stack_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub static mut pcre_callout:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pcre_callout_block) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub static mut pcre_stack_guard: ::core::option::Option<unsafe extern "C" fn() -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub static mut pcre16_malloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::aya_ebpf::cty::c_void>;
}
extern "C" {
    pub static mut pcre16_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub static mut pcre16_stack_malloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::aya_ebpf::cty::c_void>;
}
extern "C" {
    pub static mut pcre16_stack_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub static mut pcre16_callout:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pcre16_callout_block) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub static mut pcre16_stack_guard: ::core::option::Option<unsafe extern "C" fn() -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub static mut pcre32_malloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::aya_ebpf::cty::c_void>;
}
extern "C" {
    pub static mut pcre32_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub static mut pcre32_stack_malloc:
        ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::aya_ebpf::cty::c_void>;
}
extern "C" {
    pub static mut pcre32_stack_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub static mut pcre32_callout:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pcre32_callout_block) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub static mut pcre32_stack_guard: ::core::option::Option<unsafe extern "C" fn() -> ::aya_ebpf::cty::c_int>;
}
pub type pcre_jit_callback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> *mut pcre_jit_stack>;
pub type pcre16_jit_callback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> *mut pcre16_jit_stack>;
pub type pcre32_jit_callback =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> *mut pcre32_jit_stack>;
extern "C" {
    pub fn pcre_compile(
        arg1: *const ::aya_ebpf::cty::c_char,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut *const ::aya_ebpf::cty::c_char,
        arg4: *mut ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_uchar,
    ) -> *mut pcre;
}
extern "C" {
    pub fn pcre16_compile(
        arg1: *const ::aya_ebpf::cty::c_ushort,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut *const ::aya_ebpf::cty::c_char,
        arg4: *mut ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_uchar,
    ) -> *mut pcre16;
}
extern "C" {
    pub fn pcre32_compile(
        arg1: *const ::aya_ebpf::cty::c_uint,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut *const ::aya_ebpf::cty::c_char,
        arg4: *mut ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_uchar,
    ) -> *mut pcre32;
}
extern "C" {
    pub fn pcre_compile2(
        arg1: *const ::aya_ebpf::cty::c_char,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: *mut *const ::aya_ebpf::cty::c_char,
        arg5: *mut ::aya_ebpf::cty::c_int,
        arg6: *const ::aya_ebpf::cty::c_uchar,
    ) -> *mut pcre;
}
extern "C" {
    pub fn pcre16_compile2(
        arg1: *const ::aya_ebpf::cty::c_ushort,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: *mut *const ::aya_ebpf::cty::c_char,
        arg5: *mut ::aya_ebpf::cty::c_int,
        arg6: *const ::aya_ebpf::cty::c_uchar,
    ) -> *mut pcre16;
}
extern "C" {
    pub fn pcre32_compile2(
        arg1: *const ::aya_ebpf::cty::c_uint,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: *mut *const ::aya_ebpf::cty::c_char,
        arg5: *mut ::aya_ebpf::cty::c_int,
        arg6: *const ::aya_ebpf::cty::c_uchar,
    ) -> *mut pcre32;
}
extern "C" {
    pub fn pcre_config(arg1: ::aya_ebpf::cty::c_int, arg2: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_config(arg1: ::aya_ebpf::cty::c_int, arg2: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_config(arg1: ::aya_ebpf::cty::c_int, arg2: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_copy_named_substring(
        arg1: *const pcre,
        arg2: *const ::aya_ebpf::cty::c_char,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_char,
        arg6: *mut ::aya_ebpf::cty::c_char,
        arg7: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_copy_named_substring(
        arg1: *const pcre16,
        arg2: *const ::aya_ebpf::cty::c_ushort,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_ushort,
        arg6: *mut ::aya_ebpf::cty::c_ushort,
        arg7: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_copy_named_substring(
        arg1: *const pcre32,
        arg2: *const ::aya_ebpf::cty::c_uint,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_uint,
        arg6: *mut ::aya_ebpf::cty::c_uint,
        arg7: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_copy_substring(
        arg1: *const ::aya_ebpf::cty::c_char,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *mut ::aya_ebpf::cty::c_char,
        arg6: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_copy_substring(
        arg1: *const ::aya_ebpf::cty::c_ushort,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *mut ::aya_ebpf::cty::c_ushort,
        arg6: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_copy_substring(
        arg1: *const ::aya_ebpf::cty::c_uint,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *mut ::aya_ebpf::cty::c_uint,
        arg6: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_dfa_exec(
        arg1: *const pcre,
        arg2: *const pcre_extra,
        arg3: *const ::aya_ebpf::cty::c_char,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
        arg9: *mut ::aya_ebpf::cty::c_int,
        arg10: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_dfa_exec(
        arg1: *const pcre16,
        arg2: *const pcre16_extra,
        arg3: *const ::aya_ebpf::cty::c_ushort,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
        arg9: *mut ::aya_ebpf::cty::c_int,
        arg10: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_dfa_exec(
        arg1: *const pcre32,
        arg2: *const pcre32_extra,
        arg3: *const ::aya_ebpf::cty::c_uint,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
        arg9: *mut ::aya_ebpf::cty::c_int,
        arg10: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_exec(
        arg1: *const pcre,
        arg2: *const pcre_extra,
        arg3: *const ::aya_ebpf::cty::c_char,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_exec(
        arg1: *const pcre16,
        arg2: *const pcre16_extra,
        arg3: *const ::aya_ebpf::cty::c_ushort,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_exec(
        arg1: *const pcre32,
        arg2: *const pcre32_extra,
        arg3: *const ::aya_ebpf::cty::c_uint,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_jit_exec(
        arg1: *const pcre,
        arg2: *const pcre_extra,
        arg3: *const ::aya_ebpf::cty::c_char,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
        arg9: *mut pcre_jit_stack,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_jit_exec(
        arg1: *const pcre16,
        arg2: *const pcre16_extra,
        arg3: *const ::aya_ebpf::cty::c_ushort,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
        arg9: *mut pcre16_jit_stack,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_jit_exec(
        arg1: *const pcre32,
        arg2: *const pcre32_extra,
        arg3: *const ::aya_ebpf::cty::c_uint,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
        arg6: ::aya_ebpf::cty::c_int,
        arg7: *mut ::aya_ebpf::cty::c_int,
        arg8: ::aya_ebpf::cty::c_int,
        arg9: *mut pcre32_jit_stack,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_free_substring(arg1: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn pcre16_free_substring(arg1: *const ::aya_ebpf::cty::c_ushort);
}
extern "C" {
    pub fn pcre32_free_substring(arg1: *const ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn pcre_free_substring_list(arg1: *mut *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn pcre16_free_substring_list(arg1: *mut *const ::aya_ebpf::cty::c_ushort);
}
extern "C" {
    pub fn pcre32_free_substring_list(arg1: *mut *const ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn pcre_fullinfo(
        arg1: *const pcre,
        arg2: *const pcre_extra,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_fullinfo(
        arg1: *const pcre16,
        arg2: *const pcre16_extra,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_fullinfo(
        arg1: *const pcre32,
        arg2: *const pcre32_extra,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_get_named_substring(
        arg1: *const pcre,
        arg2: *const ::aya_ebpf::cty::c_char,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_char,
        arg6: *mut *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_get_named_substring(
        arg1: *const pcre16,
        arg2: *const ::aya_ebpf::cty::c_ushort,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_ushort,
        arg6: *mut *const ::aya_ebpf::cty::c_ushort,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_get_named_substring(
        arg1: *const pcre32,
        arg2: *const ::aya_ebpf::cty::c_uint,
        arg3: *mut ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *const ::aya_ebpf::cty::c_uint,
        arg6: *mut *const ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_get_stringnumber(arg1: *const pcre, arg2: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_get_stringnumber(arg1: *const pcre16, arg2: *const ::aya_ebpf::cty::c_ushort)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_get_stringnumber(arg1: *const pcre32, arg2: *const ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_get_stringtable_entries(
        arg1: *const pcre,
        arg2: *const ::aya_ebpf::cty::c_char,
        arg3: *mut *mut ::aya_ebpf::cty::c_char,
        arg4: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_get_stringtable_entries(
        arg1: *const pcre16,
        arg2: *const ::aya_ebpf::cty::c_ushort,
        arg3: *mut *mut ::aya_ebpf::cty::c_ushort,
        arg4: *mut *mut ::aya_ebpf::cty::c_ushort,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_get_stringtable_entries(
        arg1: *const pcre32,
        arg2: *const ::aya_ebpf::cty::c_uint,
        arg3: *mut *mut ::aya_ebpf::cty::c_uint,
        arg4: *mut *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_get_substring(
        arg1: *const ::aya_ebpf::cty::c_char,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *mut *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_get_substring(
        arg1: *const ::aya_ebpf::cty::c_ushort,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *mut *const ::aya_ebpf::cty::c_ushort,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_get_substring(
        arg1: *const ::aya_ebpf::cty::c_uint,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
        arg5: *mut *const ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_get_substring_list(
        arg1: *const ::aya_ebpf::cty::c_char,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut *mut *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_get_substring_list(
        arg1: *const ::aya_ebpf::cty::c_ushort,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut *mut *const ::aya_ebpf::cty::c_ushort,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_get_substring_list(
        arg1: *const ::aya_ebpf::cty::c_uint,
        arg2: *mut ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut *mut *const ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_maketables() -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn pcre16_maketables() -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn pcre32_maketables() -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn pcre_refcount(arg1: *mut pcre, arg2: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_refcount(arg1: *mut pcre16, arg2: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_refcount(arg1: *mut pcre32, arg2: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_study(
        arg1: *const pcre,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut *const ::aya_ebpf::cty::c_char,
    ) -> *mut pcre_extra;
}
extern "C" {
    pub fn pcre16_study(
        arg1: *const pcre16,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut *const ::aya_ebpf::cty::c_char,
    ) -> *mut pcre16_extra;
}
extern "C" {
    pub fn pcre32_study(
        arg1: *const pcre32,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: *mut *const ::aya_ebpf::cty::c_char,
    ) -> *mut pcre32_extra;
}
extern "C" {
    pub fn pcre_free_study(arg1: *mut pcre_extra);
}
extern "C" {
    pub fn pcre16_free_study(arg1: *mut pcre16_extra);
}
extern "C" {
    pub fn pcre32_free_study(arg1: *mut pcre32_extra);
}
extern "C" {
    pub fn pcre_version() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn pcre16_version() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn pcre32_version() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn pcre_pattern_to_host_byte_order(
        arg1: *mut pcre,
        arg2: *mut pcre_extra,
        arg3: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_pattern_to_host_byte_order(
        arg1: *mut pcre16,
        arg2: *mut pcre16_extra,
        arg3: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_pattern_to_host_byte_order(
        arg1: *mut pcre32,
        arg2: *mut pcre32_extra,
        arg3: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre16_utf16_to_host_byte_order(
        arg1: *mut ::aya_ebpf::cty::c_ushort,
        arg2: *const ::aya_ebpf::cty::c_ushort,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre32_utf32_to_host_byte_order(
        arg1: *mut ::aya_ebpf::cty::c_uint,
        arg2: *const ::aya_ebpf::cty::c_uint,
        arg3: ::aya_ebpf::cty::c_int,
        arg4: *mut ::aya_ebpf::cty::c_int,
        arg5: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn pcre_jit_stack_alloc(arg1: ::aya_ebpf::cty::c_int, arg2: ::aya_ebpf::cty::c_int) -> *mut pcre_jit_stack;
}
extern "C" {
    pub fn pcre16_jit_stack_alloc(arg1: ::aya_ebpf::cty::c_int, arg2: ::aya_ebpf::cty::c_int) -> *mut pcre16_jit_stack;
}
extern "C" {
    pub fn pcre32_jit_stack_alloc(arg1: ::aya_ebpf::cty::c_int, arg2: ::aya_ebpf::cty::c_int) -> *mut pcre32_jit_stack;
}
extern "C" {
    pub fn pcre_jit_stack_free(arg1: *mut pcre_jit_stack);
}
extern "C" {
    pub fn pcre16_jit_stack_free(arg1: *mut pcre16_jit_stack);
}
extern "C" {
    pub fn pcre32_jit_stack_free(arg1: *mut pcre32_jit_stack);
}
extern "C" {
    pub fn pcre_assign_jit_stack(arg1: *mut pcre_extra, arg2: pcre_jit_callback, arg3: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn pcre16_assign_jit_stack(
        arg1: *mut pcre16_extra,
        arg2: pcre16_jit_callback,
        arg3: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn pcre32_assign_jit_stack(
        arg1: *mut pcre32_extra,
        arg2: pcre32_jit_callback,
        arg3: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn pcre_jit_free_unused_memory();
}
extern "C" {
    pub fn pcre16_jit_free_unused_memory();
}
extern "C" {
    pub fn pcre32_jit_free_unused_memory();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_t {
    pub code: *mut pcre,
    pub extra: *mut pcre_extra,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_compile_t {
    pub pattern: ngx_str_t,
    pub pool: *mut ngx_pool_t,
    pub options: ngx_int_t,
    pub regex: *mut ngx_regex_t,
    pub captures: ::aya_ebpf::cty::c_int,
    pub named_captures: ::aya_ebpf::cty::c_int,
    pub name_size: ::aya_ebpf::cty::c_int,
    pub names: *mut u_char,
    pub err: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_regex_elt_t {
    pub regex: *mut ngx_regex_t,
    pub name: *mut u_char,
}
extern "C" {
    pub fn ngx_regex_init();
}
extern "C" {
    pub fn ngx_regex_compile(rc: *mut ngx_regex_compile_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_regex_exec_array(a: *mut ngx_array_t, s: *mut ngx_str_t, log: *mut ngx_log_t) -> ngx_int_t;
}
pub type ngx_radix_node_t = ngx_radix_node_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_radix_node_s {
    pub right: *mut ngx_radix_node_t,
    pub left: *mut ngx_radix_node_t,
    pub parent: *mut ngx_radix_node_t,
    pub value: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_radix_tree_t {
    pub root: *mut ngx_radix_node_t,
    pub pool: *mut ngx_pool_t,
    pub free: *mut ngx_radix_node_t,
    pub start: *mut ::aya_ebpf::cty::c_char,
    pub size: usize,
}
extern "C" {
    pub fn ngx_radix_tree_create(pool: *mut ngx_pool_t, preallocate: ngx_int_t) -> *mut ngx_radix_tree_t;
}
extern "C" {
    pub fn ngx_radix32tree_insert(tree: *mut ngx_radix_tree_t, key: u32, mask: u32, value: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix32tree_delete(tree: *mut ngx_radix_tree_t, key: u32, mask: u32) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix32tree_find(tree: *mut ngx_radix_tree_t, key: u32) -> usize;
}
extern "C" {
    pub fn ngx_radix128tree_insert(
        tree: *mut ngx_radix_tree_t,
        key: *mut u_char,
        mask: *mut u_char,
        value: usize,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix128tree_delete(tree: *mut ngx_radix_tree_t, key: *mut u_char, mask: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_radix128tree_find(tree: *mut ngx_radix_tree_t, key: *mut u_char) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_time_t {
    pub sec: time_t,
    pub msec: ngx_uint_t,
    pub gmtoff: ngx_int_t,
}
extern "C" {
    pub fn ngx_time_init();
}
extern "C" {
    pub fn ngx_time_update();
}
extern "C" {
    pub fn ngx_time_sigsafe_update();
}
extern "C" {
    pub fn ngx_http_time(buf: *mut u_char, t: time_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_cookie_time(buf: *mut u_char, t: time_t) -> *mut u_char;
}
extern "C" {
    pub fn ngx_gmtime(t: time_t, tp: *mut ngx_tm_t);
}
extern "C" {
    pub fn ngx_next_time(when: time_t) -> time_t;
}
extern "C" {
    pub static mut ngx_cached_time: *mut ngx_time_t;
}
extern "C" {
    pub static mut ngx_cached_err_log_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_log_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_http_log_iso8601: ngx_str_t;
}
extern "C" {
    pub static mut ngx_cached_syslog_time: ngx_str_t;
}
extern "C" {
    pub static mut ngx_current_msec: ngx_msec_t;
}
extern "C" {
    pub fn ngx_rwlock_wlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_rlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_unlock(lock: *mut ngx_atomic_t);
}
extern "C" {
    pub fn ngx_rwlock_downgrade(lock: *mut ngx_atomic_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_shmtx_sh_t {
    pub lock: ngx_atomic_t,
    pub wait: ngx_atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_shmtx_t {
    pub lock: *mut ngx_atomic_t,
    pub wait: *mut ngx_atomic_t,
    pub semaphore: ngx_uint_t,
    pub sem: sem_t,
    pub spin: ngx_uint_t,
}
extern "C" {
    pub fn ngx_shmtx_create(mtx: *mut ngx_shmtx_t, addr: *mut ngx_shmtx_sh_t, name: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_shmtx_destroy(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_trylock(mtx: *mut ngx_shmtx_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_shmtx_lock(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_unlock(mtx: *mut ngx_shmtx_t);
}
extern "C" {
    pub fn ngx_shmtx_force_unlock(mtx: *mut ngx_shmtx_t, pid: ngx_pid_t) -> ngx_uint_t;
}
pub type ngx_slab_page_t = ngx_slab_page_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_slab_page_s {
    pub slab: usize,
    pub next: *mut ngx_slab_page_t,
    pub prev: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_slab_stat_t {
    pub total: ngx_uint_t,
    pub used: ngx_uint_t,
    pub reqs: ngx_uint_t,
    pub fails: ngx_uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_slab_pool_t {
    pub lock: ngx_shmtx_sh_t,
    pub min_size: usize,
    pub min_shift: usize,
    pub pages: *mut ngx_slab_page_t,
    pub last: *mut ngx_slab_page_t,
    pub free: ngx_slab_page_t,
    pub stats: *mut ngx_slab_stat_t,
    pub pfree: ngx_uint_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
    pub mutex: ngx_shmtx_t,
    pub log_ctx: *mut u_char,
    pub zero: u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub addr: *mut ::aya_ebpf::cty::c_void,
}
impl ngx_slab_pool_t {
    #[inline]
    pub fn log_nomem(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log_nomem(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(log_nomem: ::aya_ebpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let log_nomem: u32 = unsafe { ::core::mem::transmute(log_nomem) };
            log_nomem as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_slab_sizes_init();
}
extern "C" {
    pub fn ngx_slab_init(pool: *mut ngx_slab_pool_t);
}
extern "C" {
    pub fn ngx_slab_alloc(pool: *mut ngx_slab_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_alloc_locked(pool: *mut ngx_slab_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_calloc(pool: *mut ngx_slab_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_calloc_locked(pool: *mut ngx_slab_pool_t, size: usize) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_slab_free(pool: *mut ngx_slab_pool_t, p: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn ngx_slab_free_locked(pool: *mut ngx_slab_pool_t, p: *mut ::aya_ebpf::cty::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_sockaddr_t {
    pub sockaddr: sockaddr,
    pub sockaddr_in: sockaddr_in,
    pub sockaddr_in6: sockaddr_in6,
    pub sockaddr_un: sockaddr_un,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_in_cidr_t {
    pub addr: in_addr_t,
    pub mask: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_in6_cidr_t {
    pub addr: in6_addr,
    pub mask: in6_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_cidr_t {
    pub family: ngx_uint_t,
    pub u: ngx_cidr_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_cidr_t__bindgen_ty_1 {
    pub in_: ngx_in_cidr_t,
    pub in6: ngx_in6_cidr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_addr_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_url_t {
    pub url: ngx_str_t,
    pub host: ngx_str_t,
    pub port_text: ngx_str_t,
    pub uri: ngx_str_t,
    pub port: in_port_t,
    pub default_port: in_port_t,
    pub last_port: in_port_t,
    pub family: ::aya_ebpf::cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub socklen: socklen_t,
    pub sockaddr: ngx_sockaddr_t,
    pub addrs: *mut ngx_addr_t,
    pub naddrs: ngx_uint_t,
    pub err: *mut ::aya_ebpf::cty::c_char,
}
impl ngx_url_t {
    #[inline]
    pub fn listen(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_part(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri_part(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_resolve(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_resolve(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_port(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_port(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        listen: ::aya_ebpf::cty::c_uint,
        uri_part: ::aya_ebpf::cty::c_uint,
        no_resolve: ::aya_ebpf::cty::c_uint,
        no_port: ::aya_ebpf::cty::c_uint,
        wildcard: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let listen: u32 = unsafe { ::core::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let uri_part: u32 = unsafe { ::core::mem::transmute(uri_part) };
            uri_part as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_resolve: u32 = unsafe { ::core::mem::transmute(no_resolve) };
            no_resolve as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_port: u32 = unsafe { ::core::mem::transmute(no_port) };
            no_port as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wildcard: u32 = unsafe { ::core::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_inet_addr(text: *mut u_char, len: usize) -> in_addr_t;
}
extern "C" {
    pub fn ngx_inet6_addr(p: *mut u_char, len: usize, addr: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet6_ntop(p: *mut u_char, text: *mut u_char, len: usize) -> usize;
}
extern "C" {
    pub fn ngx_sock_ntop(
        sa: *mut sockaddr,
        socklen: socklen_t,
        text: *mut u_char,
        len: usize,
        port: ngx_uint_t,
    ) -> usize;
}
extern "C" {
    pub fn ngx_inet_ntop(
        family: ::aya_ebpf::cty::c_int,
        addr: *mut ::aya_ebpf::cty::c_void,
        text: *mut u_char,
        len: usize,
    ) -> usize;
}
extern "C" {
    pub fn ngx_ptocidr(text: *mut ngx_str_t, cidr: *mut ngx_cidr_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cidr_match(sa: *mut sockaddr, cidrs: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_addr(pool: *mut ngx_pool_t, addr: *mut ngx_addr_t, text: *mut u_char, len: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_addr_port(
        pool: *mut ngx_pool_t,
        addr: *mut ngx_addr_t,
        text: *mut u_char,
        len: usize,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_parse_url(pool: *mut ngx_pool_t, u: *mut ngx_url_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet_resolve_host(pool: *mut ngx_pool_t, u: *mut ngx_url_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cmp_sockaddr(
        sa1: *mut sockaddr,
        slen1: socklen_t,
        sa2: *mut sockaddr,
        slen2: socklen_t,
        cmp_port: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_inet_get_port(sa: *mut sockaddr) -> in_port_t;
}
extern "C" {
    pub fn ngx_inet_set_port(sa: *mut sockaddr, port: in_port_t);
}
extern "C" {
    pub fn ngx_inet_wildcard(sa: *mut sockaddr) -> ngx_uint_t;
}
pub type ngx_shm_zone_t = ngx_shm_zone_s;
pub type ngx_shm_zone_init_pt = ::core::option::Option<
    unsafe extern "C" fn(zone: *mut ngx_shm_zone_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t,
>;
pub type ngx_log_intercept_pt = ::core::option::Option<
    unsafe extern "C" fn(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: usize) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_shm_zone_s {
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub shm: ngx_shm_t,
    pub init: ngx_shm_zone_init_pt,
    pub tag: *mut ::aya_ebpf::cty::c_void,
    pub sync: *mut ::aya_ebpf::cty::c_void,
    pub noreuse: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_cycle_s {
    pub conf_ctx: *mut *mut *mut *mut ::aya_ebpf::cty::c_void,
    pub pool: *mut ngx_pool_t,
    pub log: *mut ngx_log_t,
    pub new_log: ngx_log_t,
    pub log_use_stderr: ngx_uint_t,
    pub files: *mut *mut ngx_connection_t,
    pub free_connections: *mut ngx_connection_t,
    pub free_connection_n: ngx_uint_t,
    pub modules: *mut *mut ngx_module_t,
    pub modules_n: ngx_uint_t,
    pub modules_used: ngx_uint_t,
    pub reusable_connections_queue: ngx_queue_t,
    pub reusable_connections_n: ngx_uint_t,
    pub connections_reuse_time: time_t,
    pub listening: ngx_array_t,
    pub paths: ngx_array_t,
    pub config_dump: ngx_array_t,
    pub config_dump_rbtree: ngx_rbtree_t,
    pub config_dump_sentinel: ngx_rbtree_node_t,
    pub open_files: ngx_list_t,
    pub shared_memory: ngx_list_t,
    pub connection_n: ngx_uint_t,
    pub files_n: ngx_uint_t,
    pub connections: *mut ngx_connection_t,
    pub read_events: *mut ngx_event_t,
    pub write_events: *mut ngx_event_t,
    pub old_cycle: *mut ngx_cycle_t,
    pub conf_file: ngx_str_t,
    pub conf_param: ngx_str_t,
    pub conf_prefix: ngx_str_t,
    pub prefix: ngx_str_t,
    pub error_log: ngx_str_t,
    pub lock_file: ngx_str_t,
    pub hostname: ngx_str_t,
    pub intercept_error_log_handler: ngx_log_intercept_pt,
    pub intercept_error_log_data: *mut ::aya_ebpf::cty::c_void,
    pub entered_logger: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_core_conf_t {
    pub daemon: ngx_flag_t,
    pub master: ngx_flag_t,
    pub privileged_agent: ngx_flag_t,
    pub privileged_agent_connections: ngx_uint_t,
    pub timer_resolution: ngx_msec_t,
    pub shutdown_timeout: ngx_msec_t,
    pub worker_processes: ngx_int_t,
    pub debug_points: ngx_int_t,
    pub rlimit_nofile: ngx_int_t,
    pub rlimit_core: off_t,
    pub priority: ::aya_ebpf::cty::c_int,
    pub cpu_affinity_auto: ngx_uint_t,
    pub cpu_affinity_n: ngx_uint_t,
    pub cpu_affinity: *mut ngx_cpuset_t,
    pub username: *mut ::aya_ebpf::cty::c_char,
    pub user: ngx_uid_t,
    pub group: ngx_gid_t,
    pub working_directory: ngx_str_t,
    pub lock_file: ngx_str_t,
    pub pid: ngx_str_t,
    pub oldpid: ngx_str_t,
    pub env: ngx_array_t,
    pub environment: *mut *mut ::aya_ebpf::cty::c_char,
    pub transparent: ngx_uint_t,
}
extern "C" {
    pub fn ngx_init_cycle(old_cycle: *mut ngx_cycle_t) -> *mut ngx_cycle_t;
}
extern "C" {
    pub fn ngx_create_pidfile(name: *mut ngx_str_t, log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_delete_pidfile(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_signal_process(cycle: *mut ngx_cycle_t, sig: *mut ::aya_ebpf::cty::c_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_reopen_files(cycle: *mut ngx_cycle_t, user: ngx_uid_t);
}
extern "C" {
    pub fn ngx_set_environment(cycle: *mut ngx_cycle_t, last: *mut ngx_uint_t) -> *mut *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_exec_new_binary(cycle: *mut ngx_cycle_t, argv: *const *mut ::aya_ebpf::cty::c_char) -> ngx_pid_t;
}
extern "C" {
    pub fn ngx_get_cpu_affinity(n: ngx_uint_t) -> *mut ngx_cpuset_t;
}
extern "C" {
    pub fn ngx_shared_memory_add(
        cf: *mut ngx_conf_t,
        name: *mut ngx_str_t,
        size: usize,
        tag: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ngx_shm_zone_t;
}
extern "C" {
    pub fn ngx_set_shutdown_timer(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_cycle: *mut ngx_cycle_t;
}
extern "C" {
    pub static mut ngx_old_cycles: ngx_array_t;
}
extern "C" {
    pub static mut ngx_core_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_test_config: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_dump_config: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_quiet_mode: ngx_uint_t;
}
pub type ngx_resolver_t = ngx_resolver_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_connection_t {
    pub udp: *mut ngx_connection_t,
    pub tcp: *mut ngx_connection_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub server: ngx_str_t,
    pub log: ngx_log_t,
    pub read_buf: *mut ngx_buf_t,
    pub write_buf: *mut ngx_buf_t,
    pub resolver: *mut ngx_resolver_t,
}
pub type ngx_resolver_ctx_t = ngx_resolver_ctx_s;
pub type ngx_resolver_handler_pt = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ngx_resolver_ctx_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_addr_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_srv_t {
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
    pub port: u_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_srv_name_t {
    pub name: ngx_str_t,
    pub priority: u_short,
    pub weight: u_short,
    pub port: u_short,
    pub ctx: *mut ngx_resolver_ctx_t,
    pub state: ngx_int_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_resolver_node_t {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub name: *mut u_char,
    pub addr6: in6_addr,
    pub nlen: u_short,
    pub qlen: u_short,
    pub query: *mut u_char,
    pub query6: *mut u_char,
    pub u: ngx_resolver_node_t__bindgen_ty_1,
    pub code: u_char,
    pub naddrs: u_short,
    pub nsrvs: u_short,
    pub cnlen: u_short,
    pub u6: ngx_resolver_node_t__bindgen_ty_2,
    pub naddrs6: u_short,
    pub expire: time_t,
    pub valid: time_t,
    pub ttl: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub last_connection: ngx_uint_t,
    pub waiting: *mut ngx_resolver_ctx_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_resolver_node_t__bindgen_ty_1 {
    pub addr: in_addr_t,
    pub addrs: *mut in_addr_t,
    pub cname: *mut u_char,
    pub srvs: *mut ngx_resolver_srv_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_resolver_node_t__bindgen_ty_2 {
    pub addr6: in6_addr,
    pub addrs6: *mut in6_addr,
}
impl ngx_resolver_node_t {
    #[inline]
    pub fn tcp(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp6(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp6(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcp: ::aya_ebpf::cty::c_uint,
        tcp6: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tcp: u32 = unsafe { ::core::mem::transmute(tcp) };
            tcp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tcp6: u32 = unsafe { ::core::mem::transmute(tcp6) };
            tcp6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_s {
    pub event: *mut ngx_event_t,
    pub dummy: *mut ::aya_ebpf::cty::c_void,
    pub log: *mut ngx_log_t,
    pub ident: ngx_int_t,
    pub connections: ngx_array_t,
    pub last_connection: ngx_uint_t,
    pub name_rbtree: ngx_rbtree_t,
    pub name_sentinel: ngx_rbtree_node_t,
    pub srv_rbtree: ngx_rbtree_t,
    pub srv_sentinel: ngx_rbtree_node_t,
    pub addr_rbtree: ngx_rbtree_t,
    pub addr_sentinel: ngx_rbtree_node_t,
    pub name_resend_queue: ngx_queue_t,
    pub srv_resend_queue: ngx_queue_t,
    pub addr_resend_queue: ngx_queue_t,
    pub name_expire_queue: ngx_queue_t,
    pub srv_expire_queue: ngx_queue_t,
    pub addr_expire_queue: ngx_queue_t,
    pub ipv6: ngx_uint_t,
    pub addr6_rbtree: ngx_rbtree_t,
    pub addr6_sentinel: ngx_rbtree_node_t,
    pub addr6_resend_queue: ngx_queue_t,
    pub addr6_expire_queue: ngx_queue_t,
    pub resend_timeout: time_t,
    pub tcp_timeout: time_t,
    pub expire: time_t,
    pub valid: time_t,
    pub log_level: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_resolver_ctx_s {
    pub next: *mut ngx_resolver_ctx_t,
    pub resolver: *mut ngx_resolver_t,
    pub node: *mut ngx_resolver_node_t,
    pub ident: ngx_int_t,
    pub state: ngx_int_t,
    pub name: ngx_str_t,
    pub service: ngx_str_t,
    pub valid: time_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_resolver_addr_t,
    pub addr: ngx_resolver_addr_t,
    pub sin: sockaddr_in,
    pub count: ngx_uint_t,
    pub nsrvs: ngx_uint_t,
    pub srvs: *mut ngx_resolver_srv_name_t,
    pub handler: ngx_resolver_handler_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub timeout: ngx_msec_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub recursion: ngx_uint_t,
    pub event: *mut ngx_event_t,
}
impl ngx_resolver_ctx_s {
    #[inline]
    pub fn quick(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quick(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancelable(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancelable(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        quick: ::aya_ebpf::cty::c_uint,
        async_: ::aya_ebpf::cty::c_uint,
        cancelable: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let quick: u32 = unsafe { ::core::mem::transmute(quick) };
            quick as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_: u32 = unsafe { ::core::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let cancelable: u32 = unsafe { ::core::mem::transmute(cancelable) };
            cancelable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_resolver_create(cf: *mut ngx_conf_t, names: *mut ngx_str_t, n: ngx_uint_t) -> *mut ngx_resolver_t;
}
extern "C" {
    pub fn ngx_resolve_start(r: *mut ngx_resolver_t, temp: *mut ngx_resolver_ctx_t) -> *mut ngx_resolver_ctx_t;
}
extern "C" {
    pub fn ngx_resolve_name(ctx: *mut ngx_resolver_ctx_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_resolve_name_done(ctx: *mut ngx_resolver_ctx_t);
}
extern "C" {
    pub fn ngx_resolve_addr(ctx: *mut ngx_resolver_ctx_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_resolve_addr_done(ctx: *mut ngx_resolver_ctx_t);
}
extern "C" {
    pub fn ngx_resolver_strerror(err: ngx_int_t) -> *mut ::aya_ebpf::cty::c_char;
}
pub type __gwchar_t = ::aya_ebpf::cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::aya_ebpf::cty::c_long,
    pub rem: ::aya_ebpf::cty::c_long,
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::aya_ebpf::cty::c_char,
        __endptr: *mut *mut ::aya_ebpf::cty::c_char,
        __base: ::aya_ebpf::cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::aya_ebpf::cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::aya_ebpf::cty::c_int,
    ) -> uintmax_t;
}
pub type ossl_intmax_t = intmax_t;
pub type ossl_uintmax_t = uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st {
    _unused: [u8; 0],
}
pub type OPENSSL_STACK = stack_st;
pub type OPENSSL_sk_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_ebpf::cty::c_void,
        arg2: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OPENSSL_sk_freefunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
pub type OPENSSL_sk_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
extern "C" {
    pub fn OPENSSL_sk_num(arg1: *const OPENSSL_STACK) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_value(arg1: *const OPENSSL_STACK, arg2: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_set(
        st: *mut OPENSSL_STACK,
        i: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_new(cmp: OPENSSL_sk_compfunc) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_null() -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_reserve(c: OPENSSL_sk_compfunc, n: ::aya_ebpf::cty::c_int) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_reserve(st: *mut OPENSSL_STACK, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_free(arg1: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_pop_free(
        st: *mut OPENSSL_STACK,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    );
}
extern "C" {
    pub fn OPENSSL_sk_deep_copy(
        arg1: *const OPENSSL_STACK,
        c: OPENSSL_sk_copyfunc,
        f: OPENSSL_sk_freefunc,
    ) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_insert(
        sk: *mut OPENSSL_STACK,
        data: *const ::aya_ebpf::cty::c_void,
        where_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_delete(st: *mut OPENSSL_STACK, loc: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_delete_ptr(
        st: *mut OPENSSL_STACK,
        p: *const ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_find(st: *mut OPENSSL_STACK, data: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_find_ex(st: *mut OPENSSL_STACK, data: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_find_all(
        st: *mut OPENSSL_STACK,
        data: *const ::aya_ebpf::cty::c_void,
        pnum: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_push(st: *mut OPENSSL_STACK, data: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_unshift(st: *mut OPENSSL_STACK, data: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_shift(st: *mut OPENSSL_STACK) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_pop(st: *mut OPENSSL_STACK) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_zero(st: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_set_cmp_func(sk: *mut OPENSSL_STACK, cmp: OPENSSL_sk_compfunc) -> OPENSSL_sk_compfunc;
}
extern "C" {
    pub fn OPENSSL_sk_dup(st: *const OPENSSL_STACK) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_sort(st: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_is_sorted(st: *const OPENSSL_STACK) -> ::aya_ebpf::cty::c_int;
}
pub type OPENSSL_STRING = *mut ::aya_ebpf::cty::c_char;
pub type OPENSSL_CSTRING = *const ::aya_ebpf::cty::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_STRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::aya_ebpf::cty::c_char,
        b: *const *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OPENSSL_STRING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ::aya_ebpf::cty::c_char)>;
pub type sk_OPENSSL_STRING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_CSTRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_CSTRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::aya_ebpf::cty::c_char,
        b: *const *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OPENSSL_CSTRING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ::aya_ebpf::cty::c_char)>;
pub type sk_OPENSSL_CSTRING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ::aya_ebpf::cty::c_char) -> *mut ::aya_ebpf::cty::c_char>;
pub type OPENSSL_BLOCK = *mut ::aya_ebpf::cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_BLOCK {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_BLOCK_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::aya_ebpf::cty::c_void,
        b: *const *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OPENSSL_BLOCK_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ::aya_ebpf::cty::c_void)>;
pub type sk_OPENSSL_BLOCK_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_provider_st {
    _unused: [u8; 0],
}
pub type OSSL_PROVIDER = ossl_provider_st;
pub type ASN1_INTEGER = asn1_string_st;
pub type ASN1_ENUMERATED = asn1_string_st;
pub type ASN1_BIT_STRING = asn1_string_st;
pub type ASN1_OCTET_STRING = asn1_string_st;
pub type ASN1_PRINTABLESTRING = asn1_string_st;
pub type ASN1_T61STRING = asn1_string_st;
pub type ASN1_IA5STRING = asn1_string_st;
pub type ASN1_GENERALSTRING = asn1_string_st;
pub type ASN1_UNIVERSALSTRING = asn1_string_st;
pub type ASN1_BMPSTRING = asn1_string_st;
pub type ASN1_UTCTIME = asn1_string_st;
pub type ASN1_TIME = asn1_string_st;
pub type ASN1_GENERALIZEDTIME = asn1_string_st;
pub type ASN1_VISIBLESTRING = asn1_string_st;
pub type ASN1_UTF8STRING = asn1_string_st;
pub type ASN1_STRING = asn1_string_st;
pub type ASN1_BOOLEAN = ::aya_ebpf::cty::c_int;
pub type ASN1_NULL = ::aya_ebpf::cty::c_int;
pub type ASN1_TYPE = asn1_type_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_object_st {
    _unused: [u8; 0],
}
pub type ASN1_OBJECT = asn1_object_st;
pub type ASN1_STRING_TABLE = asn1_string_table_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ITEM_st {
    _unused: [u8; 0],
}
pub type ASN1_ITEM = ASN1_ITEM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_pctx_st {
    _unused: [u8; 0],
}
pub type ASN1_PCTX = asn1_pctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_sctx_st {
    _unused: [u8; 0],
}
pub type ASN1_SCTX = asn1_sctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_st {
    _unused: [u8; 0],
}
pub type BIO = bio_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_st {
    _unused: [u8; 0],
}
pub type BIGNUM = bignum_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_ctx {
    _unused: [u8; 0],
}
pub type BN_CTX = bignum_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_blinding_st {
    _unused: [u8; 0],
}
pub type BN_BLINDING = bn_blinding_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_mont_ctx_st {
    _unused: [u8; 0],
}
pub type BN_MONT_CTX = bn_mont_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_recp_ctx_st {
    _unused: [u8; 0],
}
pub type BN_RECP_CTX = bn_recp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_gencb_st {
    _unused: [u8; 0],
}
pub type BN_GENCB = bn_gencb_st;
pub type BUF_MEM = buf_mem_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIGNUM {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIGNUM_const {
    _unused: [u8; 0],
}
pub type ERR_STATE = err_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER = evp_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = evp_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_MD_CTX = evp_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_mac_st {
    _unused: [u8; 0],
}
pub type EVP_MAC = evp_mac_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_mac_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_MAC_CTX = evp_mac_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY = evp_pkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_asn1_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_ASN1_METHOD = evp_pkey_asn1_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_method_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_METHOD = evp_pkey_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_keymgmt_st {
    _unused: [u8; 0],
}
pub type EVP_KEYMGMT = evp_keymgmt_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_kdf_st {
    _unused: [u8; 0],
}
pub type EVP_KDF = evp_kdf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_kdf_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_KDF_CTX = evp_kdf_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_rand_st {
    _unused: [u8; 0],
}
pub type EVP_RAND = evp_rand_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_rand_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_RAND_CTX = evp_rand_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_keyexch_st {
    _unused: [u8; 0],
}
pub type EVP_KEYEXCH = evp_keyexch_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_signature_st {
    _unused: [u8; 0],
}
pub type EVP_SIGNATURE = evp_signature_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_asym_cipher_st {
    _unused: [u8; 0],
}
pub type EVP_ASYM_CIPHER = evp_asym_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_kem_st {
    _unused: [u8; 0],
}
pub type EVP_KEM = evp_kem_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_Encode_Ctx_st {
    _unused: [u8; 0],
}
pub type EVP_ENCODE_CTX = evp_Encode_Ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_ctx_st {
    _unused: [u8; 0],
}
pub type HMAC_CTX = hmac_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    _unused: [u8; 0],
}
pub type DH = dh_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_method {
    _unused: [u8; 0],
}
pub type DH_METHOD = dh_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_st {
    _unused: [u8; 0],
}
pub type DSA = dsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_method {
    _unused: [u8; 0],
}
pub type DSA_METHOD = dsa_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    _unused: [u8; 0],
}
pub type RSA = rsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_meth_st {
    _unused: [u8; 0],
}
pub type RSA_METHOD = rsa_meth_st;
pub type RSA_PSS_PARAMS = rsa_pss_params_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_method_st {
    _unused: [u8; 0],
}
pub type EC_KEY_METHOD = ec_key_method_st;
pub type RAND_METHOD = rand_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_drbg_st {
    _unused: [u8; 0],
}
pub type RAND_DRBG = rand_drbg_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_dane_st {
    _unused: [u8; 0],
}
pub type SSL_DANE = ssl_dane_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_st {
    _unused: [u8; 0],
}
pub type X509 = x509_st;
pub type X509_ALGOR = X509_algor_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_st {
    _unused: [u8; 0],
}
pub type X509_CRL = X509_crl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crl_method_st {
    _unused: [u8; 0],
}
pub type X509_CRL_METHOD = x509_crl_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_revoked_st {
    _unused: [u8; 0],
}
pub type X509_REVOKED = x509_revoked_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_st {
    _unused: [u8; 0],
}
pub type X509_NAME = X509_name_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_pubkey_st {
    _unused: [u8; 0],
}
pub type X509_PUBKEY = X509_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_st {
    _unused: [u8; 0],
}
pub type X509_STORE = x509_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_ctx_st {
    _unused: [u8; 0],
}
pub type X509_STORE_CTX = x509_store_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_object_st {
    _unused: [u8; 0],
}
pub type X509_OBJECT = x509_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP = x509_lookup_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_method_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP_METHOD = x509_lookup_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_VERIFY_PARAM_st {
    _unused: [u8; 0],
}
pub type X509_VERIFY_PARAM = X509_VERIFY_PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_sig_info_st {
    _unused: [u8; 0],
}
pub type X509_SIG_INFO = x509_sig_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs8_priv_key_info_st {
    _unused: [u8; 0],
}
pub type PKCS8_PRIV_KEY_INFO = pkcs8_priv_key_info_st;
pub type X509V3_CTX = v3_ext_ctx;
pub type CONF = conf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_init_settings_st {
    _unused: [u8; 0],
}
pub type OPENSSL_INIT_SETTINGS = ossl_init_settings_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_st {
    _unused: [u8; 0],
}
pub type UI = ui_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_method_st {
    _unused: [u8; 0],
}
pub type UI_METHOD = ui_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub type SSL = ssl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CTX = ssl_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_ctx_st {
    _unused: [u8; 0],
}
pub type COMP_CTX = comp_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct comp_method_st {
    _unused: [u8; 0],
}
pub type COMP_METHOD = comp_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_NODE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_NODE = X509_POLICY_NODE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_LEVEL_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_LEVEL = X509_POLICY_LEVEL_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_TREE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_TREE = X509_POLICY_TREE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_POLICY_CACHE_st {
    _unused: [u8; 0],
}
pub type X509_POLICY_CACHE = X509_POLICY_CACHE_st;
pub type AUTHORITY_KEYID = AUTHORITY_KEYID_st;
pub type DIST_POINT = DIST_POINT_st;
pub type ISSUING_DIST_POINT = ISSUING_DIST_POINT_st;
pub type NAME_CONSTRAINTS = NAME_CONSTRAINTS_st;
pub type CRYPTO_EX_DATA = crypto_ex_data_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_http_req_ctx_st {
    _unused: [u8; 0],
}
pub type OSSL_HTTP_REQ_CTX = ossl_http_req_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPONSE = ocsp_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_responder_id_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPID = ocsp_responder_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sct_st {
    _unused: [u8; 0],
}
pub type SCT = sct_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sct_ctx_st {
    _unused: [u8; 0],
}
pub type SCT_CTX = sct_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlog_st {
    _unused: [u8; 0],
}
pub type CTLOG = ctlog_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlog_store_st {
    _unused: [u8; 0],
}
pub type CTLOG_STORE = ctlog_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ct_policy_eval_ctx_st {
    _unused: [u8; 0],
}
pub type CT_POLICY_EVAL_CTX = ct_policy_eval_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_store_info_st {
    _unused: [u8; 0],
}
pub type OSSL_STORE_INFO = ossl_store_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_store_search_st {
    _unused: [u8; 0],
}
pub type OSSL_STORE_SEARCH = ossl_store_search_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_lib_ctx_st {
    _unused: [u8; 0],
}
pub type OSSL_LIB_CTX = ossl_lib_ctx_st;
pub type OSSL_DISPATCH = ossl_dispatch_st;
pub type OSSL_ITEM = ossl_item_st;
pub type OSSL_ALGORITHM = ossl_algorithm_st;
pub type OSSL_PARAM = ossl_param_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_param_bld_st {
    _unused: [u8; 0],
}
pub type OSSL_PARAM_BLD = ossl_param_bld_st;
pub type pem_password_cb = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
        rwflag: ::aya_ebpf::cty::c_int,
        userdata: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_encoder_st {
    _unused: [u8; 0],
}
pub type OSSL_ENCODER = ossl_encoder_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_encoder_ctx_st {
    _unused: [u8; 0],
}
pub type OSSL_ENCODER_CTX = ossl_encoder_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_decoder_st {
    _unused: [u8; 0],
}
pub type OSSL_DECODER = ossl_decoder_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_decoder_ctx_st {
    _unused: [u8; 0],
}
pub type OSSL_DECODER_CTX = ossl_decoder_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_self_test_st {
    _unused: [u8; 0],
}
pub type OSSL_SELF_TEST = ossl_self_test_st;
extern "C" {
    pub fn ERR_load_ASN1_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_ASYNC_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_BIO_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_BN_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_BUF_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_CMS_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_COMP_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_CONF_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_CRYPTO_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_CT_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_DH_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_DSA_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_EC_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_ENGINE_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_ERR_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_EVP_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_KDF_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_OBJ_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_OCSP_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_PEM_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_PKCS12_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_PKCS7_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_RAND_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_RSA_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_OSSL_STORE_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_TS_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_UI_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_X509_strings() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_X509V3_strings() -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_core_handle_st {
    _unused: [u8; 0],
}
pub type OSSL_CORE_HANDLE = ossl_core_handle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openssl_core_ctx_st {
    _unused: [u8; 0],
}
pub type OPENSSL_CORE_CTX = openssl_core_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_core_bio_st {
    _unused: [u8; 0],
}
pub type OSSL_CORE_BIO = ossl_core_bio_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_dispatch_st {
    pub function_id: ::aya_ebpf::cty::c_int,
    pub function: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_item_st {
    pub id: ::aya_ebpf::cty::c_uint,
    pub ptr: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_algorithm_st {
    pub algorithm_names: *const ::aya_ebpf::cty::c_char,
    pub property_definition: *const ::aya_ebpf::cty::c_char,
    pub implementation: *const OSSL_DISPATCH,
    pub algorithm_description: *const ::aya_ebpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_param_st {
    pub key: *const ::aya_ebpf::cty::c_char,
    pub data_type: ::aya_ebpf::cty::c_uint,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub data_size: usize,
    pub return_size: usize,
}
pub type OSSL_thread_stop_handler_fn = ::core::option::Option<unsafe extern "C" fn(arg: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_provider_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *const OSSL_CORE_HANDLE,
        in_: *const OSSL_DISPATCH,
        out: *mut *const OSSL_DISPATCH,
        provctx: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn OSSL_provider_init(
        handle: *const OSSL_CORE_HANDLE,
        in_: *const OSSL_DISPATCH,
        out: *mut *const OSSL_DISPATCH,
        provctx: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type OSSL_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(params: *const OSSL_PARAM, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_INOUT_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        in_params: *const OSSL_PARAM,
        out_params: *mut OSSL_PARAM,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_PASSPHRASE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        pass: *mut ::aya_ebpf::cty::c_char,
        pass_size: usize,
        pass_len: *mut usize,
        params: *const OSSL_PARAM,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock {
    pub dummy: ::aya_ebpf::cty::c_int,
}
pub type CRYPTO_RWLOCK = ::aya_ebpf::cty::c_void;
extern "C" {
    pub fn CRYPTO_THREAD_lock_new() -> *mut CRYPTO_RWLOCK;
}
extern "C" {
    pub fn CRYPTO_THREAD_read_lock(lock: *mut CRYPTO_RWLOCK) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_write_lock(lock: *mut CRYPTO_RWLOCK) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_unlock(lock: *mut CRYPTO_RWLOCK) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_lock_free(lock: *mut CRYPTO_RWLOCK);
}
extern "C" {
    pub fn CRYPTO_atomic_add(
        val: *mut ::aya_ebpf::cty::c_int,
        amount: ::aya_ebpf::cty::c_int,
        ret: *mut ::aya_ebpf::cty::c_int,
        lock: *mut CRYPTO_RWLOCK,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_atomic_or(val: *mut u64, op: u64, ret: *mut u64, lock: *mut CRYPTO_RWLOCK) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_atomic_load(val: *mut u64, ret: *mut u64, lock: *mut CRYPTO_RWLOCK) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_strlcpy(dst: *mut ::aya_ebpf::cty::c_char, src: *const ::aya_ebpf::cty::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn OPENSSL_strlcat(dst: *mut ::aya_ebpf::cty::c_char, src: *const ::aya_ebpf::cty::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn OPENSSL_strnlen(str_: *const ::aya_ebpf::cty::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn OPENSSL_buf2hexstr_ex(
        str_: *mut ::aya_ebpf::cty::c_char,
        str_n: usize,
        strlength: *mut usize,
        buf: *const ::aya_ebpf::cty::c_uchar,
        buflen: usize,
        sep: ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_buf2hexstr(
        buf: *const ::aya_ebpf::cty::c_uchar,
        buflen: ::aya_ebpf::cty::c_long,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_hexstr2buf_ex(
        buf: *mut ::aya_ebpf::cty::c_uchar,
        buf_n: usize,
        buflen: *mut usize,
        str_: *const ::aya_ebpf::cty::c_char,
        sep: ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_hexstr2buf(
        str_: *const ::aya_ebpf::cty::c_char,
        buflen: *mut ::aya_ebpf::cty::c_long,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn OPENSSL_hexchar2int(c: ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_strcasecmp(
        s1: *const ::aya_ebpf::cty::c_char,
        s2: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_strncasecmp(
        s1: *const ::aya_ebpf::cty::c_char,
        s2: *const ::aya_ebpf::cty::c_char,
        n: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_version_major() -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn OPENSSL_version_minor() -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn OPENSSL_version_patch() -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn OPENSSL_version_pre_release() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_version_build_metadata() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OpenSSL_version_num() -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn OpenSSL_version(type_: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_info(type_: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_issetugid() -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_st {
    pub ctx: *mut OSSL_LIB_CTX,
    pub sk: *mut stack_st_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_void {
    _unused: [u8; 0],
}
pub type sk_void_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::aya_ebpf::cty::c_void,
        b: *const *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_void_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ::aya_ebpf::cty::c_void)>;
pub type sk_void_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type CRYPTO_EX_new = ::core::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::aya_ebpf::cty::c_void,
        ptr: *mut ::aya_ebpf::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        argp: *mut ::aya_ebpf::cty::c_void,
    ),
>;
pub type CRYPTO_EX_free = ::core::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::aya_ebpf::cty::c_void,
        ptr: *mut ::aya_ebpf::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        argp: *mut ::aya_ebpf::cty::c_void,
    ),
>;
pub type CRYPTO_EX_dup = ::core::option::Option<
    unsafe extern "C" fn(
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
        from_d: *mut *mut ::aya_ebpf::cty::c_void,
        idx: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        argp: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn CRYPTO_get_ex_new_index(
        class_index: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        argp: *mut ::aya_ebpf::cty::c_void,
        new_func: CRYPTO_EX_new,
        dup_func: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_index(
        class_index: ::aya_ebpf::cty::c_int,
        idx: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_new_ex_data(
        class_index: ::aya_ebpf::cty::c_int,
        obj: *mut ::aya_ebpf::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_dup_ex_data(
        class_index: ::aya_ebpf::cty::c_int,
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_free_ex_data(
        class_index: ::aya_ebpf::cty::c_int,
        obj: *mut ::aya_ebpf::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
    );
}
extern "C" {
    pub fn CRYPTO_alloc_ex_data(
        class_index: ::aya_ebpf::cty::c_int,
        obj: *mut ::aya_ebpf::cty::c_void,
        ad: *mut CRYPTO_EX_DATA,
        idx: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_set_ex_data(
        ad: *mut CRYPTO_EX_DATA,
        idx: ::aya_ebpf::cty::c_int,
        val: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_get_ex_data(ad: *const CRYPTO_EX_DATA, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_threadid_st {
    pub dummy: ::aya_ebpf::cty::c_int,
}
pub type CRYPTO_THREADID = crypto_threadid_st;
pub type CRYPTO_malloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type CRYPTO_realloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type CRYPTO_free_fn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: *mut ::aya_ebpf::cty::c_void,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ),
>;
extern "C" {
    pub fn CRYPTO_set_mem_functions(
        malloc_fn: CRYPTO_malloc_fn,
        realloc_fn: CRYPTO_realloc_fn,
        free_fn: CRYPTO_free_fn,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_get_mem_functions(
        malloc_fn: *mut CRYPTO_malloc_fn,
        realloc_fn: *mut CRYPTO_realloc_fn,
        free_fn: *mut CRYPTO_free_fn,
    );
}
extern "C" {
    pub fn CRYPTO_malloc(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_zalloc(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_memdup(
        str_: *const ::aya_ebpf::cty::c_void,
        siz: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_strdup(
        str_: *const ::aya_ebpf::cty::c_char,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CRYPTO_strndup(
        str_: *const ::aya_ebpf::cty::c_char,
        s: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CRYPTO_free(
        ptr: *mut ::aya_ebpf::cty::c_void,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_clear_free(
        ptr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_realloc(
        addr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_clear_realloc(
        addr: *mut ::aya_ebpf::cty::c_void,
        old_num: usize,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_init(sz: usize, minsize: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_done() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_zalloc(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_secure_free(
        ptr: *mut ::aya_ebpf::cty::c_void,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_secure_clear_free(
        ptr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn CRYPTO_secure_allocated(ptr: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_initialized() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_actual_size(ptr: *mut ::aya_ebpf::cty::c_void) -> usize;
}
extern "C" {
    pub fn CRYPTO_secure_used() -> usize;
}
extern "C" {
    pub fn OPENSSL_cleanse(ptr: *mut ::aya_ebpf::cty::c_void, len: usize);
}
extern "C" {
    pub fn OPENSSL_die(
        assertion: *const ::aya_ebpf::cty::c_char,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn OPENSSL_isservice() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_init();
}
extern "C" {
    pub fn OPENSSL_fork_prepare();
}
extern "C" {
    pub fn OPENSSL_fork_parent();
}
extern "C" {
    pub fn OPENSSL_fork_child();
}
extern "C" {
    pub fn OPENSSL_gmtime(timer: *const time_t, result: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn OPENSSL_gmtime_adj(
        tm: *mut tm,
        offset_day: ::aya_ebpf::cty::c_int,
        offset_sec: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_gmtime_diff(
        pday: *mut ::aya_ebpf::cty::c_int,
        psec: *mut ::aya_ebpf::cty::c_int,
        from: *const tm,
        to: *const tm,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_memcmp(
        in_a: *const ::aya_ebpf::cty::c_void,
        in_b: *const ::aya_ebpf::cty::c_void,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_cleanup();
}
extern "C" {
    pub fn OPENSSL_init_crypto(opts: u64, settings: *const OPENSSL_INIT_SETTINGS) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_atexit(handler: ::core::option::Option<unsafe extern "C" fn()>) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_thread_stop();
}
extern "C" {
    pub fn OPENSSL_thread_stop_ex(ctx: *mut OSSL_LIB_CTX);
}
extern "C" {
    pub fn OPENSSL_INIT_new() -> *mut OPENSSL_INIT_SETTINGS;
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_filename(
        settings: *mut OPENSSL_INIT_SETTINGS,
        config_filename: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_file_flags(settings: *mut OPENSSL_INIT_SETTINGS, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn OPENSSL_INIT_set_config_appname(
        settings: *mut OPENSSL_INIT_SETTINGS,
        config_appname: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_INIT_free(settings: *mut OPENSSL_INIT_SETTINGS);
}
pub type CRYPTO_ONCE = pthread_once_t;
pub type CRYPTO_THREAD_LOCAL = pthread_key_t;
pub type CRYPTO_THREAD_ID = pthread_t;
extern "C" {
    pub fn CRYPTO_THREAD_run_once(
        once: *mut CRYPTO_ONCE,
        init: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_init_local(
        key: *mut CRYPTO_THREAD_LOCAL,
        cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_get_local(key: *mut CRYPTO_THREAD_LOCAL) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CRYPTO_THREAD_set_local(
        key: *mut CRYPTO_THREAD_LOCAL,
        val: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_cleanup_local(key: *mut CRYPTO_THREAD_LOCAL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRYPTO_THREAD_get_current_id() -> CRYPTO_THREAD_ID;
}
extern "C" {
    pub fn CRYPTO_THREAD_compare_id(a: CRYPTO_THREAD_ID, b: CRYPTO_THREAD_ID) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_LIB_CTX_new() -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn OSSL_LIB_CTX_new_from_dispatch(
        handle: *const OSSL_CORE_HANDLE,
        in_: *const OSSL_DISPATCH,
    ) -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn OSSL_LIB_CTX_new_child(handle: *const OSSL_CORE_HANDLE, in_: *const OSSL_DISPATCH) -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn OSSL_LIB_CTX_load_config(
        ctx: *mut OSSL_LIB_CTX,
        config_file: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_LIB_CTX_free(arg1: *mut OSSL_LIB_CTX);
}
extern "C" {
    pub fn OSSL_LIB_CTX_get0_global_default() -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn OSSL_LIB_CTX_set0_default(libctx: *mut OSSL_LIB_CTX) -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn COMP_CTX_new(meth: *mut COMP_METHOD) -> *mut COMP_CTX;
}
extern "C" {
    pub fn COMP_CTX_get_method(ctx: *const COMP_CTX) -> *const COMP_METHOD;
}
extern "C" {
    pub fn COMP_CTX_get_type(comp: *const COMP_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn COMP_get_type(meth: *const COMP_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn COMP_get_name(meth: *const COMP_METHOD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn COMP_CTX_free(ctx: *mut COMP_CTX);
}
extern "C" {
    pub fn COMP_compress_block(
        ctx: *mut COMP_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        olen: ::aya_ebpf::cty::c_int,
        in_: *mut ::aya_ebpf::cty::c_uchar,
        ilen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn COMP_expand_block(
        ctx: *mut COMP_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        olen: ::aya_ebpf::cty::c_int,
        in_: *mut ::aya_ebpf::cty::c_uchar,
        ilen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn COMP_zlib() -> *mut COMP_METHOD;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_addr_st {
    _unused: [u8; 0],
}
pub type BIO_ADDR = bio_addr_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_addrinfo_st {
    _unused: [u8; 0],
}
pub type BIO_ADDRINFO = bio_addrinfo_st;
extern "C" {
    pub fn BIO_get_new_index() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_set_flags(b: *mut BIO, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BIO_test_flags(b: *const BIO, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_clear_flags(b: *mut BIO, flags: ::aya_ebpf::cty::c_int);
}
pub type BIO_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        oper: ::aya_ebpf::cty::c_int,
        argp: *const ::aya_ebpf::cty::c_char,
        argi: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        ret: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_long,
>;
extern "C" {
    pub fn BIO_get_callback(b: *const BIO) -> BIO_callback_fn;
}
extern "C" {
    pub fn BIO_set_callback(b: *mut BIO, callback: BIO_callback_fn);
}
extern "C" {
    pub fn BIO_debug_callback(
        bio: *mut BIO,
        cmd: ::aya_ebpf::cty::c_int,
        argp: *const ::aya_ebpf::cty::c_char,
        argi: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        ret: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_long;
}
pub type BIO_callback_fn_ex = ::core::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        oper: ::aya_ebpf::cty::c_int,
        argp: *const ::aya_ebpf::cty::c_char,
        len: usize,
        argi: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        ret: ::aya_ebpf::cty::c_int,
        processed: *mut usize,
    ) -> ::aya_ebpf::cty::c_long,
>;
extern "C" {
    pub fn BIO_get_callback_ex(b: *const BIO) -> BIO_callback_fn_ex;
}
extern "C" {
    pub fn BIO_set_callback_ex(b: *mut BIO, callback: BIO_callback_fn_ex);
}
extern "C" {
    pub fn BIO_debug_callback_ex(
        bio: *mut BIO,
        oper: ::aya_ebpf::cty::c_int,
        argp: *const ::aya_ebpf::cty::c_char,
        len: usize,
        argi: ::aya_ebpf::cty::c_int,
        argl: ::aya_ebpf::cty::c_long,
        ret: ::aya_ebpf::cty::c_int,
        processed: *mut usize,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn BIO_get_callback_arg(b: *const BIO) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BIO_set_callback_arg(b: *mut BIO, arg: *mut ::aya_ebpf::cty::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_method_st {
    _unused: [u8; 0],
}
pub type BIO_METHOD = bio_method_st;
extern "C" {
    pub fn BIO_method_name(b: *const BIO) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BIO_method_type(b: *const BIO) -> ::aya_ebpf::cty::c_int;
}
pub type BIO_info_cb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut BIO,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type bio_info_cb = BIO_info_cb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIO {
    _unused: [u8; 0],
}
pub type sk_BIO_compfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const *const BIO, b: *const *const BIO) -> ::aya_ebpf::cty::c_int>;
pub type sk_BIO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut BIO)>;
pub type sk_BIO_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const BIO) -> *mut BIO>;
pub type asn1_ps_func = ::core::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        pbuf: *mut *mut ::aya_ebpf::cty::c_uchar,
        plen: *mut ::aya_ebpf::cty::c_int,
        parg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type BIO_dgram_sctp_notification_handler_fn = ::core::option::Option<
    unsafe extern "C" fn(b: *mut BIO, context: *mut ::aya_ebpf::cty::c_void, buf: *mut ::aya_ebpf::cty::c_void),
>;
extern "C" {
    pub fn BIO_ctrl_pending(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_wpending(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_get_write_guarantee(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_get_read_request(b: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_reset_read_request(b: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_set_ex_data(
        bio: *mut BIO,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_get_ex_data(bio: *const BIO, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn BIO_number_read(bio: *mut BIO) -> u64;
}
extern "C" {
    pub fn BIO_number_written(bio: *mut BIO) -> u64;
}
extern "C" {
    pub fn BIO_asn1_set_prefix(b: *mut BIO, prefix: asn1_ps_func, prefix_free: asn1_ps_func) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_prefix(
        b: *mut BIO,
        pprefix: *mut asn1_ps_func,
        pprefix_free: *mut asn1_ps_func,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_asn1_set_suffix(b: *mut BIO, suffix: asn1_ps_func, suffix_free: asn1_ps_func) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_asn1_get_suffix(
        b: *mut BIO,
        psuffix: *mut asn1_ps_func,
        psuffix_free: *mut asn1_ps_func,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_s_file() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_file(filename: *const ::aya_ebpf::cty::c_char, mode: *const ::aya_ebpf::cty::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_from_core_bio(libctx: *mut OSSL_LIB_CTX, corebio: *mut OSSL_CORE_BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fp(stream: *mut FILE, close_flag: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_ex(libctx: *mut OSSL_LIB_CTX, method: *const BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new(type_: *const BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free(a: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_set_data(a: *mut BIO, ptr: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn BIO_get_data(a: *mut BIO) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn BIO_set_init(a: *mut BIO, init: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BIO_get_init(a: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_set_shutdown(a: *mut BIO, shut: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BIO_get_shutdown(a: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_vfree(a: *mut BIO);
}
extern "C" {
    pub fn BIO_up_ref(a: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_read(
        b: *mut BIO,
        data: *mut ::aya_ebpf::cty::c_void,
        dlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_read_ex(
        b: *mut BIO,
        data: *mut ::aya_ebpf::cty::c_void,
        dlen: usize,
        readbytes: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_gets(
        bp: *mut BIO,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_get_line(
        bio: *mut BIO,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_write(
        b: *mut BIO,
        data: *const ::aya_ebpf::cty::c_void,
        dlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_write_ex(
        b: *mut BIO,
        data: *const ::aya_ebpf::cty::c_void,
        dlen: usize,
        written: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_puts(bp: *mut BIO, buf: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_indent(b: *mut BIO, indent: ::aya_ebpf::cty::c_int, max: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ctrl(
        bp: *mut BIO,
        cmd: ::aya_ebpf::cty::c_int,
        larg: ::aya_ebpf::cty::c_long,
        parg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn BIO_callback_ctrl(b: *mut BIO, cmd: ::aya_ebpf::cty::c_int, fp: BIO_info_cb) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn BIO_ptr_ctrl(
        bp: *mut BIO,
        cmd: ::aya_ebpf::cty::c_int,
        larg: ::aya_ebpf::cty::c_long,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn BIO_int_ctrl(
        bp: *mut BIO,
        cmd: ::aya_ebpf::cty::c_int,
        larg: ::aya_ebpf::cty::c_long,
        iarg: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn BIO_push(b: *mut BIO, append: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_pop(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free_all(a: *mut BIO);
}
extern "C" {
    pub fn BIO_find_type(b: *mut BIO, bio_type: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_next(b: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_next(b: *mut BIO, next: *mut BIO);
}
extern "C" {
    pub fn BIO_get_retry_BIO(bio: *mut BIO, reason: *mut ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_retry_reason(bio: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_set_retry_reason(bio: *mut BIO, reason: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BIO_dup_chain(in_: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_nread0(bio: *mut BIO, buf: *mut *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_nread(
        bio: *mut BIO,
        buf: *mut *mut ::aya_ebpf::cty::c_char,
        num: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_nwrite0(bio: *mut BIO, buf: *mut *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_nwrite(
        bio: *mut BIO,
        buf: *mut *mut ::aya_ebpf::cty::c_char,
        num: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_s_mem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_secmem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_mem_buf(buf: *const ::aya_ebpf::cty::c_void, len: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_s_socket() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_connect() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_accept() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_fd() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_log() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_bio() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_null() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_null() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_buffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_readbuffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_linebuffer() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_nbio_test() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_prefix() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_core() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_s_datagram() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_dgram_non_fatal_error(error: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_new_dgram(fd: ::aya_ebpf::cty::c_int, close_flag: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_sock_should_retry(i: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_sock_non_fatal_error(error: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_socket_wait(
        fd: ::aya_ebpf::cty::c_int,
        for_read: ::aya_ebpf::cty::c_int,
        max_time: time_t,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_wait(bio: *mut BIO, max_time: time_t, nap_milliseconds: ::aya_ebpf::cty::c_uint)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_do_connect_retry(
        bio: *mut BIO,
        timeout: ::aya_ebpf::cty::c_int,
        nap_milliseconds: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_fd_should_retry(i: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_fd_non_fatal_error(error: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_cb(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                data: *const ::aya_ebpf::cty::c_void,
                len: usize,
                u: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        u: *mut ::aya_ebpf::cty::c_void,
        s: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_cb(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                data: *const ::aya_ebpf::cty::c_void,
                len: usize,
                u: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        u: *mut ::aya_ebpf::cty::c_void,
        s: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_dump(
        b: *mut BIO,
        bytes: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_indent(
        b: *mut BIO,
        bytes: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_fp(
        fp: *mut FILE,
        s: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_dump_indent_fp(
        fp: *mut FILE,
        s: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_hex_string(
        out: *mut BIO,
        indent: ::aya_ebpf::cty::c_int,
        width: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_void,
        datalen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_new() -> *mut BIO_ADDR;
}
extern "C" {
    pub fn BIO_ADDR_rawmake(
        ap: *mut BIO_ADDR,
        family: ::aya_ebpf::cty::c_int,
        where_: *const ::aya_ebpf::cty::c_void,
        wherelen: usize,
        port: ::aya_ebpf::cty::c_ushort,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_free(arg1: *mut BIO_ADDR);
}
extern "C" {
    pub fn BIO_ADDR_clear(ap: *mut BIO_ADDR);
}
extern "C" {
    pub fn BIO_ADDR_family(ap: *const BIO_ADDR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_rawaddress(
        ap: *const BIO_ADDR,
        p: *mut ::aya_ebpf::cty::c_void,
        l: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDR_rawport(ap: *const BIO_ADDR) -> ::aya_ebpf::cty::c_ushort;
}
extern "C" {
    pub fn BIO_ADDR_hostname_string(ap: *const BIO_ADDR, numeric: ::aya_ebpf::cty::c_int)
        -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BIO_ADDR_service_string(ap: *const BIO_ADDR, numeric: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BIO_ADDR_path_string(ap: *const BIO_ADDR) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BIO_ADDRINFO_next(bai: *const BIO_ADDRINFO) -> *const BIO_ADDRINFO;
}
extern "C" {
    pub fn BIO_ADDRINFO_family(bai: *const BIO_ADDRINFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_socktype(bai: *const BIO_ADDRINFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_protocol(bai: *const BIO_ADDRINFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ADDRINFO_address(bai: *const BIO_ADDRINFO) -> *const BIO_ADDR;
}
extern "C" {
    pub fn BIO_ADDRINFO_free(bai: *mut BIO_ADDRINFO);
}
pub const BIO_hostserv_priorities_BIO_PARSE_PRIO_HOST: BIO_hostserv_priorities = 0;
pub const BIO_hostserv_priorities_BIO_PARSE_PRIO_SERV: BIO_hostserv_priorities = 1;
pub type BIO_hostserv_priorities = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn BIO_parse_hostserv(
        hostserv: *const ::aya_ebpf::cty::c_char,
        host: *mut *mut ::aya_ebpf::cty::c_char,
        service: *mut *mut ::aya_ebpf::cty::c_char,
        hostserv_prio: BIO_hostserv_priorities,
    ) -> ::aya_ebpf::cty::c_int;
}
pub const BIO_lookup_type_BIO_LOOKUP_CLIENT: BIO_lookup_type = 0;
pub const BIO_lookup_type_BIO_LOOKUP_SERVER: BIO_lookup_type = 1;
pub type BIO_lookup_type = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn BIO_lookup(
        host: *const ::aya_ebpf::cty::c_char,
        service: *const ::aya_ebpf::cty::c_char,
        lookup_type: BIO_lookup_type,
        family: ::aya_ebpf::cty::c_int,
        socktype: ::aya_ebpf::cty::c_int,
        res: *mut *mut BIO_ADDRINFO,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_lookup_ex(
        host: *const ::aya_ebpf::cty::c_char,
        service: *const ::aya_ebpf::cty::c_char,
        lookup_type: ::aya_ebpf::cty::c_int,
        family: ::aya_ebpf::cty::c_int,
        socktype: ::aya_ebpf::cty::c_int,
        protocol: ::aya_ebpf::cty::c_int,
        res: *mut *mut BIO_ADDRINFO,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_sock_error(sock: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_socket_ioctl(
        fd: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_long,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_socket_nbio(fd: ::aya_ebpf::cty::c_int, mode: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_sock_init() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_set_tcp_ndelay(sock: ::aya_ebpf::cty::c_int, turn_on: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_gethostbyname(name: *const ::aya_ebpf::cty::c_char) -> *mut hostent;
}
extern "C" {
    pub fn BIO_get_port(
        str_: *const ::aya_ebpf::cty::c_char,
        port_ptr: *mut ::aya_ebpf::cty::c_ushort,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_get_host_ip(
        str_: *const ::aya_ebpf::cty::c_char,
        ip: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_get_accept_socket(
        host_port: *mut ::aya_ebpf::cty::c_char,
        mode: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_accept(sock: ::aya_ebpf::cty::c_int, ip_port: *mut *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BIO_sock_info_u {
    pub addr: *mut BIO_ADDR,
}
pub const BIO_sock_info_type_BIO_SOCK_INFO_ADDRESS: BIO_sock_info_type = 0;
pub type BIO_sock_info_type = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn BIO_sock_info(
        sock: ::aya_ebpf::cty::c_int,
        type_: BIO_sock_info_type,
        info: *mut BIO_sock_info_u,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_socket(
        domain: ::aya_ebpf::cty::c_int,
        socktype: ::aya_ebpf::cty::c_int,
        protocol: ::aya_ebpf::cty::c_int,
        options: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_connect(
        sock: ::aya_ebpf::cty::c_int,
        addr: *const BIO_ADDR,
        options: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_bind(
        sock: ::aya_ebpf::cty::c_int,
        addr: *const BIO_ADDR,
        options: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_listen(
        sock: ::aya_ebpf::cty::c_int,
        addr: *const BIO_ADDR,
        options: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_accept_ex(
        accept_sock: ::aya_ebpf::cty::c_int,
        addr: *mut BIO_ADDR,
        options: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_closesocket(sock: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_new_socket(sock: ::aya_ebpf::cty::c_int, close_flag: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_connect(host_port: *const ::aya_ebpf::cty::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_accept(host_port: *const ::aya_ebpf::cty::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fd(fd: ::aya_ebpf::cty::c_int, close_flag: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_bio_pair(
        bio1: *mut *mut BIO,
        writebuf1: usize,
        bio2: *mut *mut BIO,
        writebuf2: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_copy_next_retry(b: *mut BIO);
}
extern "C" {
    pub fn BIO_printf(bio: *mut BIO, format: *const ::aya_ebpf::cty::c_char, ...) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_vprintf(
        bio: *mut BIO,
        format: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_snprintf(
        buf: *mut ::aya_ebpf::cty::c_char,
        n: usize,
        format: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_vsnprintf(
        buf: *mut ::aya_ebpf::cty::c_char,
        n: usize,
        format: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_new(type_: ::aya_ebpf::cty::c_int, name: *const ::aya_ebpf::cty::c_char) -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_meth_free(biom: *mut BIO_METHOD);
}
extern "C" {
    pub fn BIO_meth_get_write(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const ::aya_ebpf::cty::c_char,
            arg2: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_get_write_ex(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *const ::aya_ebpf::cty::c_char,
            arg2: usize,
            arg3: *mut usize,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_write(
        biom: *mut BIO_METHOD,
        write: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::aya_ebpf::cty::c_char,
                arg3: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_set_write_ex(
        biom: *mut BIO_METHOD,
        bwrite: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::aya_ebpf::cty::c_char,
                arg3: usize,
                arg4: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_read(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut ::aya_ebpf::cty::c_char,
            arg2: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_get_read_ex(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut ::aya_ebpf::cty::c_char,
            arg2: usize,
            arg3: *mut usize,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_read(
        biom: *mut BIO_METHOD,
        read: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::aya_ebpf::cty::c_char,
                arg3: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_set_read_ex(
        biom: *mut BIO_METHOD,
        bread: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::aya_ebpf::cty::c_char,
                arg3: usize,
                arg4: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_puts(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(biom: *mut BIO, arg1: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_puts(
        biom: *mut BIO_METHOD,
        puts: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO, arg2: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_gets(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: *mut ::aya_ebpf::cty::c_char,
            arg2: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_gets(
        biom: *mut BIO_METHOD,
        ossl_gets: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::aya_ebpf::cty::c_char,
                arg3: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_ctrl(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            biom: *mut BIO,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: ::aya_ebpf::cty::c_long,
            arg3: *mut ::aya_ebpf::cty::c_void,
        ) -> ::aya_ebpf::cty::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_ctrl(
        biom: *mut BIO_METHOD,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: ::aya_ebpf::cty::c_long,
                arg4: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_long,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_create(
        bion: *const BIO_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(bion: *mut BIO) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_create(
        biom: *mut BIO_METHOD,
        create: ::core::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_destroy(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(biom: *mut BIO) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_destroy(
        biom: *mut BIO_METHOD,
        destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_meth_get_callback_ctrl(
        biom: *const BIO_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(biom: *mut BIO, arg1: ::aya_ebpf::cty::c_int, arg2: BIO_info_cb) -> ::aya_ebpf::cty::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_callback_ctrl(
        biom: *mut BIO_METHOD,
        callback_ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: BIO_info_cb,
            ) -> ::aya_ebpf::cty::c_long,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_mem_st {
    pub length: usize,
    pub data: *mut ::aya_ebpf::cty::c_char,
    pub max: usize,
    pub flags: ::aya_ebpf::cty::c_ulong,
}
extern "C" {
    pub fn BUF_MEM_new() -> *mut BUF_MEM;
}
extern "C" {
    pub fn BUF_MEM_new_ex(flags: ::aya_ebpf::cty::c_ulong) -> *mut BUF_MEM;
}
extern "C" {
    pub fn BUF_MEM_free(a: *mut BUF_MEM);
}
extern "C" {
    pub fn BUF_MEM_grow(str_: *mut BUF_MEM, len: usize) -> usize;
}
extern "C" {
    pub fn BUF_MEM_grow_clean(str_: *mut BUF_MEM, len: usize) -> usize;
}
extern "C" {
    pub fn BUF_reverse(out: *mut ::aya_ebpf::cty::c_uchar, in_: *const ::aya_ebpf::cty::c_uchar, siz: usize);
}
pub type OSSL_FUNC_core_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_core_get_params_fn = ::core::option::Option<
    unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_core_thread_start_fn = ::core::option::Option<
    unsafe extern "C" fn(
        prov: *const OSSL_CORE_HANDLE,
        handfn: OSSL_thread_stop_handler_fn,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_core_get_libctx_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> *mut OPENSSL_CORE_CTX>;
pub type OSSL_FUNC_core_new_error_fn = ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE)>;
pub type OSSL_FUNC_core_set_error_debug_fn = ::core::option::Option<
    unsafe extern "C" fn(
        prov: *const OSSL_CORE_HANDLE,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
        func: *const ::aya_ebpf::cty::c_char,
    ),
>;
pub type OSSL_FUNC_core_vset_error_fn = ::core::option::Option<
    unsafe extern "C" fn(
        prov: *const OSSL_CORE_HANDLE,
        reason: u32,
        fmt: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    ),
>;
pub type OSSL_FUNC_core_set_error_mark_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_core_clear_last_error_mark_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_core_pop_error_to_mark_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_core_obj_add_sigid_fn = ::core::option::Option<
    unsafe extern "C" fn(
        prov: *const OSSL_CORE_HANDLE,
        sign_name: *const ::aya_ebpf::cty::c_char,
        digest_name: *const ::aya_ebpf::cty::c_char,
        pkey_name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_core_obj_create_fn = ::core::option::Option<
    unsafe extern "C" fn(
        prov: *const OSSL_CORE_HANDLE,
        oid: *const ::aya_ebpf::cty::c_char,
        sn: *const ::aya_ebpf::cty::c_char,
        ln: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_CRYPTO_malloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_CRYPTO_zalloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_CRYPTO_free_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::aya_ebpf::cty::c_void,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ),
>;
pub type OSSL_FUNC_CRYPTO_clear_free_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ),
>;
pub type OSSL_FUNC_CRYPTO_realloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_CRYPTO_clear_realloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        addr: *mut ::aya_ebpf::cty::c_void,
        old_num: usize,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_CRYPTO_secure_malloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_CRYPTO_secure_zalloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_CRYPTO_secure_free_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::aya_ebpf::cty::c_void,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ),
>;
pub type OSSL_FUNC_CRYPTO_secure_clear_free_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
    ),
>;
pub type OSSL_FUNC_CRYPTO_secure_allocated_fn =
    ::core::option::Option<unsafe extern "C" fn(ptr: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_OPENSSL_cleanse_fn =
    ::core::option::Option<unsafe extern "C" fn(ptr: *mut ::aya_ebpf::cty::c_void, len: usize)>;
pub type OSSL_FUNC_BIO_new_file_fn = ::core::option::Option<
    unsafe extern "C" fn(
        filename: *const ::aya_ebpf::cty::c_char,
        mode: *const ::aya_ebpf::cty::c_char,
    ) -> *mut OSSL_CORE_BIO,
>;
pub type OSSL_FUNC_BIO_new_membuf_fn = ::core::option::Option<
    unsafe extern "C" fn(buf: *const ::aya_ebpf::cty::c_void, len: ::aya_ebpf::cty::c_int) -> *mut OSSL_CORE_BIO,
>;
pub type OSSL_FUNC_BIO_read_ex_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bio: *mut OSSL_CORE_BIO,
        data: *mut ::aya_ebpf::cty::c_void,
        data_len: usize,
        bytes_read: *mut usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_BIO_write_ex_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bio: *mut OSSL_CORE_BIO,
        data: *const ::aya_ebpf::cty::c_void,
        data_len: usize,
        written: *mut usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_BIO_gets_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bio: *mut OSSL_CORE_BIO,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_BIO_puts_fn = ::core::option::Option<
    unsafe extern "C" fn(bio: *mut OSSL_CORE_BIO, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_BIO_up_ref_fn =
    ::core::option::Option<unsafe extern "C" fn(bio: *mut OSSL_CORE_BIO) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_BIO_free_fn =
    ::core::option::Option<unsafe extern "C" fn(bio: *mut OSSL_CORE_BIO) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_BIO_vprintf_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bio: *mut OSSL_CORE_BIO,
        format: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_BIO_vsnprintf_fn = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::aya_ebpf::cty::c_char,
        n: usize,
        fmt: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_BIO_ctrl_fn = ::core::option::Option<
    unsafe extern "C" fn(
        bio: *mut OSSL_CORE_BIO,
        cmd: ::aya_ebpf::cty::c_int,
        num: ::aya_ebpf::cty::c_long,
        ptr: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_self_test_cb_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut OPENSSL_CORE_CTX, cb: *mut OSSL_CALLBACK, cbarg: *mut *mut ::aya_ebpf::cty::c_void),
>;
pub type OSSL_FUNC_get_entropy_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *const OSSL_CORE_HANDLE,
        pout: *mut *mut ::aya_ebpf::cty::c_uchar,
        entropy: ::aya_ebpf::cty::c_int,
        min_len: usize,
        max_len: usize,
    ) -> usize,
>;
pub type OSSL_FUNC_get_user_entropy_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *const OSSL_CORE_HANDLE,
        pout: *mut *mut ::aya_ebpf::cty::c_uchar,
        entropy: ::aya_ebpf::cty::c_int,
        min_len: usize,
        max_len: usize,
    ) -> usize,
>;
pub type OSSL_FUNC_cleanup_entropy_fn = ::core::option::Option<
    unsafe extern "C" fn(handle: *const OSSL_CORE_HANDLE, buf: *mut ::aya_ebpf::cty::c_uchar, len: usize),
>;
pub type OSSL_FUNC_cleanup_user_entropy_fn = ::core::option::Option<
    unsafe extern "C" fn(handle: *const OSSL_CORE_HANDLE, buf: *mut ::aya_ebpf::cty::c_uchar, len: usize),
>;
pub type OSSL_FUNC_get_nonce_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *const OSSL_CORE_HANDLE,
        pout: *mut *mut ::aya_ebpf::cty::c_uchar,
        min_len: usize,
        max_len: usize,
        salt: *const ::aya_ebpf::cty::c_void,
        salt_len: usize,
    ) -> usize,
>;
pub type OSSL_FUNC_get_user_nonce_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *const OSSL_CORE_HANDLE,
        pout: *mut *mut ::aya_ebpf::cty::c_uchar,
        min_len: usize,
        max_len: usize,
        salt: *const ::aya_ebpf::cty::c_void,
        salt_len: usize,
    ) -> usize,
>;
pub type OSSL_FUNC_cleanup_nonce_fn = ::core::option::Option<
    unsafe extern "C" fn(handle: *const OSSL_CORE_HANDLE, buf: *mut ::aya_ebpf::cty::c_uchar, len: usize),
>;
pub type OSSL_FUNC_cleanup_user_nonce_fn = ::core::option::Option<
    unsafe extern "C" fn(handle: *const OSSL_CORE_HANDLE, buf: *mut ::aya_ebpf::cty::c_uchar, len: usize),
>;
pub type OSSL_FUNC_provider_register_child_cb_fn = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *const OSSL_CORE_HANDLE,
        create_cb: ::core::option::Option<
            unsafe extern "C" fn(
                provider: *const OSSL_CORE_HANDLE,
                cbdata: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        remove_cb: ::core::option::Option<
            unsafe extern "C" fn(
                provider: *const OSSL_CORE_HANDLE,
                cbdata: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        global_props_cb: ::core::option::Option<
            unsafe extern "C" fn(
                props: *const ::aya_ebpf::cty::c_char,
                cbdata: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        cbdata: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_provider_deregister_child_cb_fn =
    ::core::option::Option<unsafe extern "C" fn(handle: *const OSSL_CORE_HANDLE)>;
pub type OSSL_FUNC_provider_name_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> *const ::aya_ebpf::cty::c_char>;
pub type OSSL_FUNC_provider_get0_provider_ctx_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_provider_get0_dispatch_fn =
    ::core::option::Option<unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE) -> *const OSSL_DISPATCH>;
pub type OSSL_FUNC_provider_up_ref_fn = ::core::option::Option<
    unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE, activate: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_provider_free_fn = ::core::option::Option<
    unsafe extern "C" fn(prov: *const OSSL_CORE_HANDLE, deactivate: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_provider_teardown_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_provider_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_provider_get_params_fn = ::core::option::Option<
    unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_provider_query_operation_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        operation_id: ::aya_ebpf::cty::c_int,
        no_store: *mut ::aya_ebpf::cty::c_int,
    ) -> *const OSSL_ALGORITHM,
>;
pub type OSSL_FUNC_provider_unquery_operation_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        operation_id: ::aya_ebpf::cty::c_int,
        arg1: *const OSSL_ALGORITHM,
    ),
>;
pub type OSSL_FUNC_provider_get_reason_strings_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_ITEM>;
pub type OSSL_FUNC_provider_get_capabilities_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        capability: *const ::aya_ebpf::cty::c_char,
        cb: OSSL_CALLBACK,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_provider_self_test_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_digest_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_digest_init_fn = ::core::option::Option<
    unsafe extern "C" fn(dctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_digest_update_fn = ::core::option::Option<
    unsafe extern "C" fn(
        dctx: *mut ::aya_ebpf::cty::c_void,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_digest_final_fn = ::core::option::Option<
    unsafe extern "C" fn(
        dctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsz: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_digest_digest_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: usize,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsz: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_digest_freectx_fn = ::core::option::Option<unsafe extern "C" fn(dctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_digest_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(dctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_digest_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_digest_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_digest_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_digest_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_digest_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(dctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_digest_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(dctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_cipher_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_cipher_encrypt_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        cctx: *mut ::aya_ebpf::cty::c_void,
        key: *const ::aya_ebpf::cty::c_uchar,
        keylen: usize,
        iv: *const ::aya_ebpf::cty::c_uchar,
        ivlen: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_decrypt_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        cctx: *mut ::aya_ebpf::cty::c_void,
        key: *const ::aya_ebpf::cty::c_uchar,
        keylen: usize,
        iv: *const ::aya_ebpf::cty::c_uchar,
        ivlen: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_update_fn = ::core::option::Option<
    unsafe extern "C" fn(
        cctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsize: usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_final_fn = ::core::option::Option<
    unsafe extern "C" fn(
        cctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsize: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_cipher_fn = ::core::option::Option<
    unsafe extern "C" fn(
        cctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsize: usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_freectx_fn = ::core::option::Option<unsafe extern "C" fn(cctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_cipher_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(cctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_cipher_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_cipher_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(cctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(cctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_cipher_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_cipher_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(cctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_cipher_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(cctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_mac_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_mac_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(src: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_mac_freectx_fn = ::core::option::Option<unsafe extern "C" fn(mctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_mac_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        mctx: *mut ::aya_ebpf::cty::c_void,
        key: *const ::aya_ebpf::cty::c_uchar,
        keylen: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_mac_update_fn = ::core::option::Option<
    unsafe extern "C" fn(
        mctx: *mut ::aya_ebpf::cty::c_void,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_mac_final_fn = ::core::option::Option<
    unsafe extern "C" fn(
        mctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsize: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_mac_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_mac_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(mctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_mac_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(mctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_mac_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_mac_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(mctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_mac_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(mctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kdf_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_kdf_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(src: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_kdf_freectx_fn = ::core::option::Option<unsafe extern "C" fn(kctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_kdf_reset_fn = ::core::option::Option<unsafe extern "C" fn(kctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_kdf_derive_fn = ::core::option::Option<
    unsafe extern "C" fn(
        kctx: *mut ::aya_ebpf::cty::c_void,
        key: *mut ::aya_ebpf::cty::c_uchar,
        keylen: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kdf_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_kdf_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(kctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_kdf_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(kctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_kdf_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_kdf_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(kctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kdf_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(kctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_rand_newctx_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        parent: *mut ::aya_ebpf::cty::c_void,
        parent_calls: *const OSSL_DISPATCH,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_rand_freectx_fn = ::core::option::Option<unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_rand_instantiate_fn = ::core::option::Option<
    unsafe extern "C" fn(
        vdrbg: *mut ::aya_ebpf::cty::c_void,
        strength: ::aya_ebpf::cty::c_uint,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        pstr: *const ::aya_ebpf::cty::c_uchar,
        pstr_len: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_rand_uninstantiate_fn =
    ::core::option::Option<unsafe extern "C" fn(vdrbg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_rand_generate_fn = ::core::option::Option<
    unsafe extern "C" fn(
        vctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: usize,
        strength: ::aya_ebpf::cty::c_uint,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        addin: *const ::aya_ebpf::cty::c_uchar,
        addin_len: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_rand_reseed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        vctx: *mut ::aya_ebpf::cty::c_void,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        ent: *const ::aya_ebpf::cty::c_uchar,
        ent_len: usize,
        addin: *const ::aya_ebpf::cty::c_uchar,
        addin_len: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_rand_nonce_fn = ::core::option::Option<
    unsafe extern "C" fn(
        vctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        strength: ::aya_ebpf::cty::c_uint,
        min_noncelen: usize,
        max_noncelen: usize,
    ) -> usize,
>;
pub type OSSL_FUNC_rand_enable_locking_fn =
    ::core::option::Option<unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_rand_lock_fn =
    ::core::option::Option<unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_rand_unlock_fn = ::core::option::Option<unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_rand_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_rand_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_rand_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_rand_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_rand_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_rand_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_rand_set_callbacks_fn = ::core::option::Option<
    unsafe extern "C" fn(
        vctx: *mut ::aya_ebpf::cty::c_void,
        get_entropy: OSSL_INOUT_CALLBACK,
        cleanup_entropy: OSSL_CALLBACK,
        get_nonce: OSSL_INOUT_CALLBACK,
        cleanup_nonce: OSSL_CALLBACK,
        arg: *mut ::aya_ebpf::cty::c_void,
    ),
>;
pub type OSSL_FUNC_rand_verify_zeroization_fn =
    ::core::option::Option<unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_rand_get_seed_fn = ::core::option::Option<
    unsafe extern "C" fn(
        vctx: *mut ::aya_ebpf::cty::c_void,
        buffer: *mut *mut ::aya_ebpf::cty::c_uchar,
        entropy: ::aya_ebpf::cty::c_int,
        min_len: usize,
        max_len: usize,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        adin: *const ::aya_ebpf::cty::c_uchar,
        adin_len: usize,
    ) -> usize,
>;
pub type OSSL_FUNC_rand_clear_seed_fn = ::core::option::Option<
    unsafe extern "C" fn(vctx: *mut ::aya_ebpf::cty::c_void, buffer: *mut ::aya_ebpf::cty::c_uchar, b_len: usize),
>;
pub type OSSL_FUNC_keymgmt_new_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_keymgmt_gen_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
        params: *const OSSL_PARAM,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_keymgmt_gen_set_template_fn = ::core::option::Option<
    unsafe extern "C" fn(
        genctx: *mut ::aya_ebpf::cty::c_void,
        templ: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_gen_set_params_fn = ::core::option::Option<
    unsafe extern "C" fn(genctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_gen_settable_params_fn = ::core::option::Option<
    unsafe extern "C" fn(
        genctx: *mut ::aya_ebpf::cty::c_void,
        provctx: *mut ::aya_ebpf::cty::c_void,
    ) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_keymgmt_gen_fn = ::core::option::Option<
    unsafe extern "C" fn(
        genctx: *mut ::aya_ebpf::cty::c_void,
        cb: OSSL_CALLBACK,
        cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_keymgmt_gen_cleanup_fn =
    ::core::option::Option<unsafe extern "C" fn(genctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_keymgmt_load_fn = ::core::option::Option<
    unsafe extern "C" fn(reference: *const ::aya_ebpf::cty::c_void, reference_sz: usize) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_keymgmt_free_fn = ::core::option::Option<unsafe extern "C" fn(keydata: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_keymgmt_get_params_fn = ::core::option::Option<
    unsafe extern "C" fn(keydata: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_keymgmt_set_params_fn = ::core::option::Option<
    unsafe extern "C" fn(keydata: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_settable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_keymgmt_query_operation_name_fn =
    ::core::option::Option<unsafe extern "C" fn(operation_id: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char>;
pub type OSSL_FUNC_keymgmt_has_fn = ::core::option::Option<
    unsafe extern "C" fn(
        keydata: *const ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_validate_fn = ::core::option::Option<
    unsafe extern "C" fn(
        keydata: *const ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
        checktype: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_match_fn = ::core::option::Option<
    unsafe extern "C" fn(
        keydata1: *const ::aya_ebpf::cty::c_void,
        keydata2: *const ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_import_fn = ::core::option::Option<
    unsafe extern "C" fn(
        keydata: *mut ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_import_types_fn =
    ::core::option::Option<unsafe extern "C" fn(selection: ::aya_ebpf::cty::c_int) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_keymgmt_export_fn = ::core::option::Option<
    unsafe extern "C" fn(
        keydata: *mut ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
        param_cb: OSSL_CALLBACK,
        cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keymgmt_export_types_fn =
    ::core::option::Option<unsafe extern "C" fn(selection: ::aya_ebpf::cty::c_int) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_keymgmt_dup_fn = ::core::option::Option<
    unsafe extern "C" fn(
        keydata_from: *const ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_keyexch_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_keyexch_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keyexch_derive_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        secret: *mut ::aya_ebpf::cty::c_uchar,
        secretlen: *mut usize,
        outlen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keyexch_set_peer_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keyexch_freectx_fn = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_keyexch_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_keyexch_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keyexch_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_keyexch_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_keyexch_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_signature_newctx_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_signature_sign_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_sign_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        sig: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut usize,
        sigsize: usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_verify_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_verify_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_verify_recover_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_verify_recover_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        rout: *mut ::aya_ebpf::cty::c_uchar,
        routlen: *mut usize,
        routsize: usize,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_sign_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        mdname: *const ::aya_ebpf::cty::c_char,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_sign_update_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        data: *const ::aya_ebpf::cty::c_uchar,
        datalen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_sign_final_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        sig: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut usize,
        sigsize: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_sign_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        sigret: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut usize,
        sigsize: usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_verify_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        mdname: *const ::aya_ebpf::cty::c_char,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_verify_update_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        data: *const ::aya_ebpf::cty::c_uchar,
        datalen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_verify_final_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_digest_verify_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_freectx_fn = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_signature_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_signature_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_signature_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_signature_get_ctx_md_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_gettable_ctx_md_params_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_signature_set_ctx_md_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_signature_settable_ctx_md_params_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_asym_cipher_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_asym_cipher_encrypt_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_asym_cipher_encrypt_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        outsize: usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_asym_cipher_decrypt_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_asym_cipher_decrypt_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        outsize: usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_asym_cipher_freectx_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_asym_cipher_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_asym_cipher_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_asym_cipher_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_asym_cipher_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_asym_cipher_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_kem_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_kem_encapsulate_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kem_encapsulate_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        secret: *mut ::aya_ebpf::cty::c_uchar,
        secretlen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kem_decapsulate_init_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        provkey: *mut ::aya_ebpf::cty::c_void,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kem_decapsulate_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kem_freectx_fn = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_kem_dupctx_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_kem_get_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kem_gettable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_kem_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_kem_settable_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM,
>;
pub type OSSL_FUNC_encoder_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_encoder_freectx_fn = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_encoder_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_encoder_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_encoder_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_encoder_settable_ctx_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_encoder_does_selection_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_encoder_encode_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        out: *mut OSSL_CORE_BIO,
        obj_raw: *const ::aya_ebpf::cty::c_void,
        obj_abstract: *const OSSL_PARAM,
        selection: ::aya_ebpf::cty::c_int,
        cb: OSSL_PASSPHRASE_CALLBACK,
        cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_encoder_import_object_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
        params: *const OSSL_PARAM,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_encoder_free_object_fn =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_decoder_newctx_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void>;
pub type OSSL_FUNC_decoder_freectx_fn = ::core::option::Option<unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void)>;
pub type OSSL_FUNC_decoder_get_params_fn =
    ::core::option::Option<unsafe extern "C" fn(params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_decoder_gettable_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_decoder_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_decoder_settable_ctx_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_decoder_does_selection_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        selection: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_decoder_decode_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        in_: *mut OSSL_CORE_BIO,
        selection: ::aya_ebpf::cty::c_int,
        data_cb: OSSL_CALLBACK,
        data_cbarg: *mut ::aya_ebpf::cty::c_void,
        pw_cb: OSSL_PASSPHRASE_CALLBACK,
        pw_cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_decoder_export_object_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::aya_ebpf::cty::c_void,
        objref: *const ::aya_ebpf::cty::c_void,
        objref_sz: usize,
        export_cb: OSSL_CALLBACK,
        export_cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_store_open_fn = ::core::option::Option<
    unsafe extern "C" fn(
        provctx: *mut ::aya_ebpf::cty::c_void,
        uri: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_store_attach_fn = ::core::option::Option<
    unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void, in_: *mut OSSL_CORE_BIO) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type OSSL_FUNC_store_settable_ctx_params_fn =
    ::core::option::Option<unsafe extern "C" fn(provctx: *mut ::aya_ebpf::cty::c_void) -> *const OSSL_PARAM>;
pub type OSSL_FUNC_store_set_ctx_params_fn = ::core::option::Option<
    unsafe extern "C" fn(loaderctx: *mut ::aya_ebpf::cty::c_void, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_store_load_fn = ::core::option::Option<
    unsafe extern "C" fn(
        loaderctx: *mut ::aya_ebpf::cty::c_void,
        object_cb: OSSL_CALLBACK,
        object_cbarg: *mut ::aya_ebpf::cty::c_void,
        pw_cb: OSSL_PASSPHRASE_CALLBACK,
        pw_cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OSSL_FUNC_store_eof_fn =
    ::core::option::Option<unsafe extern "C" fn(loaderctx: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_store_close_fn =
    ::core::option::Option<unsafe extern "C" fn(loaderctx: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type OSSL_FUNC_store_export_object_fn = ::core::option::Option<
    unsafe extern "C" fn(
        loaderctx: *mut ::aya_ebpf::cty::c_void,
        objref: *const ::aya_ebpf::cty::c_void,
        objref_sz: usize,
        export_cb: OSSL_CALLBACK,
        export_cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn BN_set_flags(b: *mut BIGNUM, n: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BN_get_flags(b: *const BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_with_flags(dest: *mut BIGNUM, b: *const BIGNUM, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BN_GENCB_call(
        cb: *mut BN_GENCB,
        a: ::aya_ebpf::cty::c_int,
        b: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GENCB_new() -> *mut BN_GENCB;
}
extern "C" {
    pub fn BN_GENCB_free(cb: *mut BN_GENCB);
}
extern "C" {
    pub fn BN_GENCB_set_old(
        gencb: *mut BN_GENCB,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_set(
        gencb: *mut BN_GENCB,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut BN_GENCB,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_get_arg(cb: *mut BN_GENCB) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn BN_abs_is_word(a: *const BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_zero(a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_one(a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_word(a: *const BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_odd(a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_zero_ex(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_value_one() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_options() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BN_CTX_new_ex(ctx: *mut OSSL_LIB_CTX) -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_secure_new_ex(ctx: *mut OSSL_LIB_CTX) -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_secure_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_free(c: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_start(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_get(ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_end(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_rand_ex(
        rnd: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        top: ::aya_ebpf::cty::c_int,
        bottom: ::aya_ebpf::cty::c_int,
        strength: ::aya_ebpf::cty::c_uint,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_rand(
        rnd: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        top: ::aya_ebpf::cty::c_int,
        bottom: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_priv_rand_ex(
        rnd: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        top: ::aya_ebpf::cty::c_int,
        bottom: ::aya_ebpf::cty::c_int,
        strength: ::aya_ebpf::cty::c_uint,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_priv_rand(
        rnd: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        top: ::aya_ebpf::cty::c_int,
        bottom: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_rand_range_ex(
        r: *mut BIGNUM,
        range: *const BIGNUM,
        strength: ::aya_ebpf::cty::c_uint,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_priv_rand_range_ex(
        r: *mut BIGNUM,
        range: *const BIGNUM,
        strength: ::aya_ebpf::cty::c_uint,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_priv_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand(
        rnd: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        top: ::aya_ebpf::cty::c_int,
        bottom: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_num_bits(a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_num_bits_word(l: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_security_bits(L: ::aya_ebpf::cty::c_int, N: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_secure_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_clear_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_copy(a: *mut BIGNUM, b: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_swap(a: *mut BIGNUM, b: *mut BIGNUM);
}
extern "C" {
    pub fn BN_bin2bn(s: *const ::aya_ebpf::cty::c_uchar, len: ::aya_ebpf::cty::c_int, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2bin(a: *const BIGNUM, to: *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_bn2binpad(
        a: *const BIGNUM,
        to: *mut ::aya_ebpf::cty::c_uchar,
        tolen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_lebin2bn(s: *const ::aya_ebpf::cty::c_uchar, len: ::aya_ebpf::cty::c_int, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2lebinpad(
        a: *const BIGNUM,
        to: *mut ::aya_ebpf::cty::c_uchar,
        tolen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_native2bn(s: *const ::aya_ebpf::cty::c_uchar, len: ::aya_ebpf::cty::c_int, ret: *mut BIGNUM)
        -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2nativepad(
        a: *const BIGNUM,
        to: *mut ::aya_ebpf::cty::c_uchar,
        tolen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mpi2bn(s: *const ::aya_ebpf::cty::c_uchar, len: ::aya_ebpf::cty::c_int, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2mpi(a: *const BIGNUM, to: *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_sub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_usub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_uadd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mul(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_sqr(r: *mut BIGNUM, a: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_set_negative(b: *mut BIGNUM, n: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn BN_is_negative(b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_div(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        d: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_nnmod(r: *mut BIGNUM, m: *const BIGNUM, d: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_add(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_add_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_sub(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_sub_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_sqr(r: *mut BIGNUM, a: *const BIGNUM, m: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1_quick(r: *mut BIGNUM, a: *const BIGNUM, m: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::aya_ebpf::cty::c_int,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_lshift_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::aya_ebpf::cty::c_int,
        m: *const BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_word(a: *const BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn BN_div_word(a: *mut BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn BN_mul_word(a: *mut BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_add_word(a: *mut BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_sub_word(a: *mut BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_set_word(a: *mut BIGNUM, w: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_get_word(a: *const BIGNUM) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn BN_cmp(a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_free(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_is_bit_set(a: *const BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_lshift(r: *mut BIGNUM, a: *const BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_lshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_exp(r: *mut BIGNUM, a: *const BIGNUM, p: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime(
        rr: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        in_mont: *mut BN_MONT_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_word(
        r: *mut BIGNUM,
        a: ::aya_ebpf::cty::c_ulong,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp2_mont(
        r: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        m_ctx: *mut BN_MONT_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_simple(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime_x2(
        rr1: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        m1: *const BIGNUM,
        in_mont1: *mut BN_MONT_CTX,
        rr2: *mut BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m2: *const BIGNUM,
        in_mont2: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mask_bits(a: *mut BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_print_fp(fp: *mut FILE, a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_print(bio: *mut BIO, a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_reciprocal(
        r: *mut BIGNUM,
        m: *const BIGNUM,
        len: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_rshift(r: *mut BIGNUM, a: *const BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_rshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_clear(a: *mut BIGNUM);
}
extern "C" {
    pub fn BN_dup(a: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_ucmp(a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_set_bit(a: *mut BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_clear_bit(a: *mut BIGNUM, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_bn2hex(a: *const BIGNUM) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BN_bn2dec(a: *const BIGNUM) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn BN_hex2bn(a: *mut *mut BIGNUM, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_dec2bn(a: *mut *mut BIGNUM, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_asc2bn(a: *mut *mut BIGNUM, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_gcd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_kronecker(a: *const BIGNUM, b: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_are_coprime(a: *mut BIGNUM, b: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_inverse(ret: *mut BIGNUM, a: *const BIGNUM, n: *const BIGNUM, ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_sqrt(ret: *mut BIGNUM, a: *const BIGNUM, n: *const BIGNUM, ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_consttime_swap(
        swap: ::aya_ebpf::cty::c_ulong,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        nwords: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn BN_generate_prime(
        ret: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        safe: ::aya_ebpf::cty::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_is_prime(
        p: *const BIGNUM,
        nchecks: ::aya_ebpf::cty::c_int,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest(
        p: *const BIGNUM,
        nchecks: ::aya_ebpf::cty::c_int,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        ctx: *mut BN_CTX,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
        do_trial_division: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_prime_ex(
        p: *const BIGNUM,
        nchecks: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest_ex(
        p: *const BIGNUM,
        nchecks: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::aya_ebpf::cty::c_int,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_generate_prime_ex2(
        ret: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        safe: ::aya_ebpf::cty::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_generate_prime_ex(
        ret: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        safe: ::aya_ebpf::cty::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_check_prime(p: *const BIGNUM, ctx: *mut BN_CTX, cb: *mut BN_GENCB) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_X931_generate_Xpq(
        Xp: *mut BIGNUM,
        Xq: *mut BIGNUM,
        nbits: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_X931_derive_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp: *const BIGNUM,
        Xp1: *const BIGNUM,
        Xp2: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_X931_generate_prime_ex(
        p: *mut BIGNUM,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        Xp1: *mut BIGNUM,
        Xp2: *mut BIGNUM,
        Xp: *const BIGNUM,
        e: *const BIGNUM,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new() -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_mod_mul_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_to_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_from_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *mut BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_free(mont: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_MONT_CTX_set(mont: *mut BN_MONT_CTX, mod_: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_copy(to: *mut BN_MONT_CTX, from: *mut BN_MONT_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set_locked(
        pmont: *mut *mut BN_MONT_CTX,
        lock: *mut CRYPTO_RWLOCK,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_BLINDING_new(A: *const BIGNUM, Ai: *const BIGNUM, mod_: *mut BIGNUM) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_BLINDING_free(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_update(b: *mut BN_BLINDING, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert(n: *mut BIGNUM, b: *mut BN_BLINDING, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert(n: *mut BIGNUM, b: *mut BN_BLINDING, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_convert_ex(
        n: *mut BIGNUM,
        r: *mut BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_invert_ex(
        n: *mut BIGNUM,
        r: *const BIGNUM,
        b: *mut BN_BLINDING,
        arg1: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_is_current_thread(b: *mut BN_BLINDING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_set_current_thread(b: *mut BN_BLINDING);
}
extern "C" {
    pub fn BN_BLINDING_lock(b: *mut BN_BLINDING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_unlock(b: *mut BN_BLINDING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_BLINDING_get_flags(arg1: *const BN_BLINDING) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn BN_BLINDING_set_flags(arg1: *mut BN_BLINDING, arg2: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn BN_BLINDING_create_param(
        b: *mut BN_BLINDING,
        e: *const BIGNUM,
        m: *mut BIGNUM,
        ctx: *mut BN_CTX,
        bn_mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                r: *mut BIGNUM,
                a: *const BIGNUM,
                p: *const BIGNUM,
                m: *const BIGNUM,
                ctx: *mut BN_CTX,
                m_ctx: *mut BN_MONT_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        m_ctx: *mut BN_MONT_CTX,
    ) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn BN_set_params(
        mul: ::aya_ebpf::cty::c_int,
        high: ::aya_ebpf::cty::c_int,
        low: ::aya_ebpf::cty::c_int,
        mont: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn BN_get_params(which: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_RECP_CTX_new() -> *mut BN_RECP_CTX;
}
extern "C" {
    pub fn BN_RECP_CTX_free(recp: *mut BN_RECP_CTX);
}
extern "C" {
    pub fn BN_RECP_CTX_set(recp: *mut BN_RECP_CTX, rdiv: *const BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_mul_reciprocal(
        r: *mut BIGNUM,
        x: *const BIGNUM,
        y: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_mod_exp_recp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_div_recp(
        dv: *mut BIGNUM,
        rem: *mut BIGNUM,
        m: *const BIGNUM,
        recp: *mut BN_RECP_CTX,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod(r: *mut BIGNUM, a: *const BIGNUM, p: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_arr(r: *mut BIGNUM, a: *const BIGNUM, p: *const ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_mul_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqr_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_inv_arr(
        r: *mut BIGNUM,
        b: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_div_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_exp_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_sqrt_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_mod_solve_quad_arr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_poly2arr(
        a: *const BIGNUM,
        p: *mut ::aya_ebpf::cty::c_int,
        max: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_GF2m_arr2poly(p: *const ::aya_ebpf::cty::c_int, a: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_192(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_224(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_256(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_384(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_nist_mod_521(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_get0_nist_prime_192() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_224() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_256() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_384() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_get0_nist_prime_521() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_nist_mod_func(
        p: *const BIGNUM,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            p: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *const BIGNUM,
            arg3: *mut BN_CTX,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn BN_generate_dsa_nonce(
        out: *mut BIGNUM,
        range: *const BIGNUM,
        priv_: *const BIGNUM,
        message: *const ::aya_ebpf::cty::c_uchar,
        message_len: usize,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BN_get_rfc2409_prime_768(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc2409_prime_1024(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_1536(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_2048(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_3072(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_4096(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_6144(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_8192(bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bntest_rand(
        rnd: *mut BIGNUM,
        bits: ::aya_ebpf::cty::c_int,
        top: ::aya_ebpf::cty::c_int,
        bottom: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_locate(p: *mut OSSL_PARAM, key: *const ::aya_ebpf::cty::c_char) -> *mut OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_locate_const(p: *const OSSL_PARAM, key: *const ::aya_ebpf::cty::c_char) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_int(key: *const ::aya_ebpf::cty::c_char, buf: *mut ::aya_ebpf::cty::c_int) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_uint(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_uint,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_long(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_long,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_ulong(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_ulong,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_int32(key: *const ::aya_ebpf::cty::c_char, buf: *mut i32) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_uint32(key: *const ::aya_ebpf::cty::c_char, buf: *mut u32) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_int64(key: *const ::aya_ebpf::cty::c_char, buf: *mut i64) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_uint64(key: *const ::aya_ebpf::cty::c_char, buf: *mut u64) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_size_t(key: *const ::aya_ebpf::cty::c_char, buf: *mut usize) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_time_t(key: *const ::aya_ebpf::cty::c_char, buf: *mut time_t) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_BN(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_uchar,
        bsize: usize,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_double(key: *const ::aya_ebpf::cty::c_char, buf: *mut f64) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_utf8_string(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_char,
        bsize: usize,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_utf8_ptr(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut *mut ::aya_ebpf::cty::c_char,
        bsize: usize,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_octet_string(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_void,
        bsize: usize,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_octet_ptr(
        key: *const ::aya_ebpf::cty::c_char,
        buf: *mut *mut ::aya_ebpf::cty::c_void,
        bsize: usize,
    ) -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_construct_end() -> OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_allocate_from_text(
        to: *mut OSSL_PARAM,
        paramdefs: *const OSSL_PARAM,
        key: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
        value_n: usize,
        found: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_int(p: *const OSSL_PARAM, val: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_uint(p: *const OSSL_PARAM, val: *mut ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_long(p: *const OSSL_PARAM, val: *mut ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_ulong(p: *const OSSL_PARAM, val: *mut ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_int32(p: *const OSSL_PARAM, val: *mut i32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_uint32(p: *const OSSL_PARAM, val: *mut u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_int64(p: *const OSSL_PARAM, val: *mut i64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_uint64(p: *const OSSL_PARAM, val: *mut u64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_size_t(p: *const OSSL_PARAM, val: *mut usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_time_t(p: *const OSSL_PARAM, val: *mut time_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_int(p: *mut OSSL_PARAM, val: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_uint(p: *mut OSSL_PARAM, val: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_long(p: *mut OSSL_PARAM, val: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_ulong(p: *mut OSSL_PARAM, val: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_int32(p: *mut OSSL_PARAM, val: i32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_uint32(p: *mut OSSL_PARAM, val: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_int64(p: *mut OSSL_PARAM, val: i64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_uint64(p: *mut OSSL_PARAM, val: u64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_size_t(p: *mut OSSL_PARAM, val: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_time_t(p: *mut OSSL_PARAM, val: time_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_double(p: *const OSSL_PARAM, val: *mut f64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_double(p: *mut OSSL_PARAM, val: f64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_BN(p: *const OSSL_PARAM, val: *mut *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_BN(p: *mut OSSL_PARAM, val: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_utf8_string(
        p: *const OSSL_PARAM,
        val: *mut *mut ::aya_ebpf::cty::c_char,
        max_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_utf8_string(p: *mut OSSL_PARAM, val: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_octet_string(
        p: *const OSSL_PARAM,
        val: *mut *mut ::aya_ebpf::cty::c_void,
        max_len: usize,
        used_len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_octet_string(
        p: *mut OSSL_PARAM,
        val: *const ::aya_ebpf::cty::c_void,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_utf8_ptr(
        p: *const OSSL_PARAM,
        val: *mut *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_utf8_ptr(p: *mut OSSL_PARAM, val: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_octet_ptr(
        p: *const OSSL_PARAM,
        val: *mut *const ::aya_ebpf::cty::c_void,
        used_len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_octet_ptr(
        p: *mut OSSL_PARAM,
        val: *const ::aya_ebpf::cty::c_void,
        used_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_utf8_string_ptr(
        p: *const OSSL_PARAM,
        val: *mut *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_get_octet_string_ptr(
        p: *const OSSL_PARAM,
        val: *mut *const ::aya_ebpf::cty::c_void,
        used_len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_modified(p: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_PARAM_set_all_unmodified(p: *mut OSSL_PARAM);
}
extern "C" {
    pub fn OSSL_PARAM_dup(p: *const OSSL_PARAM) -> *mut OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_merge(p1: *const OSSL_PARAM, p2: *const OSSL_PARAM) -> *mut OSSL_PARAM;
}
extern "C" {
    pub fn OSSL_PARAM_free(p: *mut OSSL_PARAM);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ALGOR {
    _unused: [u8; 0],
}
pub type sk_X509_ALGOR_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_ALGOR, b: *const *const X509_ALGOR) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_ALGOR_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_ALGOR)>;
pub type sk_X509_ALGOR_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const X509_ALGOR) -> *mut X509_ALGOR>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_st {
    pub length: ::aya_ebpf::cty::c_int,
    pub type_: ::aya_ebpf::cty::c_int,
    pub data: *mut ::aya_ebpf::cty::c_uchar,
    pub flags: ::aya_ebpf::cty::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ENCODING_st {
    pub enc: *mut ::aya_ebpf::cty::c_uchar,
    pub len: ::aya_ebpf::cty::c_long,
    pub modified: ::aya_ebpf::cty::c_int,
}
pub type ASN1_ENCODING = ASN1_ENCODING_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_table_st {
    pub nid: ::aya_ebpf::cty::c_int,
    pub minsize: ::aya_ebpf::cty::c_long,
    pub maxsize: ::aya_ebpf::cty::c_long,
    pub mask: ::aya_ebpf::cty::c_ulong,
    pub flags: ::aya_ebpf::cty::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_STRING_TABLE {
    _unused: [u8; 0],
}
pub type sk_ASN1_STRING_TABLE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_STRING_TABLE,
        b: *const *const ASN1_STRING_TABLE,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_STRING_TABLE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_STRING_TABLE)>;
pub type sk_ASN1_STRING_TABLE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_STRING_TABLE) -> *mut ASN1_STRING_TABLE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TEMPLATE_st {
    _unused: [u8; 0],
}
pub type ASN1_TEMPLATE = ASN1_TEMPLATE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TLC_st {
    _unused: [u8; 0],
}
pub type ASN1_TLC = ASN1_TLC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_VALUE_st {
    _unused: [u8; 0],
}
pub type ASN1_VALUE = ASN1_VALUE_st;
pub type d2i_of_void = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut *mut ::aya_ebpf::cty::c_void,
        arg2: *mut *const ::aya_ebpf::cty::c_uchar,
        arg3: ::aya_ebpf::cty::c_long,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type i2d_of_void = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_ebpf::cty::c_void,
        arg2: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type ASN1_ITEM_EXP = ::core::option::Option<unsafe extern "C" fn() -> *const ASN1_ITEM>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_type_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub value: asn1_type_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asn1_type_st__bindgen_ty_1 {
    pub ptr: *mut ::aya_ebpf::cty::c_char,
    pub boolean: ASN1_BOOLEAN,
    pub asn1_string: *mut ASN1_STRING,
    pub object: *mut ASN1_OBJECT,
    pub integer: *mut ASN1_INTEGER,
    pub enumerated: *mut ASN1_ENUMERATED,
    pub bit_string: *mut ASN1_BIT_STRING,
    pub octet_string: *mut ASN1_OCTET_STRING,
    pub printablestring: *mut ASN1_PRINTABLESTRING,
    pub t61string: *mut ASN1_T61STRING,
    pub ia5string: *mut ASN1_IA5STRING,
    pub generalstring: *mut ASN1_GENERALSTRING,
    pub bmpstring: *mut ASN1_BMPSTRING,
    pub universalstring: *mut ASN1_UNIVERSALSTRING,
    pub utctime: *mut ASN1_UTCTIME,
    pub generalizedtime: *mut ASN1_GENERALIZEDTIME,
    pub visiblestring: *mut ASN1_VISIBLESTRING,
    pub utf8string: *mut ASN1_UTF8STRING,
    pub set: *mut ASN1_STRING,
    pub sequence: *mut ASN1_STRING,
    pub asn1_value: *mut ASN1_VALUE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_TYPE {
    _unused: [u8; 0],
}
pub type sk_ASN1_TYPE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ASN1_TYPE, b: *const *const ASN1_TYPE) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_TYPE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_TYPE)>;
pub type sk_ASN1_TYPE_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_TYPE) -> *mut ASN1_TYPE>;
pub type ASN1_SEQUENCE_ANY = stack_st_ASN1_TYPE;
extern "C" {
    pub fn d2i_ASN1_SEQUENCE_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SEQUENCE_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_SEQUENCE_ANY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_SET_ANY(
        a: *mut *mut ASN1_SEQUENCE_ANY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SET_ANY(
        a: *const ASN1_SEQUENCE_ANY,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_SET_ANY_it() -> *const ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BIT_STRING_BITNAME_st {
    pub bitnum: ::aya_ebpf::cty::c_int,
    pub lname: *const ::aya_ebpf::cty::c_char,
    pub sname: *const ::aya_ebpf::cty::c_char,
}
pub type BIT_STRING_BITNAME = BIT_STRING_BITNAME_st;
extern "C" {
    pub fn ASN1_TYPE_new() -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_free(a: *mut ASN1_TYPE);
}
extern "C" {
    pub fn d2i_ASN1_TYPE(
        a: *mut *mut ASN1_TYPE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn i2d_ASN1_TYPE(a: *const ASN1_TYPE, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ANY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TYPE_get(a: *const ASN1_TYPE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set(a: *mut ASN1_TYPE, type_: ::aya_ebpf::cty::c_int, value: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn ASN1_TYPE_set1(
        a: *mut ASN1_TYPE,
        type_: ::aya_ebpf::cty::c_int,
        value: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_cmp(a: *const ASN1_TYPE, b: *const ASN1_TYPE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_pack_sequence(
        it: *const ASN1_ITEM,
        s: *mut ::aya_ebpf::cty::c_void,
        t: *mut *mut ASN1_TYPE,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_unpack_sequence(it: *const ASN1_ITEM, t: *const ASN1_TYPE) -> *mut ::aya_ebpf::cty::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_OBJECT {
    _unused: [u8; 0],
}
pub type sk_ASN1_OBJECT_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ASN1_OBJECT, b: *const *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_OBJECT_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_OBJECT)>;
pub type sk_ASN1_OBJECT_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_OBJECT) -> *mut ASN1_OBJECT>;
extern "C" {
    pub fn ASN1_OBJECT_new() -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_OBJECT_free(a: *mut ASN1_OBJECT);
}
extern "C" {
    pub fn d2i_ASN1_OBJECT(
        a: *mut *mut ASN1_OBJECT,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn i2d_ASN1_OBJECT(a: *const ASN1_OBJECT, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_OBJECT_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_STRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_clear_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_copy(dst: *mut ASN1_STRING, str_: *const ASN1_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_dup(a: *const ASN1_STRING) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_type_new(type_: ::aya_ebpf::cty::c_int) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_cmp(a: *const ASN1_STRING, b: *const ASN1_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set(
        str_: *mut ASN1_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set0(str_: *mut ASN1_STRING, data: *mut ::aya_ebpf::cty::c_void, len: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn ASN1_STRING_length(x: *const ASN1_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_length_set(x: *mut ASN1_STRING, n: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn ASN1_STRING_type(x: *const ASN1_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_data(x: *mut ASN1_STRING) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_get0_data(x: *const ASN1_STRING) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn ASN1_BIT_STRING_new() -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_free(a: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn d2i_ASN1_BIT_STRING(
        a: *mut *mut ASN1_BIT_STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2d_ASN1_BIT_STRING(
        a: *const ASN1_BIT_STRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set(
        a: *mut ASN1_BIT_STRING,
        d: *mut ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_bit(
        a: *mut ASN1_BIT_STRING,
        n: ::aya_ebpf::cty::c_int,
        value: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_get_bit(a: *const ASN1_BIT_STRING, n: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_check(
        a: *const ASN1_BIT_STRING,
        flags: *const ::aya_ebpf::cty::c_uchar,
        flags_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_name_print(
        out: *mut BIO,
        bs: *mut ASN1_BIT_STRING,
        tbl: *mut BIT_STRING_BITNAME,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_num_asc(
        name: *const ::aya_ebpf::cty::c_char,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_asc(
        bs: *mut ASN1_BIT_STRING,
        name: *const ::aya_ebpf::cty::c_char,
        value: ::aya_ebpf::cty::c_int,
        tbl: *mut BIT_STRING_BITNAME,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_INTEGER {
    _unused: [u8; 0],
}
pub type sk_ASN1_INTEGER_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ASN1_INTEGER, b: *const *const ASN1_INTEGER) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_INTEGER_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_INTEGER)>;
pub type sk_ASN1_INTEGER_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_INTEGER) -> *mut ASN1_INTEGER>;
extern "C" {
    pub fn ASN1_INTEGER_new() -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_free(a: *mut ASN1_INTEGER);
}
extern "C" {
    pub fn d2i_ASN1_INTEGER(
        a: *mut *mut ASN1_INTEGER,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2d_ASN1_INTEGER(a: *const ASN1_INTEGER, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn d2i_ASN1_UINTEGER(
        a: *mut *mut ASN1_INTEGER,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_dup(a: *const ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_cmp(x: *const ASN1_INTEGER, y: *const ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_new() -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_free(a: *mut ASN1_ENUMERATED);
}
extern "C" {
    pub fn d2i_ASN1_ENUMERATED(
        a: *mut *mut ASN1_ENUMERATED,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn i2d_ASN1_ENUMERATED(
        a: *const ASN1_ENUMERATED,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_check(a: *const ASN1_UTCTIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_set(s: *mut ASN1_UTCTIME, t: time_t) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_adj(
        s: *mut ASN1_UTCTIME,
        t: time_t,
        offset_day: ::aya_ebpf::cty::c_int,
        offset_sec: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_set_string(s: *mut ASN1_UTCTIME, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_cmp_time_t(s: *const ASN1_UTCTIME, t: time_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_check(a: *const ASN1_GENERALIZEDTIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set(s: *mut ASN1_GENERALIZEDTIME, t: time_t) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_adj(
        s: *mut ASN1_GENERALIZEDTIME,
        t: time_t,
        offset_day: ::aya_ebpf::cty::c_int,
        offset_sec: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set_string(
        s: *mut ASN1_GENERALIZEDTIME,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_diff(
        pday: *mut ::aya_ebpf::cty::c_int,
        psec: *mut ::aya_ebpf::cty::c_int,
        from: *const ASN1_TIME,
        to: *const ASN1_TIME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_new() -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_free(a: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn d2i_ASN1_OCTET_STRING(
        a: *mut *mut ASN1_OCTET_STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn i2d_ASN1_OCTET_STRING(
        a: *const ASN1_OCTET_STRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_dup(a: *const ASN1_OCTET_STRING) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_cmp(a: *const ASN1_OCTET_STRING, b: *const ASN1_OCTET_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_set(
        str_: *mut ASN1_OCTET_STRING,
        data: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_UTF8STRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_UTF8STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ASN1_UTF8STRING, b: *const *const ASN1_UTF8STRING) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_UTF8STRING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_UTF8STRING)>;
pub type sk_ASN1_UTF8STRING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_UTF8STRING) -> *mut ASN1_UTF8STRING>;
extern "C" {
    pub fn ASN1_VISIBLESTRING_new() -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_free(a: *mut ASN1_VISIBLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_VISIBLESTRING(
        a: *mut *mut ASN1_VISIBLESTRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_VISIBLESTRING(
        a: *const ASN1_VISIBLESTRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_new() -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_free(a: *mut ASN1_UNIVERSALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_UNIVERSALSTRING(
        a: *mut *mut ASN1_UNIVERSALSTRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_UNIVERSALSTRING(
        a: *const ASN1_UNIVERSALSTRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTF8STRING_new() -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn ASN1_UTF8STRING_free(a: *mut ASN1_UTF8STRING);
}
extern "C" {
    pub fn d2i_ASN1_UTF8STRING(
        a: *mut *mut ASN1_UTF8STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn i2d_ASN1_UTF8STRING(
        a: *const ASN1_UTF8STRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTF8STRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_NULL_new() -> *mut ASN1_NULL;
}
extern "C" {
    pub fn ASN1_NULL_free(a: *mut ASN1_NULL);
}
extern "C" {
    pub fn d2i_ASN1_NULL(
        a: *mut *mut ASN1_NULL,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_NULL;
}
extern "C" {
    pub fn i2d_ASN1_NULL(a: *const ASN1_NULL, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_NULL_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BMPSTRING_new() -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn ASN1_BMPSTRING_free(a: *mut ASN1_BMPSTRING);
}
extern "C" {
    pub fn d2i_ASN1_BMPSTRING(
        a: *mut *mut ASN1_BMPSTRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn i2d_ASN1_BMPSTRING(
        a: *const ASN1_BMPSTRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_BMPSTRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn UTF8_getc(
        str_: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        val: *mut ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UTF8_putc(
        str_: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        value: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_GENERALSTRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_GENERALSTRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ASN1_GENERALSTRING,
        b: *const *const ASN1_GENERALSTRING,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_GENERALSTRING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_GENERALSTRING)>;
pub type sk_ASN1_GENERALSTRING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_GENERALSTRING) -> *mut ASN1_GENERALSTRING>;
extern "C" {
    pub fn ASN1_PRINTABLE_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLE_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLE(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLE(a: *const ASN1_STRING, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn DIRECTORYSTRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DIRECTORYSTRING_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DIRECTORYSTRING(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DIRECTORYSTRING(a: *const ASN1_STRING, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DIRECTORYSTRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn DISPLAYTEXT_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DISPLAYTEXT_free(a: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DISPLAYTEXT(
        a: *mut *mut ASN1_STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DISPLAYTEXT(a: *const ASN1_STRING, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DISPLAYTEXT_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_new() -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_free(a: *mut ASN1_PRINTABLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLESTRING(
        a: *mut *mut ASN1_PRINTABLESTRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLESTRING(
        a: *const ASN1_PRINTABLESTRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_T61STRING_new() -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn ASN1_T61STRING_free(a: *mut ASN1_T61STRING);
}
extern "C" {
    pub fn d2i_ASN1_T61STRING(
        a: *mut *mut ASN1_T61STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn i2d_ASN1_T61STRING(
        a: *const ASN1_T61STRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_T61STRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_IA5STRING_new() -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn ASN1_IA5STRING_free(a: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn d2i_ASN1_IA5STRING(
        a: *mut *mut ASN1_IA5STRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn i2d_ASN1_IA5STRING(
        a: *const ASN1_IA5STRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_IA5STRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_new() -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_free(a: *mut ASN1_GENERALSTRING);
}
extern "C" {
    pub fn d2i_ASN1_GENERALSTRING(
        a: *mut *mut ASN1_GENERALSTRING,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn i2d_ASN1_GENERALSTRING(
        a: *const ASN1_GENERALSTRING,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_new() -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_free(a: *mut ASN1_UTCTIME);
}
extern "C" {
    pub fn d2i_ASN1_UTCTIME(
        a: *mut *mut ASN1_UTCTIME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn i2d_ASN1_UTCTIME(a: *const ASN1_UTCTIME, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_new() -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_free(a: *mut ASN1_GENERALIZEDTIME);
}
extern "C" {
    pub fn d2i_ASN1_GENERALIZEDTIME(
        a: *mut *mut ASN1_GENERALIZEDTIME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn i2d_ASN1_GENERALIZEDTIME(
        a: *const ASN1_GENERALIZEDTIME,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_new() -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_free(a: *mut ASN1_TIME);
}
extern "C" {
    pub fn d2i_ASN1_TIME(
        a: *mut *mut ASN1_TIME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn i2d_ASN1_TIME(a: *const ASN1_TIME, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_dup(a: *const ASN1_TIME) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_dup(a: *const ASN1_UTCTIME) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_dup(a: *const ASN1_GENERALIZEDTIME) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_NDEF_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_set(s: *mut ASN1_TIME, t: time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_adj(
        s: *mut ASN1_TIME,
        t: time_t,
        offset_day: ::aya_ebpf::cty::c_int,
        offset_sec: ::aya_ebpf::cty::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_check(t: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_generalizedtime(
        t: *const ASN1_TIME,
        out: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_TIME_set_string(s: *mut ASN1_TIME, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_set_string_X509(s: *mut ASN1_TIME, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_tm(s: *const ASN1_TIME, tm: *mut tm) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_normalize(s: *mut ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_cmp_time_t(s: *const ASN1_TIME, t: time_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_compare(a: *const ASN1_TIME, b: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_INTEGER(bp: *mut BIO, a: *const ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn a2i_ASN1_INTEGER(
        bp: *mut BIO,
        bs: *mut ASN1_INTEGER,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_ENUMERATED(bp: *mut BIO, a: *const ASN1_ENUMERATED) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn a2i_ASN1_ENUMERATED(
        bp: *mut BIO,
        bs: *mut ASN1_ENUMERATED,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_OBJECT(bp: *mut BIO, a: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn a2i_ASN1_STRING(
        bp: *mut BIO,
        bs: *mut ASN1_STRING,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2a_ASN1_STRING(bp: *mut BIO, a: *const ASN1_STRING, type_: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2t_ASN1_OBJECT(
        buf: *mut ::aya_ebpf::cty::c_char,
        buf_len: ::aya_ebpf::cty::c_int,
        a: *const ASN1_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn a2d_ASN1_OBJECT(
        out: *mut ::aya_ebpf::cty::c_uchar,
        olen: ::aya_ebpf::cty::c_int,
        buf: *const ::aya_ebpf::cty::c_char,
        num: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_OBJECT_create(
        nid: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        sn: *const ::aya_ebpf::cty::c_char,
        ln: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_INTEGER_get_int64(pr: *mut i64, a: *const ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_int64(a: *mut ASN1_INTEGER, r: i64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get_uint64(pr: *mut u64, a: *const ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_uint64(a: *mut ASN1_INTEGER, r: u64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set(a: *mut ASN1_INTEGER, v: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get(a: *const ASN1_INTEGER) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_INTEGER(bn: *const BIGNUM, ai: *mut ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_to_BN(ai: *const ASN1_INTEGER, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get_int64(pr: *mut i64, a: *const ASN1_ENUMERATED) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set_int64(a: *mut ASN1_ENUMERATED, r: i64) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set(a: *mut ASN1_ENUMERATED, v: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get(a: *const ASN1_ENUMERATED) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn BN_to_ASN1_ENUMERATED(bn: *const BIGNUM, ai: *mut ASN1_ENUMERATED) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_to_BN(ai: *const ASN1_ENUMERATED, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_PRINTABLE_type(s: *const ::aya_ebpf::cty::c_uchar, max: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_tag2bit(tag: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_get_object(
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        plength: *mut ::aya_ebpf::cty::c_long,
        ptag: *mut ::aya_ebpf::cty::c_int,
        pclass: *mut ::aya_ebpf::cty::c_int,
        omax: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_check_infinite_end(
        p: *mut *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_const_check_infinite_end(
        p: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_put_object(
        pp: *mut *mut ::aya_ebpf::cty::c_uchar,
        constructed: ::aya_ebpf::cty::c_int,
        length: ::aya_ebpf::cty::c_int,
        tag: ::aya_ebpf::cty::c_int,
        xclass: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn ASN1_put_eoc(pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_object_size(
        constructed: ::aya_ebpf::cty::c_int,
        length: ::aya_ebpf::cty::c_int,
        tag: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_dup(
        i2d: i2d_of_void,
        d2i: d2i_of_void,
        x: *const ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_dup(it: *const ASN1_ITEM, x: *const ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_sign_ex(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        id: *const ASN1_OCTET_STRING,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_verify_ex(
        it: *const ASN1_ITEM,
        alg: *const X509_ALGOR,
        signature: *const ASN1_BIT_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        id: *const ASN1_OCTET_STRING,
        pkey: *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_d2i_fp(
        xnew: ::core::option::Option<unsafe extern "C" fn() -> *mut ::aya_ebpf::cty::c_void>,
        d2i: d2i_of_void,
        in_: *mut FILE,
        x: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp_ex(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        x: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        x: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_i2d_fp(i2d: i2d_of_void, out: *mut FILE, x: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_fp(
        it: *const ASN1_ITEM,
        out: *mut FILE,
        x: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex_fp(
        fp: *mut FILE,
        str_: *const ASN1_STRING,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_to_UTF8(
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
        in_: *const ASN1_STRING,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_d2i_bio(
        xnew: ::core::option::Option<unsafe extern "C" fn() -> *mut ::aya_ebpf::cty::c_void>,
        d2i: d2i_of_void,
        in_: *mut BIO,
        x: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio_ex(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        pval: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        pval: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_i2d_bio(i2d: i2d_of_void, out: *mut BIO, x: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_bio(
        it: *const ASN1_ITEM,
        out: *mut BIO,
        x: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_mem_bio(it: *const ASN1_ITEM, val: *const ASN1_VALUE) -> *mut BIO;
}
extern "C" {
    pub fn ASN1_UTCTIME_print(fp: *mut BIO, a: *const ASN1_UTCTIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_print(fp: *mut BIO, a: *const ASN1_GENERALIZEDTIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print(bp: *mut BIO, tm: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print_ex(
        bp: *mut BIO,
        tm: *const ASN1_TIME,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print(bp: *mut BIO, v: *const ASN1_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex(
        out: *mut BIO,
        str_: *const ASN1_STRING,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_buf_print(
        bp: *mut BIO,
        buf: *const ::aya_ebpf::cty::c_uchar,
        buflen: usize,
        off: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_bn_print(
        bp: *mut BIO,
        number: *const ::aya_ebpf::cty::c_char,
        num: *const BIGNUM,
        buf: *mut ::aya_ebpf::cty::c_uchar,
        off: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_parse(
        bp: *mut BIO,
        pp: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_parse_dump(
        bp: *mut BIO,
        pp: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
        indent: ::aya_ebpf::cty::c_int,
        dump: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_tag2str(tag: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_to_string(s: *mut ASN1_UNIVERSALSTRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_octetstring(
        a: *mut ASN1_TYPE,
        data: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_octetstring(
        a: *const ASN1_TYPE,
        data: *mut ::aya_ebpf::cty::c_uchar,
        max_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set_int_octetstring(
        a: *mut ASN1_TYPE,
        num: ::aya_ebpf::cty::c_long,
        data: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_get_int_octetstring(
        a: *const ASN1_TYPE,
        num: *mut ::aya_ebpf::cty::c_long,
        data: *mut ::aya_ebpf::cty::c_uchar,
        max_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_unpack(oct: *const ASN1_STRING, it: *const ASN1_ITEM) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ASN1_item_pack(
        obj: *mut ::aya_ebpf::cty::c_void,
        it: *const ASN1_ITEM,
        oct: *mut *mut ASN1_OCTET_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask(mask: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask_asc(p: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get_default_mask() -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_mbstring_copy(
        out: *mut *mut ASN1_STRING,
        in_: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        inform: ::aya_ebpf::cty::c_int,
        mask: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_ncopy(
        out: *mut *mut ASN1_STRING,
        in_: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        inform: ::aya_ebpf::cty::c_int,
        mask: ::aya_ebpf::cty::c_ulong,
        minsize: ::aya_ebpf::cty::c_long,
        maxsize: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_by_NID(
        out: *mut *mut ASN1_STRING,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: ::aya_ebpf::cty::c_int,
        inform: ::aya_ebpf::cty::c_int,
        nid: ::aya_ebpf::cty::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_get(nid: ::aya_ebpf::cty::c_int) -> *mut ASN1_STRING_TABLE;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_add(
        arg1: ::aya_ebpf::cty::c_int,
        arg2: ::aya_ebpf::cty::c_long,
        arg3: ::aya_ebpf::cty::c_long,
        arg4: ::aya_ebpf::cty::c_ulong,
        arg5: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_cleanup();
}
extern "C" {
    pub fn ASN1_item_new(it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_new_ex(
        it: *const ASN1_ITEM,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_free(val: *mut ASN1_VALUE, it: *const ASN1_ITEM);
}
extern "C" {
    pub fn ASN1_item_d2i_ex(
        val: *mut *mut ASN1_VALUE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
        it: *const ASN1_ITEM,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_d2i(
        val: *mut *mut ASN1_VALUE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_i2d(
        val: *const ASN1_VALUE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_ndef_i2d(
        val: *const ASN1_VALUE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_add_oid_module();
}
extern "C" {
    pub fn ASN1_add_stable_module();
}
extern "C" {
    pub fn ASN1_generate_nconf(str_: *const ::aya_ebpf::cty::c_char, nconf: *mut CONF) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_generate_v3(str_: *const ::aya_ebpf::cty::c_char, cnf: *mut X509V3_CTX) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_str2mask(
        str_: *const ::aya_ebpf::cty::c_char,
        pmask: *mut ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_print(
        out: *mut BIO,
        ifld: *const ASN1_VALUE,
        indent: ::aya_ebpf::cty::c_int,
        it: *const ASN1_ITEM,
        pctx: *const ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_PCTX_new() -> *mut ASN1_PCTX;
}
extern "C" {
    pub fn ASN1_PCTX_free(p: *mut ASN1_PCTX);
}
extern "C" {
    pub fn ASN1_PCTX_get_flags(p: *const ASN1_PCTX) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_flags(p: *mut ASN1_PCTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_nm_flags(p: *const ASN1_PCTX) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_nm_flags(p: *mut ASN1_PCTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_cert_flags(p: *const ASN1_PCTX) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_cert_flags(p: *mut ASN1_PCTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_oid_flags(p: *const ASN1_PCTX) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_oid_flags(p: *mut ASN1_PCTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_PCTX_get_str_flags(p: *const ASN1_PCTX) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_PCTX_set_str_flags(p: *mut ASN1_PCTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ASN1_SCTX_new(
        scan_cb: ::core::option::Option<unsafe extern "C" fn(ctx: *mut ASN1_SCTX) -> ::aya_ebpf::cty::c_int>,
    ) -> *mut ASN1_SCTX;
}
extern "C" {
    pub fn ASN1_SCTX_free(p: *mut ASN1_SCTX);
}
extern "C" {
    pub fn ASN1_SCTX_get_item(p: *mut ASN1_SCTX) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_SCTX_get_template(p: *mut ASN1_SCTX) -> *const ASN1_TEMPLATE;
}
extern "C" {
    pub fn ASN1_SCTX_get_flags(p: *mut ASN1_SCTX) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ASN1_SCTX_set_app_data(p: *mut ASN1_SCTX, data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn ASN1_SCTX_get_app_data(p: *mut ASN1_SCTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn BIO_f_asn1() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_NDEF(out: *mut BIO, val: *mut ASN1_VALUE, it: *const ASN1_ITEM) -> *mut BIO;
}
extern "C" {
    pub fn i2d_ASN1_bio_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
        it: *const ASN1_ITEM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_ASN1_stream(
        out: *mut BIO,
        val: *mut ASN1_VALUE,
        in_: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
        hdr: *const ::aya_ebpf::cty::c_char,
        it: *const ASN1_ITEM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SMIME_write_ASN1(
        bio: *mut BIO,
        val: *mut ASN1_VALUE,
        data: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
        ctype_nid: ::aya_ebpf::cty::c_int,
        econt_nid: ::aya_ebpf::cty::c_int,
        mdalgs: *mut stack_st_X509_ALGOR,
        it: *const ASN1_ITEM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SMIME_write_ASN1_ex(
        bio: *mut BIO,
        val: *mut ASN1_VALUE,
        data: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
        ctype_nid: ::aya_ebpf::cty::c_int,
        econt_nid: ::aya_ebpf::cty::c_int,
        mdalgs: *mut stack_st_X509_ALGOR,
        it: *const ASN1_ITEM,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SMIME_read_ASN1(bio: *mut BIO, bcont: *mut *mut BIO, it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn SMIME_read_ASN1_ex(
        bio: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
        bcont: *mut *mut BIO,
        it: *const ASN1_ITEM,
        x: *mut *mut ASN1_VALUE,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn SMIME_crlf_copy(in_: *mut BIO, out: *mut BIO, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SMIME_text(in_: *mut BIO, out: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_ITEM_lookup(name: *const ::aya_ebpf::cty::c_char) -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_ITEM_get(i: usize) -> *const ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obj_name_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub alias: ::aya_ebpf::cty::c_int,
    pub name: *const ::aya_ebpf::cty::c_char,
    pub data: *const ::aya_ebpf::cty::c_char,
}
pub type OBJ_NAME = obj_name_st;
extern "C" {
    pub fn OBJ_NAME_init() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_new_index(
        hash_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_ulong,
        >,
        cmp_func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_char,
                arg2: *const ::aya_ebpf::cty::c_char,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        free_func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_char,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *const ::aya_ebpf::cty::c_char,
            ),
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_get(
        name: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OBJ_NAME_add(
        name: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_remove(name: *const ::aya_ebpf::cty::c_char, type_: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_NAME_cleanup(type_: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn OBJ_NAME_do_all(
        type_: ::aya_ebpf::cty::c_int,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn OBJ_NAME_do_all_sorted(
        type_: ::aya_ebpf::cty::c_int,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn OBJ_dup(a: *const ASN1_OBJECT) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2obj(n: ::aya_ebpf::cty::c_int) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2ln(n: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OBJ_nid2sn(n: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OBJ_obj2nid(o: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_txt2obj(s: *const ::aya_ebpf::cty::c_char, no_name: ::aya_ebpf::cty::c_int) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_obj2txt(
        buf: *mut ::aya_ebpf::cty::c_char,
        buf_len: ::aya_ebpf::cty::c_int,
        a: *const ASN1_OBJECT,
        no_name: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_txt2nid(s: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_ln2nid(s: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_sn2nid(s: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_cmp(a: *const ASN1_OBJECT, b: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_bsearch_(
        key: *const ::aya_ebpf::cty::c_void,
        base: *const ::aya_ebpf::cty::c_void,
        num: ::aya_ebpf::cty::c_int,
        size: ::aya_ebpf::cty::c_int,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_void,
                arg2: *const ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> *const ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OBJ_bsearch_ex_(
        key: *const ::aya_ebpf::cty::c_void,
        base: *const ::aya_ebpf::cty::c_void,
        num: ::aya_ebpf::cty::c_int,
        size: ::aya_ebpf::cty::c_int,
        cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_void,
                arg2: *const ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        flags: ::aya_ebpf::cty::c_int,
    ) -> *const ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OBJ_new_nid(num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_add_object(obj: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_create(
        oid: *const ::aya_ebpf::cty::c_char,
        sn: *const ::aya_ebpf::cty::c_char,
        ln: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_create_objects(in_: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_length(obj: *const ASN1_OBJECT) -> usize;
}
extern "C" {
    pub fn OBJ_get0_data(obj: *const ASN1_OBJECT) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn OBJ_find_sigid_algs(
        signid: ::aya_ebpf::cty::c_int,
        pdig_nid: *mut ::aya_ebpf::cty::c_int,
        ppkey_nid: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_by_algs(
        psignid: *mut ::aya_ebpf::cty::c_int,
        dig_nid: ::aya_ebpf::cty::c_int,
        pkey_nid: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_add_sigid(
        signid: ::aya_ebpf::cty::c_int,
        dig_id: ::aya_ebpf::cty::c_int,
        pkey_id: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OBJ_sigid_free();
}
extern "C" {
    pub fn EVP_set_default_properties(
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_default_properties_is_fips_enabled(libctx: *mut OSSL_LIB_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_default_properties_enable_fips(
        libctx: *mut OSSL_LIB_CTX,
        enable: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_new(md_type: ::aya_ebpf::cty::c_int, pkey_type: ::aya_ebpf::cty::c_int) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_meth_dup(md: *const EVP_MD) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_meth_free(md: *mut EVP_MD);
}
extern "C" {
    pub fn EVP_MD_meth_set_input_blocksize(md: *mut EVP_MD, blocksize: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_result_size(md: *mut EVP_MD, resultsize: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_app_datasize(md: *mut EVP_MD, datasize: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_flags(md: *mut EVP_MD, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_init(
        md: *mut EVP_MD,
        init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_update(
        md: *mut EVP_MD,
        update: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                data: *const ::aya_ebpf::cty::c_void,
                count: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_final(
        md: *mut EVP_MD,
        final_: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_MD_CTX, md: *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_copy(
        md: *mut EVP_MD,
        copy: ::core::option::Option<
            unsafe extern "C" fn(to: *mut EVP_MD_CTX, from: *const EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_cleanup(
        md: *mut EVP_MD,
        cleanup: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_set_ctrl(
        md: *mut EVP_MD,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                cmd: ::aya_ebpf::cty::c_int,
                p1: ::aya_ebpf::cty::c_int,
                p2: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_input_blocksize(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_result_size(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_app_datasize(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_flags(md: *const EVP_MD) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn EVP_MD_meth_get_init(
        md: *const EVP_MD,
    ) -> ::core::option::Option<unsafe extern "C" fn(md: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn EVP_MD_meth_get_update(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: *const ::aya_ebpf::cty::c_void,
            arg2: usize,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_final(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(md: *mut EVP_MD_CTX, arg1: *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_copy(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(md: *mut EVP_MD_CTX, arg1: *const EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_meth_get_cleanup(
        md: *const EVP_MD,
    ) -> ::core::option::Option<unsafe extern "C" fn(md: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn EVP_MD_meth_get_ctrl(
        md: *const EVP_MD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            md: *mut EVP_MD_CTX,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: *mut ::aya_ebpf::cty::c_void,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_new(
        cipher_type: ::aya_ebpf::cty::c_int,
        block_size: ::aya_ebpf::cty::c_int,
        key_len: ::aya_ebpf::cty::c_int,
    ) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_meth_dup(cipher: *const EVP_CIPHER) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_meth_free(cipher: *mut EVP_CIPHER);
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_iv_length(
        cipher: *mut EVP_CIPHER,
        iv_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_flags(cipher: *mut EVP_CIPHER, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_impl_ctx_size(
        cipher: *mut EVP_CIPHER,
        ctx_size: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_init(
        cipher: *mut EVP_CIPHER,
        init: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_CIPHER_CTX,
                key: *const ::aya_ebpf::cty::c_uchar,
                iv: *const ::aya_ebpf::cty::c_uchar,
                enc: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_do_cipher(
        cipher: *mut EVP_CIPHER,
        do_cipher: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_CIPHER_CTX,
                out: *mut ::aya_ebpf::cty::c_uchar,
                in_: *const ::aya_ebpf::cty::c_uchar,
                inl: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_cleanup(
        cipher: *mut EVP_CIPHER,
        cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_set_asn1_params(
        cipher: *mut EVP_CIPHER,
        set_asn1_parameters: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX, arg2: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_get_asn1_params(
        cipher: *mut EVP_CIPHER,
        get_asn1_parameters: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut EVP_CIPHER_CTX, arg2: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_set_ctrl(
        cipher: *mut EVP_CIPHER,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut EVP_CIPHER_CTX,
                type_: ::aya_ebpf::cty::c_int,
                arg: ::aya_ebpf::cty::c_int,
                ptr: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_init(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: *const ::aya_ebpf::cty::c_uchar,
            arg3: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_do_cipher(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: *mut ::aya_ebpf::cty::c_uchar,
            arg2: *const ::aya_ebpf::cty::c_uchar,
            arg3: usize,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_cleanup(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<unsafe extern "C" fn(cipher: *mut EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_set_asn1_params(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(cipher: *mut EVP_CIPHER_CTX, arg1: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_get_asn1_params(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(cipher: *mut EVP_CIPHER_CTX, arg1: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_CIPHER_meth_get_ctrl(
        cipher: *const EVP_CIPHER,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            cipher: *mut EVP_CIPHER_CTX,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: *mut ::aya_ebpf::cty::c_void,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM {
    pub out: *mut ::aya_ebpf::cty::c_uchar,
    pub inp: *const ::aya_ebpf::cty::c_uchar,
    pub len: usize,
    pub interleave: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_info_st {
    pub cipher: *const EVP_CIPHER,
    pub iv: [::aya_ebpf::cty::c_uchar; 16usize],
}
pub type EVP_CIPHER_INFO = evp_cipher_info_st;
pub type EVP_PBE_KEYGEN = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type EVP_PBE_KEYGEN_EX = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn EVP_MD_get_type(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_get0_name(md: *const EVP_MD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_MD_get0_description(md: *const EVP_MD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_MD_is_a(md: *const EVP_MD, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_names_do_all(
        md: *const EVP_MD,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_get0_provider(md: *const EVP_MD) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_MD_get_pkey_type(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_get_size(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_get_block_size(md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_get_flags(md: *const EVP_MD) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn EVP_MD_CTX_get0_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_get1_md(ctx: *mut EVP_MD_CTX) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_update_fn(
        ctx: *mut EVP_MD_CTX,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            arg1: *const ::aya_ebpf::cty::c_void,
            arg2: usize,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn EVP_MD_CTX_set_update_fn(
        ctx: *mut EVP_MD_CTX,
        update: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                data: *const ::aya_ebpf::cty::c_void,
                count: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_MD_CTX_get_pkey_ctx(ctx: *const EVP_MD_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_set_pkey_ctx(ctx: *mut EVP_MD_CTX, pctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_get0_md_data(ctx: *const EVP_MD_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_get_nid(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get0_name(cipher: *const EVP_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_CIPHER_get0_description(cipher: *const EVP_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_CIPHER_is_a(cipher: *const EVP_CIPHER, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_names_do_all(
        cipher: *const EVP_CIPHER,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get0_provider(cipher: *const EVP_CIPHER) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_CIPHER_get_block_size(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_impl_ctx_size(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_key_length(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_iv_length(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_flags(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn EVP_CIPHER_get_mode(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_type(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_up_ref(cipher: *mut EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_free(cipher: *mut EVP_CIPHER);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get0_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get1_cipher(ctx: *mut EVP_CIPHER_CTX) -> *mut EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_is_encrypting(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_nid(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_block_size(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_key_length(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_iv_length(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_tag_length(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv(ctx: *const EVP_CIPHER_CTX) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_original_iv(ctx: *const EVP_CIPHER_CTX) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_noconst(ctx: *mut EVP_CIPHER_CTX) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_updated_iv(
        ctx: *mut EVP_CIPHER_CTX,
        buf: *mut ::aya_ebpf::cty::c_void,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_original_iv(
        ctx: *mut EVP_CIPHER_CTX,
        buf: *mut ::aya_ebpf::cty::c_void,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_buf_noconst(ctx: *mut EVP_CIPHER_CTX) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_num(ctx: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_num(ctx: *mut EVP_CIPHER_CTX, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_dup(in_: *const EVP_CIPHER_CTX) -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_copy(out: *mut EVP_CIPHER_CTX, in_: *const EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_app_data(ctx: *const EVP_CIPHER_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_app_data(ctx: *mut EVP_CIPHER_CTX, data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_cipher_data(ctx: *const EVP_CIPHER_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_cipher_data(
        ctx: *mut EVP_CIPHER_CTX,
        cipher_data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_Cipher(
        c: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_get_params(digest: *const EVP_MD, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_set_params(ctx: *mut EVP_MD_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_get_params(ctx: *mut EVP_MD_CTX, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_gettable_params(digest: *const EVP_MD) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MD_settable_ctx_params(md: *const EVP_MD) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MD_gettable_ctx_params(md: *const EVP_MD) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MD_CTX_settable_params(ctx: *mut EVP_MD_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MD_CTX_gettable_params(ctx: *mut EVP_MD_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MD_CTX_ctrl(
        ctx: *mut EVP_MD_CTX,
        cmd: ::aya_ebpf::cty::c_int,
        p1: ::aya_ebpf::cty::c_int,
        p2: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_new() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_reset(ctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_free(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_dup(in_: *const EVP_MD_CTX) -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_copy_ex(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_set_flags(ctx: *mut EVP_MD_CTX, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_clear_flags(ctx: *mut EVP_MD_CTX, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EVP_MD_CTX_test_flags(ctx: *const EVP_MD_CTX, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex2(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD, impl_: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *const ::aya_ebpf::cty::c_void,
        cnt: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::aya_ebpf::cty::c_uchar,
        s: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_Digest(
        data: *const ::aya_ebpf::cty::c_void,
        count: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
        size: *mut ::aya_ebpf::cty::c_uint,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_Q_digest(
        libctx: *mut OSSL_LIB_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
        data: *const ::aya_ebpf::cty::c_void,
        datalen: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
        mdlen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_copy(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::aya_ebpf::cty::c_uchar,
        s: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestFinalXOF(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_MD;
}
extern "C" {
    pub fn EVP_MD_up_ref(md: *mut EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MD_free(md: *mut EVP_MD);
}
extern "C" {
    pub fn EVP_read_pw_string(
        buf: *mut ::aya_ebpf::cty::c_char,
        length: ::aya_ebpf::cty::c_int,
        prompt: *const ::aya_ebpf::cty::c_char,
        verify: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_read_pw_string_min(
        buf: *mut ::aya_ebpf::cty::c_char,
        minlen: ::aya_ebpf::cty::c_int,
        maxlen: ::aya_ebpf::cty::c_int,
        prompt: *const ::aya_ebpf::cty::c_char,
        verify: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_set_pw_prompt(prompt: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn EVP_get_pw_prompt() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_BytesToKey(
        type_: *const EVP_CIPHER,
        md: *const EVP_MD,
        salt: *const ::aya_ebpf::cty::c_uchar,
        data: *const ::aya_ebpf::cty::c_uchar,
        datal: ::aya_ebpf::cty::c_int,
        count: ::aya_ebpf::cty::c_int,
        key: *mut ::aya_ebpf::cty::c_uchar,
        iv: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_flags(ctx: *mut EVP_CIPHER_CTX, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_clear_flags(ctx: *mut EVP_CIPHER_CTX, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_test_flags(ctx: *const EVP_CIPHER_CTX, flags: ::aya_ebpf::cty::c_int)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex2(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex2(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
        enc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
        enc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex2(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const ::aya_ebpf::cty::c_uchar,
        iv: *const ::aya_ebpf::cty::c_uchar,
        enc: ::aya_ebpf::cty::c_int,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        outm: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SignFinal(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::aya_ebpf::cty::c_uchar,
        s: *mut ::aya_ebpf::cty::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SignFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md: *mut ::aya_ebpf::cty::c_uchar,
        s: *mut ::aya_ebpf::cty::c_uint,
        pkey: *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSign(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sigbuf: *const ::aya_ebpf::cty::c_uchar,
        siglen: ::aya_ebpf::cty::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal_ex(
        ctx: *mut EVP_MD_CTX,
        sigbuf: *const ::aya_ebpf::cty::c_uchar,
        siglen: ::aya_ebpf::cty::c_uint,
        pkey: *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerify(
        ctx: *mut EVP_MD_CTX,
        sigret: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit_ex(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        mdname: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        props: *const ::aya_ebpf::cty::c_char,
        pkey: *mut EVP_PKEY,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSignUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::aya_ebpf::cty::c_void,
        dsize: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestSignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit_ex(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        mdname: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        props: *const ::aya_ebpf::cty::c_char,
        pkey: *mut EVP_PKEY,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::aya_ebpf::cty::c_void,
        dsize: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_OpenInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *const ::aya_ebpf::cty::c_uchar,
        ekl: ::aya_ebpf::cty::c_int,
        iv: *const ::aya_ebpf::cty::c_uchar,
        priv_: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_OpenFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SealInit(
        ctx: *mut EVP_CIPHER_CTX,
        type_: *const EVP_CIPHER,
        ek: *mut *mut ::aya_ebpf::cty::c_uchar,
        ekl: *mut ::aya_ebpf::cty::c_int,
        iv: *mut ::aya_ebpf::cty::c_uchar,
        pubk: *mut *mut EVP_PKEY,
        npubk: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SealFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_new() -> *mut EVP_ENCODE_CTX;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_free(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_ENCODE_CTX_copy(dctx: *mut EVP_ENCODE_CTX, sctx: *const EVP_ENCODE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_num(ctx: *mut EVP_ENCODE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_EncodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn EVP_EncodeBlock(
        t: *mut ::aya_ebpf::cty::c_uchar,
        f: *const ::aya_ebpf::cty::c_uchar,
        n: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_DecodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_DecodeBlock(
        t: *mut ::aya_ebpf::cty::c_uchar,
        f: *const ::aya_ebpf::cty::c_uchar,
        n: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_new() -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_reset(c: *mut EVP_CIPHER_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_free(c: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_key_length(
        x: *mut EVP_CIPHER_CTX,
        keylen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_padding(c: *mut EVP_CIPHER_CTX, pad: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_ctrl(
        ctx: *mut EVP_CIPHER_CTX,
        type_: ::aya_ebpf::cty::c_int,
        arg: ::aya_ebpf::cty::c_int,
        ptr: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_rand_key(
        ctx: *mut EVP_CIPHER_CTX,
        key: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_params(cipher: *mut EVP_CIPHER, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_params(ctx: *mut EVP_CIPHER_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_params(ctx: *mut EVP_CIPHER_CTX, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_gettable_params(cipher: *const EVP_CIPHER) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_CIPHER_settable_ctx_params(cipher: *const EVP_CIPHER) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_CIPHER_gettable_ctx_params(cipher: *const EVP_CIPHER) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_settable_params(ctx: *mut EVP_CIPHER_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_gettable_params(ctx: *mut EVP_CIPHER_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn BIO_f_md() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_base64() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_cipher() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_f_reliable() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_cipher(
        b: *mut BIO,
        c: *const EVP_CIPHER,
        k: *const ::aya_ebpf::cty::c_uchar,
        i: *const ::aya_ebpf::cty::c_uchar,
        enc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_md_null() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md4() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2b512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2s256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake128() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_ripemd160() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_whirlpool() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sm3() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_enc_null() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_desx_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_40() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc4_hmac_md5() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_40_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_64_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cfb64() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap_pad() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ocb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aria_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_camellia_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20_poly1305() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_seed_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_sm4_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_add_cipher(cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_add_digest(digest: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_get_cipherbyname(name: *const ::aya_ebpf::cty::c_char) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_get_digestbyname(name: *const ::aya_ebpf::cty::c_char) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_CIPHER_do_all(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const ::aya_ebpf::cty::c_char,
                to: *const ::aya_ebpf::cty::c_char,
                x: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_CIPHER_do_all_sorted(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_CIPHER,
                from: *const ::aya_ebpf::cty::c_char,
                to: *const ::aya_ebpf::cty::c_char,
                x: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_CIPHER_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(cipher: *mut EVP_CIPHER, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const ::aya_ebpf::cty::c_char,
                to: *const ::aya_ebpf::cty::c_char,
                x: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_sorted(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                ciph: *const EVP_MD,
                from: *const ::aya_ebpf::cty::c_char,
                to: *const ::aya_ebpf::cty::c_char,
                x: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(md: *mut EVP_MD, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MAC_fetch(
        libctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_MAC;
}
extern "C" {
    pub fn EVP_MAC_up_ref(mac: *mut EVP_MAC) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_free(mac: *mut EVP_MAC);
}
extern "C" {
    pub fn EVP_MAC_get0_name(mac: *const EVP_MAC) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_MAC_get0_description(mac: *const EVP_MAC) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_MAC_is_a(mac: *const EVP_MAC, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_get0_provider(mac: *const EVP_MAC) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_MAC_get_params(mac: *mut EVP_MAC, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_CTX_new(mac: *mut EVP_MAC) -> *mut EVP_MAC_CTX;
}
extern "C" {
    pub fn EVP_MAC_CTX_free(ctx: *mut EVP_MAC_CTX);
}
extern "C" {
    pub fn EVP_MAC_CTX_dup(src: *const EVP_MAC_CTX) -> *mut EVP_MAC_CTX;
}
extern "C" {
    pub fn EVP_MAC_CTX_get0_mac(ctx: *mut EVP_MAC_CTX) -> *mut EVP_MAC;
}
extern "C" {
    pub fn EVP_MAC_CTX_get_params(ctx: *mut EVP_MAC_CTX, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_CTX_set_params(ctx: *mut EVP_MAC_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_CTX_get_mac_size(ctx: *mut EVP_MAC_CTX) -> usize;
}
extern "C" {
    pub fn EVP_MAC_CTX_get_block_size(ctx: *mut EVP_MAC_CTX) -> usize;
}
extern "C" {
    pub fn EVP_Q_mac(
        libctx: *mut OSSL_LIB_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
        subalg: *const ::aya_ebpf::cty::c_char,
        params: *const OSSL_PARAM,
        key: *const ::aya_ebpf::cty::c_void,
        keylen: usize,
        data: *const ::aya_ebpf::cty::c_uchar,
        datalen: usize,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outsize: usize,
        outlen: *mut usize,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_MAC_init(
        ctx: *mut EVP_MAC_CTX,
        key: *const ::aya_ebpf::cty::c_uchar,
        keylen: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_update(
        ctx: *mut EVP_MAC_CTX,
        data: *const ::aya_ebpf::cty::c_uchar,
        datalen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_final(
        ctx: *mut EVP_MAC_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outl: *mut usize,
        outsize: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_finalXOF(
        ctx: *mut EVP_MAC_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outsize: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_MAC_gettable_params(mac: *const EVP_MAC) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MAC_gettable_ctx_params(mac: *const EVP_MAC) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MAC_settable_ctx_params(mac: *const EVP_MAC) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MAC_CTX_gettable_params(ctx: *mut EVP_MAC_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MAC_CTX_settable_params(ctx: *mut EVP_MAC_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_MAC_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(mac: *mut EVP_MAC, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_MAC_names_do_all(
        mac: *const EVP_MAC,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_fetch(
        libctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_RAND;
}
extern "C" {
    pub fn EVP_RAND_up_ref(rand: *mut EVP_RAND) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_free(rand: *mut EVP_RAND);
}
extern "C" {
    pub fn EVP_RAND_get0_name(rand: *const EVP_RAND) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_RAND_get0_description(md: *const EVP_RAND) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_RAND_is_a(rand: *const EVP_RAND, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_get0_provider(rand: *const EVP_RAND) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_RAND_get_params(rand: *mut EVP_RAND, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_CTX_new(rand: *mut EVP_RAND, parent: *mut EVP_RAND_CTX) -> *mut EVP_RAND_CTX;
}
extern "C" {
    pub fn EVP_RAND_CTX_up_ref(ctx: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_CTX_free(ctx: *mut EVP_RAND_CTX);
}
extern "C" {
    pub fn EVP_RAND_CTX_get0_rand(ctx: *mut EVP_RAND_CTX) -> *mut EVP_RAND;
}
extern "C" {
    pub fn EVP_RAND_CTX_get_params(ctx: *mut EVP_RAND_CTX, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_CTX_set_params(ctx: *mut EVP_RAND_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_gettable_params(rand: *const EVP_RAND) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_RAND_gettable_ctx_params(rand: *const EVP_RAND) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_RAND_settable_ctx_params(rand: *const EVP_RAND) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_RAND_CTX_gettable_params(ctx: *mut EVP_RAND_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_RAND_CTX_settable_params(ctx: *mut EVP_RAND_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_RAND_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(rand: *mut EVP_RAND, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_RAND_names_do_all(
        rand: *const EVP_RAND,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_instantiate(
        ctx: *mut EVP_RAND_CTX,
        strength: ::aya_ebpf::cty::c_uint,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        pstr: *const ::aya_ebpf::cty::c_uchar,
        pstr_len: usize,
        params: *const OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_uninstantiate(ctx: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_generate(
        ctx: *mut EVP_RAND_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: usize,
        strength: ::aya_ebpf::cty::c_uint,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        addin: *const ::aya_ebpf::cty::c_uchar,
        addin_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_reseed(
        ctx: *mut EVP_RAND_CTX,
        prediction_resistance: ::aya_ebpf::cty::c_int,
        ent: *const ::aya_ebpf::cty::c_uchar,
        ent_len: usize,
        addin: *const ::aya_ebpf::cty::c_uchar,
        addin_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_nonce(
        ctx: *mut EVP_RAND_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_enable_locking(ctx: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_verify_zeroization(ctx: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_RAND_get_strength(ctx: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn EVP_RAND_get_state(ctx: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_old(
        dec_key: *mut ::aya_ebpf::cty::c_uchar,
        enc_key: *const ::aya_ebpf::cty::c_uchar,
        enc_key_len: ::aya_ebpf::cty::c_int,
        private_key: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_old(
        enc_key: *mut ::aya_ebpf::cty::c_uchar,
        key: *const ::aya_ebpf::cty::c_uchar,
        key_len: ::aya_ebpf::cty::c_int,
        pub_key: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_is_a(pkey: *const EVP_PKEY, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type_names_do_all(
        pkey: *const EVP_PKEY,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type(type_: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_id(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_base_id(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_bits(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_security_bits(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_size(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_can_sign(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type(pkey: *mut EVP_PKEY, type_: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type_str(
        pkey: *mut EVP_PKEY,
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_type_by_keymgmt(pkey: *mut EVP_PKEY, keymgmt: *mut EVP_KEYMGMT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_engine(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_engine(pkey: *const EVP_PKEY) -> *mut ENGINE;
}
extern "C" {
    pub fn EVP_PKEY_assign(
        pkey: *mut EVP_PKEY,
        type_: ::aya_ebpf::cty::c_int,
        key: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0(pkey: *const EVP_PKEY) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_PKEY_get0_hmac(pkey: *const EVP_PKEY, len: *mut usize) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_get0_poly1305(pkey: *const EVP_PKEY, len: *mut usize) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_get0_siphash(pkey: *const EVP_PKEY, len: *mut usize) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EVP_PKEY_set1_RSA(pkey: *mut EVP_PKEY, key: *mut rsa_st) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_RSA(pkey: *const EVP_PKEY) -> *const rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_RSA(pkey: *mut EVP_PKEY) -> *mut rsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DSA(pkey: *mut EVP_PKEY, key: *mut dsa_st) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DSA(pkey: *const EVP_PKEY) -> *const dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_DSA(pkey: *mut EVP_PKEY) -> *mut dsa_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_DH(pkey: *mut EVP_PKEY, key: *mut dh_st) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DH(pkey: *const EVP_PKEY) -> *const dh_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_DH(pkey: *mut EVP_PKEY) -> *mut dh_st;
}
extern "C" {
    pub fn EVP_PKEY_set1_EC_KEY(pkey: *mut EVP_PKEY, key: *mut ec_key_st) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_EC_KEY(pkey: *const EVP_PKEY) -> *const ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *mut EVP_PKEY) -> *mut ec_key_st;
}
extern "C" {
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_dup(pkey: *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    pub fn EVP_PKEY_get0_description(pkey: *const EVP_PKEY) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_PKEY_get0_provider(key: *const EVP_PKEY) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn d2i_PublicKey(
        type_: ::aya_ebpf::cty::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PublicKey(a: *const EVP_PKEY, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_ex(
        type_: ::aya_ebpf::cty::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_PrivateKey(
        type_: ::aya_ebpf::cty::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_AutoPrivateKey_ex(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_AutoPrivateKey(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PrivateKey(a: *const EVP_PKEY, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_KeyParams(a: *const EVP_PKEY, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_KeyParams(
        type_: ::aya_ebpf::cty::c_int,
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_KeyParams_bio(bp: *mut BIO, pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_KeyParams_bio(type_: ::aya_ebpf::cty::c_int, a: *mut *mut EVP_PKEY, in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_copy_parameters(to: *mut EVP_PKEY, from: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_missing_parameters(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_save_parameters(pkey: *mut EVP_PKEY, mode: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_parameters_eq(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_eq(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp_parameters(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public_fp(
        fp: *mut FILE,
        pkey: *const EVP_PKEY,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private_fp(
        fp: *mut FILE,
        pkey: *const EVP_PKEY,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params_fp(
        fp: *mut FILE,
        pkey: *const EVP_PKEY,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_default_digest_nid(
        pkey: *mut EVP_PKEY,
        pnid: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_default_digest_name(
        pkey: *mut EVP_PKEY,
        mdname: *mut ::aya_ebpf::cty::c_char,
        mdname_sz: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_digestsign_supports_digest(
        pkey: *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_encoded_public_key(
        pkey: *mut EVP_PKEY,
        pub_: *const ::aya_ebpf::cty::c_uchar,
        publen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_encoded_public_key(pkey: *mut EVP_PKEY, ppub: *mut *mut ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn EVP_CIPHER_param_to_asn1(c: *mut EVP_CIPHER_CTX, type_: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_asn1_to_param(c: *mut EVP_CIPHER_CTX, type_: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_set_asn1_iv(c: *mut EVP_CIPHER_CTX, type_: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_get_asn1_iv(c: *mut EVP_CIPHER_CTX, type_: *mut ASN1_TYPE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_keyivgen_ex(
        cctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC_SHA1(
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        iter: ::aya_ebpf::cty::c_int,
        keylen: ::aya_ebpf::cty::c_int,
        out: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC(
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        iter: ::aya_ebpf::cty::c_int,
        digest: *const EVP_MD,
        keylen: ::aya_ebpf::cty::c_int,
        out: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_v2_PBE_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_v2_PBE_keyivgen_ex(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_scrypt(
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: usize,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: usize,
        N: u64,
        r: u64,
        p: u64,
        maxmem: u64,
        key: *mut ::aya_ebpf::cty::c_uchar,
        keylen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_scrypt_ex(
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: usize,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: usize,
        N: u64,
        r: u64,
        p: u64,
        maxmem: u64,
        key: *mut ::aya_ebpf::cty::c_uchar,
        keylen: usize,
        ctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_v2_scrypt_keyivgen(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        c: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_v2_scrypt_keyivgen_ex(
        ctx: *mut EVP_CIPHER_CTX,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        c: *const EVP_CIPHER,
        md: *const EVP_MD,
        en_de: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_PBE_add();
}
extern "C" {
    pub fn EVP_PBE_CipherInit(
        pbe_obj: *mut ASN1_OBJECT,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        ctx: *mut EVP_CIPHER_CTX,
        en_de: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_CipherInit_ex(
        pbe_obj: *mut ASN1_OBJECT,
        pass: *const ::aya_ebpf::cty::c_char,
        passlen: ::aya_ebpf::cty::c_int,
        param: *mut ASN1_TYPE,
        ctx: *mut EVP_CIPHER_CTX,
        en_de: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add_type(
        pbe_type: ::aya_ebpf::cty::c_int,
        pbe_nid: ::aya_ebpf::cty::c_int,
        cipher_nid: ::aya_ebpf::cty::c_int,
        md_nid: ::aya_ebpf::cty::c_int,
        keygen: EVP_PBE_KEYGEN,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_alg_add(
        nid: ::aya_ebpf::cty::c_int,
        cipher: *const EVP_CIPHER,
        md: *const EVP_MD,
        keygen: EVP_PBE_KEYGEN,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_find(
        type_: ::aya_ebpf::cty::c_int,
        pbe_nid: ::aya_ebpf::cty::c_int,
        pcnid: *mut ::aya_ebpf::cty::c_int,
        pmnid: *mut ::aya_ebpf::cty::c_int,
        pkeygen: *mut EVP_PBE_KEYGEN,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_find_ex(
        type_: ::aya_ebpf::cty::c_int,
        pbe_nid: ::aya_ebpf::cty::c_int,
        pcnid: *mut ::aya_ebpf::cty::c_int,
        pmnid: *mut ::aya_ebpf::cty::c_int,
        pkeygen: *mut EVP_PBE_KEYGEN,
        pkeygen_ex: *mut EVP_PBE_KEYGEN_EX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PBE_cleanup();
}
extern "C" {
    pub fn EVP_PBE_get(
        ptype: *mut ::aya_ebpf::cty::c_int,
        ppbe_nid: *mut ::aya_ebpf::cty::c_int,
        num: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get_count() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0(idx: ::aya_ebpf::cty::c_int) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find(pe: *mut *mut ENGINE, type_: ::aya_ebpf::cty::c_int) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_find_str(
        pe: *mut *mut ENGINE,
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add0(ameth: *const EVP_PKEY_ASN1_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_add_alias(to: ::aya_ebpf::cty::c_int, from: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_asn1_get0_info(
        ppkey_id: *mut ::aya_ebpf::cty::c_int,
        pkey_base_id: *mut ::aya_ebpf::cty::c_int,
        ppkey_flags: *mut ::aya_ebpf::cty::c_int,
        pinfo: *mut *const ::aya_ebpf::cty::c_char,
        ppem_str: *mut *const ::aya_ebpf::cty::c_char,
        ameth: *const EVP_PKEY_ASN1_METHOD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_asn1(pkey: *const EVP_PKEY) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_new(
        id: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_int,
        pem_str: *const ::aya_ebpf::cty::c_char,
        info: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_asn1_copy(dst: *mut EVP_PKEY_ASN1_METHOD, src: *const EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_free(ameth: *mut EVP_PKEY_ASN1_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pub_decode: ::core::option::Option<
            unsafe extern "C" fn(pk: *mut EVP_PKEY, pub_: *const X509_PUBKEY) -> ::aya_ebpf::cty::c_int,
        >,
        pub_encode: ::core::option::Option<
            unsafe extern "C" fn(pub_: *mut X509_PUBKEY, pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
        pub_cmp: ::core::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
        pub_print: ::core::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::aya_ebpf::cty::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        pkey_size: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
        pkey_bits: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_private(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        priv_decode: ::core::option::Option<
            unsafe extern "C" fn(pk: *mut EVP_PKEY, p8inf: *const PKCS8_PRIV_KEY_INFO) -> ::aya_ebpf::cty::c_int,
        >,
        priv_encode: ::core::option::Option<
            unsafe extern "C" fn(p8: *mut PKCS8_PRIV_KEY_INFO, pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
        priv_print: ::core::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::aya_ebpf::cty::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        param_decode: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                pder: *mut *const ::aya_ebpf::cty::c_uchar,
                derlen: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        param_encode: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *const EVP_PKEY,
                pder: *mut *mut ::aya_ebpf::cty::c_uchar,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        param_missing: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
        param_copy: ::core::option::Option<
            unsafe extern "C" fn(to: *mut EVP_PKEY, from: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
        param_cmp: ::core::option::Option<
            unsafe extern "C" fn(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
        param_print: ::core::option::Option<
            unsafe extern "C" fn(
                out: *mut BIO,
                pkey: *const EVP_PKEY,
                indent: ::aya_ebpf::cty::c_int,
                pctx: *mut ASN1_PCTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_free(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_free: ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_ctrl(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                pkey: *mut EVP_PKEY,
                op: ::aya_ebpf::cty::c_int,
                arg1: ::aya_ebpf::cty::c_long,
                arg2: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_item(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        item_verify: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                data: *const ::aya_ebpf::cty::c_void,
                a: *const X509_ALGOR,
                sig: *const ASN1_BIT_STRING,
                pkey: *mut EVP_PKEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        item_sign: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                it: *const ASN1_ITEM,
                data: *const ::aya_ebpf::cty::c_void,
                alg1: *mut X509_ALGOR,
                alg2: *mut X509_ALGOR,
                sig: *mut ASN1_BIT_STRING,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_siginf(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        siginf_set: ::core::option::Option<
            unsafe extern "C" fn(
                siginf: *mut X509_SIG_INFO,
                alg: *const X509_ALGOR,
                sig: *const ASN1_STRING,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_check: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_public_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_pub_check: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_param_check(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_param_check: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_set_priv_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        set_priv_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                priv_: *const ::aya_ebpf::cty::c_uchar,
                len: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_set_pub_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        set_pub_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *mut EVP_PKEY,
                pub_: *const ::aya_ebpf::cty::c_uchar,
                len: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_get_priv_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        get_priv_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *const EVP_PKEY,
                priv_: *mut ::aya_ebpf::cty::c_uchar,
                len: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_get_pub_key(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        get_pub_key: ::core::option::Option<
            unsafe extern "C" fn(
                pk: *const EVP_PKEY,
                pub_: *mut ::aya_ebpf::cty::c_uchar,
                len: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_asn1_set_security_bits(
        ameth: *mut EVP_PKEY_ASN1_METHOD,
        pkey_security_bits: ::core::option::Option<unsafe extern "C" fn(pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_signature_md(ctx: *mut EVP_PKEY_CTX, md: *mut *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_signature_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set1_id(
        ctx: *mut EVP_PKEY_CTX,
        id: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get1_id(ctx: *mut EVP_PKEY_CTX, id: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get1_id_len(ctx: *mut EVP_PKEY_CTX, id_len: *mut usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_kem_op(ctx: *mut EVP_PKEY_CTX, op: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_type_name(key: *const EVP_PKEY) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_mac_key(
        ctx: *mut EVP_PKEY_CTX,
        key: *const ::aya_ebpf::cty::c_uchar,
        keylen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_find(type_: ::aya_ebpf::cty::c_int) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_new(id: ::aya_ebpf::cty::c_int, flags: ::aya_ebpf::cty::c_int) -> *mut EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0_info(
        ppkey_id: *mut ::aya_ebpf::cty::c_int,
        pflags: *mut ::aya_ebpf::cty::c_int,
        meth: *const EVP_PKEY_METHOD,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_copy(dst: *mut EVP_PKEY_METHOD, src: *const EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_free(pmeth: *mut EVP_PKEY_METHOD);
}
extern "C" {
    pub fn EVP_PKEY_meth_add0(pmeth: *const EVP_PKEY_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_remove(pmeth: *const EVP_PKEY_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_get_count() -> usize;
}
extern "C" {
    pub fn EVP_PKEY_meth_get0(idx: usize) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn EVP_KEYMGMT_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_KEYMGMT;
}
extern "C" {
    pub fn EVP_KEYMGMT_up_ref(keymgmt: *mut EVP_KEYMGMT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEYMGMT_free(keymgmt: *mut EVP_KEYMGMT);
}
extern "C" {
    pub fn EVP_KEYMGMT_get0_provider(keymgmt: *const EVP_KEYMGMT) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_KEYMGMT_get0_name(keymgmt: *const EVP_KEYMGMT) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_KEYMGMT_get0_description(keymgmt: *const EVP_KEYMGMT) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_KEYMGMT_is_a(keymgmt: *const EVP_KEYMGMT, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEYMGMT_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(keymgmt: *mut EVP_KEYMGMT, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_KEYMGMT_names_do_all(
        keymgmt: *const EVP_KEYMGMT,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEYMGMT_gettable_params(keymgmt: *const EVP_KEYMGMT) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_KEYMGMT_settable_params(keymgmt: *const EVP_KEYMGMT) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_KEYMGMT_gen_settable_params(keymgmt: *const EVP_KEYMGMT) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_id(id: ::aya_ebpf::cty::c_int, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_from_name(
        libctx: *mut OSSL_LIB_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        propquery: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_from_pkey(
        libctx: *mut OSSL_LIB_CTX,
        pkey: *mut EVP_PKEY,
        propquery: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_dup(ctx: *const EVP_PKEY_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_free(ctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_PKEY_CTX_is_a(ctx: *mut EVP_PKEY_CTX, keytype: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_params(ctx: *mut EVP_PKEY_CTX, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_gettable_params(ctx: *const EVP_PKEY_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_params(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_settable_params(ctx: *const EVP_PKEY_CTX) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        keytype: ::aya_ebpf::cty::c_int,
        optype: ::aya_ebpf::cty::c_int,
        cmd: ::aya_ebpf::cty::c_int,
        p1: ::aya_ebpf::cty::c_int,
        p2: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_str(
        ctx: *mut EVP_PKEY_CTX,
        type_: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_ctrl_uint64(
        ctx: *mut EVP_PKEY_CTX,
        keytype: ::aya_ebpf::cty::c_int,
        optype: ::aya_ebpf::cty::c_int,
        cmd: ::aya_ebpf::cty::c_int,
        value: u64,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_str2ctrl(
        ctx: *mut EVP_PKEY_CTX,
        cmd: ::aya_ebpf::cty::c_int,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_hex2ctrl(
        ctx: *mut EVP_PKEY_CTX,
        cmd: ::aya_ebpf::cty::c_int,
        hex: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_md(
        ctx: *mut EVP_PKEY_CTX,
        optype: ::aya_ebpf::cty::c_int,
        cmd: ::aya_ebpf::cty::c_int,
        md: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_operation(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_keygen_info(
        ctx: *mut EVP_PKEY_CTX,
        dat: *mut ::aya_ebpf::cty::c_int,
        datlen: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn EVP_PKEY_new_mac_key(
        type_: ::aya_ebpf::cty::c_int,
        e: *mut ENGINE,
        key: *const ::aya_ebpf::cty::c_uchar,
        keylen: ::aya_ebpf::cty::c_int,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_private_key_ex(
        libctx: *mut OSSL_LIB_CTX,
        keytype: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
        priv_: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_private_key(
        type_: ::aya_ebpf::cty::c_int,
        e: *mut ENGINE,
        priv_: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_public_key_ex(
        libctx: *mut OSSL_LIB_CTX,
        keytype: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
        pub_: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_public_key(
        type_: ::aya_ebpf::cty::c_int,
        e: *mut ENGINE,
        pub_: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_private_key(
        pkey: *const EVP_PKEY,
        priv_: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_public_key(
        pkey: *const EVP_PKEY,
        pub_: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_new_CMAC_key(
        e: *mut ENGINE,
        priv_: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
        cipher: *const EVP_CIPHER,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_data(ctx: *mut EVP_PKEY_CTX, data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_data(ctx: *const EVP_PKEY_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_pkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_peerkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_app_data(ctx: *mut EVP_PKEY_CTX, data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_app_data(ctx: *mut EVP_PKEY_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_SIGNATURE_free(signature: *mut EVP_SIGNATURE);
}
extern "C" {
    pub fn EVP_SIGNATURE_up_ref(signature: *mut EVP_SIGNATURE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SIGNATURE_get0_provider(signature: *const EVP_SIGNATURE) -> *mut OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_SIGNATURE_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_SIGNATURE;
}
extern "C" {
    pub fn EVP_SIGNATURE_is_a(
        signature: *const EVP_SIGNATURE,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SIGNATURE_get0_name(signature: *const EVP_SIGNATURE) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_SIGNATURE_get0_description(signature: *const EVP_SIGNATURE) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_SIGNATURE_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(signature: *mut EVP_SIGNATURE, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_SIGNATURE_names_do_all(
        signature: *const EVP_SIGNATURE,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_SIGNATURE_gettable_ctx_params(sig: *const EVP_SIGNATURE) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_SIGNATURE_settable_ctx_params(sig: *const EVP_SIGNATURE) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_free(cipher: *mut EVP_ASYM_CIPHER);
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_up_ref(cipher: *mut EVP_ASYM_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_get0_provider(cipher: *const EVP_ASYM_CIPHER) -> *mut OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_ASYM_CIPHER;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_is_a(
        cipher: *const EVP_ASYM_CIPHER,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_get0_name(cipher: *const EVP_ASYM_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_get0_description(cipher: *const EVP_ASYM_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(cipher: *mut EVP_ASYM_CIPHER, arg: *mut ::aya_ebpf::cty::c_void),
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_names_do_all(
        cipher: *const EVP_ASYM_CIPHER,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_gettable_ctx_params(ciph: *const EVP_ASYM_CIPHER) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_ASYM_CIPHER_settable_ctx_params(ciph: *const EVP_ASYM_CIPHER) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_KEM_free(wrap: *mut EVP_KEM);
}
extern "C" {
    pub fn EVP_KEM_up_ref(wrap: *mut EVP_KEM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEM_get0_provider(wrap: *const EVP_KEM) -> *mut OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_KEM_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_KEM;
}
extern "C" {
    pub fn EVP_KEM_is_a(wrap: *const EVP_KEM, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEM_get0_name(wrap: *const EVP_KEM) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_KEM_get0_description(wrap: *const EVP_KEM) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_KEM_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(wrap: *mut EVP_KEM, arg: *mut ::aya_ebpf::cty::c_void)>,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_KEM_names_do_all(
        wrap: *const EVP_KEM,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEM_gettable_ctx_params(kem: *const EVP_KEM) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_KEM_settable_ctx_params(kem: *const EVP_KEM) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_sign_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign_init_ex(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign(
        ctx: *mut EVP_PKEY_CTX,
        sig: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init_ex(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify(
        ctx: *mut EVP_PKEY_CTX,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
        tbs: *const ::aya_ebpf::cty::c_uchar,
        tbslen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init_ex(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover(
        ctx: *mut EVP_PKEY_CTX,
        rout: *mut ::aya_ebpf::cty::c_uchar,
        routlen: *mut usize,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init_ex(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init_ex(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init_ex(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer_ex(
        ctx: *mut EVP_PKEY_CTX,
        peer: *mut EVP_PKEY,
        validate_peer: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer(ctx: *mut EVP_PKEY_CTX, peer: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive(
        ctx: *mut EVP_PKEY_CTX,
        key: *mut ::aya_ebpf::cty::c_uchar,
        keylen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encapsulate_init(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encapsulate(
        ctx: *mut EVP_PKEY_CTX,
        wrappedkey: *mut ::aya_ebpf::cty::c_uchar,
        wrappedkeylen: *mut usize,
        genkey: *mut ::aya_ebpf::cty::c_uchar,
        genkeylen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decapsulate_init(ctx: *mut EVP_PKEY_CTX, params: *const OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decapsulate(
        ctx: *mut EVP_PKEY_CTX,
        unwrapped: *mut ::aya_ebpf::cty::c_uchar,
        unwrappedlen: *mut usize,
        wrapped: *const ::aya_ebpf::cty::c_uchar,
        wrappedlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type EVP_PKEY_gen_cb = ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>;
extern "C" {
    pub fn EVP_PKEY_fromdata_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_fromdata(
        ctx: *mut EVP_PKEY_CTX,
        ppkey: *mut *mut EVP_PKEY,
        selection: ::aya_ebpf::cty::c_int,
        param: *mut OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_fromdata_settable(ctx: *mut EVP_PKEY_CTX, selection: ::aya_ebpf::cty::c_int) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_todata(
        pkey: *const EVP_PKEY,
        selection: ::aya_ebpf::cty::c_int,
        params: *mut *mut OSSL_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_export(
        pkey: *const EVP_PKEY,
        selection: ::aya_ebpf::cty::c_int,
        export_cb: OSSL_CALLBACK,
        export_cbarg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_gettable_params(pkey: *const EVP_PKEY) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_get_params(pkey: *const EVP_PKEY, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_int_param(
        pkey: *const EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        out: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_size_t_param(
        pkey: *const EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        out: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_bn_param(
        pkey: *const EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        bn: *mut *mut BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_utf8_string_param(
        pkey: *const EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        str_: *mut ::aya_ebpf::cty::c_char,
        max_buf_sz: usize,
        out_sz: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_octet_string_param(
        pkey: *const EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        buf: *mut ::aya_ebpf::cty::c_uchar,
        max_buf_sz: usize,
        out_sz: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_settable_params(pkey: *const EVP_PKEY) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_PKEY_set_params(pkey: *mut EVP_PKEY, params: *mut OSSL_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_int_param(
        pkey: *mut EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        in_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_size_t_param(
        pkey: *mut EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        in_: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_bn_param(
        pkey: *mut EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        bn: *const BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_utf8_string_param(
        pkey: *mut EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_octet_string_param(
        pkey: *mut EVP_PKEY,
        key_name: *const ::aya_ebpf::cty::c_char,
        buf: *const ::aya_ebpf::cty::c_uchar,
        bsize: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_ec_point_conv_form(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_field_type(pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_Q_keygen(
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
        type_: *const ::aya_ebpf::cty::c_char,
        ...
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_paramgen_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen(ctx: *mut EVP_PKEY_CTX, ppkey: *mut *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen_init(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen(ctx: *mut EVP_PKEY_CTX, ppkey: *mut *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_generate(ctx: *mut EVP_PKEY_CTX, ppkey: *mut *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_check(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_public_check(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_public_check_quick(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_param_check(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_param_check_quick(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_private_check(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_pairwise_check(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set_ex_data(
        key: *mut EVP_PKEY,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_ex_data(key: *const EVP_PKEY, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_cb(ctx: *mut EVP_PKEY_CTX, cb: EVP_PKEY_gen_cb);
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_cb(ctx: *mut EVP_PKEY_CTX) -> EVP_PKEY_gen_cb;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_keygen_info(ctx: *mut EVP_PKEY_CTX, idx: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_meth_set_init(
        pmeth: *mut EVP_PKEY_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_copy(
        pmeth: *mut EVP_PKEY_METHOD,
        copy: ::core::option::Option<
            unsafe extern "C" fn(dst: *mut EVP_PKEY_CTX, src: *const EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_cleanup(
        pmeth: *mut EVP_PKEY_METHOD,
        cleanup: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_paramgen(
        pmeth: *mut EVP_PKEY_METHOD,
        paramgen_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        paramgen: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_keygen(
        pmeth: *mut EVP_PKEY_METHOD,
        keygen_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        keygen: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_sign(
        pmeth: *mut EVP_PKEY_METHOD,
        sign_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        sign: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        verify: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::aya_ebpf::cty::c_uchar,
                siglen: usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verify_recover(
        pmeth: *mut EVP_PKEY_METHOD,
        verify_recover_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        verify_recover: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_signctx(
        pmeth: *mut EVP_PKEY_METHOD,
        signctx_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, mctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        signctx: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                mctx: *mut EVP_MD_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_verifyctx(
        pmeth: *mut EVP_PKEY_METHOD,
        verifyctx_init: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, mctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        verifyctx: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::aya_ebpf::cty::c_uchar,
                siglen: ::aya_ebpf::cty::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_encrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        encrypt_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        encryptfn: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::aya_ebpf::cty::c_uchar,
                outlen: *mut usize,
                in_: *const ::aya_ebpf::cty::c_uchar,
                inlen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_decrypt(
        pmeth: *mut EVP_PKEY_METHOD,
        decrypt_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        decrypt: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::aya_ebpf::cty::c_uchar,
                outlen: *mut usize,
                in_: *const ::aya_ebpf::cty::c_uchar,
                inlen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_derive(
        pmeth: *mut EVP_PKEY_METHOD,
        derive_init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        derive: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut ::aya_ebpf::cty::c_uchar,
                keylen: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_ctrl(
        pmeth: *mut EVP_PKEY_METHOD,
        ctrl: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: ::aya_ebpf::cty::c_int,
                p1: ::aya_ebpf::cty::c_int,
                p2: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        ctrl_str: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const ::aya_ebpf::cty::c_char,
                value: *const ::aya_ebpf::cty::c_char,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digestsign(
        pmeth: *mut EVP_PKEY_METHOD,
        digestsign: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digestverify(
        pmeth: *mut EVP_PKEY_METHOD,
        digestverify: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *const ::aya_ebpf::cty::c_uchar,
                siglen: usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_public_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_param_check(
        pmeth: *mut EVP_PKEY_METHOD,
        check: ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_set_digest_custom(
        pmeth: *mut EVP_PKEY_METHOD,
        digest_custom: ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, mctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_init(
        pmeth: *const EVP_PKEY_METHOD,
        pinit: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_copy(
        pmeth: *const EVP_PKEY_METHOD,
        pcopy: *mut ::core::option::Option<
            unsafe extern "C" fn(dst: *mut EVP_PKEY_CTX, src: *const EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_cleanup(
        pmeth: *const EVP_PKEY_METHOD,
        pcleanup: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX)>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_paramgen(
        pmeth: *const EVP_PKEY_METHOD,
        pparamgen_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        pparamgen: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_keygen(
        pmeth: *const EVP_PKEY_METHOD,
        pkeygen_init: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        pkeygen: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_sign(
        pmeth: *const EVP_PKEY_METHOD,
        psign_init: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        psign: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify(
        pmeth: *const EVP_PKEY_METHOD,
        pverify_init: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        pverify: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::aya_ebpf::cty::c_uchar,
                siglen: usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verify_recover(
        pmeth: *const EVP_PKEY_METHOD,
        pverify_recover_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        pverify_recover: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_signctx(
        pmeth: *const EVP_PKEY_METHOD,
        psignctx_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, mctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        psignctx: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                mctx: *mut EVP_MD_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_verifyctx(
        pmeth: *const EVP_PKEY_METHOD,
        pverifyctx_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, mctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        pverifyctx: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                sig: *const ::aya_ebpf::cty::c_uchar,
                siglen: ::aya_ebpf::cty::c_int,
                mctx: *mut EVP_MD_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_encrypt(
        pmeth: *const EVP_PKEY_METHOD,
        pencrypt_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        pencryptfn: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::aya_ebpf::cty::c_uchar,
                outlen: *mut usize,
                in_: *const ::aya_ebpf::cty::c_uchar,
                inlen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_decrypt(
        pmeth: *const EVP_PKEY_METHOD,
        pdecrypt_init: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int,
        >,
        pdecrypt: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                out: *mut ::aya_ebpf::cty::c_uchar,
                outlen: *mut usize,
                in_: *const ::aya_ebpf::cty::c_uchar,
                inlen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_derive(
        pmeth: *const EVP_PKEY_METHOD,
        pderive_init: *mut ::core::option::Option<unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int>,
        pderive: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                key: *mut ::aya_ebpf::cty::c_uchar,
                keylen: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_ctrl(
        pmeth: *const EVP_PKEY_METHOD,
        pctrl: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: ::aya_ebpf::cty::c_int,
                p1: ::aya_ebpf::cty::c_int,
                p2: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        pctrl_str: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_PKEY_CTX,
                type_: *const ::aya_ebpf::cty::c_char,
                value: *const ::aya_ebpf::cty::c_char,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digestsign(
        pmeth: *const EVP_PKEY_METHOD,
        digestsign: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digestverify(
        pmeth: *const EVP_PKEY_METHOD,
        digestverify: *mut ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut EVP_MD_CTX,
                sig: *const ::aya_ebpf::cty::c_uchar,
                siglen: usize,
                tbs: *const ::aya_ebpf::cty::c_uchar,
                tbslen: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_public_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_param_check(
        pmeth: *const EVP_PKEY_METHOD,
        pcheck: *mut ::core::option::Option<unsafe extern "C" fn(pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EVP_PKEY_meth_get_digest_custom(
        pmeth: *const EVP_PKEY_METHOD,
        pdigest_custom: *mut ::core::option::Option<
            unsafe extern "C" fn(ctx: *mut EVP_PKEY_CTX, mctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_KEYEXCH_free(exchange: *mut EVP_KEYEXCH);
}
extern "C" {
    pub fn EVP_KEYEXCH_up_ref(exchange: *mut EVP_KEYEXCH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEYEXCH_fetch(
        ctx: *mut OSSL_LIB_CTX,
        algorithm: *const ::aya_ebpf::cty::c_char,
        properties: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_KEYEXCH;
}
extern "C" {
    pub fn EVP_KEYEXCH_get0_provider(exchange: *const EVP_KEYEXCH) -> *mut OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_KEYEXCH_is_a(keyexch: *const EVP_KEYEXCH, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEYEXCH_get0_name(keyexch: *const EVP_KEYEXCH) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_KEYEXCH_get0_description(keyexch: *const EVP_KEYEXCH) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_KEYEXCH_do_all_provided(
        libctx: *mut OSSL_LIB_CTX,
        fn_: ::core::option::Option<unsafe extern "C" fn(keyexch: *mut EVP_KEYEXCH, data: *mut ::aya_ebpf::cty::c_void)>,
        data: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn EVP_KEYEXCH_names_do_all(
        keyexch: *const EVP_KEYEXCH,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(name: *const ::aya_ebpf::cty::c_char, data: *mut ::aya_ebpf::cty::c_void),
        >,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_KEYEXCH_gettable_ctx_params(keyexch: *const EVP_KEYEXCH) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_KEYEXCH_settable_ctx_params(keyexch: *const EVP_KEYEXCH) -> *const OSSL_PARAM;
}
extern "C" {
    pub fn EVP_add_alg_module();
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_group_name(
        ctx: *mut EVP_PKEY_CTX,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_group_name(
        ctx: *mut EVP_PKEY_CTX,
        name: *mut ::aya_ebpf::cty::c_char,
        namelen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_group_name(
        pkey: *const EVP_PKEY,
        name: *mut ::aya_ebpf::cty::c_char,
        name_sz: usize,
        gname_len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_libctx(ctx: *mut EVP_PKEY_CTX) -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_propq(ctx: *const EVP_PKEY_CTX) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_provider(ctx: *const EVP_PKEY_CTX) -> *const OSSL_PROVIDER;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
        ctx: *mut EVP_PKEY_CTX,
        nid: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ec_param_enc(
        ctx: *mut EVP_PKEY_CTX,
        param_enc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ecdh_cofactor_mode(
        ctx: *mut EVP_PKEY_CTX,
        cofactor_mode: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_ecdh_cofactor_mode(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ecdh_kdf_type(ctx: *mut EVP_PKEY_CTX, kdf: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_ecdh_kdf_type(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ecdh_kdf_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_ecdh_kdf_md(ctx: *mut EVP_PKEY_CTX, md: *mut *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ecdh_kdf_outlen(
        ctx: *mut EVP_PKEY_CTX,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_ecdh_kdf_outlen(
        ctx: *mut EVP_PKEY_CTX,
        len: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_ecdh_kdf_ukm(
        ctx: *mut EVP_PKEY_CTX,
        ukm: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_ecdh_kdf_ukm(
        ctx: *mut EVP_PKEY_CTX,
        ukm: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
pub const point_conversion_form_t_POINT_CONVERSION_COMPRESSED: point_conversion_form_t = 2;
pub const point_conversion_form_t_POINT_CONVERSION_UNCOMPRESSED: point_conversion_form_t = 4;
pub const point_conversion_form_t_POINT_CONVERSION_HYBRID: point_conversion_form_t = 6;
pub type point_conversion_form_t = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn OSSL_EC_curve_nid2name(nid: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_method_st {
    _unused: [u8; 0],
}
pub type EC_METHOD = ec_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_point_st {
    _unused: [u8; 0],
}
pub type EC_POINT = ec_point_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecpk_parameters_st {
    _unused: [u8; 0],
}
pub type ECPKPARAMETERS = ecpk_parameters_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_parameters_st {
    _unused: [u8; 0],
}
pub type ECPARAMETERS = ec_parameters_st;
extern "C" {
    pub fn EC_GFp_simple_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_mont_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nist_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nistp224_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nistp256_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GFp_nistp521_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GF2m_simple_method() -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_GROUP_new(meth: *const EC_METHOD) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_clear_free(group: *mut EC_GROUP);
}
extern "C" {
    pub fn EC_GROUP_method_of(group: *const EC_GROUP) -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_METHOD_get_field_type(meth: *const EC_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_free(group: *mut EC_GROUP);
}
extern "C" {
    pub fn EC_GROUP_copy(dst: *mut EC_GROUP, src: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_dup(src: *const EC_GROUP) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_set_generator(
        group: *mut EC_GROUP,
        generator: *const EC_POINT,
        order: *const BIGNUM,
        cofactor: *const BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_generator(group: *const EC_GROUP) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_GROUP_get_mont_data(group: *const EC_GROUP) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn EC_GROUP_get_order(group: *const EC_GROUP, order: *mut BIGNUM, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_order(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_order_bits(group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_cofactor(
        group: *const EC_GROUP,
        cofactor: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_cofactor(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_set_curve_name(group: *mut EC_GROUP, nid: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_field(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_get_field_type(group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_asn1_flag(group: *mut EC_GROUP, flag: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_asn1_flag(group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_point_conversion_form(group: *mut EC_GROUP, form: point_conversion_form_t);
}
extern "C" {
    pub fn EC_GROUP_get_point_conversion_form(arg1: *const EC_GROUP) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_GROUP_get0_seed(x: *const EC_GROUP) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn EC_GROUP_get_seed_len(arg1: *const EC_GROUP) -> usize;
}
extern "C" {
    pub fn EC_GROUP_set_seed(arg1: *mut EC_GROUP, arg2: *const ::aya_ebpf::cty::c_uchar, len: usize) -> usize;
}
extern "C" {
    pub fn EC_GROUP_set_curve(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_curve_GFp(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GFp(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_curve_GF2m(
        group: *mut EC_GROUP,
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GF2m(
        group: *const EC_GROUP,
        p: *mut BIGNUM,
        a: *mut BIGNUM,
        b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_degree(group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_check(group: *const EC_GROUP, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_check_discriminant(group: *const EC_GROUP, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_cmp(a: *const EC_GROUP, b: *const EC_GROUP, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_new_curve_GFp(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_curve_GF2m(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_from_params(
        params: *const OSSL_PARAM,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_by_curve_name_ex(
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
        nid: ::aya_ebpf::cty::c_int,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_by_curve_name(nid: ::aya_ebpf::cty::c_int) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_from_ecparameters(params: *const ECPARAMETERS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_get_ecparameters(group: *const EC_GROUP, params: *mut ECPARAMETERS) -> *mut ECPARAMETERS;
}
extern "C" {
    pub fn EC_GROUP_new_from_ecpkparameters(params: *const ECPKPARAMETERS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_get_ecpkparameters(group: *const EC_GROUP, params: *mut ECPKPARAMETERS) -> *mut ECPKPARAMETERS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EC_builtin_curve {
    pub nid: ::aya_ebpf::cty::c_int,
    pub comment: *const ::aya_ebpf::cty::c_char,
}
extern "C" {
    pub fn EC_get_builtin_curves(r: *mut EC_builtin_curve, nitems: usize) -> usize;
}
extern "C" {
    pub fn EC_curve_nid2nist(nid: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EC_curve_nist2nid(name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_check_named_curve(
        group: *const EC_GROUP,
        nist_only: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_new(group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_POINT_clear_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_POINT_copy(dst: *mut EC_POINT, src: *const EC_POINT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_dup(src: *const EC_POINT, group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_set_to_infinity(group: *const EC_GROUP, point: *mut EC_POINT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_method_of(point: *const EC_POINT) -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_POINT_set_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        z: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_Jprojective_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        z: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GFp(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GFp(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GF2m(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::aya_ebpf::cty::c_int,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_point2oct(
        group: *const EC_GROUP,
        p: *const EC_POINT,
        form: point_conversion_form_t,
        buf: *mut ::aya_ebpf::cty::c_uchar,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> usize;
}
extern "C" {
    pub fn EC_POINT_oct2point(
        group: *const EC_GROUP,
        p: *mut EC_POINT,
        buf: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_point2buf(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        pbuf: *mut *mut ::aya_ebpf::cty::c_uchar,
        ctx: *mut BN_CTX,
    ) -> usize;
}
extern "C" {
    pub fn EC_POINT_point2bn(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BIGNUM,
        arg4: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn EC_POINT_bn2point(
        arg1: *const EC_GROUP,
        arg2: *const BIGNUM,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_point2hex(
        arg1: *const EC_GROUP,
        arg2: *const EC_POINT,
        form: point_conversion_form_t,
        arg3: *mut BN_CTX,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn EC_POINT_hex2point(
        arg1: *const EC_GROUP,
        arg2: *const ::aya_ebpf::cty::c_char,
        arg3: *mut EC_POINT,
        arg4: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_add(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_dbl(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_invert(group: *const EC_GROUP, a: *mut EC_POINT, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_is_at_infinity(group: *const EC_GROUP, p: *const EC_POINT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_is_on_curve(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_cmp(
        group: *const EC_GROUP,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_make_affine(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINTs_make_affine(
        group: *const EC_GROUP,
        num: usize,
        points: *mut *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINTs_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        num: usize,
        p: *mut *const EC_POINT,
        m: *mut *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_POINT_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        q: *const EC_POINT,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_precompute_mult(group: *mut EC_GROUP, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_have_precompute_mult(group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECPKPARAMETERS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ECPKPARAMETERS_new() -> *mut ECPKPARAMETERS;
}
extern "C" {
    pub fn ECPKPARAMETERS_free(a: *mut ECPKPARAMETERS);
}
extern "C" {
    pub fn ECPARAMETERS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ECPARAMETERS_new() -> *mut ECPARAMETERS;
}
extern "C" {
    pub fn ECPARAMETERS_free(a: *mut ECPARAMETERS);
}
extern "C" {
    pub fn EC_GROUP_get_basis_type(arg1: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_trinomial_basis(arg1: *const EC_GROUP, k: *mut ::aya_ebpf::cty::c_uint)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_pentanomial_basis(
        arg1: *const EC_GROUP,
        k1: *mut ::aya_ebpf::cty::c_uint,
        k2: *mut ::aya_ebpf::cty::c_uint,
        k3: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_ECPKParameters(
        arg1: *mut *mut EC_GROUP,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn i2d_ECPKParameters(arg1: *const EC_GROUP, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECPKParameters_print(bp: *mut BIO, x: *const EC_GROUP, off: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECPKParameters_print_fp(
        fp: *mut FILE,
        x: *const EC_GROUP,
        off: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_new_ex(ctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_get_flags(key: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_set_flags(key: *mut EC_KEY, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EC_KEY_clear_flags(key: *mut EC_KEY, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EC_KEY_decoded_from_explicit_params(key: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_new_by_curve_name_ex(
        ctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
        nid: ::aya_ebpf::cty::c_int,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_new_by_curve_name(nid: ::aya_ebpf::cty::c_int) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    pub fn EC_KEY_copy(dst: *mut EC_KEY, src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_dup(src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_engine(eckey: *const EC_KEY) -> *mut ENGINE;
}
extern "C" {
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_private_key(key: *const EC_KEY) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_KEY_set_private_key(key: *mut EC_KEY, prv: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_public_key(key: *const EC_KEY) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_KEY_set_public_key(key: *mut EC_KEY, pub_: *const EC_POINT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get_enc_flags(key: *const EC_KEY) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn EC_KEY_set_enc_flags(eckey: *mut EC_KEY, flags: ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn EC_KEY_get_conv_form(key: *const EC_KEY) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_KEY_set_conv_form(eckey: *mut EC_KEY, cform: point_conversion_form_t);
}
extern "C" {
    pub fn EC_KEY_set_ex_data(
        key: *mut EC_KEY,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_get_ex_data(key: *const EC_KEY, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn EC_KEY_set_asn1_flag(eckey: *mut EC_KEY, asn1_flag: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn EC_KEY_precompute_mult(key: *mut EC_KEY, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_check_key(key: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_can_sign(eckey: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_set_public_key_affine_coordinates(
        key: *mut EC_KEY,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_key2buf(
        key: *const EC_KEY,
        form: point_conversion_form_t,
        pbuf: *mut *mut ::aya_ebpf::cty::c_uchar,
        ctx: *mut BN_CTX,
    ) -> usize;
}
extern "C" {
    pub fn EC_KEY_oct2key(
        key: *mut EC_KEY,
        buf: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_oct2priv(key: *mut EC_KEY, buf: *const ::aya_ebpf::cty::c_uchar, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_priv2oct(key: *const EC_KEY, buf: *mut ::aya_ebpf::cty::c_uchar, len: usize) -> usize;
}
extern "C" {
    pub fn EC_KEY_priv2buf(eckey: *const EC_KEY, pbuf: *mut *mut ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn d2i_ECPrivateKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey(key: *const EC_KEY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_ECParameters(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECParameters(key: *const EC_KEY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn o2i_ECPublicKey(
        key: *mut *mut EC_KEY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2o_ECPublicKey(key: *const EC_KEY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECParameters_print(bp: *mut BIO, key: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_print(bp: *mut BIO, key: *const EC_KEY, off: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECParameters_print_fp(fp: *mut FILE, key: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_print_fp(fp: *mut FILE, key: *const EC_KEY, off: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_OpenSSL() -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_get_default_method() -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_set_default_method(meth: *const EC_KEY_METHOD);
}
extern "C" {
    pub fn EC_KEY_get_method(key: *const EC_KEY) -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_set_method(key: *mut EC_KEY, meth: *const EC_KEY_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_new_method(engine: *mut ENGINE) -> *mut EC_KEY;
}
extern "C" {
    pub fn ECDH_KDF_X9_62(
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: usize,
        Z: *const ::aya_ebpf::cty::c_uchar,
        Zlen: usize,
        sinfo: *const ::aya_ebpf::cty::c_uchar,
        sinfolen: usize,
        md: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDH_compute_key(
        out: *mut ::aya_ebpf::cty::c_void,
        outlen: usize,
        pub_key: *const EC_POINT,
        ecdh: *const EC_KEY,
        KDF: ::core::option::Option<
            unsafe extern "C" fn(
                in_: *const ::aya_ebpf::cty::c_void,
                inlen: usize,
                out: *mut ::aya_ebpf::cty::c_void,
                outlen: *mut usize,
            ) -> *mut ::aya_ebpf::cty::c_void,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ECDSA_SIG_st {
    _unused: [u8; 0],
}
pub type ECDSA_SIG = ECDSA_SIG_st;
extern "C" {
    pub fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);
}
extern "C" {
    pub fn d2i_ECDSA_SIG(
        a: *mut *mut ECDSA_SIG,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn i2d_ECDSA_SIG(a: *const ECDSA_SIG, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_get0(sig: *const ECDSA_SIG, pr: *mut *const BIGNUM, ps: *mut *const BIGNUM);
}
extern "C" {
    pub fn ECDSA_SIG_get0_r(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_get0_s(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_set0(sig: *mut ECDSA_SIG, r: *mut BIGNUM, s: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_do_sign(
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgst_len: ::aya_ebpf::cty::c_int,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_do_sign_ex(
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgstlen: ::aya_ebpf::cty::c_int,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_do_verify(
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgst_len: ::aya_ebpf::cty::c_int,
        sig: *const ECDSA_SIG,
        eckey: *mut EC_KEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_sign_setup(
        eckey: *mut EC_KEY,
        ctx: *mut BN_CTX,
        kinv: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_sign(
        type_: ::aya_ebpf::cty::c_int,
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgstlen: ::aya_ebpf::cty::c_int,
        sig: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut ::aya_ebpf::cty::c_uint,
        eckey: *mut EC_KEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_sign_ex(
        type_: ::aya_ebpf::cty::c_int,
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgstlen: ::aya_ebpf::cty::c_int,
        sig: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut ::aya_ebpf::cty::c_uint,
        kinv: *const BIGNUM,
        rp: *const BIGNUM,
        eckey: *mut EC_KEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_verify(
        type_: ::aya_ebpf::cty::c_int,
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgstlen: ::aya_ebpf::cty::c_int,
        sig: *const ::aya_ebpf::cty::c_uchar,
        siglen: ::aya_ebpf::cty::c_int,
        eckey: *mut EC_KEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ECDSA_size(eckey: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EC_KEY_METHOD_new(meth: *const EC_KEY_METHOD) -> *mut EC_KEY_METHOD;
}
extern "C" {
    pub fn EC_KEY_METHOD_free(meth: *mut EC_KEY_METHOD);
}
extern "C" {
    pub fn EC_KEY_METHOD_set_init(
        meth: *mut EC_KEY_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::aya_ebpf::cty::c_int>,
        finish: ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY)>,
        copy: ::core::option::Option<
            unsafe extern "C" fn(dest: *mut EC_KEY, src: *const EC_KEY) -> ::aya_ebpf::cty::c_int,
        >,
        set_group: ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, grp: *const EC_GROUP) -> ::aya_ebpf::cty::c_int,
        >,
        set_private: ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, priv_key: *const BIGNUM) -> ::aya_ebpf::cty::c_int,
        >,
        set_public: ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, pub_key: *const EC_POINT) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_keygen(
        meth: *mut EC_KEY_METHOD,
        keygen: ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_compute_key(
        meth: *mut EC_KEY_METHOD,
        ckey: ::core::option::Option<
            unsafe extern "C" fn(
                psec: *mut *mut ::aya_ebpf::cty::c_uchar,
                pseclen: *mut usize,
                pub_key: *const EC_POINT,
                ecdh: *const EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_sign(
        meth: *mut EC_KEY_METHOD,
        sign: ::core::option::Option<
            unsafe extern "C" fn(
                type_: ::aya_ebpf::cty::c_int,
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dlen: ::aya_ebpf::cty::c_int,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut ::aya_ebpf::cty::c_uint,
                kinv: *const BIGNUM,
                r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        sign_setup: ::core::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx_in: *mut BN_CTX,
                kinvp: *mut *mut BIGNUM,
                rp: *mut *mut BIGNUM,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        sign_sig: ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dgst_len: ::aya_ebpf::cty::c_int,
                in_kinv: *const BIGNUM,
                in_r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_set_verify(
        meth: *mut EC_KEY_METHOD,
        verify: ::core::option::Option<
            unsafe extern "C" fn(
                type_: ::aya_ebpf::cty::c_int,
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dgst_len: ::aya_ebpf::cty::c_int,
                sigbuf: *const ::aya_ebpf::cty::c_uchar,
                sig_len: ::aya_ebpf::cty::c_int,
                eckey: *mut EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        verify_sig: ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dgst_len: ::aya_ebpf::cty::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_init(
        meth: *const EC_KEY_METHOD,
        pinit: *mut ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::aya_ebpf::cty::c_int>,
        pfinish: *mut ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY)>,
        pcopy: *mut ::core::option::Option<
            unsafe extern "C" fn(dest: *mut EC_KEY, src: *const EC_KEY) -> ::aya_ebpf::cty::c_int,
        >,
        pset_group: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, grp: *const EC_GROUP) -> ::aya_ebpf::cty::c_int,
        >,
        pset_private: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, priv_key: *const BIGNUM) -> ::aya_ebpf::cty::c_int,
        >,
        pset_public: *mut ::core::option::Option<
            unsafe extern "C" fn(key: *mut EC_KEY, pub_key: *const EC_POINT) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_keygen(
        meth: *const EC_KEY_METHOD,
        pkeygen: *mut ::core::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::aya_ebpf::cty::c_int>,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_compute_key(
        meth: *const EC_KEY_METHOD,
        pck: *mut ::core::option::Option<
            unsafe extern "C" fn(
                psec: *mut *mut ::aya_ebpf::cty::c_uchar,
                pseclen: *mut usize,
                pub_key: *const EC_POINT,
                ecdh: *const EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_sign(
        meth: *const EC_KEY_METHOD,
        psign: *mut ::core::option::Option<
            unsafe extern "C" fn(
                type_: ::aya_ebpf::cty::c_int,
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dlen: ::aya_ebpf::cty::c_int,
                sig: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut ::aya_ebpf::cty::c_uint,
                kinv: *const BIGNUM,
                r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        psign_setup: *mut ::core::option::Option<
            unsafe extern "C" fn(
                eckey: *mut EC_KEY,
                ctx_in: *mut BN_CTX,
                kinvp: *mut *mut BIGNUM,
                rp: *mut *mut BIGNUM,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        psign_sig: *mut ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dgst_len: ::aya_ebpf::cty::c_int,
                in_kinv: *const BIGNUM,
                in_r: *const BIGNUM,
                eckey: *mut EC_KEY,
            ) -> *mut ECDSA_SIG,
        >,
    );
}
extern "C" {
    pub fn EC_KEY_METHOD_get_verify(
        meth: *const EC_KEY_METHOD,
        pverify: *mut ::core::option::Option<
            unsafe extern "C" fn(
                type_: ::aya_ebpf::cty::c_int,
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dgst_len: ::aya_ebpf::cty::c_int,
                sigbuf: *const ::aya_ebpf::cty::c_uchar,
                sig_len: ::aya_ebpf::cty::c_int,
                eckey: *mut EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        pverify_sig: *mut ::core::option::Option<
            unsafe extern "C" fn(
                dgst: *const ::aya_ebpf::cty::c_uchar,
                dgst_len: ::aya_ebpf::cty::c_int,
                sig: *const ECDSA_SIG,
                eckey: *mut EC_KEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_padding(
        ctx: *mut EVP_PKEY_CTX,
        pad_mode: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_padding(
        ctx: *mut EVP_PKEY_CTX,
        pad_mode: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        saltlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_pss_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        saltlen: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_bits(
        ctx: *mut EVP_PKEY_CTX,
        bits: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set1_rsa_keygen_pubexp(ctx: *mut EVP_PKEY_CTX, pubexp: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_primes(
        ctx: *mut EVP_PKEY_CTX,
        primes: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        saltlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx: *mut EVP_PKEY_CTX, pubexp: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_mgf1_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_mgf1_md_name(
        ctx: *mut EVP_PKEY_CTX,
        mdname: *const ::aya_ebpf::cty::c_char,
        mdprops: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_mgf1_md(ctx: *mut EVP_PKEY_CTX, md: *mut *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_mgf1_md_name(
        ctx: *mut EVP_PKEY_CTX,
        name: *mut ::aya_ebpf::cty::c_char,
        namelen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md_name(
        ctx: *mut EVP_PKEY_CTX,
        mdname: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_md_name(
        ctx: *mut EVP_PKEY_CTX,
        mdname: *const ::aya_ebpf::cty::c_char,
        mdprops: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_oaep_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_oaep_md_name(
        ctx: *mut EVP_PKEY_CTX,
        mdname: *const ::aya_ebpf::cty::c_char,
        mdprops: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_oaep_md(ctx: *mut EVP_PKEY_CTX, md: *mut *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_oaep_md_name(
        ctx: *mut EVP_PKEY_CTX,
        name: *mut ::aya_ebpf::cty::c_char,
        namelen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx: *mut EVP_PKEY_CTX,
        label: *mut ::aya_ebpf::cty::c_void,
        llen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_rsa_oaep_label(
        ctx: *mut EVP_PKEY_CTX,
        label: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_new() -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_method(engine: *mut ENGINE) -> *mut RSA;
}
extern "C" {
    pub fn RSA_bits(rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_size(rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_security_bits(rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set0_key(r: *mut RSA, n: *mut BIGNUM, e: *mut BIGNUM, d: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set0_factors(r: *mut RSA, p: *mut BIGNUM, q: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set0_crt_params(
        r: *mut RSA,
        dmp1: *mut BIGNUM,
        dmq1: *mut BIGNUM,
        iqmp: *mut BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set0_multi_prime_params(
        r: *mut RSA,
        primes: *mut *mut BIGNUM,
        exps: *mut *mut BIGNUM,
        coeffs: *mut *mut BIGNUM,
        pnum: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_get0_key(r: *const RSA, n: *mut *const BIGNUM, e: *mut *const BIGNUM, d: *mut *const BIGNUM);
}
extern "C" {
    pub fn RSA_get0_factors(r: *const RSA, p: *mut *const BIGNUM, q: *mut *const BIGNUM);
}
extern "C" {
    pub fn RSA_get_multi_prime_extra_count(r: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_get0_multi_prime_factors(r: *const RSA, primes: *mut *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_get0_crt_params(
        r: *const RSA,
        dmp1: *mut *const BIGNUM,
        dmq1: *mut *const BIGNUM,
        iqmp: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_get0_multi_prime_crt_params(
        r: *const RSA,
        exps: *mut *const BIGNUM,
        coeffs: *mut *const BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_get0_n(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_e(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_d(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_p(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_q(d: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmp1(r: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmq1(r: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_iqmp(r: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_pss_params(r: *const RSA) -> *const RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_clear_flags(r: *mut RSA, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn RSA_test_flags(r: *const RSA, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set_flags(r: *mut RSA, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn RSA_get_version(r: *mut RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_get0_engine(r: *const RSA) -> *mut ENGINE;
}
extern "C" {
    pub fn RSA_generate_key(
        bits: ::aya_ebpf::cty::c_int,
        e: ::aya_ebpf::cty::c_ulong,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_generate_key_ex(
        rsa: *mut RSA,
        bits: ::aya_ebpf::cty::c_int,
        e: *mut BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_generate_multi_prime_key(
        rsa: *mut RSA,
        bits: ::aya_ebpf::cty::c_int,
        primes: ::aya_ebpf::cty::c_int,
        e: *mut BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_X931_derive_ex(
        rsa: *mut RSA,
        p1: *mut BIGNUM,
        p2: *mut BIGNUM,
        q1: *mut BIGNUM,
        q2: *mut BIGNUM,
        Xp1: *const BIGNUM,
        Xp2: *const BIGNUM,
        Xp: *const BIGNUM,
        Xq1: *const BIGNUM,
        Xq2: *const BIGNUM,
        Xq: *const BIGNUM,
        e: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_X931_generate_key_ex(
        rsa: *mut RSA,
        bits: ::aya_ebpf::cty::c_int,
        e: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_check_key(arg1: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_check_key_ex(arg1: *const RSA, cb: *mut BN_GENCB) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_public_encrypt(
        flen: ::aya_ebpf::cty::c_int,
        from: *const ::aya_ebpf::cty::c_uchar,
        to: *mut ::aya_ebpf::cty::c_uchar,
        rsa: *mut RSA,
        padding: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_private_encrypt(
        flen: ::aya_ebpf::cty::c_int,
        from: *const ::aya_ebpf::cty::c_uchar,
        to: *mut ::aya_ebpf::cty::c_uchar,
        rsa: *mut RSA,
        padding: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_public_decrypt(
        flen: ::aya_ebpf::cty::c_int,
        from: *const ::aya_ebpf::cty::c_uchar,
        to: *mut ::aya_ebpf::cty::c_uchar,
        rsa: *mut RSA,
        padding: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_private_decrypt(
        flen: ::aya_ebpf::cty::c_int,
        from: *const ::aya_ebpf::cty::c_uchar,
        to: *mut ::aya_ebpf::cty::c_uchar,
        rsa: *mut RSA,
        padding: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_free(r: *mut RSA);
}
extern "C" {
    pub fn RSA_up_ref(r: *mut RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_flags(r: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set_default_method(meth: *const RSA_METHOD);
}
extern "C" {
    pub fn RSA_get_default_method() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_null_method() -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_get_method(rsa: *const RSA) -> *const RSA_METHOD;
}
extern "C" {
    pub fn RSA_set_method(rsa: *mut RSA, meth: *const RSA_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_PKCS1_OpenSSL() -> *const RSA_METHOD;
}
extern "C" {
    pub fn d2i_RSAPublicKey(
        a: *mut *mut RSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey(a: *const RSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSAPublicKey_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn d2i_RSAPrivateKey(
        a: *mut *mut RSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey(a: *const RSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSAPrivateKey_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn RSA_pkey_ctx_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        optype: ::aya_ebpf::cty::c_int,
        cmd: ::aya_ebpf::cty::c_int,
        p1: ::aya_ebpf::cty::c_int,
        p2: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_pss_params_st {
    pub hashAlgorithm: *mut X509_ALGOR,
    pub maskGenAlgorithm: *mut X509_ALGOR,
    pub saltLength: *mut ASN1_INTEGER,
    pub trailerField: *mut ASN1_INTEGER,
    pub maskHash: *mut X509_ALGOR,
}
extern "C" {
    pub fn RSA_PSS_PARAMS_new() -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_free(a: *mut RSA_PSS_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_PSS_PARAMS(
        a: *mut *mut RSA_PSS_PARAMS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_PSS_PARAMS(
        a: *const RSA_PSS_PARAMS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_dup(a: *const RSA_PSS_PARAMS) -> *mut RSA_PSS_PARAMS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_oaep_params_st {
    pub hashFunc: *mut X509_ALGOR,
    pub maskGenFunc: *mut X509_ALGOR,
    pub pSourceFunc: *mut X509_ALGOR,
    pub maskHash: *mut X509_ALGOR,
}
pub type RSA_OAEP_PARAMS = rsa_oaep_params_st;
extern "C" {
    pub fn RSA_OAEP_PARAMS_new() -> *mut RSA_OAEP_PARAMS;
}
extern "C" {
    pub fn RSA_OAEP_PARAMS_free(a: *mut RSA_OAEP_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_OAEP_PARAMS(
        a: *mut *mut RSA_OAEP_PARAMS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut RSA_OAEP_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_OAEP_PARAMS(
        a: *const RSA_OAEP_PARAMS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_OAEP_PARAMS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn RSA_print_fp(fp: *mut FILE, r: *const RSA, offset: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_print(bp: *mut BIO, r: *const RSA, offset: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_sign(
        type_: ::aya_ebpf::cty::c_int,
        m: *const ::aya_ebpf::cty::c_uchar,
        m_length: ::aya_ebpf::cty::c_uint,
        sigret: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut ::aya_ebpf::cty::c_uint,
        rsa: *mut RSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_verify(
        type_: ::aya_ebpf::cty::c_int,
        m: *const ::aya_ebpf::cty::c_uchar,
        m_length: ::aya_ebpf::cty::c_uint,
        sigbuf: *const ::aya_ebpf::cty::c_uchar,
        siglen: ::aya_ebpf::cty::c_uint,
        rsa: *mut RSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_sign_ASN1_OCTET_STRING(
        type_: ::aya_ebpf::cty::c_int,
        m: *const ::aya_ebpf::cty::c_uchar,
        m_length: ::aya_ebpf::cty::c_uint,
        sigret: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut ::aya_ebpf::cty::c_uint,
        rsa: *mut RSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_verify_ASN1_OCTET_STRING(
        type_: ::aya_ebpf::cty::c_int,
        m: *const ::aya_ebpf::cty::c_uchar,
        m_length: ::aya_ebpf::cty::c_uint,
        sigbuf: *mut ::aya_ebpf::cty::c_uchar,
        siglen: ::aya_ebpf::cty::c_uint,
        rsa: *mut RSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_blinding_on(rsa: *mut RSA, ctx: *mut BN_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_blinding_off(rsa: *mut RSA);
}
extern "C" {
    pub fn RSA_setup_blinding(rsa: *mut RSA, ctx: *mut BN_CTX) -> *mut BN_BLINDING;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_type_1(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_type_1(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
        rsa_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_type_2(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_type_2(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
        rsa_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS1_MGF1(
        mask: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
        seed: *const ::aya_ebpf::cty::c_uchar,
        seedlen: ::aya_ebpf::cty::c_long,
        dgst: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
        p: *const ::aya_ebpf::cty::c_uchar,
        pl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_OAEP(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
        rsa_len: ::aya_ebpf::cty::c_int,
        p: *const ::aya_ebpf::cty::c_uchar,
        pl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP_mgf1(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        from: *const ::aya_ebpf::cty::c_uchar,
        flen: ::aya_ebpf::cty::c_int,
        param: *const ::aya_ebpf::cty::c_uchar,
        plen: ::aya_ebpf::cty::c_int,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_check_PKCS1_OAEP_mgf1(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        from: *const ::aya_ebpf::cty::c_uchar,
        flen: ::aya_ebpf::cty::c_int,
        num: ::aya_ebpf::cty::c_int,
        param: *const ::aya_ebpf::cty::c_uchar,
        plen: ::aya_ebpf::cty::c_int,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_none(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_check_none(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
        rsa_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_X931(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_check_X931(
        to: *mut ::aya_ebpf::cty::c_uchar,
        tlen: ::aya_ebpf::cty::c_int,
        f: *const ::aya_ebpf::cty::c_uchar,
        fl: ::aya_ebpf::cty::c_int,
        rsa_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_X931_hash_id(nid: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS(
        rsa: *mut RSA,
        mHash: *const ::aya_ebpf::cty::c_uchar,
        Hash: *const EVP_MD,
        EM: *const ::aya_ebpf::cty::c_uchar,
        sLen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS(
        rsa: *mut RSA,
        EM: *mut ::aya_ebpf::cty::c_uchar,
        mHash: *const ::aya_ebpf::cty::c_uchar,
        Hash: *const EVP_MD,
        sLen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS_mgf1(
        rsa: *mut RSA,
        mHash: *const ::aya_ebpf::cty::c_uchar,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        EM: *const ::aya_ebpf::cty::c_uchar,
        sLen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS_mgf1(
        rsa: *mut RSA,
        EM: *mut ::aya_ebpf::cty::c_uchar,
        mHash: *const ::aya_ebpf::cty::c_uchar,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        sLen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_set_ex_data(
        r: *mut RSA,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_get_ex_data(r: *const RSA, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn RSAPublicKey_dup(a: *const RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSAPrivateKey_dup(a: *const RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSA_meth_new(name: *const ::aya_ebpf::cty::c_char, flags: ::aya_ebpf::cty::c_int) -> *mut RSA_METHOD;
}
extern "C" {
    pub fn RSA_meth_free(meth: *mut RSA_METHOD);
}
extern "C" {
    pub fn RSA_meth_dup(meth: *const RSA_METHOD) -> *mut RSA_METHOD;
}
extern "C" {
    pub fn RSA_meth_get0_name(meth: *const RSA_METHOD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn RSA_meth_set1_name(meth: *mut RSA_METHOD, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_flags(meth: *const RSA_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_set_flags(meth: *mut RSA_METHOD, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get0_app_data(meth: *const RSA_METHOD) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn RSA_meth_set0_app_data(
        meth: *mut RSA_METHOD,
        app_data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_pub_enc(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: ::aya_ebpf::cty::c_int,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: *mut ::aya_ebpf::cty::c_uchar,
            arg3: *mut RSA,
            arg4: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_pub_enc(
        rsa: *mut RSA_METHOD,
        pub_enc: ::core::option::Option<
            unsafe extern "C" fn(
                flen: ::aya_ebpf::cty::c_int,
                from: *const ::aya_ebpf::cty::c_uchar,
                to: *mut ::aya_ebpf::cty::c_uchar,
                rsa: *mut RSA,
                padding: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_pub_dec(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: ::aya_ebpf::cty::c_int,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: *mut ::aya_ebpf::cty::c_uchar,
            arg3: *mut RSA,
            arg4: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_pub_dec(
        rsa: *mut RSA_METHOD,
        pub_dec: ::core::option::Option<
            unsafe extern "C" fn(
                flen: ::aya_ebpf::cty::c_int,
                from: *const ::aya_ebpf::cty::c_uchar,
                to: *mut ::aya_ebpf::cty::c_uchar,
                rsa: *mut RSA,
                padding: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_priv_enc(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: ::aya_ebpf::cty::c_int,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: *mut ::aya_ebpf::cty::c_uchar,
            arg3: *mut RSA,
            arg4: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_priv_enc(
        rsa: *mut RSA_METHOD,
        priv_enc: ::core::option::Option<
            unsafe extern "C" fn(
                flen: ::aya_ebpf::cty::c_int,
                from: *const ::aya_ebpf::cty::c_uchar,
                to: *mut ::aya_ebpf::cty::c_uchar,
                rsa: *mut RSA,
                padding: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_priv_dec(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: ::aya_ebpf::cty::c_int,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: *mut ::aya_ebpf::cty::c_uchar,
            arg3: *mut RSA,
            arg4: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_priv_dec(
        rsa: *mut RSA_METHOD,
        priv_dec: ::core::option::Option<
            unsafe extern "C" fn(
                flen: ::aya_ebpf::cty::c_int,
                from: *const ::aya_ebpf::cty::c_uchar,
                to: *mut ::aya_ebpf::cty::c_uchar,
                rsa: *mut RSA,
                padding: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_mod_exp(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *mut RSA,
            arg3: *mut BN_CTX,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_mod_exp(
        rsa: *mut RSA_METHOD,
        mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                r0: *mut BIGNUM,
                i: *const BIGNUM,
                rsa: *mut RSA,
                ctx: *mut BN_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_bn_mod_exp(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: *mut BIGNUM,
            arg1: *const BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *mut BN_CTX,
            arg5: *mut BN_MONT_CTX,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_bn_mod_exp(
        rsa: *mut RSA_METHOD,
        bn_mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                r: *mut BIGNUM,
                a: *const BIGNUM,
                p: *const BIGNUM,
                m: *const BIGNUM,
                ctx: *mut BN_CTX,
                m_ctx: *mut BN_MONT_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_init(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(meth: *mut RSA) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn RSA_meth_set_init(
        rsa: *mut RSA_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_finish(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(meth: *mut RSA) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn RSA_meth_set_finish(
        rsa: *mut RSA_METHOD,
        finish: ::core::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_sign(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: ::aya_ebpf::cty::c_int,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: ::aya_ebpf::cty::c_uint,
            arg3: *mut ::aya_ebpf::cty::c_uchar,
            arg4: *mut ::aya_ebpf::cty::c_uint,
            arg5: *const RSA,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_sign(
        rsa: *mut RSA_METHOD,
        sign: ::core::option::Option<
            unsafe extern "C" fn(
                type_: ::aya_ebpf::cty::c_int,
                m: *const ::aya_ebpf::cty::c_uchar,
                m_length: ::aya_ebpf::cty::c_uint,
                sigret: *mut ::aya_ebpf::cty::c_uchar,
                siglen: *mut ::aya_ebpf::cty::c_uint,
                rsa: *const RSA,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_verify(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: ::aya_ebpf::cty::c_int,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: ::aya_ebpf::cty::c_uint,
            arg3: *const ::aya_ebpf::cty::c_uchar,
            arg4: ::aya_ebpf::cty::c_uint,
            arg5: *const RSA,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_verify(
        rsa: *mut RSA_METHOD,
        verify: ::core::option::Option<
            unsafe extern "C" fn(
                dtype: ::aya_ebpf::cty::c_int,
                m: *const ::aya_ebpf::cty::c_uchar,
                m_length: ::aya_ebpf::cty::c_uint,
                sigbuf: *const ::aya_ebpf::cty::c_uchar,
                siglen: ::aya_ebpf::cty::c_uint,
                rsa: *const RSA,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_keygen(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: *mut RSA,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: *mut BIGNUM,
            arg3: *mut BN_GENCB,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_keygen(
        rsa: *mut RSA_METHOD,
        keygen: ::core::option::Option<
            unsafe extern "C" fn(
                rsa: *mut RSA,
                bits: ::aya_ebpf::cty::c_int,
                e: *mut BIGNUM,
                cb: *mut BN_GENCB,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RSA_meth_get_multi_prime_keygen(
        meth: *const RSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            meth: *mut RSA,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: *mut BIGNUM,
            arg4: *mut BN_GENCB,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn RSA_meth_set_multi_prime_keygen(
        meth: *mut RSA_METHOD,
        keygen: ::core::option::Option<
            unsafe extern "C" fn(
                rsa: *mut RSA,
                bits: ::aya_ebpf::cty::c_int,
                primes: ::aya_ebpf::cty::c_int,
                e: *mut BIGNUM,
                cb: *mut BN_GENCB,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_paramgen_type(
        ctx: *mut EVP_PKEY_CTX,
        typ: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_paramgen_gindex(
        ctx: *mut EVP_PKEY_CTX,
        gindex: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_paramgen_seed(
        ctx: *mut EVP_PKEY_CTX,
        seed: *const ::aya_ebpf::cty::c_uchar,
        seedlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_paramgen_prime_len(
        ctx: *mut EVP_PKEY_CTX,
        pbits: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_paramgen_subprime_len(
        ctx: *mut EVP_PKEY_CTX,
        qlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_paramgen_generator(
        ctx: *mut EVP_PKEY_CTX,
        gen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_nid(ctx: *mut EVP_PKEY_CTX, nid: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_rfc5114(ctx: *mut EVP_PKEY_CTX, gen: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dhx_rfc5114(ctx: *mut EVP_PKEY_CTX, gen: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_pad(ctx: *mut EVP_PKEY_CTX, pad: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_kdf_type(ctx: *mut EVP_PKEY_CTX, kdf: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_dh_kdf_type(ctx: *mut EVP_PKEY_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_dh_kdf_oid(ctx: *mut EVP_PKEY_CTX, oid: *mut ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_dh_kdf_oid(ctx: *mut EVP_PKEY_CTX, oid: *mut *mut ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_kdf_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_dh_kdf_md(ctx: *mut EVP_PKEY_CTX, md: *mut *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dh_kdf_outlen(ctx: *mut EVP_PKEY_CTX, len: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_dh_kdf_outlen(
        ctx: *mut EVP_PKEY_CTX,
        len: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_dh_kdf_ukm(
        ctx: *mut EVP_PKEY_CTX,
        ukm: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_dh_kdf_ukm(
        ctx: *mut EVP_PKEY_CTX,
        ukm: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DHparams_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn DHparams_dup(a: *const DH) -> *mut DH;
}
extern "C" {
    pub fn DH_OpenSSL() -> *const DH_METHOD;
}
extern "C" {
    pub fn DH_set_default_method(meth: *const DH_METHOD);
}
extern "C" {
    pub fn DH_get_default_method() -> *const DH_METHOD;
}
extern "C" {
    pub fn DH_set_method(dh: *mut DH, meth: *const DH_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_new_method(engine: *mut ENGINE) -> *mut DH;
}
extern "C" {
    pub fn DH_new() -> *mut DH;
}
extern "C" {
    pub fn DH_free(dh: *mut DH);
}
extern "C" {
    pub fn DH_up_ref(dh: *mut DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_bits(dh: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_size(dh: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_security_bits(dh: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_set_ex_data(
        d: *mut DH,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_get_ex_data(d: *const DH, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn DH_generate_parameters_ex(
        dh: *mut DH,
        prime_len: ::aya_ebpf::cty::c_int,
        generator: ::aya_ebpf::cty::c_int,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_check_params_ex(dh: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_check_ex(dh: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_check_pub_key_ex(dh: *const DH, pub_key: *const BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_check_params(dh: *const DH, ret: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_check(dh: *const DH, codes: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_check_pub_key(
        dh: *const DH,
        pub_key: *const BIGNUM,
        codes: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_generate_key(dh: *mut DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_compute_key(
        key: *mut ::aya_ebpf::cty::c_uchar,
        pub_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_compute_key_padded(
        key: *mut ::aya_ebpf::cty::c_uchar,
        pub_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DHparams(
        a: *mut *mut DH,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHparams(a: *const DH, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DHxparams(
        a: *mut *mut DH,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHxparams(a: *const DH, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DHparams_print_fp(fp: *mut FILE, x: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DHparams_print(bp: *mut BIO, x: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_get_1024_160() -> *mut DH;
}
extern "C" {
    pub fn DH_get_2048_224() -> *mut DH;
}
extern "C" {
    pub fn DH_get_2048_256() -> *mut DH;
}
extern "C" {
    pub fn DH_new_by_nid(nid: ::aya_ebpf::cty::c_int) -> *mut DH;
}
extern "C" {
    pub fn DH_get_nid(dh: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_KDF_X9_42(
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: usize,
        Z: *const ::aya_ebpf::cty::c_uchar,
        Zlen: usize,
        key_oid: *mut ASN1_OBJECT,
        ukm: *const ::aya_ebpf::cty::c_uchar,
        ukmlen: usize,
        md: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_get0_pqg(dh: *const DH, p: *mut *const BIGNUM, q: *mut *const BIGNUM, g: *mut *const BIGNUM);
}
extern "C" {
    pub fn DH_set0_pqg(dh: *mut DH, p: *mut BIGNUM, q: *mut BIGNUM, g: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_get0_key(dh: *const DH, pub_key: *mut *const BIGNUM, priv_key: *mut *const BIGNUM);
}
extern "C" {
    pub fn DH_set0_key(dh: *mut DH, pub_key: *mut BIGNUM, priv_key: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_get0_p(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_q(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_g(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_priv_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_pub_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_clear_flags(dh: *mut DH, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn DH_test_flags(dh: *const DH, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_set_flags(dh: *mut DH, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn DH_get0_engine(d: *mut DH) -> *mut ENGINE;
}
extern "C" {
    pub fn DH_get_length(dh: *const DH) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn DH_set_length(dh: *mut DH, length: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_new(name: *const ::aya_ebpf::cty::c_char, flags: ::aya_ebpf::cty::c_int) -> *mut DH_METHOD;
}
extern "C" {
    pub fn DH_meth_free(dhm: *mut DH_METHOD);
}
extern "C" {
    pub fn DH_meth_dup(dhm: *const DH_METHOD) -> *mut DH_METHOD;
}
extern "C" {
    pub fn DH_meth_get0_name(dhm: *const DH_METHOD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn DH_meth_set1_name(dhm: *mut DH_METHOD, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_flags(dhm: *const DH_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_set_flags(dhm: *mut DH_METHOD, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get0_app_data(dhm: *const DH_METHOD) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn DH_meth_set0_app_data(dhm: *mut DH_METHOD, app_data: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_generate_key(
        dhm: *const DH_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(dhm: *mut DH) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn DH_meth_set_generate_key(
        dhm: *mut DH_METHOD,
        generate_key: ::core::option::Option<unsafe extern "C" fn(arg1: *mut DH) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_compute_key(
        dhm: *const DH_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dhm: *mut ::aya_ebpf::cty::c_uchar,
            arg1: *const BIGNUM,
            arg2: *mut DH,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DH_meth_set_compute_key(
        dhm: *mut DH_METHOD,
        compute_key: ::core::option::Option<
            unsafe extern "C" fn(
                key: *mut ::aya_ebpf::cty::c_uchar,
                pub_key: *const BIGNUM,
                dh: *mut DH,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_bn_mod_exp(
        dhm: *const DH_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dhm: *const DH,
            arg1: *mut BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *const BIGNUM,
            arg5: *mut BN_CTX,
            arg6: *mut BN_MONT_CTX,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DH_meth_set_bn_mod_exp(
        dhm: *mut DH_METHOD,
        bn_mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const DH,
                arg2: *mut BIGNUM,
                arg3: *const BIGNUM,
                arg4: *const BIGNUM,
                arg5: *const BIGNUM,
                arg6: *mut BN_CTX,
                arg7: *mut BN_MONT_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_init(
        dhm: *const DH_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(dhm: *mut DH) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn DH_meth_set_init(
        dhm: *mut DH_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut DH) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_finish(
        dhm: *const DH_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(dhm: *mut DH) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn DH_meth_set_finish(
        dhm: *mut DH_METHOD,
        finish: ::core::option::Option<unsafe extern "C" fn(arg1: *mut DH) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_meth_get_generate_params(
        dhm: *const DH_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dhm: *mut DH,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: *mut BN_GENCB,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DH_meth_set_generate_params(
        dhm: *mut DH_METHOD,
        generate_params: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DH,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: ::aya_ebpf::cty::c_int,
                arg4: *mut BN_GENCB,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DH_generate_parameters(
        prime_len: ::aya_ebpf::cty::c_int,
        generator: ::aya_ebpf::cty::c_int,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_bits(
        ctx: *mut EVP_PKEY_CTX,
        nbits: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
        ctx: *mut EVP_PKEY_CTX,
        qbits: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_md_props(
        ctx: *mut EVP_PKEY_CTX,
        md_name: *const ::aya_ebpf::cty::c_char,
        md_properties: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_gindex(
        ctx: *mut EVP_PKEY_CTX,
        gindex: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_type(
        ctx: *mut EVP_PKEY_CTX,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_seed(
        ctx: *mut EVP_PKEY_CTX,
        seed: *const ::aya_ebpf::cty::c_uchar,
        seedlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_md(ctx: *mut EVP_PKEY_CTX, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DSA_SIG_st {
    _unused: [u8; 0],
}
pub type DSA_SIG = DSA_SIG_st;
extern "C" {
    pub fn DSA_SIG_new() -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_free(a: *mut DSA_SIG);
}
extern "C" {
    pub fn d2i_DSA_SIG(
        a: *mut *mut DSA_SIG,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn i2d_DSA_SIG(a: *const DSA_SIG, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_SIG_get0(sig: *const DSA_SIG, pr: *mut *const BIGNUM, ps: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_SIG_set0(sig: *mut DSA_SIG, r: *mut BIGNUM, s: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSAparams_dup(a: *const DSA) -> *mut DSA;
}
extern "C" {
    pub fn DSA_do_sign(
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dlen: ::aya_ebpf::cty::c_int,
        dsa: *mut DSA,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_do_verify(
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgst_len: ::aya_ebpf::cty::c_int,
        sig: *mut DSA_SIG,
        dsa: *mut DSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_OpenSSL() -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_set_default_method(arg1: *const DSA_METHOD);
}
extern "C" {
    pub fn DSA_get_default_method() -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_set_method(dsa: *mut DSA, arg1: *const DSA_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_get_method(d: *mut DSA) -> *const DSA_METHOD;
}
extern "C" {
    pub fn DSA_new() -> *mut DSA;
}
extern "C" {
    pub fn DSA_new_method(engine: *mut ENGINE) -> *mut DSA;
}
extern "C" {
    pub fn DSA_free(r: *mut DSA);
}
extern "C" {
    pub fn DSA_up_ref(r: *mut DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_size(arg1: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_bits(d: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_security_bits(d: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_sign_setup(
        dsa: *mut DSA,
        ctx_in: *mut BN_CTX,
        kinvp: *mut *mut BIGNUM,
        rp: *mut *mut BIGNUM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_sign(
        type_: ::aya_ebpf::cty::c_int,
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dlen: ::aya_ebpf::cty::c_int,
        sig: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut ::aya_ebpf::cty::c_uint,
        dsa: *mut DSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_verify(
        type_: ::aya_ebpf::cty::c_int,
        dgst: *const ::aya_ebpf::cty::c_uchar,
        dgst_len: ::aya_ebpf::cty::c_int,
        sigbuf: *const ::aya_ebpf::cty::c_uchar,
        siglen: ::aya_ebpf::cty::c_int,
        dsa: *mut DSA,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_set_ex_data(
        d: *mut DSA,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_get_ex_data(d: *const DSA, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn d2i_DSAPublicKey(
        a: *mut *mut DSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPublicKey(a: *const DSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey(
        a: *mut *mut DSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey(a: *const DSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSAparams(
        a: *mut *mut DSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAparams(a: *const DSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_generate_parameters(
        bits: ::aya_ebpf::cty::c_int,
        seed: *mut ::aya_ebpf::cty::c_uchar,
        seed_len: ::aya_ebpf::cty::c_int,
        counter_ret: *mut ::aya_ebpf::cty::c_int,
        h_ret: *mut ::aya_ebpf::cty::c_ulong,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
        cb_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn DSA_generate_parameters_ex(
        dsa: *mut DSA,
        bits: ::aya_ebpf::cty::c_int,
        seed: *const ::aya_ebpf::cty::c_uchar,
        seed_len: ::aya_ebpf::cty::c_int,
        counter_ret: *mut ::aya_ebpf::cty::c_int,
        h_ret: *mut ::aya_ebpf::cty::c_ulong,
        cb: *mut BN_GENCB,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_generate_key(a: *mut DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSAparams_print(bp: *mut BIO, x: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_print(bp: *mut BIO, x: *const DSA, off: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSAparams_print_fp(fp: *mut FILE, x: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_print_fp(bp: *mut FILE, x: *const DSA, off: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_dup_DH(r: *const DSA) -> *mut DH;
}
extern "C" {
    pub fn DSA_get0_pqg(d: *const DSA, p: *mut *const BIGNUM, q: *mut *const BIGNUM, g: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_set0_pqg(d: *mut DSA, p: *mut BIGNUM, q: *mut BIGNUM, g: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_get0_key(d: *const DSA, pub_key: *mut *const BIGNUM, priv_key: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_set0_key(d: *mut DSA, pub_key: *mut BIGNUM, priv_key: *mut BIGNUM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_get0_p(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_q(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_g(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_pub_key(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_priv_key(d: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_clear_flags(d: *mut DSA, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn DSA_test_flags(d: *const DSA, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_set_flags(d: *mut DSA, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn DSA_get0_engine(d: *mut DSA) -> *mut ENGINE;
}
extern "C" {
    pub fn DSA_meth_new(name: *const ::aya_ebpf::cty::c_char, flags: ::aya_ebpf::cty::c_int) -> *mut DSA_METHOD;
}
extern "C" {
    pub fn DSA_meth_free(dsam: *mut DSA_METHOD);
}
extern "C" {
    pub fn DSA_meth_dup(dsam: *const DSA_METHOD) -> *mut DSA_METHOD;
}
extern "C" {
    pub fn DSA_meth_get0_name(dsam: *const DSA_METHOD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn DSA_meth_set1_name(dsam: *mut DSA_METHOD, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_flags(dsam: *const DSA_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_set_flags(dsam: *mut DSA_METHOD, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get0_app_data(dsam: *const DSA_METHOD) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn DSA_meth_set0_app_data(
        dsam: *mut DSA_METHOD,
        app_data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_sign(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dsam: *const ::aya_ebpf::cty::c_uchar,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: *mut DSA,
        ) -> *mut DSA_SIG,
    >;
}
extern "C" {
    pub fn DSA_meth_set_sign(
        dsam: *mut DSA_METHOD,
        sign: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_uchar,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut DSA,
            ) -> *mut DSA_SIG,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_sign_setup(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: *mut BN_CTX,
            arg2: *mut *mut BIGNUM,
            arg3: *mut *mut BIGNUM,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_sign_setup(
        dsam: *mut DSA_METHOD,
        sign_setup: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: *mut BN_CTX,
                arg3: *mut *mut BIGNUM,
                arg4: *mut *mut BIGNUM,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_verify(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dsam: *const ::aya_ebpf::cty::c_uchar,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: *mut DSA_SIG,
            arg3: *mut DSA,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_verify(
        dsam: *mut DSA_METHOD,
        verify: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::aya_ebpf::cty::c_uchar,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *mut DSA_SIG,
                arg4: *mut DSA,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_mod_exp(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: *mut BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *const BIGNUM,
            arg5: *const BIGNUM,
            arg6: *const BIGNUM,
            arg7: *mut BN_CTX,
            arg8: *mut BN_MONT_CTX,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_mod_exp(
        dsam: *mut DSA_METHOD,
        mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: *mut BIGNUM,
                arg3: *const BIGNUM,
                arg4: *const BIGNUM,
                arg5: *const BIGNUM,
                arg6: *const BIGNUM,
                arg7: *const BIGNUM,
                arg8: *mut BN_CTX,
                arg9: *mut BN_MONT_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_bn_mod_exp(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: *mut BIGNUM,
            arg2: *const BIGNUM,
            arg3: *const BIGNUM,
            arg4: *const BIGNUM,
            arg5: *mut BN_CTX,
            arg6: *mut BN_MONT_CTX,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_bn_mod_exp(
        dsam: *mut DSA_METHOD,
        bn_mod_exp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: *mut BIGNUM,
                arg3: *const BIGNUM,
                arg4: *const BIGNUM,
                arg5: *const BIGNUM,
                arg6: *mut BN_CTX,
                arg7: *mut BN_MONT_CTX,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_init(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(dsam: *mut DSA) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn DSA_meth_set_init(
        dsam: *mut DSA_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut DSA) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_finish(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(dsam: *mut DSA) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn DSA_meth_set_finish(
        dsam: *mut DSA_METHOD,
        finish: ::core::option::Option<unsafe extern "C" fn(arg1: *mut DSA) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_paramgen(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            dsam: *mut DSA,
            arg1: ::aya_ebpf::cty::c_int,
            arg2: *const ::aya_ebpf::cty::c_uchar,
            arg3: ::aya_ebpf::cty::c_int,
            arg4: *mut ::aya_ebpf::cty::c_int,
            arg5: *mut ::aya_ebpf::cty::c_ulong,
            arg6: *mut BN_GENCB,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn DSA_meth_set_paramgen(
        dsam: *mut DSA_METHOD,
        paramgen: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut DSA,
                arg2: ::aya_ebpf::cty::c_int,
                arg3: *const ::aya_ebpf::cty::c_uchar,
                arg4: ::aya_ebpf::cty::c_int,
                arg5: *mut ::aya_ebpf::cty::c_int,
                arg6: *mut ::aya_ebpf::cty::c_ulong,
                arg7: *mut BN_GENCB,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DSA_meth_get_keygen(
        dsam: *const DSA_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(dsam: *mut DSA) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn DSA_meth_set_keygen(
        dsam: *mut DSA_METHOD,
        keygen: ::core::option::Option<unsafe extern "C" fn(arg1: *mut DSA) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAstate_st {
    pub h0: ::aya_ebpf::cty::c_uint,
    pub h1: ::aya_ebpf::cty::c_uint,
    pub h2: ::aya_ebpf::cty::c_uint,
    pub h3: ::aya_ebpf::cty::c_uint,
    pub h4: ::aya_ebpf::cty::c_uint,
    pub Nl: ::aya_ebpf::cty::c_uint,
    pub Nh: ::aya_ebpf::cty::c_uint,
    pub data: [::aya_ebpf::cty::c_uint; 16usize],
    pub num: ::aya_ebpf::cty::c_uint,
}
pub type SHA_CTX = SHAstate_st;
extern "C" {
    pub fn SHA1_Init(c: *mut SHA_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA1_Update(c: *mut SHA_CTX, data: *const ::aya_ebpf::cty::c_void, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA1_Final(md: *mut ::aya_ebpf::cty::c_uchar, c: *mut SHA_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA1_Transform(c: *mut SHA_CTX, data: *const ::aya_ebpf::cty::c_uchar);
}
extern "C" {
    pub fn SHA1(
        d: *const ::aya_ebpf::cty::c_uchar,
        n: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA256state_st {
    pub h: [::aya_ebpf::cty::c_uint; 8usize],
    pub Nl: ::aya_ebpf::cty::c_uint,
    pub Nh: ::aya_ebpf::cty::c_uint,
    pub data: [::aya_ebpf::cty::c_uint; 16usize],
    pub num: ::aya_ebpf::cty::c_uint,
    pub md_len: ::aya_ebpf::cty::c_uint,
}
pub type SHA256_CTX = SHA256state_st;
extern "C" {
    pub fn SHA224_Init(c: *mut SHA256_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA224_Update(c: *mut SHA256_CTX, data: *const ::aya_ebpf::cty::c_void, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA224_Final(md: *mut ::aya_ebpf::cty::c_uchar, c: *mut SHA256_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA256_Init(c: *mut SHA256_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA256_Update(c: *mut SHA256_CTX, data: *const ::aya_ebpf::cty::c_void, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA256_Final(md: *mut ::aya_ebpf::cty::c_uchar, c: *mut SHA256_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA256_Transform(c: *mut SHA256_CTX, data: *const ::aya_ebpf::cty::c_uchar);
}
extern "C" {
    pub fn SHA224(
        d: *const ::aya_ebpf::cty::c_uchar,
        n: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn SHA256(
        d: *const ::aya_ebpf::cty::c_uchar,
        n: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHA512state_st {
    pub h: [::aya_ebpf::cty::c_ulonglong; 8usize],
    pub Nl: ::aya_ebpf::cty::c_ulonglong,
    pub Nh: ::aya_ebpf::cty::c_ulonglong,
    pub u: SHA512state_st__bindgen_ty_1,
    pub num: ::aya_ebpf::cty::c_uint,
    pub md_len: ::aya_ebpf::cty::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512state_st__bindgen_ty_1 {
    pub d: [::aya_ebpf::cty::c_ulonglong; 16usize],
    pub p: [::aya_ebpf::cty::c_uchar; 128usize],
}
pub type SHA512_CTX = SHA512state_st;
extern "C" {
    pub fn SHA384_Init(c: *mut SHA512_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA384_Update(c: *mut SHA512_CTX, data: *const ::aya_ebpf::cty::c_void, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA384_Final(md: *mut ::aya_ebpf::cty::c_uchar, c: *mut SHA512_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA512_Init(c: *mut SHA512_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA512_Update(c: *mut SHA512_CTX, data: *const ::aya_ebpf::cty::c_void, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA512_Final(md: *mut ::aya_ebpf::cty::c_uchar, c: *mut SHA512_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SHA512_Transform(c: *mut SHA512_CTX, data: *const ::aya_ebpf::cty::c_uchar);
}
extern "C" {
    pub fn SHA384(
        d: *const ::aya_ebpf::cty::c_uchar,
        n: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn SHA512(
        d: *const ::aya_ebpf::cty::c_uchar,
        n: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME {
    _unused: [u8; 0],
}
pub type sk_X509_NAME_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_NAME, b: *const *const X509_NAME) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_NAME_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_NAME)>;
pub type sk_X509_NAME_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const X509_NAME) -> *mut X509_NAME>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509 {
    _unused: [u8; 0],
}
pub type sk_X509_compfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const *const X509, b: *const *const X509) -> ::aya_ebpf::cty::c_int>;
pub type sk_X509_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509)>;
pub type sk_X509_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const X509) -> *mut X509>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_REVOKED {
    _unused: [u8; 0],
}
pub type sk_X509_REVOKED_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_REVOKED, b: *const *const X509_REVOKED) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_REVOKED_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_REVOKED)>;
pub type sk_X509_REVOKED_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_REVOKED) -> *mut X509_REVOKED>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_CRL {
    _unused: [u8; 0],
}
pub type sk_X509_CRL_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_CRL, b: *const *const X509_CRL) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_CRL_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_CRL)>;
pub type sk_X509_CRL_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const X509_CRL) -> *mut X509_CRL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_algor_st {
    pub algorithm: *mut ASN1_OBJECT,
    pub parameter: *mut ASN1_TYPE,
}
pub type X509_ALGORS = stack_st_X509_ALGOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_val_st {
    pub notBefore: *mut ASN1_TIME,
    pub notAfter: *mut ASN1_TIME,
}
pub type X509_VAL = X509_val_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_sig_st {
    _unused: [u8; 0],
}
pub type X509_SIG = X509_sig_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_entry_st {
    _unused: [u8; 0],
}
pub type X509_NAME_ENTRY = X509_name_entry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME_ENTRY {
    _unused: [u8; 0],
}
pub type sk_X509_NAME_ENTRY_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_NAME_ENTRY, b: *const *const X509_NAME_ENTRY) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_NAME_ENTRY_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_NAME_ENTRY)>;
pub type sk_X509_NAME_ENTRY_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_extension_st {
    _unused: [u8; 0],
}
pub type X509_EXTENSION = X509_extension_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_EXTENSION {
    _unused: [u8; 0],
}
pub type sk_X509_EXTENSION_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_EXTENSION, b: *const *const X509_EXTENSION) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_EXTENSION_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_EXTENSION)>;
pub type sk_X509_EXTENSION_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_EXTENSION) -> *mut X509_EXTENSION>;
pub type X509_EXTENSIONS = stack_st_X509_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_attributes_st {
    _unused: [u8; 0],
}
pub type X509_ATTRIBUTE = x509_attributes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ATTRIBUTE {
    _unused: [u8; 0],
}
pub type sk_X509_ATTRIBUTE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_ATTRIBUTE, b: *const *const X509_ATTRIBUTE) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_ATTRIBUTE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_ATTRIBUTE)>;
pub type sk_X509_ATTRIBUTE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_info_st {
    _unused: [u8; 0],
}
pub type X509_REQ_INFO = X509_req_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_st {
    _unused: [u8; 0],
}
pub type X509_REQ = X509_req_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cert_aux_st {
    _unused: [u8; 0],
}
pub type X509_CERT_AUX = x509_cert_aux_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_cinf_st {
    _unused: [u8; 0],
}
pub type X509_CINF = x509_cinf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_info_st {
    _unused: [u8; 0],
}
pub type X509_CRL_INFO = X509_crl_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct private_key_st {
    pub version: ::aya_ebpf::cty::c_int,
    pub enc_algor: *mut X509_ALGOR,
    pub enc_pkey: *mut ASN1_OCTET_STRING,
    pub dec_pkey: *mut EVP_PKEY,
    pub key_length: ::aya_ebpf::cty::c_int,
    pub key_data: *mut ::aya_ebpf::cty::c_char,
    pub key_free: ::aya_ebpf::cty::c_int,
    pub cipher: EVP_CIPHER_INFO,
}
pub type X509_PKEY = private_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_info_st {
    pub x509: *mut X509,
    pub crl: *mut X509_CRL,
    pub x_pkey: *mut X509_PKEY,
    pub enc_cipher: EVP_CIPHER_INFO,
    pub enc_len: ::aya_ebpf::cty::c_int,
    pub enc_data: *mut ::aya_ebpf::cty::c_char,
}
pub type X509_INFO = X509_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_INFO {
    _unused: [u8; 0],
}
pub type sk_X509_INFO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_INFO, b: *const *const X509_INFO) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_INFO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_INFO)>;
pub type sk_X509_INFO_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const X509_INFO) -> *mut X509_INFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spkac_st {
    pub pubkey: *mut X509_PUBKEY,
    pub challenge: *mut ASN1_IA5STRING,
}
pub type NETSCAPE_SPKAC = Netscape_spkac_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spki_st {
    pub spkac: *mut NETSCAPE_SPKAC,
    pub sig_algor: X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
}
pub type NETSCAPE_SPKI = Netscape_spki_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_certificate_sequence {
    pub type_: *mut ASN1_OBJECT,
    pub certs: *mut stack_st_X509,
}
pub type NETSCAPE_CERT_SEQUENCE = Netscape_certificate_sequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBEPARAM_st {
    pub salt: *mut ASN1_OCTET_STRING,
    pub iter: *mut ASN1_INTEGER,
}
pub type PBEPARAM = PBEPARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBE2PARAM_st {
    pub keyfunc: *mut X509_ALGOR,
    pub encryption: *mut X509_ALGOR,
}
pub type PBE2PARAM = PBE2PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PBKDF2PARAM_st {
    pub salt: *mut ASN1_TYPE,
    pub iter: *mut ASN1_INTEGER,
    pub keylength: *mut ASN1_INTEGER,
    pub prf: *mut X509_ALGOR,
}
pub type PBKDF2PARAM = PBKDF2PARAM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCRYPT_PARAMS_st {
    pub salt: *mut ASN1_OCTET_STRING,
    pub costParameter: *mut ASN1_INTEGER,
    pub blockSize: *mut ASN1_INTEGER,
    pub parallelizationParameter: *mut ASN1_INTEGER,
    pub keyLength: *mut ASN1_INTEGER,
}
pub type SCRYPT_PARAMS = SCRYPT_PARAMS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_node_st {
    _unused: [u8; 0],
}
pub type OPENSSL_LH_NODE = lhash_node_st;
pub type OPENSSL_LH_COMPFUNC = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_ebpf::cty::c_void,
        arg2: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type OPENSSL_LH_HASHFUNC =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_ulong>;
pub type OPENSSL_LH_DOALL_FUNC = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
pub type OPENSSL_LH_DOALL_FUNCARG =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void, arg2: *mut ::aya_ebpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st {
    _unused: [u8; 0],
}
pub type OPENSSL_LHASH = lhash_st;
extern "C" {
    pub fn OPENSSL_LH_error(lh: *mut OPENSSL_LHASH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_LH_new(h: OPENSSL_LH_HASHFUNC, c: OPENSSL_LH_COMPFUNC) -> *mut OPENSSL_LHASH;
}
extern "C" {
    pub fn OPENSSL_LH_free(lh: *mut OPENSSL_LHASH);
}
extern "C" {
    pub fn OPENSSL_LH_flush(lh: *mut OPENSSL_LHASH);
}
extern "C" {
    pub fn OPENSSL_LH_insert(lh: *mut OPENSSL_LHASH, data: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_LH_delete(
        lh: *mut OPENSSL_LHASH,
        data: *const ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_LH_retrieve(
        lh: *mut OPENSSL_LHASH,
        data: *const ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_LH_doall(lh: *mut OPENSSL_LHASH, func: OPENSSL_LH_DOALL_FUNC);
}
extern "C" {
    pub fn OPENSSL_LH_doall_arg(
        lh: *mut OPENSSL_LHASH,
        func: OPENSSL_LH_DOALL_FUNCARG,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn OPENSSL_LH_strhash(c: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn OPENSSL_LH_num_items(lh: *const OPENSSL_LHASH) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn OPENSSL_LH_get_down_load(lh: *const OPENSSL_LHASH) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn OPENSSL_LH_set_down_load(lh: *mut OPENSSL_LHASH, down_load: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn OPENSSL_LH_stats(lh: *const OPENSSL_LHASH, fp: *mut FILE);
}
extern "C" {
    pub fn OPENSSL_LH_node_stats(lh: *const OPENSSL_LHASH, fp: *mut FILE);
}
extern "C" {
    pub fn OPENSSL_LH_node_usage_stats(lh: *const OPENSSL_LHASH, fp: *mut FILE);
}
extern "C" {
    pub fn OPENSSL_LH_stats_bio(lh: *const OPENSSL_LHASH, out: *mut BIO);
}
extern "C" {
    pub fn OPENSSL_LH_node_stats_bio(lh: *const OPENSSL_LHASH, out: *mut BIO);
}
extern "C" {
    pub fn OPENSSL_LH_node_usage_stats_bio(lh: *const OPENSSL_LHASH, out: *mut BIO);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_OPENSSL_STRING {
    pub dummy: lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_OPENSSL_STRING_lh_OPENSSL_STRING_dummy {
    pub d1: *mut ::aya_ebpf::cty::c_void,
    pub d2: ::aya_ebpf::cty::c_ulong,
    pub d3: ::aya_ebpf::cty::c_int,
}
pub type lh_OPENSSL_STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const OPENSSL_STRING, b: *const OPENSSL_STRING) -> ::aya_ebpf::cty::c_int,
>;
pub type lh_OPENSSL_STRING_hashfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const OPENSSL_STRING) -> ::aya_ebpf::cty::c_ulong>;
pub type lh_OPENSSL_STRING_doallfunc = ::core::option::Option<unsafe extern "C" fn(a: *mut OPENSSL_STRING)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_OPENSSL_CSTRING {
    pub dummy: lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_OPENSSL_CSTRING_lh_OPENSSL_CSTRING_dummy {
    pub d1: *mut ::aya_ebpf::cty::c_void,
    pub d2: ::aya_ebpf::cty::c_ulong,
    pub d3: ::aya_ebpf::cty::c_int,
}
pub type lh_OPENSSL_CSTRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const OPENSSL_CSTRING, b: *const OPENSSL_CSTRING) -> ::aya_ebpf::cty::c_int,
>;
pub type lh_OPENSSL_CSTRING_hashfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const OPENSSL_CSTRING) -> ::aya_ebpf::cty::c_ulong>;
pub type lh_OPENSSL_CSTRING_doallfunc = ::core::option::Option<unsafe extern "C" fn(a: *mut OPENSSL_CSTRING)>;
pub const X509_LOOKUP_TYPE_X509_LU_NONE: X509_LOOKUP_TYPE = 0;
pub const X509_LOOKUP_TYPE_X509_LU_X509: X509_LOOKUP_TYPE = 1;
pub const X509_LOOKUP_TYPE_X509_LU_CRL: X509_LOOKUP_TYPE = 2;
pub type X509_LOOKUP_TYPE = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_LOOKUP {
    _unused: [u8; 0],
}
pub type sk_X509_LOOKUP_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_LOOKUP, b: *const *const X509_LOOKUP) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_LOOKUP_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_LOOKUP)>;
pub type sk_X509_LOOKUP_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_LOOKUP) -> *mut X509_LOOKUP>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_OBJECT {
    _unused: [u8; 0],
}
pub type sk_X509_OBJECT_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_OBJECT, b: *const *const X509_OBJECT) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_OBJECT_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_OBJECT)>;
pub type sk_X509_OBJECT_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_OBJECT) -> *mut X509_OBJECT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_VERIFY_PARAM {
    _unused: [u8; 0],
}
pub type sk_X509_VERIFY_PARAM_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509_VERIFY_PARAM,
        b: *const *const X509_VERIFY_PARAM,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_VERIFY_PARAM_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_VERIFY_PARAM)>;
pub type sk_X509_VERIFY_PARAM_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_VERIFY_PARAM) -> *mut X509_VERIFY_PARAM>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_trust_st {
    pub trust: ::aya_ebpf::cty::c_int,
    pub flags: ::aya_ebpf::cty::c_int,
    pub check_trust: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut x509_trust_st,
            arg2: *mut X509,
            arg3: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub arg1: ::aya_ebpf::cty::c_int,
    pub arg2: *mut ::aya_ebpf::cty::c_void,
}
pub type X509_TRUST = x509_trust_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_TRUST {
    _unused: [u8; 0],
}
pub type sk_X509_TRUST_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_TRUST, b: *const *const X509_TRUST) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_TRUST_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_TRUST)>;
pub type sk_X509_TRUST_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const X509_TRUST) -> *mut X509_TRUST>;
extern "C" {
    pub fn X509_TRUST_set(t: *mut ::aya_ebpf::cty::c_int, trust: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_TRUST_get_count() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0(idx: ::aya_ebpf::cty::c_int) -> *mut X509_TRUST;
}
extern "C" {
    pub fn X509_TRUST_get_by_id(id: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_TRUST_add(
        id: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_int,
        ck: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut X509_TRUST,
                arg2: *mut X509,
                arg3: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        name: *const ::aya_ebpf::cty::c_char,
        arg1: ::aya_ebpf::cty::c_int,
        arg2: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_TRUST_cleanup();
}
extern "C" {
    pub fn X509_TRUST_get_flags(xp: *const X509_TRUST) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0_name(xp: *const X509_TRUST) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_TRUST_get_trust(xp: *const X509_TRUST) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_trusted(x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_add1_trust_object(x: *mut X509, obj: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_add1_reject_object(x: *mut X509, obj: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_trust_clear(x: *mut X509);
}
extern "C" {
    pub fn X509_reject_clear(x: *mut X509);
}
extern "C" {
    pub fn X509_get0_trust_objects(x: *mut X509) -> *mut stack_st_ASN1_OBJECT;
}
extern "C" {
    pub fn X509_get0_reject_objects(x: *mut X509) -> *mut stack_st_ASN1_OBJECT;
}
extern "C" {
    pub fn X509_TRUST_set_default(
        trust: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: ::aya_ebpf::cty::c_int,
                arg2: *mut X509,
                arg3: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            trust: ::aya_ebpf::cty::c_int,
            arg1: *mut X509,
            arg2: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn X509_check_trust(
        x: *mut X509,
        id: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_verify_cert(ctx: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_verify(ctx: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_build_chain(
        target: *mut X509,
        certs: *mut stack_st_X509,
        store: *mut X509_STORE,
        with_self_signed: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_set_depth(store: *mut X509_STORE, depth: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
pub type X509_STORE_CTX_verify_cb = ::core::option::Option<
    unsafe extern "C" fn(arg1: ::aya_ebpf::cty::c_int, arg2: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn X509_STORE_CTX_print_verify_cb(ok: ::aya_ebpf::cty::c_int, ctx: *mut X509_STORE_CTX)
        -> ::aya_ebpf::cty::c_int;
}
pub type X509_STORE_CTX_verify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int>;
pub type X509_STORE_CTX_get_issuer_fn = ::core::option::Option<
    unsafe extern "C" fn(issuer: *mut *mut X509, ctx: *mut X509_STORE_CTX, x: *mut X509) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_STORE_CTX_check_issued_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, x: *mut X509, issuer: *mut X509) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_STORE_CTX_check_revocation_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int>;
pub type X509_STORE_CTX_get_crl_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut *mut X509_CRL, x: *mut X509) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_STORE_CTX_check_crl_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut X509_CRL) -> ::aya_ebpf::cty::c_int>;
pub type X509_STORE_CTX_cert_crl_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut X509_CRL, x: *mut X509) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_STORE_CTX_check_policy_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int>;
pub type X509_STORE_CTX_lookup_certs_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, nm: *const X509_NAME) -> *mut stack_st_X509>;
pub type X509_STORE_CTX_lookup_crls_fn = ::core::option::Option<
    unsafe extern "C" fn(ctx: *const X509_STORE_CTX, nm: *const X509_NAME) -> *mut stack_st_X509_CRL,
>;
pub type X509_STORE_CTX_cleanup_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int>;
extern "C" {
    pub fn X509_STORE_CTX_set_depth(ctx: *mut X509_STORE_CTX, depth: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn X509_OBJECT_idx_by_subject(
        h: *mut stack_st_X509_OBJECT,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_OBJECT_retrieve_by_subject(
        h: *mut stack_st_X509_OBJECT,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_retrieve_match(h: *mut stack_st_X509_OBJECT, x: *mut X509_OBJECT) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_up_ref_count(a: *mut X509_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_OBJECT_new() -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_free(a: *mut X509_OBJECT);
}
extern "C" {
    pub fn X509_OBJECT_get_type(a: *const X509_OBJECT) -> X509_LOOKUP_TYPE;
}
extern "C" {
    pub fn X509_OBJECT_get0_X509(a: *const X509_OBJECT) -> *mut X509;
}
extern "C" {
    pub fn X509_OBJECT_set1_X509(a: *mut X509_OBJECT, obj: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_OBJECT_get0_X509_CRL(a: *const X509_OBJECT) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_OBJECT_set1_X509_CRL(a: *mut X509_OBJECT, obj: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_new() -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_free(v: *mut X509_STORE);
}
extern "C" {
    pub fn X509_STORE_lock(ctx: *mut X509_STORE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_unlock(ctx: *mut X509_STORE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_up_ref(v: *mut X509_STORE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_get0_objects(v: *const X509_STORE) -> *mut stack_st_X509_OBJECT;
}
extern "C" {
    pub fn X509_STORE_get1_all_certs(st: *mut X509_STORE) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_certs(st: *mut X509_STORE_CTX, nm: *const X509_NAME) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_crls(st: *const X509_STORE_CTX, nm: *const X509_NAME) -> *mut stack_st_X509_CRL;
}
extern "C" {
    pub fn X509_STORE_set_flags(ctx: *mut X509_STORE, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_set_purpose(ctx: *mut X509_STORE, purpose: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_set_trust(ctx: *mut X509_STORE, trust: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_set1_param(ctx: *mut X509_STORE, pm: *const X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_get0_param(ctx: *const X509_STORE) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_set_verify(ctx: *mut X509_STORE, verify: X509_STORE_CTX_verify_fn);
}
extern "C" {
    pub fn X509_STORE_CTX_set_verify(ctx: *mut X509_STORE_CTX, verify: X509_STORE_CTX_verify_fn);
}
extern "C" {
    pub fn X509_STORE_get_verify(ctx: *const X509_STORE) -> X509_STORE_CTX_verify_fn;
}
extern "C" {
    pub fn X509_STORE_set_verify_cb(ctx: *mut X509_STORE, verify_cb: X509_STORE_CTX_verify_cb);
}
extern "C" {
    pub fn X509_STORE_get_verify_cb(ctx: *const X509_STORE) -> X509_STORE_CTX_verify_cb;
}
extern "C" {
    pub fn X509_STORE_set_get_issuer(ctx: *mut X509_STORE, get_issuer: X509_STORE_CTX_get_issuer_fn);
}
extern "C" {
    pub fn X509_STORE_get_get_issuer(ctx: *const X509_STORE) -> X509_STORE_CTX_get_issuer_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_issued(ctx: *mut X509_STORE, check_issued: X509_STORE_CTX_check_issued_fn);
}
extern "C" {
    pub fn X509_STORE_get_check_issued(ctx: *const X509_STORE) -> X509_STORE_CTX_check_issued_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_revocation(ctx: *mut X509_STORE, check_revocation: X509_STORE_CTX_check_revocation_fn);
}
extern "C" {
    pub fn X509_STORE_get_check_revocation(ctx: *const X509_STORE) -> X509_STORE_CTX_check_revocation_fn;
}
extern "C" {
    pub fn X509_STORE_set_get_crl(ctx: *mut X509_STORE, get_crl: X509_STORE_CTX_get_crl_fn);
}
extern "C" {
    pub fn X509_STORE_get_get_crl(ctx: *const X509_STORE) -> X509_STORE_CTX_get_crl_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_crl(ctx: *mut X509_STORE, check_crl: X509_STORE_CTX_check_crl_fn);
}
extern "C" {
    pub fn X509_STORE_get_check_crl(ctx: *const X509_STORE) -> X509_STORE_CTX_check_crl_fn;
}
extern "C" {
    pub fn X509_STORE_set_cert_crl(ctx: *mut X509_STORE, cert_crl: X509_STORE_CTX_cert_crl_fn);
}
extern "C" {
    pub fn X509_STORE_get_cert_crl(ctx: *const X509_STORE) -> X509_STORE_CTX_cert_crl_fn;
}
extern "C" {
    pub fn X509_STORE_set_check_policy(ctx: *mut X509_STORE, check_policy: X509_STORE_CTX_check_policy_fn);
}
extern "C" {
    pub fn X509_STORE_get_check_policy(ctx: *const X509_STORE) -> X509_STORE_CTX_check_policy_fn;
}
extern "C" {
    pub fn X509_STORE_set_lookup_certs(ctx: *mut X509_STORE, lookup_certs: X509_STORE_CTX_lookup_certs_fn);
}
extern "C" {
    pub fn X509_STORE_get_lookup_certs(ctx: *const X509_STORE) -> X509_STORE_CTX_lookup_certs_fn;
}
extern "C" {
    pub fn X509_STORE_set_lookup_crls(ctx: *mut X509_STORE, lookup_crls: X509_STORE_CTX_lookup_crls_fn);
}
extern "C" {
    pub fn X509_STORE_get_lookup_crls(ctx: *const X509_STORE) -> X509_STORE_CTX_lookup_crls_fn;
}
extern "C" {
    pub fn X509_STORE_set_cleanup(ctx: *mut X509_STORE, cleanup: X509_STORE_CTX_cleanup_fn);
}
extern "C" {
    pub fn X509_STORE_get_cleanup(ctx: *const X509_STORE) -> X509_STORE_CTX_cleanup_fn;
}
extern "C" {
    pub fn X509_STORE_set_ex_data(
        ctx: *mut X509_STORE,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_get_ex_data(ctx: *const X509_STORE, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_STORE_CTX_new_ex(
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_new() -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_issuer(
        issuer: *mut *mut X509,
        ctx: *mut X509_STORE_CTX,
        x: *mut X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_free(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_init(
        ctx: *mut X509_STORE_CTX,
        trust_store: *mut X509_STORE,
        target: *mut X509,
        untrusted: *mut stack_st_X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_trusted_stack(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_cleanup(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_store(ctx: *const X509_STORE_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_cert(ctx: *const X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_untrusted(ctx: *const X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_untrusted(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set_verify_cb(ctx: *mut X509_STORE_CTX, verify: X509_STORE_CTX_verify_cb);
}
extern "C" {
    pub fn X509_STORE_CTX_get_verify_cb(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_verify_cb;
}
extern "C" {
    pub fn X509_STORE_CTX_get_verify(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_verify_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_get_issuer(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_get_issuer_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_issued(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_check_issued_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_revocation(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_check_revocation_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_get_crl(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_get_crl_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_crl(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_check_crl_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_cert_crl(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_cert_crl_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_check_policy(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_check_policy_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_lookup_certs(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_lookup_certs_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_lookup_crls(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_lookup_crls_fn;
}
extern "C" {
    pub fn X509_STORE_CTX_get_cleanup(ctx: *const X509_STORE_CTX) -> X509_STORE_CTX_cleanup_fn;
}
extern "C" {
    pub fn X509_STORE_add_lookup(v: *mut X509_STORE, m: *mut X509_LOOKUP_METHOD) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_hash_dir() -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_file() -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_store() -> *mut X509_LOOKUP_METHOD;
}
pub type X509_LOOKUP_ctrl_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        cmd: ::aya_ebpf::cty::c_int,
        argc: *const ::aya_ebpf::cty::c_char,
        argl: ::aya_ebpf::cty::c_long,
        ret: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_LOOKUP_ctrl_ex_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        cmd: ::aya_ebpf::cty::c_int,
        argc: *const ::aya_ebpf::cty::c_char,
        argl: ::aya_ebpf::cty::c_long,
        ret: *mut *mut ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_LOOKUP_get_by_subject_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_LOOKUP_get_by_subject_ex_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        ret: *mut X509_OBJECT,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_LOOKUP_get_by_issuer_serial_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        serial: *const ASN1_INTEGER,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_LOOKUP_get_by_fingerprint_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509_LOOKUP_get_by_alias_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn X509_LOOKUP_meth_new(name: *const ::aya_ebpf::cty::c_char) -> *mut X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_meth_free(method: *mut X509_LOOKUP_METHOD);
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_new_item(
        method: *mut X509_LOOKUP_METHOD,
        new_item: ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_new_item(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_free(
        method: *mut X509_LOOKUP_METHOD,
        free_fn: ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP)>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_free(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut X509_LOOKUP)>;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_init(
        method: *mut X509_LOOKUP_METHOD,
        init: ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_init(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_shutdown(
        method: *mut X509_LOOKUP_METHOD,
        shutdown: ::core::option::Option<unsafe extern "C" fn(ctx: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_shutdown(
        method: *const X509_LOOKUP_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_ctrl(
        method: *mut X509_LOOKUP_METHOD,
        ctrl_fn: X509_LOOKUP_ctrl_fn,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_ctrl(method: *const X509_LOOKUP_METHOD) -> X509_LOOKUP_ctrl_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_subject(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_subject_fn,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_subject(method: *const X509_LOOKUP_METHOD) -> X509_LOOKUP_get_by_subject_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_issuer_serial(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_issuer_serial_fn,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_issuer_serial(
        method: *const X509_LOOKUP_METHOD,
    ) -> X509_LOOKUP_get_by_issuer_serial_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_fingerprint(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_fingerprint_fn,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_fingerprint(
        method: *const X509_LOOKUP_METHOD,
    ) -> X509_LOOKUP_get_by_fingerprint_fn;
}
extern "C" {
    pub fn X509_LOOKUP_meth_set_get_by_alias(
        method: *mut X509_LOOKUP_METHOD,
        fn_: X509_LOOKUP_get_by_alias_fn,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_meth_get_get_by_alias(method: *const X509_LOOKUP_METHOD) -> X509_LOOKUP_get_by_alias_fn;
}
extern "C" {
    pub fn X509_STORE_add_cert(ctx: *mut X509_STORE, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_add_crl(ctx: *mut X509_STORE, x: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_by_subject(
        vs: *const X509_STORE_CTX,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_obj_by_subject(
        vs: *mut X509_STORE_CTX,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
    ) -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_LOOKUP_ctrl(
        ctx: *mut X509_LOOKUP,
        cmd: ::aya_ebpf::cty::c_int,
        argc: *const ::aya_ebpf::cty::c_char,
        argl: ::aya_ebpf::cty::c_long,
        ret: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_ctrl_ex(
        ctx: *mut X509_LOOKUP,
        cmd: ::aya_ebpf::cty::c_int,
        argc: *const ::aya_ebpf::cty::c_char,
        argl: ::aya_ebpf::cty::c_long,
        ret: *mut *mut ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_load_cert_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_load_cert_file_ex(
        ctx: *mut X509_LOOKUP,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_load_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_load_cert_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_load_cert_crl_file_ex(
        ctx: *mut X509_LOOKUP,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_new(method: *mut X509_LOOKUP_METHOD) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_free(ctx: *mut X509_LOOKUP);
}
extern "C" {
    pub fn X509_LOOKUP_init(ctx: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_subject(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_subject_ex(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        ret: *mut X509_OBJECT,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_issuer_serial(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        name: *const X509_NAME,
        serial: *const ASN1_INTEGER,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_fingerprint(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_by_alias(
        ctx: *mut X509_LOOKUP,
        type_: X509_LOOKUP_TYPE,
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
        ret: *mut X509_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_set_method_data(
        ctx: *mut X509_LOOKUP,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_get_method_data(ctx: *const X509_LOOKUP) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_LOOKUP_get_store(ctx: *const X509_LOOKUP) -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_LOOKUP_shutdown(ctx: *mut X509_LOOKUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_file(ctx: *mut X509_STORE, file: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_path(ctx: *mut X509_STORE, path: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_store(ctx: *mut X509_STORE, store: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_locations(
        ctx: *mut X509_STORE,
        file: *const ::aya_ebpf::cty::c_char,
        dir: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_set_default_paths(ctx: *mut X509_STORE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_file_ex(
        ctx: *mut X509_STORE,
        file: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_store_ex(
        ctx: *mut X509_STORE,
        store: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_load_locations_ex(
        ctx: *mut X509_STORE,
        file: *const ::aya_ebpf::cty::c_char,
        dir: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_set_default_paths_ex(
        ctx: *mut X509_STORE,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_ex_data(
        ctx: *const X509_STORE_CTX,
        idx: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_STORE_CTX_get_error(ctx: *const X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_error(ctx: *mut X509_STORE_CTX, s: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn X509_STORE_CTX_get_error_depth(ctx: *const X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_error_depth(ctx: *mut X509_STORE_CTX, depth: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn X509_STORE_CTX_get_current_cert(ctx: *const X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set_current_cert(ctx: *mut X509_STORE_CTX, x: *mut X509);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_issuer(ctx: *const X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_crl(ctx: *const X509_STORE_CTX) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_parent_ctx(ctx: *const X509_STORE_CTX) -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_chain(ctx: *const X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_chain(ctx: *const X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set_cert(ctx: *mut X509_STORE_CTX, target: *mut X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set0_verified_chain(c: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_set0_crls(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509_CRL);
}
extern "C" {
    pub fn X509_STORE_CTX_set_purpose(
        ctx: *mut X509_STORE_CTX,
        purpose: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_trust(ctx: *mut X509_STORE_CTX, trust: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_purpose_inherit(
        ctx: *mut X509_STORE_CTX,
        def_purpose: ::aya_ebpf::cty::c_int,
        purpose: ::aya_ebpf::cty::c_int,
        trust: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_flags(ctx: *mut X509_STORE_CTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn X509_STORE_CTX_set_time(ctx: *mut X509_STORE_CTX, flags: ::aya_ebpf::cty::c_ulong, t: time_t);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_policy_tree(ctx: *const X509_STORE_CTX) -> *mut X509_POLICY_TREE;
}
extern "C" {
    pub fn X509_STORE_CTX_get_explicit_policy(ctx: *const X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_num_untrusted(ctx: *const X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_param(ctx: *const X509_STORE_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_param(ctx: *mut X509_STORE_CTX, param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_STORE_CTX_set_default(
        ctx: *mut X509_STORE_CTX,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_dane(ctx: *mut X509_STORE_CTX, dane: *mut SSL_DANE);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_new() -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_free(param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_inherit(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1(to: *mut X509_VERIFY_PARAM, from: *const X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_name(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_clear_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_flags(param: *const X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_purpose(
        param: *mut X509_VERIFY_PARAM,
        purpose: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_trust(
        param: *mut X509_VERIFY_PARAM,
        trust: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_depth(param: *mut X509_VERIFY_PARAM, depth: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_auth_level(param: *mut X509_VERIFY_PARAM, auth_level: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_time(param: *const X509_VERIFY_PARAM) -> time_t;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_time(param: *mut X509_VERIFY_PARAM, t: time_t);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_policy(
        param: *mut X509_VERIFY_PARAM,
        policy: *mut ASN1_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_policies(
        param: *mut X509_VERIFY_PARAM,
        policies: *mut stack_st_ASN1_OBJECT,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_inh_flags(param: *mut X509_VERIFY_PARAM, flags: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_inh_flags(param: *const X509_VERIFY_PARAM) -> u32;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_host(
        param: *mut X509_VERIFY_PARAM,
        idx: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::aya_ebpf::cty::c_char,
        namelen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::aya_ebpf::cty::c_char,
        namelen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_hostflags(param: *mut X509_VERIFY_PARAM, flags: ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_hostflags(param: *const X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_peername(param: *const X509_VERIFY_PARAM) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_move_peername(arg1: *mut X509_VERIFY_PARAM, arg2: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_email(param: *mut X509_VERIFY_PARAM) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_email(
        param: *mut X509_VERIFY_PARAM,
        email: *const ::aya_ebpf::cty::c_char,
        emaillen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get1_ip_asc(param: *mut X509_VERIFY_PARAM) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip(
        param: *mut X509_VERIFY_PARAM,
        ip: *const ::aya_ebpf::cty::c_uchar,
        iplen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip_asc(
        param: *mut X509_VERIFY_PARAM,
        ipasc: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_depth(param: *const X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_auth_level(param: *const X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0_name(param: *const X509_VERIFY_PARAM) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_table(param: *mut X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_count() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get0(id: ::aya_ebpf::cty::c_int) -> *const X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_lookup(name: *const ::aya_ebpf::cty::c_char) -> *const X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_table_cleanup();
}
extern "C" {
    pub fn X509_policy_check(
        ptree: *mut *mut X509_POLICY_TREE,
        pexplicit_policy: *mut ::aya_ebpf::cty::c_int,
        certs: *mut stack_st_X509,
        policy_oids: *mut stack_st_ASN1_OBJECT,
        flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_policy_tree_free(tree: *mut X509_POLICY_TREE);
}
extern "C" {
    pub fn X509_policy_tree_level_count(tree: *const X509_POLICY_TREE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_policy_tree_get0_level(
        tree: *const X509_POLICY_TREE,
        i: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_POLICY_LEVEL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_POLICY_NODE {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_policy_tree_get0_policies(tree: *const X509_POLICY_TREE) -> *mut stack_st_X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_tree_get0_user_policies(tree: *const X509_POLICY_TREE) -> *mut stack_st_X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_level_node_count(level: *mut X509_POLICY_LEVEL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_policy_level_get0_node(
        level: *const X509_POLICY_LEVEL,
        i: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_POLICY_NODE;
}
extern "C" {
    pub fn X509_policy_node_get0_policy(node: *const X509_POLICY_NODE) -> *const ASN1_OBJECT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICYQUALINFO {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_policy_node_get0_qualifiers(node: *const X509_POLICY_NODE) -> *mut stack_st_POLICYQUALINFO;
}
extern "C" {
    pub fn X509_policy_node_get0_parent(node: *const X509_POLICY_NODE) -> *const X509_POLICY_NODE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PKCS7_CTX_st {
    pub libctx: *mut OSSL_LIB_CTX,
    pub propq: *mut ::aya_ebpf::cty::c_char,
}
pub type PKCS7_CTX = PKCS7_CTX_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_issuer_and_serial_st {
    pub issuer: *mut X509_NAME,
    pub serial: *mut ASN1_INTEGER,
}
pub type PKCS7_ISSUER_AND_SERIAL = pkcs7_issuer_and_serial_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signer_info_st {
    pub version: *mut ASN1_INTEGER,
    pub issuer_and_serial: *mut PKCS7_ISSUER_AND_SERIAL,
    pub digest_alg: *mut X509_ALGOR,
    pub auth_attr: *mut stack_st_X509_ATTRIBUTE,
    pub digest_enc_alg: *mut X509_ALGOR,
    pub enc_digest: *mut ASN1_OCTET_STRING,
    pub unauth_attr: *mut stack_st_X509_ATTRIBUTE,
    pub pkey: *mut EVP_PKEY,
    pub ctx: *const PKCS7_CTX,
}
pub type PKCS7_SIGNER_INFO = pkcs7_signer_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7_SIGNER_INFO {
    _unused: [u8; 0],
}
pub type sk_PKCS7_SIGNER_INFO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const PKCS7_SIGNER_INFO,
        b: *const *const PKCS7_SIGNER_INFO,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_PKCS7_SIGNER_INFO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut PKCS7_SIGNER_INFO)>;
pub type sk_PKCS7_SIGNER_INFO_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const PKCS7_SIGNER_INFO) -> *mut PKCS7_SIGNER_INFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_recip_info_st {
    pub version: *mut ASN1_INTEGER,
    pub issuer_and_serial: *mut PKCS7_ISSUER_AND_SERIAL,
    pub key_enc_algor: *mut X509_ALGOR,
    pub enc_key: *mut ASN1_OCTET_STRING,
    pub cert: *mut X509,
    pub ctx: *const PKCS7_CTX,
}
pub type PKCS7_RECIP_INFO = pkcs7_recip_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7_RECIP_INFO {
    _unused: [u8; 0],
}
pub type sk_PKCS7_RECIP_INFO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const PKCS7_RECIP_INFO, b: *const *const PKCS7_RECIP_INFO) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_PKCS7_RECIP_INFO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut PKCS7_RECIP_INFO)>;
pub type sk_PKCS7_RECIP_INFO_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const PKCS7_RECIP_INFO) -> *mut PKCS7_RECIP_INFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signed_st {
    pub version: *mut ASN1_INTEGER,
    pub md_algs: *mut stack_st_X509_ALGOR,
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
    pub signer_info: *mut stack_st_PKCS7_SIGNER_INFO,
    pub contents: *mut pkcs7_st,
}
pub type PKCS7_SIGNED = pkcs7_signed_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_enc_content_st {
    pub content_type: *mut ASN1_OBJECT,
    pub algorithm: *mut X509_ALGOR,
    pub enc_data: *mut ASN1_OCTET_STRING,
    pub cipher: *const EVP_CIPHER,
    pub ctx: *const PKCS7_CTX,
}
pub type PKCS7_ENC_CONTENT = pkcs7_enc_content_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_enveloped_st {
    pub version: *mut ASN1_INTEGER,
    pub recipientinfo: *mut stack_st_PKCS7_RECIP_INFO,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
}
pub type PKCS7_ENVELOPE = pkcs7_enveloped_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_signedandenveloped_st {
    pub version: *mut ASN1_INTEGER,
    pub md_algs: *mut stack_st_X509_ALGOR,
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
    pub signer_info: *mut stack_st_PKCS7_SIGNER_INFO,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
    pub recipientinfo: *mut stack_st_PKCS7_RECIP_INFO,
}
pub type PKCS7_SIGN_ENVELOPE = pkcs7_signedandenveloped_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_digest_st {
    pub version: *mut ASN1_INTEGER,
    pub md: *mut X509_ALGOR,
    pub contents: *mut pkcs7_st,
    pub digest: *mut ASN1_OCTET_STRING,
}
pub type PKCS7_DIGEST = pkcs7_digest_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs7_encrypted_st {
    pub version: *mut ASN1_INTEGER,
    pub enc_data: *mut PKCS7_ENC_CONTENT,
}
pub type PKCS7_ENCRYPT = pkcs7_encrypted_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pkcs7_st {
    pub asn1: *mut ::aya_ebpf::cty::c_uchar,
    pub length: ::aya_ebpf::cty::c_long,
    pub state: ::aya_ebpf::cty::c_int,
    pub detached: ::aya_ebpf::cty::c_int,
    pub type_: *mut ASN1_OBJECT,
    pub d: pkcs7_st__bindgen_ty_1,
    pub ctx: PKCS7_CTX,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pkcs7_st__bindgen_ty_1 {
    pub ptr: *mut ::aya_ebpf::cty::c_char,
    pub data: *mut ASN1_OCTET_STRING,
    pub sign: *mut PKCS7_SIGNED,
    pub enveloped: *mut PKCS7_ENVELOPE,
    pub signed_and_enveloped: *mut PKCS7_SIGN_ENVELOPE,
    pub digest: *mut PKCS7_DIGEST,
    pub encrypted: *mut PKCS7_ENCRYPT,
    pub other: *mut ASN1_TYPE,
}
pub type PKCS7 = pkcs7_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PKCS7 {
    _unused: [u8; 0],
}
pub type sk_PKCS7_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const PKCS7, b: *const *const PKCS7) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_PKCS7_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut PKCS7)>;
pub type sk_PKCS7_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const PKCS7) -> *mut PKCS7>;
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_new() -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_free(a: *mut PKCS7_ISSUER_AND_SERIAL);
}
extern "C" {
    pub fn d2i_PKCS7_ISSUER_AND_SERIAL(
        a: *mut *mut PKCS7_ISSUER_AND_SERIAL,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn i2d_PKCS7_ISSUER_AND_SERIAL(
        a: *const PKCS7_ISSUER_AND_SERIAL,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ISSUER_AND_SERIAL_digest(
        data: *mut PKCS7_ISSUER_AND_SERIAL,
        type_: *const EVP_MD,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS7_fp(fp: *mut FILE, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7_fp(fp: *mut FILE, p7: *const PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_dup(a: *const PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn d2i_PKCS7_bio(bp: *mut BIO, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7_bio(bp: *mut BIO, p7: *const PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PKCS7_bio_stream(
        out: *mut BIO,
        p7: *mut PKCS7,
        in_: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7_stream(
        out: *mut BIO,
        p7: *mut PKCS7,
        in_: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_new() -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_free(a: *mut PKCS7_SIGNER_INFO);
}
extern "C" {
    pub fn d2i_PKCS7_SIGNER_INFO(
        a: *mut *mut PKCS7_SIGNER_INFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn i2d_PKCS7_SIGNER_INFO(
        a: *const PKCS7_SIGNER_INFO,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_new() -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_free(a: *mut PKCS7_RECIP_INFO);
}
extern "C" {
    pub fn d2i_PKCS7_RECIP_INFO(
        a: *mut *mut PKCS7_RECIP_INFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn i2d_PKCS7_RECIP_INFO(
        a: *const PKCS7_RECIP_INFO,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_SIGNED_new() -> *mut PKCS7_SIGNED;
}
extern "C" {
    pub fn PKCS7_SIGNED_free(a: *mut PKCS7_SIGNED);
}
extern "C" {
    pub fn d2i_PKCS7_SIGNED(
        a: *mut *mut PKCS7_SIGNED,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_SIGNED;
}
extern "C" {
    pub fn i2d_PKCS7_SIGNED(a: *const PKCS7_SIGNED, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNED_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_new() -> *mut PKCS7_ENC_CONTENT;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_free(a: *mut PKCS7_ENC_CONTENT);
}
extern "C" {
    pub fn d2i_PKCS7_ENC_CONTENT(
        a: *mut *mut PKCS7_ENC_CONTENT,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_ENC_CONTENT;
}
extern "C" {
    pub fn i2d_PKCS7_ENC_CONTENT(
        a: *const PKCS7_ENC_CONTENT,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_ENC_CONTENT_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_new() -> *mut PKCS7_ENVELOPE;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_free(a: *mut PKCS7_ENVELOPE);
}
extern "C" {
    pub fn d2i_PKCS7_ENVELOPE(
        a: *mut *mut PKCS7_ENVELOPE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_ENVELOPE;
}
extern "C" {
    pub fn i2d_PKCS7_ENVELOPE(
        a: *const PKCS7_ENVELOPE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_ENVELOPE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_new() -> *mut PKCS7_SIGN_ENVELOPE;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_free(a: *mut PKCS7_SIGN_ENVELOPE);
}
extern "C" {
    pub fn d2i_PKCS7_SIGN_ENVELOPE(
        a: *mut *mut PKCS7_SIGN_ENVELOPE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_SIGN_ENVELOPE;
}
extern "C" {
    pub fn i2d_PKCS7_SIGN_ENVELOPE(
        a: *const PKCS7_SIGN_ENVELOPE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_SIGN_ENVELOPE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_DIGEST_new() -> *mut PKCS7_DIGEST;
}
extern "C" {
    pub fn PKCS7_DIGEST_free(a: *mut PKCS7_DIGEST);
}
extern "C" {
    pub fn d2i_PKCS7_DIGEST(
        a: *mut *mut PKCS7_DIGEST,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_DIGEST;
}
extern "C" {
    pub fn i2d_PKCS7_DIGEST(a: *const PKCS7_DIGEST, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_DIGEST_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_new() -> *mut PKCS7_ENCRYPT;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_free(a: *mut PKCS7_ENCRYPT);
}
extern "C" {
    pub fn d2i_PKCS7_ENCRYPT(
        a: *mut *mut PKCS7_ENCRYPT,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7_ENCRYPT;
}
extern "C" {
    pub fn i2d_PKCS7_ENCRYPT(a: *const PKCS7_ENCRYPT, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_ENCRYPT_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_new() -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_free(a: *mut PKCS7);
}
extern "C" {
    pub fn d2i_PKCS7(
        a: *mut *mut PKCS7,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7(a: *const PKCS7, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_new_ex(libctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_ATTR_SIGN_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS7_ATTR_VERIFY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn i2d_PKCS7_NDEF(a: *const PKCS7, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_print_ctx(
        out: *mut BIO,
        x: *const PKCS7,
        indent: ::aya_ebpf::cty::c_int,
        pctx: *const ASN1_PCTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_ctrl(
        p7: *mut PKCS7,
        cmd: ::aya_ebpf::cty::c_int,
        larg: ::aya_ebpf::cty::c_long,
        parg: *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn PKCS7_type_is_other(p7: *mut PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_set_type(p7: *mut PKCS7, type_: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_set0_type_other(
        p7: *mut PKCS7,
        type_: ::aya_ebpf::cty::c_int,
        other: *mut ASN1_TYPE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_set_content(p7: *mut PKCS7, p7_data: *mut PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_set(
        p7i: *mut PKCS7_SIGNER_INFO,
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        dgst: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_sign(si: *mut PKCS7_SIGNER_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add_signer(p7: *mut PKCS7, p7i: *mut PKCS7_SIGNER_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add_certificate(p7: *mut PKCS7, x509: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add_crl(p7: *mut PKCS7, x509: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_content_new(p7: *mut PKCS7, nid: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_dataVerify(
        cert_store: *mut X509_STORE,
        ctx: *mut X509_STORE_CTX,
        bio: *mut BIO,
        p7: *mut PKCS7,
        si: *mut PKCS7_SIGNER_INFO,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_signatureVerify(
        bio: *mut BIO,
        p7: *mut PKCS7,
        si: *mut PKCS7_SIGNER_INFO,
        x509: *mut X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_dataInit(p7: *mut PKCS7, bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn PKCS7_dataFinal(p7: *mut PKCS7, bio: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_dataDecode(p7: *mut PKCS7, pkey: *mut EVP_PKEY, in_bio: *mut BIO, pcert: *mut X509) -> *mut BIO;
}
extern "C" {
    pub fn PKCS7_add_signature(
        p7: *mut PKCS7,
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        dgst: *const EVP_MD,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_cert_from_signer_info(p7: *mut PKCS7, si: *mut PKCS7_SIGNER_INFO) -> *mut X509;
}
extern "C" {
    pub fn PKCS7_set_digest(p7: *mut PKCS7, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_get_signer_info(p7: *mut PKCS7) -> *mut stack_st_PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_add_recipient(p7: *mut PKCS7, x509: *mut X509) -> *mut PKCS7_RECIP_INFO;
}
extern "C" {
    pub fn PKCS7_SIGNER_INFO_get0_algs(
        si: *mut PKCS7_SIGNER_INFO,
        pk: *mut *mut EVP_PKEY,
        pdig: *mut *mut X509_ALGOR,
        psig: *mut *mut X509_ALGOR,
    );
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_get0_alg(ri: *mut PKCS7_RECIP_INFO, penc: *mut *mut X509_ALGOR);
}
extern "C" {
    pub fn PKCS7_add_recipient_info(p7: *mut PKCS7, ri: *mut PKCS7_RECIP_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_RECIP_INFO_set(p7i: *mut PKCS7_RECIP_INFO, x509: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_set_cipher(p7: *mut PKCS7, cipher: *const EVP_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_stream(boundary: *mut *mut *mut ::aya_ebpf::cty::c_uchar, p7: *mut PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_get_issuer_and_serial(p7: *mut PKCS7, idx: ::aya_ebpf::cty::c_int) -> *mut PKCS7_ISSUER_AND_SERIAL;
}
extern "C" {
    pub fn PKCS7_get_octet_string(p7: *mut PKCS7) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn PKCS7_digest_from_attributes(sk: *mut stack_st_X509_ATTRIBUTE) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn PKCS7_add_signed_attribute(
        p7si: *mut PKCS7_SIGNER_INFO,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add_attribute(
        p7si: *mut PKCS7_SIGNER_INFO,
        nid: ::aya_ebpf::cty::c_int,
        atrtype: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_get_attribute(si: *const PKCS7_SIGNER_INFO, nid: ::aya_ebpf::cty::c_int) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn PKCS7_get_signed_attribute(si: *const PKCS7_SIGNER_INFO, nid: ::aya_ebpf::cty::c_int) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn PKCS7_set_signed_attributes(
        p7si: *mut PKCS7_SIGNER_INFO,
        sk: *mut stack_st_X509_ATTRIBUTE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_set_attributes(
        p7si: *mut PKCS7_SIGNER_INFO,
        sk: *mut stack_st_X509_ATTRIBUTE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_sign(
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        certs: *mut stack_st_X509,
        data: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_sign_ex(
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        certs: *mut stack_st_X509,
        data: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_sign_add_signer(
        p7: *mut PKCS7,
        signcert: *mut X509,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
        flags: ::aya_ebpf::cty::c_int,
    ) -> *mut PKCS7_SIGNER_INFO;
}
extern "C" {
    pub fn PKCS7_final(p7: *mut PKCS7, data: *mut BIO, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_verify(
        p7: *mut PKCS7,
        certs: *mut stack_st_X509,
        store: *mut X509_STORE,
        indata: *mut BIO,
        out: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_get0_signers(
        p7: *mut PKCS7,
        certs: *mut stack_st_X509,
        flags: ::aya_ebpf::cty::c_int,
    ) -> *mut stack_st_X509;
}
extern "C" {
    pub fn PKCS7_encrypt(
        certs: *mut stack_st_X509,
        in_: *mut BIO,
        cipher: *const EVP_CIPHER,
        flags: ::aya_ebpf::cty::c_int,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_encrypt_ex(
        certs: *mut stack_st_X509,
        in_: *mut BIO,
        cipher: *const EVP_CIPHER,
        flags: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PKCS7_decrypt(
        p7: *mut PKCS7,
        pkey: *mut EVP_PKEY,
        cert: *mut X509,
        data: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add_attrib_smimecap(
        si: *mut PKCS7_SIGNER_INFO,
        cap: *mut stack_st_X509_ALGOR,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_get_smimecap(si: *mut PKCS7_SIGNER_INFO) -> *mut stack_st_X509_ALGOR;
}
extern "C" {
    pub fn PKCS7_simple_smimecap(
        sk: *mut stack_st_X509_ALGOR,
        nid: ::aya_ebpf::cty::c_int,
        arg: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add_attrib_content_type(si: *mut PKCS7_SIGNER_INFO, coid: *mut ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add0_attrib_signing_time(si: *mut PKCS7_SIGNER_INFO, t: *mut ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS7_add1_attrib_digest(
        si: *mut PKCS7_SIGNER_INFO,
        md: *const ::aya_ebpf::cty::c_uchar,
        mdlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SMIME_write_PKCS7(
        bio: *mut BIO,
        p7: *mut PKCS7,
        data: *mut BIO,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SMIME_read_PKCS7_ex(bio: *mut BIO, bcont: *mut *mut BIO, p7: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn SMIME_read_PKCS7(bio: *mut BIO, bcont: *mut *mut BIO) -> *mut PKCS7;
}
extern "C" {
    pub fn BIO_new_PKCS7(out: *mut BIO, p7: *mut PKCS7) -> *mut BIO;
}
extern "C" {
    pub fn X509_CRL_set_default_method(meth: *const X509_CRL_METHOD);
}
extern "C" {
    pub fn X509_CRL_METHOD_new(
        crl_init: ::core::option::Option<unsafe extern "C" fn(crl: *mut X509_CRL) -> ::aya_ebpf::cty::c_int>,
        crl_free: ::core::option::Option<unsafe extern "C" fn(crl: *mut X509_CRL) -> ::aya_ebpf::cty::c_int>,
        crl_lookup: ::core::option::Option<
            unsafe extern "C" fn(
                crl: *mut X509_CRL,
                ret: *mut *mut X509_REVOKED,
                serial: *const ASN1_INTEGER,
                issuer: *const X509_NAME,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        crl_verify: ::core::option::Option<
            unsafe extern "C" fn(crl: *mut X509_CRL, pk: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> *mut X509_CRL_METHOD;
}
extern "C" {
    pub fn X509_CRL_METHOD_free(m: *mut X509_CRL_METHOD);
}
extern "C" {
    pub fn X509_CRL_set_meth_data(crl: *mut X509_CRL, dat: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn X509_CRL_get_meth_data(crl: *mut X509_CRL) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_verify_cert_error_string(n: ::aya_ebpf::cty::c_long) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_verify(a: *mut X509, r: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_self_signed(cert: *mut X509, verify_signature: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_verify_ex(
        a: *mut X509_REQ,
        r: *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_verify(a: *mut X509_REQ, r: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_verify(a: *mut X509_CRL, r: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_verify(a: *mut NETSCAPE_SPKI, r: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_decode(
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_encode(x: *mut NETSCAPE_SPKI) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn NETSCAPE_SPKI_get_pubkey(x: *mut NETSCAPE_SPKI) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn NETSCAPE_SPKI_set_pubkey(x: *mut NETSCAPE_SPKI, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_print(out: *mut BIO, spki: *mut NETSCAPE_SPKI) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_signature_dump(
        bp: *mut BIO,
        sig: *const ASN1_STRING,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_signature_print(bp: *mut BIO, alg: *const X509_ALGOR, sig: *const ASN1_STRING)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_sign(x: *mut X509, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_sign_ctx(x: *mut X509, ctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_sign(x: *mut X509_REQ, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_sign_ctx(x: *mut X509_REQ, ctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_sign(x: *mut X509_CRL, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_sign_ctx(x: *mut X509_CRL, ctx: *mut EVP_MD_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_sign(x: *mut NETSCAPE_SPKI, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_pubkey_digest(
        data: *const X509,
        type_: *const EVP_MD,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_digest(
        data: *const X509,
        type_: *const EVP_MD,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_digest_sig(
        cert: *const X509,
        md_used: *mut *mut EVP_MD,
        md_is_fallback: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_CRL_digest(
        data: *const X509_CRL,
        type_: *const EVP_MD,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_digest(
        data: *const X509_REQ,
        type_: *const EVP_MD,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_digest(
        data: *const X509_NAME,
        type_: *const EVP_MD,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_load_http(
        url: *const ::aya_ebpf::cty::c_char,
        bio: *mut BIO,
        rbio: *mut BIO,
        timeout: ::aya_ebpf::cty::c_int,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_CRL_load_http(
        url: *const ::aya_ebpf::cty::c_char,
        bio: *mut BIO,
        rbio: *mut BIO,
        timeout: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_CRL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CONF_VALUE {
    pub section: *mut ::aya_ebpf::cty::c_char,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub value: *mut ::aya_ebpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CONF_VALUE {
    _unused: [u8; 0],
}
pub type sk_CONF_VALUE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const CONF_VALUE, b: *const *const CONF_VALUE) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_CONF_VALUE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut CONF_VALUE)>;
pub type sk_CONF_VALUE_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const CONF_VALUE) -> *mut CONF_VALUE>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_CONF_VALUE {
    pub dummy: lhash_st_CONF_VALUE_lh_CONF_VALUE_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_CONF_VALUE_lh_CONF_VALUE_dummy {
    pub d1: *mut ::aya_ebpf::cty::c_void,
    pub d2: ::aya_ebpf::cty::c_ulong,
    pub d3: ::aya_ebpf::cty::c_int,
}
pub type lh_CONF_VALUE_compfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const CONF_VALUE, b: *const CONF_VALUE) -> ::aya_ebpf::cty::c_int>;
pub type lh_CONF_VALUE_hashfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const CONF_VALUE) -> ::aya_ebpf::cty::c_ulong>;
pub type lh_CONF_VALUE_doallfunc = ::core::option::Option<unsafe extern "C" fn(a: *mut CONF_VALUE)>;
pub type CONF_METHOD = conf_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_method_st {
    pub name: *const ::aya_ebpf::cty::c_char,
    pub create: ::core::option::Option<unsafe extern "C" fn(meth: *mut CONF_METHOD) -> *mut CONF>,
    pub init: ::core::option::Option<unsafe extern "C" fn(conf: *mut CONF) -> ::aya_ebpf::cty::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(conf: *mut CONF) -> ::aya_ebpf::cty::c_int>,
    pub destroy_data: ::core::option::Option<unsafe extern "C" fn(conf: *mut CONF) -> ::aya_ebpf::cty::c_int>,
    pub load_bio: ::core::option::Option<
        unsafe extern "C" fn(
            conf: *mut CONF,
            bp: *mut BIO,
            eline: *mut ::aya_ebpf::cty::c_long,
        ) -> ::aya_ebpf::cty::c_int,
    >,
    pub dump: ::core::option::Option<unsafe extern "C" fn(conf: *const CONF, bp: *mut BIO) -> ::aya_ebpf::cty::c_int>,
    pub is_number: ::core::option::Option<
        unsafe extern "C" fn(conf: *const CONF, c: ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int,
    >,
    pub to_int: ::core::option::Option<
        unsafe extern "C" fn(conf: *const CONF, c: ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int,
    >,
    pub load: ::core::option::Option<
        unsafe extern "C" fn(
            conf: *mut CONF,
            name: *const ::aya_ebpf::cty::c_char,
            eline: *mut ::aya_ebpf::cty::c_long,
        ) -> ::aya_ebpf::cty::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_st {
    pub meth: *mut CONF_METHOD,
    pub meth_data: *mut ::aya_ebpf::cty::c_void,
    pub data: *mut lhash_st_CONF_VALUE,
    pub flag_dollarid: ::aya_ebpf::cty::c_int,
    pub flag_abspath: ::aya_ebpf::cty::c_int,
    pub includedir: *mut ::aya_ebpf::cty::c_char,
    pub libctx: *mut OSSL_LIB_CTX,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_imodule_st {
    _unused: [u8; 0],
}
pub type CONF_IMODULE = conf_imodule_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_module_st {
    _unused: [u8; 0],
}
pub type CONF_MODULE = conf_module_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CONF_MODULE {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CONF_IMODULE {
    _unused: [u8; 0],
}
pub type conf_init_func =
    ::core::option::Option<unsafe extern "C" fn(md: *mut CONF_IMODULE, cnf: *const CONF) -> ::aya_ebpf::cty::c_int>;
pub type conf_finish_func = ::core::option::Option<unsafe extern "C" fn(md: *mut CONF_IMODULE)>;
extern "C" {
    pub fn CONF_set_default_method(meth: *mut CONF_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_set_nconf(conf: *mut CONF, hash: *mut lhash_st_CONF_VALUE);
}
extern "C" {
    pub fn CONF_load(
        conf: *mut lhash_st_CONF_VALUE,
        file: *const ::aya_ebpf::cty::c_char,
        eline: *mut ::aya_ebpf::cty::c_long,
    ) -> *mut lhash_st_CONF_VALUE;
}
extern "C" {
    pub fn CONF_load_fp(
        conf: *mut lhash_st_CONF_VALUE,
        fp: *mut FILE,
        eline: *mut ::aya_ebpf::cty::c_long,
    ) -> *mut lhash_st_CONF_VALUE;
}
extern "C" {
    pub fn CONF_load_bio(
        conf: *mut lhash_st_CONF_VALUE,
        bp: *mut BIO,
        eline: *mut ::aya_ebpf::cty::c_long,
    ) -> *mut lhash_st_CONF_VALUE;
}
extern "C" {
    pub fn CONF_get_section(
        conf: *mut lhash_st_CONF_VALUE,
        section: *const ::aya_ebpf::cty::c_char,
    ) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn CONF_get_string(
        conf: *mut lhash_st_CONF_VALUE,
        group: *const ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CONF_get_number(
        conf: *mut lhash_st_CONF_VALUE,
        group: *const ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn CONF_free(conf: *mut lhash_st_CONF_VALUE);
}
extern "C" {
    pub fn CONF_dump_fp(conf: *mut lhash_st_CONF_VALUE, out: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_dump_bio(conf: *mut lhash_st_CONF_VALUE, out: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_config(config_name: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn NCONF_new_ex(libctx: *mut OSSL_LIB_CTX, meth: *mut CONF_METHOD) -> *mut CONF;
}
extern "C" {
    pub fn NCONF_get0_libctx(conf: *const CONF) -> *mut OSSL_LIB_CTX;
}
extern "C" {
    pub fn NCONF_new(meth: *mut CONF_METHOD) -> *mut CONF;
}
extern "C" {
    pub fn NCONF_default() -> *mut CONF_METHOD;
}
extern "C" {
    pub fn NCONF_WIN32() -> *mut CONF_METHOD;
}
extern "C" {
    pub fn NCONF_free(conf: *mut CONF);
}
extern "C" {
    pub fn NCONF_free_data(conf: *mut CONF);
}
extern "C" {
    pub fn NCONF_load(
        conf: *mut CONF,
        file: *const ::aya_ebpf::cty::c_char,
        eline: *mut ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NCONF_load_fp(conf: *mut CONF, fp: *mut FILE, eline: *mut ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NCONF_load_bio(conf: *mut CONF, bp: *mut BIO, eline: *mut ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NCONF_get_section_names(conf: *const CONF) -> *mut stack_st_OPENSSL_CSTRING;
}
extern "C" {
    pub fn NCONF_get_section(conf: *const CONF, section: *const ::aya_ebpf::cty::c_char) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn NCONF_get_string(
        conf: *const CONF,
        group: *const ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn NCONF_get_number_e(
        conf: *const CONF,
        group: *const ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
        result: *mut ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NCONF_dump_fp(conf: *const CONF, out: *mut FILE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NCONF_dump_bio(conf: *const CONF, out: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_modules_load(
        cnf: *const CONF,
        appname: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_modules_load_file_ex(
        libctx: *mut OSSL_LIB_CTX,
        filename: *const ::aya_ebpf::cty::c_char,
        appname: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_modules_load_file(
        filename: *const ::aya_ebpf::cty::c_char,
        appname: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_modules_unload(all: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn CONF_modules_finish();
}
extern "C" {
    pub fn CONF_module_add(
        name: *const ::aya_ebpf::cty::c_char,
        ifunc: conf_init_func,
        ffunc: conf_finish_func,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CONF_imodule_get_name(md: *const CONF_IMODULE) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CONF_imodule_get_value(md: *const CONF_IMODULE) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CONF_imodule_get_usr_data(md: *const CONF_IMODULE) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CONF_imodule_set_usr_data(md: *mut CONF_IMODULE, usr_data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn CONF_imodule_get_module(md: *const CONF_IMODULE) -> *mut CONF_MODULE;
}
extern "C" {
    pub fn CONF_imodule_get_flags(md: *const CONF_IMODULE) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn CONF_imodule_set_flags(md: *mut CONF_IMODULE, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn CONF_module_get_usr_data(pmod: *mut CONF_MODULE) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn CONF_module_set_usr_data(pmod: *mut CONF_MODULE, usr_data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn CONF_get1_default_config_file() -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CONF_parse_list(
        list: *const ::aya_ebpf::cty::c_char,
        sep: ::aya_ebpf::cty::c_int,
        nospc: ::aya_ebpf::cty::c_int,
        list_cb: ::core::option::Option<
            unsafe extern "C" fn(
                elem: *const ::aya_ebpf::cty::c_char,
                len: ::aya_ebpf::cty::c_int,
                usr: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OPENSSL_load_builtin_modules();
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_new(
        wbio: *mut BIO,
        rbio: *mut BIO,
        buf_size: ::aya_ebpf::cty::c_int,
    ) -> *mut OSSL_HTTP_REQ_CTX;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_free(rctx: *mut OSSL_HTTP_REQ_CTX);
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_set_request_line(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        method_POST: ::aya_ebpf::cty::c_int,
        server: *const ::aya_ebpf::cty::c_char,
        port: *const ::aya_ebpf::cty::c_char,
        path: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_add1_header(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_set_expected(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        content_type: *const ::aya_ebpf::cty::c_char,
        asn1: ::aya_ebpf::cty::c_int,
        timeout: ::aya_ebpf::cty::c_int,
        keep_alive: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_set1_req(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        content_type: *const ::aya_ebpf::cty::c_char,
        it: *const ASN1_ITEM,
        req: *const ASN1_VALUE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_nbio(rctx: *mut OSSL_HTTP_REQ_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_nbio_d2i(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        pval: *mut *mut ASN1_VALUE,
        it: *const ASN1_ITEM,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_exchange(rctx: *mut OSSL_HTTP_REQ_CTX) -> *mut BIO;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_get0_mem_bio(rctx: *const OSSL_HTTP_REQ_CTX) -> *mut BIO;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_get_resp_len(rctx: *const OSSL_HTTP_REQ_CTX) -> usize;
}
extern "C" {
    pub fn OSSL_HTTP_REQ_CTX_set_max_response_length(rctx: *mut OSSL_HTTP_REQ_CTX, len: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn OSSL_HTTP_is_alive(rctx: *const OSSL_HTTP_REQ_CTX) -> ::aya_ebpf::cty::c_int;
}
pub type OSSL_HTTP_bio_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        bio: *mut BIO,
        arg: *mut ::aya_ebpf::cty::c_void,
        connect: ::aya_ebpf::cty::c_int,
        detail: ::aya_ebpf::cty::c_int,
    ) -> *mut BIO,
>;
extern "C" {
    pub fn OSSL_HTTP_open(
        server: *const ::aya_ebpf::cty::c_char,
        port: *const ::aya_ebpf::cty::c_char,
        proxy: *const ::aya_ebpf::cty::c_char,
        no_proxy: *const ::aya_ebpf::cty::c_char,
        use_ssl: ::aya_ebpf::cty::c_int,
        bio: *mut BIO,
        rbio: *mut BIO,
        bio_update_fn: OSSL_HTTP_bio_cb_t,
        arg: *mut ::aya_ebpf::cty::c_void,
        buf_size: ::aya_ebpf::cty::c_int,
        overall_timeout: ::aya_ebpf::cty::c_int,
    ) -> *mut OSSL_HTTP_REQ_CTX;
}
extern "C" {
    pub fn OSSL_HTTP_proxy_connect(
        bio: *mut BIO,
        server: *const ::aya_ebpf::cty::c_char,
        port: *const ::aya_ebpf::cty::c_char,
        proxyuser: *const ::aya_ebpf::cty::c_char,
        proxypass: *const ::aya_ebpf::cty::c_char,
        timeout: ::aya_ebpf::cty::c_int,
        bio_err: *mut BIO,
        prog: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_set1_request(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        path: *const ::aya_ebpf::cty::c_char,
        headers: *const stack_st_CONF_VALUE,
        content_type: *const ::aya_ebpf::cty::c_char,
        req: *mut BIO,
        expected_content_type: *const ::aya_ebpf::cty::c_char,
        expect_asn1: ::aya_ebpf::cty::c_int,
        max_resp_len: usize,
        timeout: ::aya_ebpf::cty::c_int,
        keep_alive: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_exchange(
        rctx: *mut OSSL_HTTP_REQ_CTX,
        redirection_url: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> *mut BIO;
}
extern "C" {
    pub fn OSSL_HTTP_get(
        url: *const ::aya_ebpf::cty::c_char,
        proxy: *const ::aya_ebpf::cty::c_char,
        no_proxy: *const ::aya_ebpf::cty::c_char,
        bio: *mut BIO,
        rbio: *mut BIO,
        bio_update_fn: OSSL_HTTP_bio_cb_t,
        arg: *mut ::aya_ebpf::cty::c_void,
        buf_size: ::aya_ebpf::cty::c_int,
        headers: *const stack_st_CONF_VALUE,
        expected_content_type: *const ::aya_ebpf::cty::c_char,
        expect_asn1: ::aya_ebpf::cty::c_int,
        max_resp_len: usize,
        timeout: ::aya_ebpf::cty::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn OSSL_HTTP_transfer(
        prctx: *mut *mut OSSL_HTTP_REQ_CTX,
        server: *const ::aya_ebpf::cty::c_char,
        port: *const ::aya_ebpf::cty::c_char,
        path: *const ::aya_ebpf::cty::c_char,
        use_ssl: ::aya_ebpf::cty::c_int,
        proxy: *const ::aya_ebpf::cty::c_char,
        no_proxy: *const ::aya_ebpf::cty::c_char,
        bio: *mut BIO,
        rbio: *mut BIO,
        bio_update_fn: OSSL_HTTP_bio_cb_t,
        arg: *mut ::aya_ebpf::cty::c_void,
        buf_size: ::aya_ebpf::cty::c_int,
        headers: *const stack_st_CONF_VALUE,
        content_type: *const ::aya_ebpf::cty::c_char,
        req: *mut BIO,
        expected_content_type: *const ::aya_ebpf::cty::c_char,
        expect_asn1: ::aya_ebpf::cty::c_int,
        max_resp_len: usize,
        timeout: ::aya_ebpf::cty::c_int,
        keep_alive: ::aya_ebpf::cty::c_int,
    ) -> *mut BIO;
}
extern "C" {
    pub fn OSSL_HTTP_close(rctx: *mut OSSL_HTTP_REQ_CTX, ok: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_parse_url(
        url: *const ::aya_ebpf::cty::c_char,
        pscheme: *mut *mut ::aya_ebpf::cty::c_char,
        puser: *mut *mut ::aya_ebpf::cty::c_char,
        phost: *mut *mut ::aya_ebpf::cty::c_char,
        pport: *mut *mut ::aya_ebpf::cty::c_char,
        pport_num: *mut ::aya_ebpf::cty::c_int,
        ppath: *mut *mut ::aya_ebpf::cty::c_char,
        pquery: *mut *mut ::aya_ebpf::cty::c_char,
        pfrag: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_parse_url(
        url: *const ::aya_ebpf::cty::c_char,
        pssl: *mut ::aya_ebpf::cty::c_int,
        puser: *mut *mut ::aya_ebpf::cty::c_char,
        phost: *mut *mut ::aya_ebpf::cty::c_char,
        pport: *mut *mut ::aya_ebpf::cty::c_char,
        pport_num: *mut ::aya_ebpf::cty::c_int,
        ppath: *mut *mut ::aya_ebpf::cty::c_char,
        pquery: *mut *mut ::aya_ebpf::cty::c_char,
        pfrag: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OSSL_HTTP_adapt_proxy(
        proxy: *const ::aya_ebpf::cty::c_char,
        no_proxy: *const ::aya_ebpf::cty::c_char,
        server: *const ::aya_ebpf::cty::c_char,
        use_ssl: ::aya_ebpf::cty::c_int,
    ) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn d2i_X509_fp(fp: *mut FILE, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_fp(fp: *mut FILE, x509: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_X509_CRL_fp(fp: *mut FILE, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL_fp(fp: *mut FILE, crl: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_X509_REQ_fp(fp: *mut FILE, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ_fp(fp: *mut FILE, req: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_fp(fp: *mut FILE, rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey_fp(fp: *mut FILE, rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_fp(fp: *mut FILE, dsa: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_fp(fp: *mut FILE, eckey: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey_fp(fp: *mut FILE, eckey: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_fp(fp: *mut FILE, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_PKCS8_fp(fp: *mut FILE, p8: *const X509_SIG) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_X509_PUBKEY_fp(fp: *mut FILE, xpk: *mut *mut X509_PUBKEY) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn i2d_X509_PUBKEY_fp(fp: *mut FILE, xpk: *const X509_PUBKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_fp(fp: *mut FILE, p8inf: *mut *mut PKCS8_PRIV_KEY_INFO) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_fp(fp: *mut FILE, p8inf: *const PKCS8_PRIV_KEY_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_fp(fp: *mut FILE, key: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_fp(fp: *mut FILE, pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_ex_fp(
        fp: *mut FILE,
        a: *mut *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_PrivateKey_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY_fp(fp: *mut FILE, pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_X509_bio(bp: *mut BIO, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_bio(bp: *mut BIO, x509: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_X509_CRL_bio(bp: *mut BIO, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL_bio(bp: *mut BIO, crl: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_X509_REQ_bio(bp: *mut BIO, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ_bio(bp: *mut BIO, req: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_bio(bp: *mut BIO, rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey_bio(bp: *mut BIO, rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_bio(bp: *mut BIO, dsa: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_bio(bp: *mut BIO, eckey: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey_bio(bp: *mut BIO, eckey: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_bio(bp: *mut BIO, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_PKCS8_bio(bp: *mut BIO, p8: *const X509_SIG) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_X509_PUBKEY_bio(bp: *mut BIO, xpk: *mut *mut X509_PUBKEY) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn i2d_X509_PUBKEY_bio(bp: *mut BIO, xpk: *const X509_PUBKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_bio(bp: *mut BIO, p8inf: *mut *mut PKCS8_PRIV_KEY_INFO) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_bio(bp: *mut BIO, p8inf: *const PKCS8_PRIV_KEY_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_bio(bp: *mut BIO, key: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_bio(bp: *mut BIO, pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey_ex_bio(
        bp: *mut BIO,
        a: *mut *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_PrivateKey_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY_bio(bp: *mut BIO, pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_dup(a: *const X509) -> *mut X509;
}
extern "C" {
    pub fn X509_ALGOR_dup(a: *const X509_ALGOR) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ATTRIBUTE_dup(a: *const X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_CRL_dup(a: *const X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_EXTENSION_dup(a: *const X509_EXTENSION) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_PUBKEY_dup(a: *const X509_PUBKEY) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_REQ_dup(a: *const X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REVOKED_dup(a: *const X509_REVOKED) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_ALGOR_set0(
        alg: *mut X509_ALGOR,
        aobj: *mut ASN1_OBJECT,
        ptype: ::aya_ebpf::cty::c_int,
        pval: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ALGOR_get0(
        paobj: *mut *const ASN1_OBJECT,
        pptype: *mut ::aya_ebpf::cty::c_int,
        ppval: *mut *const ::aya_ebpf::cty::c_void,
        algor: *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_ALGOR_set_md(alg: *mut X509_ALGOR, md: *const EVP_MD);
}
extern "C" {
    pub fn X509_ALGOR_cmp(a: *const X509_ALGOR, b: *const X509_ALGOR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ALGOR_copy(dest: *mut X509_ALGOR, src: *const X509_ALGOR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_dup(a: *const X509_NAME) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_ENTRY_dup(a: *const X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_cmp_time(s: *const ASN1_TIME, t: *mut time_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_cmp_current_time(s: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_cmp_timeframe(
        vpm: *const X509_VERIFY_PARAM,
        start: *const ASN1_TIME,
        end: *const ASN1_TIME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_time_adj(s: *mut ASN1_TIME, adj: ::aya_ebpf::cty::c_long, t: *mut time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_time_adj_ex(
        s: *mut ASN1_TIME,
        offset_day: ::aya_ebpf::cty::c_int,
        offset_sec: ::aya_ebpf::cty::c_long,
        t: *mut time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_gmtime_adj(s: *mut ASN1_TIME, adj: ::aya_ebpf::cty::c_long) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_get_default_cert_area() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir_env() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file_env() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_get_default_private_dir() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_to_X509_REQ(x: *mut X509, pkey: *mut EVP_PKEY, md: *const EVP_MD) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_to_X509(r: *mut X509_REQ, days: ::aya_ebpf::cty::c_int, pkey: *mut EVP_PKEY) -> *mut X509;
}
extern "C" {
    pub fn X509_ALGOR_new() -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_free(a: *mut X509_ALGOR);
}
extern "C" {
    pub fn d2i_X509_ALGOR(
        a: *mut *mut X509_ALGOR,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn i2d_X509_ALGOR(a: *const X509_ALGOR, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ALGOR_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_ALGORS(
        a: *mut *mut X509_ALGORS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_ALGORS;
}
extern "C" {
    pub fn i2d_X509_ALGORS(a: *const X509_ALGORS, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ALGORS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_VAL_new() -> *mut X509_VAL;
}
extern "C" {
    pub fn X509_VAL_free(a: *mut X509_VAL);
}
extern "C" {
    pub fn d2i_X509_VAL(
        a: *mut *mut X509_VAL,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_VAL;
}
extern "C" {
    pub fn i2d_X509_VAL(a: *const X509_VAL, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_VAL_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_new() -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_PUBKEY_free(a: *mut X509_PUBKEY);
}
extern "C" {
    pub fn d2i_X509_PUBKEY(
        a: *mut *mut X509_PUBKEY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn i2d_X509_PUBKEY(a: *const X509_PUBKEY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_new_ex(libctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_PUBKEY_set(x: *mut *mut X509_PUBKEY, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0(key: *const X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_PUBKEY_get(key: *const X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get_pubkey_parameters(pkey: *mut EVP_PKEY, chain: *mut stack_st_X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_pathlen(x: *mut X509) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn d2i_PUBKEY(
        a: *mut *mut EVP_PKEY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PUBKEY(a: *const EVP_PKEY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY_ex(
        a: *mut *mut EVP_PKEY,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY(
        a: *mut *mut RSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY(a: *const RSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY(
        a: *mut *mut DSA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY(a: *const DSA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY(
        a: *mut *mut EC_KEY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_EC_PUBKEY(a: *const EC_KEY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_SIG_new() -> *mut X509_SIG;
}
extern "C" {
    pub fn X509_SIG_free(a: *mut X509_SIG);
}
extern "C" {
    pub fn d2i_X509_SIG(
        a: *mut *mut X509_SIG,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_X509_SIG(a: *const X509_SIG, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_SIG_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_SIG_get0(sig: *const X509_SIG, palg: *mut *const X509_ALGOR, pdigest: *mut *const ASN1_OCTET_STRING);
}
extern "C" {
    pub fn X509_SIG_getm(sig: *mut X509_SIG, palg: *mut *mut X509_ALGOR, pdigest: *mut *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn X509_REQ_INFO_new() -> *mut X509_REQ_INFO;
}
extern "C" {
    pub fn X509_REQ_INFO_free(a: *mut X509_REQ_INFO);
}
extern "C" {
    pub fn d2i_X509_REQ_INFO(
        a: *mut *mut X509_REQ_INFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_REQ_INFO;
}
extern "C" {
    pub fn i2d_X509_REQ_INFO(a: *const X509_REQ_INFO, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_INFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_REQ_new() -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_free(a: *mut X509_REQ);
}
extern "C" {
    pub fn d2i_X509_REQ(
        a: *mut *mut X509_REQ,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ(a: *const X509_REQ, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_REQ_new_ex(libctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_ATTRIBUTE_new() -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_free(a: *mut X509_ATTRIBUTE);
}
extern "C" {
    pub fn d2i_X509_ATTRIBUTE(
        a: *mut *mut X509_ATTRIBUTE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn i2d_X509_ATTRIBUTE(
        a: *const X509_ATTRIBUTE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create(
        nid: ::aya_ebpf::cty::c_int,
        atrtype: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_EXTENSION_new() -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_free(a: *mut X509_EXTENSION);
}
extern "C" {
    pub fn d2i_X509_EXTENSION(
        a: *mut *mut X509_EXTENSION,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn i2d_X509_EXTENSION(
        a: *const X509_EXTENSION,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_EXTENSIONS(
        a: *mut *mut X509_EXTENSIONS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_EXTENSIONS;
}
extern "C" {
    pub fn i2d_X509_EXTENSIONS(
        a: *const X509_EXTENSIONS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_EXTENSIONS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_ENTRY_new() -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_free(a: *mut X509_NAME_ENTRY);
}
extern "C" {
    pub fn d2i_X509_NAME_ENTRY(
        a: *mut *mut X509_NAME_ENTRY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn i2d_X509_NAME_ENTRY(
        a: *const X509_NAME_ENTRY,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_new() -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_free(a: *mut X509_NAME);
}
extern "C" {
    pub fn d2i_X509_NAME(
        a: *mut *mut X509_NAME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_NAME;
}
extern "C" {
    pub fn i2d_X509_NAME(a: *const X509_NAME, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_set(xn: *mut *mut X509_NAME, name: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CINF_new() -> *mut X509_CINF;
}
extern "C" {
    pub fn X509_CINF_free(a: *mut X509_CINF);
}
extern "C" {
    pub fn d2i_X509_CINF(
        a: *mut *mut X509_CINF,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_CINF;
}
extern "C" {
    pub fn i2d_X509_CINF(a: *const X509_CINF, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CINF_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_new() -> *mut X509;
}
extern "C" {
    pub fn X509_free(a: *mut X509);
}
extern "C" {
    pub fn d2i_X509(
        a: *mut *mut X509,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509(a: *const X509, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_new_ex(libctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut X509;
}
extern "C" {
    pub fn X509_CERT_AUX_new() -> *mut X509_CERT_AUX;
}
extern "C" {
    pub fn X509_CERT_AUX_free(a: *mut X509_CERT_AUX);
}
extern "C" {
    pub fn d2i_X509_CERT_AUX(
        a: *mut *mut X509_CERT_AUX,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_CERT_AUX;
}
extern "C" {
    pub fn i2d_X509_CERT_AUX(a: *const X509_CERT_AUX, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CERT_AUX_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_set_ex_data(
        r: *mut X509,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_ex_data(r: *const X509, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn d2i_X509_AUX(
        a: *mut *mut X509,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509_AUX(a: *const X509, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_re_X509_tbs(x: *mut X509, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_SIG_INFO_get(
        siginf: *const X509_SIG_INFO,
        mdnid: *mut ::aya_ebpf::cty::c_int,
        pknid: *mut ::aya_ebpf::cty::c_int,
        secbits: *mut ::aya_ebpf::cty::c_int,
        flags: *mut u32,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_SIG_INFO_set(
        siginf: *mut X509_SIG_INFO,
        mdnid: ::aya_ebpf::cty::c_int,
        pknid: ::aya_ebpf::cty::c_int,
        secbits: ::aya_ebpf::cty::c_int,
        flags: u32,
    );
}
extern "C" {
    pub fn X509_get_signature_info(
        x: *mut X509,
        mdnid: *mut ::aya_ebpf::cty::c_int,
        pknid: *mut ::aya_ebpf::cty::c_int,
        secbits: *mut ::aya_ebpf::cty::c_int,
        flags: *mut u32,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get0_signature(psig: *mut *const ASN1_BIT_STRING, palg: *mut *const X509_ALGOR, x: *const X509);
}
extern "C" {
    pub fn X509_get_signature_nid(x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_set0_distinguishing_id(x: *mut X509, d_id: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn X509_get0_distinguishing_id(x: *mut X509) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_REQ_set0_distinguishing_id(x: *mut X509_REQ, d_id: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn X509_REQ_get0_distinguishing_id(x: *mut X509_REQ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_alias_set1(
        x: *mut X509,
        name: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_keyid_set1(
        x: *mut X509,
        id: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_alias_get0(x: *mut X509, len: *mut ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn X509_keyid_get0(x: *mut X509, len: *mut ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn X509_REVOKED_new() -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REVOKED_free(a: *mut X509_REVOKED);
}
extern "C" {
    pub fn d2i_X509_REVOKED(
        a: *mut *mut X509_REVOKED,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn i2d_X509_REVOKED(a: *const X509_REVOKED, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_INFO_new() -> *mut X509_CRL_INFO;
}
extern "C" {
    pub fn X509_CRL_INFO_free(a: *mut X509_CRL_INFO);
}
extern "C" {
    pub fn d2i_X509_CRL_INFO(
        a: *mut *mut X509_CRL_INFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_CRL_INFO;
}
extern "C" {
    pub fn i2d_X509_CRL_INFO(a: *const X509_CRL_INFO, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_INFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_new() -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_CRL_free(a: *mut X509_CRL);
}
extern "C" {
    pub fn d2i_X509_CRL(
        a: *mut *mut X509_CRL,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL(a: *const X509_CRL, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_new_ex(libctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_CRL_add0_revoked(crl: *mut X509_CRL, rev: *mut X509_REVOKED) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_serial(
        crl: *mut X509_CRL,
        ret: *mut *mut X509_REVOKED,
        serial: *const ASN1_INTEGER,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_cert(
        crl: *mut X509_CRL,
        ret: *mut *mut X509_REVOKED,
        x: *mut X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PKEY_new() -> *mut X509_PKEY;
}
extern "C" {
    pub fn X509_PKEY_free(a: *mut X509_PKEY);
}
extern "C" {
    pub fn NETSCAPE_SPKI_new() -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_free(a: *mut NETSCAPE_SPKI);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKI(
        a: *mut *mut NETSCAPE_SPKI,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKI(a: *const NETSCAPE_SPKI, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_new() -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_free(a: *mut NETSCAPE_SPKAC);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKAC(
        a: *mut *mut NETSCAPE_SPKAC,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKAC(
        a: *const NETSCAPE_SPKAC,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_new() -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_free(a: *mut NETSCAPE_CERT_SEQUENCE);
}
extern "C" {
    pub fn d2i_NETSCAPE_CERT_SEQUENCE(
        a: *mut *mut NETSCAPE_CERT_SEQUENCE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn i2d_NETSCAPE_CERT_SEQUENCE(
        a: *const NETSCAPE_CERT_SEQUENCE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NETSCAPE_CERT_SEQUENCE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509_INFO_new() -> *mut X509_INFO;
}
extern "C" {
    pub fn X509_INFO_free(a: *mut X509_INFO);
}
extern "C" {
    pub fn X509_NAME_oneline(
        a: *const X509_NAME,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ASN1_verify(
        i2d: i2d_of_void,
        algor1: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::aya_ebpf::cty::c_char,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_digest(
        i2d: i2d_of_void,
        type_: *const EVP_MD,
        data: *mut ::aya_ebpf::cty::c_char,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_sign(
        i2d: i2d_of_void,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::aya_ebpf::cty::c_char,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_digest(
        it: *const ASN1_ITEM,
        type_: *const EVP_MD,
        data: *mut ::aya_ebpf::cty::c_void,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_verify(
        it: *const ASN1_ITEM,
        alg: *const X509_ALGOR,
        signature: *const ASN1_BIT_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_verify_ctx(
        it: *const ASN1_ITEM,
        alg: *const X509_ALGOR,
        signature: *const ASN1_BIT_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        ctx: *mut EVP_MD_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_sign(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASN1_item_sign_ctx(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *const ::aya_ebpf::cty::c_void,
        ctx: *mut EVP_MD_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_version(x: *const X509) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn X509_set_version(x: *mut X509, version: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_set_serialNumber(x: *mut X509, serial: *mut ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_serialNumber(x: *mut X509) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn X509_get0_serialNumber(x: *const X509) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_set_issuer_name(x: *mut X509, name: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_issuer_name(a: *const X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_set_subject_name(x: *mut X509, name: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_subject_name(a: *const X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_get0_notBefore(x: *const X509) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_getm_notBefore(x: *const X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_set1_notBefore(x: *mut X509, tm: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get0_notAfter(x: *const X509) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_getm_notAfter(x: *const X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_set1_notAfter(x: *mut X509, tm: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_set_pubkey(x: *mut X509, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_up_ref(x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_signature_type(x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_X509_PUBKEY(x: *const X509) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_get0_extensions(x: *const X509) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_get0_uids(x: *const X509, piuid: *mut *const ASN1_BIT_STRING, psuid: *mut *const ASN1_BIT_STRING);
}
extern "C" {
    pub fn X509_get0_tbs_sigalg(x: *const X509) -> *const X509_ALGOR;
}
extern "C" {
    pub fn X509_get0_pubkey(x: *const X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get_pubkey(x: *mut X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get0_pubkey_bitstr(x: *const X509) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn X509_REQ_get_version(req: *const X509_REQ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn X509_REQ_set_version(x: *mut X509_REQ, version: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_subject_name(req: *const X509_REQ) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_REQ_set_subject_name(req: *mut X509_REQ, name: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get0_signature(
        req: *const X509_REQ,
        psig: *mut *const ASN1_BIT_STRING,
        palg: *mut *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_REQ_set0_signature(req: *mut X509_REQ, psig: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn X509_REQ_set1_signature_algo(req: *mut X509_REQ, palg: *mut X509_ALGOR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_signature_nid(req: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_re_X509_REQ_tbs(req: *mut X509_REQ, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_set_pubkey(x: *mut X509_REQ, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_pubkey(req: *mut X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_get0_pubkey(req: *mut X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_get_X509_PUBKEY(req: *mut X509_REQ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_REQ_extension_nid(nid: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_extension_nids() -> *mut ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_set_extension_nids(nids: *mut ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn X509_REQ_get_extensions(req: *mut X509_REQ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_REQ_add_extensions_nid(
        req: *mut X509_REQ,
        exts: *const stack_st_X509_EXTENSION,
        nid: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_add_extensions(req: *mut X509_REQ, ext: *const stack_st_X509_EXTENSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_count(req: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_NID(
        req: *const X509_REQ,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_OBJ(
        req: *const X509_REQ,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr(req: *const X509_REQ, loc: ::aya_ebpf::cty::c_int) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_delete_attr(req: *mut X509_REQ, loc: ::aya_ebpf::cty::c_int) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_add1_attr(req: *mut X509_REQ, attr: *mut X509_ATTRIBUTE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_OBJ(
        req: *mut X509_REQ,
        obj: *const ASN1_OBJECT,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_NID(
        req: *mut X509_REQ,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_txt(
        req: *mut X509_REQ,
        attrname: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_set_version(x: *mut X509_CRL, version: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_set_issuer_name(x: *mut X509_CRL, name: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_lastUpdate(x: *mut X509_CRL, tm: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_nextUpdate(x: *mut X509_CRL, tm: *const ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_sort(crl: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_up_ref(crl: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_version(crl: *const X509_CRL) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn X509_CRL_get0_lastUpdate(crl: *const X509_CRL) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get0_nextUpdate(crl: *const X509_CRL) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_lastUpdate(crl: *mut X509_CRL) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_nextUpdate(crl: *mut X509_CRL) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_issuer(crl: *const X509_CRL) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_CRL_get0_extensions(crl: *const X509_CRL) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_get_REVOKED(crl: *mut X509_CRL) -> *mut stack_st_X509_REVOKED;
}
extern "C" {
    pub fn X509_CRL_get0_signature(
        crl: *const X509_CRL,
        psig: *mut *const ASN1_BIT_STRING,
        palg: *mut *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_CRL_get_signature_nid(crl: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_re_X509_CRL_tbs(req: *mut X509_CRL, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_serialNumber(x: *const X509_REVOKED) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_REVOKED_set_serialNumber(x: *mut X509_REVOKED, serial: *mut ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_revocationDate(x: *const X509_REVOKED) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_REVOKED_set_revocationDate(r: *mut X509_REVOKED, tm: *mut ASN1_TIME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_extensions(r: *const X509_REVOKED) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_diff(
        base: *mut X509_CRL,
        newer: *mut X509_CRL,
        skey: *mut EVP_PKEY,
        md: *const EVP_MD,
        flags: ::aya_ebpf::cty::c_uint,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_REQ_check_private_key(x509: *mut X509_REQ, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_private_key(x509: *const X509, pkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_chain_check_suiteb(
        perror_depth: *mut ::aya_ebpf::cty::c_int,
        x: *mut X509,
        chain: *mut stack_st_X509,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_check_suiteb(
        crl: *mut X509_CRL,
        pk: *mut EVP_PKEY,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_chain_up_ref(chain: *mut stack_st_X509) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_issuer_and_serial_cmp(a: *const X509, b: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_issuer_and_serial_hash(a: *mut X509) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_issuer_name_cmp(a: *const X509, b: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_issuer_name_hash(a: *mut X509) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_subject_name_cmp(a: *const X509, b: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_subject_name_hash(x: *mut X509) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_issuer_name_hash_old(a: *mut X509) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_subject_name_hash_old(x: *mut X509) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_add_cert(
        sk: *mut stack_st_X509,
        cert: *mut X509,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_add_certs(
        sk: *mut stack_st_X509,
        certs: *mut stack_st_X509,
        flags: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_cmp(a: *const X509, b: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_cmp(a: *const X509_NAME, b: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_certificate_type(x: *const X509, pubkey: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_hash_ex(
        x: *const X509_NAME,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
        ok: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_NAME_hash_old(x: *const X509_NAME) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn X509_CRL_cmp(a: *const X509_CRL, b: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_match(a: *const X509_CRL, b: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_aux_print(out: *mut BIO, x: *mut X509, indent: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_print_ex_fp(
        bp: *mut FILE,
        x: *mut X509,
        nmflag: ::aya_ebpf::cty::c_ulong,
        cflag: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_print_fp(bp: *mut FILE, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_print_fp(bp: *mut FILE, x: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_print_fp(bp: *mut FILE, req: *mut X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex_fp(
        fp: *mut FILE,
        nm: *const X509_NAME,
        indent: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_print(bp: *mut BIO, name: *const X509_NAME, obase: ::aya_ebpf::cty::c_int)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex(
        out: *mut BIO,
        nm: *const X509_NAME,
        indent: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_print_ex(
        bp: *mut BIO,
        x: *mut X509,
        nmflag: ::aya_ebpf::cty::c_ulong,
        cflag: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_print(bp: *mut BIO, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ocspid_print(bp: *mut BIO, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_print_ex(out: *mut BIO, x: *mut X509_CRL, nmflag: ::aya_ebpf::cty::c_ulong)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_print(bp: *mut BIO, x: *mut X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_print_ex(
        bp: *mut BIO,
        x: *mut X509_REQ,
        nmflag: ::aya_ebpf::cty::c_ulong,
        cflag: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REQ_print(bp: *mut BIO, req: *mut X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_entry_count(name: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_NID(
        name: *const X509_NAME,
        nid: ::aya_ebpf::cty::c_int,
        buf: *mut ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_OBJ(
        name: *const X509_NAME,
        obj: *const ASN1_OBJECT,
        buf: *mut ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_NID(
        name: *const X509_NAME,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_OBJ(
        name: *const X509_NAME,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_get_entry(name: *const X509_NAME, loc: ::aya_ebpf::cty::c_int) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_delete_entry(name: *mut X509_NAME, loc: ::aya_ebpf::cty::c_int) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry(
        name: *mut X509_NAME,
        ne: *const X509_NAME_ENTRY,
        loc: ::aya_ebpf::cty::c_int,
        set: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_OBJ(
        name: *mut X509_NAME,
        obj: *const ASN1_OBJECT,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        loc: ::aya_ebpf::cty::c_int,
        set: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_NID(
        name: *mut X509_NAME,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        loc: ::aya_ebpf::cty::c_int,
        set: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_txt(
        ne: *mut *mut X509_NAME_ENTRY,
        field: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_NID(
        ne: *mut *mut X509_NAME_ENTRY,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_txt(
        name: *mut X509_NAME,
        field: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        loc: ::aya_ebpf::cty::c_int,
        set: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_OBJ(
        ne: *mut *mut X509_NAME_ENTRY,
        obj: *const ASN1_OBJECT,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_object(ne: *mut X509_NAME_ENTRY, obj: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_data(
        ne: *mut X509_NAME_ENTRY,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_object(ne: *const X509_NAME_ENTRY) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_data(ne: *const X509_NAME_ENTRY) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set(ne: *const X509_NAME_ENTRY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_NAME_get0_der(
        nm: *const X509_NAME,
        pder: *mut *const ::aya_ebpf::cty::c_uchar,
        pderlen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_count(x: *const stack_st_X509_EXTENSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_NID(
        x: *const stack_st_X509_EXTENSION,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_OBJ(
        x: *const stack_st_X509_EXTENSION,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_critical(
        x: *const stack_st_X509_EXTENSION,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_get_ext(x: *const stack_st_X509_EXTENSION, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_delete_ext(x: *mut stack_st_X509_EXTENSION, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_add_ext(
        x: *mut *mut stack_st_X509_EXTENSION,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_get_ext_count(x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_NID(
        x: *const X509,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_OBJ(
        x: *const X509,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_critical(
        x: *const X509,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_ext(x: *const X509, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_delete_ext(x: *mut X509, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_add_ext(x: *mut X509, ex: *mut X509_EXTENSION, loc: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get_ext_d2i(
        x: *const X509,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_add1_ext_i2d(
        x: *mut X509,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_count(x: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_NID(
        x: *const X509_CRL,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_OBJ(
        x: *const X509_CRL,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_critical(
        x: *const X509_CRL,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext(x: *const X509_CRL, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_delete_ext(x: *mut X509_CRL, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_add_ext(
        x: *mut X509_CRL,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_d2i(
        x: *const X509_CRL,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_CRL_add1_ext_i2d(
        x: *mut X509_CRL,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_count(x: *const X509_REVOKED) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_NID(
        x: *const X509_REVOKED,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_OBJ(
        x: *const X509_REVOKED,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_critical(
        x: *const X509_REVOKED,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext(x: *const X509_REVOKED, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_delete_ext(x: *mut X509_REVOKED, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_add_ext(
        x: *mut X509_REVOKED,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_d2i(
        x: *const X509_REVOKED,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_REVOKED_add1_ext_i2d(
        x: *mut X509_REVOKED,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_NID(
        ex: *mut *mut X509_EXTENSION,
        nid: ::aya_ebpf::cty::c_int,
        crit: ::aya_ebpf::cty::c_int,
        data: *mut ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_OBJ(
        ex: *mut *mut X509_EXTENSION,
        obj: *const ASN1_OBJECT,
        crit: ::aya_ebpf::cty::c_int,
        data: *mut ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_set_object(ex: *mut X509_EXTENSION, obj: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_critical(ex: *mut X509_EXTENSION, crit: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_data(ex: *mut X509_EXTENSION, data: *mut ASN1_OCTET_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_get_object(ex: *mut X509_EXTENSION) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_EXTENSION_get_data(ne: *mut X509_EXTENSION) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_EXTENSION_get_critical(ex: *const X509_EXTENSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509at_get_attr_count(x: *const stack_st_X509_ATTRIBUTE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509at_get_attr_by_NID(
        x: *const stack_st_X509_ATTRIBUTE,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509at_get_attr_by_OBJ(
        sk: *const stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509at_get_attr(x: *const stack_st_X509_ATTRIBUTE, loc: ::aya_ebpf::cty::c_int) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_delete_attr(x: *mut stack_st_X509_ATTRIBUTE, loc: ::aya_ebpf::cty::c_int) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        attr: *mut X509_ATTRIBUTE,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_OBJ(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_NID(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_add1_attr_by_txt(
        x: *mut *mut stack_st_X509_ATTRIBUTE,
        attrname: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509at_get0_data_by_OBJ(
        x: *const stack_st_X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_NID(
        attr: *mut *mut X509_ATTRIBUTE,
        nid: ::aya_ebpf::cty::c_int,
        atrtype: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_OBJ(
        attr: *mut *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        atrtype: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_txt(
        attr: *mut *mut X509_ATTRIBUTE,
        atrname: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_object(attr: *mut X509_ATTRIBUTE, obj: *const ASN1_OBJECT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_data(
        attr: *mut X509_ATTRIBUTE,
        attrtype: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_data(
        attr: *mut X509_ATTRIBUTE,
        idx: ::aya_ebpf::cty::c_int,
        atrtype: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_count(attr: *const X509_ATTRIBUTE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_object(attr: *mut X509_ATTRIBUTE) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_type(attr: *mut X509_ATTRIBUTE, idx: ::aya_ebpf::cty::c_int) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_count(key: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_by_NID(
        key: *const EVP_PKEY,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr_by_OBJ(
        key: *const EVP_PKEY,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_attr(key: *const EVP_PKEY, loc: ::aya_ebpf::cty::c_int) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn EVP_PKEY_delete_attr(key: *mut EVP_PKEY, loc: ::aya_ebpf::cty::c_int) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr(key: *mut EVP_PKEY, attr: *mut X509_ATTRIBUTE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_OBJ(
        key: *mut EVP_PKEY,
        obj: *const ASN1_OBJECT,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_NID(
        key: *mut EVP_PKEY,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EVP_PKEY_add1_attr_by_txt(
        key: *mut EVP_PKEY,
        attrname: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_find_by_issuer_and_serial(
        sk: *mut stack_st_X509,
        name: *const X509_NAME,
        serial: *const ASN1_INTEGER,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_find_by_subject(sk: *mut stack_st_X509, name: *const X509_NAME) -> *mut X509;
}
extern "C" {
    pub fn PBEPARAM_new() -> *mut PBEPARAM;
}
extern "C" {
    pub fn PBEPARAM_free(a: *mut PBEPARAM);
}
extern "C" {
    pub fn d2i_PBEPARAM(
        a: *mut *mut PBEPARAM,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PBEPARAM;
}
extern "C" {
    pub fn i2d_PBEPARAM(a: *const PBEPARAM, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PBEPARAM_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PBE2PARAM_new() -> *mut PBE2PARAM;
}
extern "C" {
    pub fn PBE2PARAM_free(a: *mut PBE2PARAM);
}
extern "C" {
    pub fn d2i_PBE2PARAM(
        a: *mut *mut PBE2PARAM,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PBE2PARAM;
}
extern "C" {
    pub fn i2d_PBE2PARAM(a: *const PBE2PARAM, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PBE2PARAM_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PBKDF2PARAM_new() -> *mut PBKDF2PARAM;
}
extern "C" {
    pub fn PBKDF2PARAM_free(a: *mut PBKDF2PARAM);
}
extern "C" {
    pub fn d2i_PBKDF2PARAM(
        a: *mut *mut PBKDF2PARAM,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PBKDF2PARAM;
}
extern "C" {
    pub fn i2d_PBKDF2PARAM(a: *const PBKDF2PARAM, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PBKDF2PARAM_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn SCRYPT_PARAMS_new() -> *mut SCRYPT_PARAMS;
}
extern "C" {
    pub fn SCRYPT_PARAMS_free(a: *mut SCRYPT_PARAMS);
}
extern "C" {
    pub fn d2i_SCRYPT_PARAMS(
        a: *mut *mut SCRYPT_PARAMS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut SCRYPT_PARAMS;
}
extern "C" {
    pub fn i2d_SCRYPT_PARAMS(a: *const SCRYPT_PARAMS, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCRYPT_PARAMS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKCS5_pbe_set0_algor(
        algor: *mut X509_ALGOR,
        alg: ::aya_ebpf::cty::c_int,
        iter: ::aya_ebpf::cty::c_int,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_pbe_set0_algor_ex(
        algor: *mut X509_ALGOR,
        alg: ::aya_ebpf::cty::c_int,
        iter: ::aya_ebpf::cty::c_int,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS5_pbe_set(
        alg: ::aya_ebpf::cty::c_int,
        iter: ::aya_ebpf::cty::c_int,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe_set_ex(
        alg: ::aya_ebpf::cty::c_int,
        iter: ::aya_ebpf::cty::c_int,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set(
        cipher: *const EVP_CIPHER,
        iter: ::aya_ebpf::cty::c_int,
        salt: *mut ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set_iv(
        cipher: *const EVP_CIPHER,
        iter: ::aya_ebpf::cty::c_int,
        salt: *mut ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        aiv: *mut ::aya_ebpf::cty::c_uchar,
        prf_nid: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set_iv_ex(
        cipher: *const EVP_CIPHER,
        iter: ::aya_ebpf::cty::c_int,
        salt: *mut ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        aiv: *mut ::aya_ebpf::cty::c_uchar,
        prf_nid: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbe2_set_scrypt(
        cipher: *const EVP_CIPHER,
        salt: *const ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        aiv: *mut ::aya_ebpf::cty::c_uchar,
        N: u64,
        r: u64,
        p: u64,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbkdf2_set(
        iter: ::aya_ebpf::cty::c_int,
        salt: *mut ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        prf_nid: ::aya_ebpf::cty::c_int,
        keylen: ::aya_ebpf::cty::c_int,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS5_pbkdf2_set_ex(
        iter: ::aya_ebpf::cty::c_int,
        salt: *mut ::aya_ebpf::cty::c_uchar,
        saltlen: ::aya_ebpf::cty::c_int,
        prf_nid: ::aya_ebpf::cty::c_int,
        keylen: ::aya_ebpf::cty::c_int,
        libctx: *mut OSSL_LIB_CTX,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_new() -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_free(a: *mut PKCS8_PRIV_KEY_INFO);
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO(
        a: *mut *mut PKCS8_PRIV_KEY_INFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO(
        a: *const PKCS8_PRIV_KEY_INFO,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn EVP_PKCS82PKEY(p8: *const PKCS8_PRIV_KEY_INFO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKCS82PKEY_ex(
        p8: *const PKCS8_PRIV_KEY_INFO,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY2PKCS8(pkey: *const EVP_PKEY) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_pkey_set0(
        priv_: *mut PKCS8_PRIV_KEY_INFO,
        aobj: *mut ASN1_OBJECT,
        version: ::aya_ebpf::cty::c_int,
        ptype: ::aya_ebpf::cty::c_int,
        pval: *mut ::aya_ebpf::cty::c_void,
        penc: *mut ::aya_ebpf::cty::c_uchar,
        penclen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_get0(
        ppkalg: *mut *const ASN1_OBJECT,
        pk: *mut *const ::aya_ebpf::cty::c_uchar,
        ppklen: *mut ::aya_ebpf::cty::c_int,
        pa: *mut *const X509_ALGOR,
        p8: *const PKCS8_PRIV_KEY_INFO,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_get0_attrs(p8: *const PKCS8_PRIV_KEY_INFO) -> *const stack_st_X509_ATTRIBUTE;
}
extern "C" {
    pub fn PKCS8_pkey_add1_attr(p8: *mut PKCS8_PRIV_KEY_INFO, attr: *mut X509_ATTRIBUTE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_add1_attr_by_NID(
        p8: *mut PKCS8_PRIV_KEY_INFO,
        nid: ::aya_ebpf::cty::c_int,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKCS8_pkey_add1_attr_by_OBJ(
        p8: *mut PKCS8_PRIV_KEY_INFO,
        obj: *const ASN1_OBJECT,
        type_: ::aya_ebpf::cty::c_int,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_set0_param(
        pub_: *mut X509_PUBKEY,
        aobj: *mut ASN1_OBJECT,
        ptype: ::aya_ebpf::cty::c_int,
        pval: *mut ::aya_ebpf::cty::c_void,
        penc: *mut ::aya_ebpf::cty::c_uchar,
        penclen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0_param(
        ppkalg: *mut *mut ASN1_OBJECT,
        pk: *mut *const ::aya_ebpf::cty::c_uchar,
        ppklen: *mut ::aya_ebpf::cty::c_int,
        pa: *mut *mut X509_ALGOR,
        pub_: *const X509_PUBKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_eq(a: *const X509_PUBKEY, b: *const X509_PUBKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_get_EVP_CIPHER_INFO(
        header: *mut ::aya_ebpf::cty::c_char,
        cipher: *mut EVP_CIPHER_INFO,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_do_header(
        cipher: *mut EVP_CIPHER_INFO,
        data: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_long,
        callback: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio(
        bp: *mut BIO,
        name: *mut *mut ::aya_ebpf::cty::c_char,
        header: *mut *mut ::aya_ebpf::cty::c_char,
        data: *mut *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ex(
        bp: *mut BIO,
        name: *mut *mut ::aya_ebpf::cty::c_char,
        header: *mut *mut ::aya_ebpf::cty::c_char,
        data: *mut *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_long,
        flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_bytes_read_bio_secmem(
        pdata: *mut *mut ::aya_ebpf::cty::c_uchar,
        plen: *mut ::aya_ebpf::cty::c_long,
        pnm: *mut *mut ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
        bp: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio(
        bp: *mut BIO,
        name: *const ::aya_ebpf::cty::c_char,
        hdr: *const ::aya_ebpf::cty::c_char,
        data: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_bytes_read_bio(
        pdata: *mut *mut ::aya_ebpf::cty::c_uchar,
        plen: *mut ::aya_ebpf::cty::c_long,
        pnm: *mut *mut ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
        bp: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read_bio(
        d2i: d2i_of_void,
        name: *const ::aya_ebpf::cty::c_char,
        bp: *mut BIO,
        x: *mut *mut ::aya_ebpf::cty::c_void,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write_bio(
        i2d: i2d_of_void,
        name: *const ::aya_ebpf::cty::c_char,
        bp: *mut BIO,
        x: *const ::aya_ebpf::cty::c_void,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read_bio(
        bp: *mut BIO,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_X509_INFO_read_bio_ex(
        bp: *mut BIO,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_X509_INFO_write_bio(
        bp: *mut BIO,
        xi: *const X509_INFO,
        enc: *mut EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cd: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read(
        fp: *mut FILE,
        name: *mut *mut ::aya_ebpf::cty::c_char,
        header: *mut *mut ::aya_ebpf::cty::c_char,
        data: *mut *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write(
        fp: *mut FILE,
        name: *const ::aya_ebpf::cty::c_char,
        hdr: *const ::aya_ebpf::cty::c_char,
        data: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read(
        d2i: d2i_of_void,
        name: *const ::aya_ebpf::cty::c_char,
        fp: *mut FILE,
        x: *mut *mut ::aya_ebpf::cty::c_void,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write(
        i2d: i2d_of_void,
        name: *const ::aya_ebpf::cty::c_char,
        fp: *mut FILE,
        x: *const ::aya_ebpf::cty::c_void,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        callback: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read(
        fp: *mut FILE,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_X509_INFO_read_ex(
        fp: *mut FILE,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_SignInit(ctx: *mut EVP_MD_CTX, type_: *mut EVP_MD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_SignUpdate(
        ctx: *mut EVP_MD_CTX,
        d: *const ::aya_ebpf::cty::c_uchar,
        cnt: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_SignFinal(
        ctx: *mut EVP_MD_CTX,
        sigret: *mut ::aya_ebpf::cty::c_uchar,
        siglen: *mut ::aya_ebpf::cty::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_def_callback(
        buf: *mut ::aya_ebpf::cty::c_char,
        num: ::aya_ebpf::cty::c_int,
        rwflag: ::aya_ebpf::cty::c_int,
        userdata: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_proc_type(buf: *mut ::aya_ebpf::cty::c_char, type_: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn PEM_dek_info(
        buf: *mut ::aya_ebpf::cty::c_char,
        type_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
        str_: *const ::aya_ebpf::cty::c_char,
    );
}
extern "C" {
    pub fn PEM_read_bio_X509(
        out: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509(
        out: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509(out: *mut BIO, x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_X509(out: *mut FILE, x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_AUX(
        out: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509_AUX(
        out: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509_AUX(out: *mut BIO, x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_X509_AUX(out: *mut FILE, x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_REQ(
        out: *mut BIO,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_read_X509_REQ(
        out: *mut FILE,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ(out: *mut BIO, x: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ(out: *mut FILE, x: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ_NEW(out: *mut BIO, x: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ_NEW(out: *mut FILE, x: *const X509_REQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_CRL(
        out: *mut BIO,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_read_X509_CRL(
        out: *mut FILE,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_write_bio_X509_CRL(out: *mut BIO, x: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_X509_CRL(out: *mut FILE, x: *const X509_CRL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_PUBKEY(
        out: *mut BIO,
        x: *mut *mut X509_PUBKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn PEM_read_X509_PUBKEY(
        out: *mut FILE,
        x: *mut *mut X509_PUBKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn PEM_write_bio_X509_PUBKEY(out: *mut BIO, x: *const X509_PUBKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_X509_PUBKEY(out: *mut FILE, x: *const X509_PUBKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS7(
        out: *mut BIO,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_read_PKCS7(
        out: *mut FILE,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7(out: *mut BIO, x: *const PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS7(out: *mut FILE, x: *const PKCS7) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_NETSCAPE_CERT_SEQUENCE(
        out: *mut BIO,
        x: *mut *mut NETSCAPE_CERT_SEQUENCE,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn PEM_read_NETSCAPE_CERT_SEQUENCE(
        out: *mut FILE,
        x: *mut *mut NETSCAPE_CERT_SEQUENCE,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut NETSCAPE_CERT_SEQUENCE;
}
extern "C" {
    pub fn PEM_write_bio_NETSCAPE_CERT_SEQUENCE(
        out: *mut BIO,
        x: *const NETSCAPE_CERT_SEQUENCE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_NETSCAPE_CERT_SEQUENCE(out: *mut FILE, x: *const NETSCAPE_CERT_SEQUENCE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8(
        out: *mut BIO,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_read_PKCS8(
        out: *mut FILE,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8(out: *mut BIO, x: *const X509_SIG) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8(out: *mut FILE, x: *const X509_SIG) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8_PRIV_KEY_INFO(
        out: *mut BIO,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_read_PKCS8_PRIV_KEY_INFO(
        out: *mut FILE,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8_PRIV_KEY_INFO(out: *mut BIO, x: *const PKCS8_PRIV_KEY_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8_PRIV_KEY_INFO(out: *mut FILE, x: *const PKCS8_PRIV_KEY_INFO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPrivateKey(
        out: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPrivateKey(
        out: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPrivateKey(
        out: *mut BIO,
        x: *const RSA,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPrivateKey(
        out: *mut FILE,
        x: *const RSA,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPublicKey(
        out: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPublicKey(
        out: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPublicKey(out: *mut BIO, x: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPublicKey(out: *mut FILE, x: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSA_PUBKEY(
        out: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSA_PUBKEY(
        out: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSA_PUBKEY(out: *mut BIO, x: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_RSA_PUBKEY(out: *mut FILE, x: *const RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAPrivateKey(
        out: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAPrivateKey(
        out: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAPrivateKey(
        out: *mut BIO,
        x: *const DSA,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_DSAPrivateKey(
        out: *mut FILE,
        x: *const DSA,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSA_PUBKEY(
        out: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSA_PUBKEY(
        out: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSA_PUBKEY(out: *mut BIO, x: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_DSA_PUBKEY(out: *mut FILE, x: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAparams(
        out: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAparams(
        out: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAparams(out: *mut BIO, x: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_DSAparams(out: *mut FILE, x: *const DSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPKParameters(
        out: *mut BIO,
        x: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_read_ECPKParameters(
        out: *mut FILE,
        x: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_write_bio_ECPKParameters(out: *mut BIO, x: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_ECPKParameters(out: *mut FILE, x: *const EC_GROUP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPrivateKey(
        out: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_ECPrivateKey(
        out: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_ECPrivateKey(
        out: *mut BIO,
        x: *const EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_ECPrivateKey(
        out: *mut FILE,
        x: *const EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_EC_PUBKEY(
        out: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_EC_PUBKEY(
        out: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_EC_PUBKEY(out: *mut BIO, x: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_EC_PUBKEY(out: *mut FILE, x: *const EC_KEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DHparams(
        out: *mut BIO,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_read_DHparams(
        out: *mut FILE,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_write_bio_DHparams(out: *mut BIO, x: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_DHparams(out: *mut FILE, x: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_DHxparams(out: *mut BIO, x: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_DHxparams(out: *mut FILE, x: *const DH) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PrivateKey(
        out: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_bio_PrivateKey_ex(
        out: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PrivateKey(
        out: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PrivateKey_ex(
        out: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey(
        out: *mut BIO,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey_ex(
        out: *mut BIO,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PrivateKey(
        out: *mut FILE,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PrivateKey_ex(
        out: *mut FILE,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PUBKEY(
        out: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_bio_PUBKEY_ex(
        out: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PUBKEY(
        out: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PUBKEY_ex(
        out: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PUBKEY(out: *mut BIO, x: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PUBKEY_ex(
        out: *mut BIO,
        x: *const EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PUBKEY(out: *mut FILE, x: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PUBKEY_ex(
        out: *mut FILE,
        x: *const EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey_traditional(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_uchar,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey_nid(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        nid: ::aya_ebpf::cty::c_int,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey(
        arg1: *mut BIO,
        arg2: *const EVP_PKEY,
        arg3: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_bio(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        nid: ::aya_ebpf::cty::c_int,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_fp(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        nid: ::aya_ebpf::cty::c_int,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey_nid(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        nid: ::aya_ebpf::cty::c_int,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *const ::aya_ebpf::cty::c_char,
        klen: ::aya_ebpf::cty::c_int,
        cd: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_read_bio_Parameters_ex(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_bio_Parameters(bp: *mut BIO, x: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_Parameters(bp: *mut BIO, x: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn b2i_PrivateKey(in_: *mut *const ::aya_ebpf::cty::c_uchar, length: ::aya_ebpf::cty::c_long) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PublicKey(in_: *mut *const ::aya_ebpf::cty::c_uchar, length: ::aya_ebpf::cty::c_long) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PrivateKey_bio(in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PublicKey_bio(in_: *mut BIO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2b_PrivateKey_bio(out: *mut BIO, pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2b_PublicKey_bio(out: *mut BIO, pk: *const EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn b2i_PVK_bio(in_: *mut BIO, cb: pem_password_cb, u: *mut ::aya_ebpf::cty::c_void) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn b2i_PVK_bio_ex(
        in_: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2b_PVK_bio(
        out: *mut BIO,
        pk: *const EVP_PKEY,
        enclevel: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2b_PVK_bio_ex(
        out: *mut BIO,
        pk: *const EVP_PKEY,
        enclevel: ::aya_ebpf::cty::c_int,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_size(e: *const HMAC_CTX) -> usize;
}
extern "C" {
    pub fn HMAC_CTX_new() -> *mut HMAC_CTX;
}
extern "C" {
    pub fn HMAC_CTX_reset(ctx: *mut HMAC_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_CTX_free(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_Init(
        ctx: *mut HMAC_CTX,
        key: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
        md: *const EVP_MD,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_Init_ex(
        ctx: *mut HMAC_CTX,
        key: *const ::aya_ebpf::cty::c_void,
        len: ::aya_ebpf::cty::c_int,
        md: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_Update(ctx: *mut HMAC_CTX, data: *const ::aya_ebpf::cty::c_uchar, len: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_Final(
        ctx: *mut HMAC_CTX,
        md: *mut ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_CTX_copy(dctx: *mut HMAC_CTX, sctx: *mut HMAC_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn HMAC_CTX_set_flags(ctx: *mut HMAC_CTX, flags: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn HMAC_CTX_get_md(ctx: *const HMAC_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn HMAC(
        evp_md: *const EVP_MD,
        key: *const ::aya_ebpf::cty::c_void,
        key_len: ::aya_ebpf::cty::c_int,
        data: *const ::aya_ebpf::cty::c_uchar,
        data_len: usize,
        md: *mut ::aya_ebpf::cty::c_uchar,
        md_len: *mut ::aya_ebpf::cty::c_uint,
    ) -> *mut ::aya_ebpf::cty::c_uchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_job_st {
    _unused: [u8; 0],
}
pub type ASYNC_JOB = async_job_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct async_wait_ctx_st {
    _unused: [u8; 0],
}
pub type ASYNC_WAIT_CTX = async_wait_ctx_st;
pub type ASYNC_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
extern "C" {
    pub fn ASYNC_init_thread(max_size: usize, init_size: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_cleanup_thread();
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_new() -> *mut ASYNC_WAIT_CTX;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_free(ctx: *mut ASYNC_WAIT_CTX);
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_set_wait_fd(
        ctx: *mut ASYNC_WAIT_CTX,
        key: *const ::aya_ebpf::cty::c_void,
        fd: ::aya_ebpf::cty::c_int,
        custom_data: *mut ::aya_ebpf::cty::c_void,
        cleanup: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ASYNC_WAIT_CTX,
                arg2: *const ::aya_ebpf::cty::c_void,
                arg3: ::aya_ebpf::cty::c_int,
                arg4: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_fd(
        ctx: *mut ASYNC_WAIT_CTX,
        key: *const ::aya_ebpf::cty::c_void,
        fd: *mut ::aya_ebpf::cty::c_int,
        custom_data: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_all_fds(
        ctx: *mut ASYNC_WAIT_CTX,
        fd: *mut ::aya_ebpf::cty::c_int,
        numfds: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_callback(
        ctx: *mut ASYNC_WAIT_CTX,
        callback: *mut ASYNC_callback_fn,
        callback_arg: *mut *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_set_callback(
        ctx: *mut ASYNC_WAIT_CTX,
        callback: ASYNC_callback_fn,
        callback_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_set_status(ctx: *mut ASYNC_WAIT_CTX, status: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_status(ctx: *mut ASYNC_WAIT_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_get_changed_fds(
        ctx: *mut ASYNC_WAIT_CTX,
        addfd: *mut ::aya_ebpf::cty::c_int,
        numaddfds: *mut usize,
        delfd: *mut ::aya_ebpf::cty::c_int,
        numdelfds: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_WAIT_CTX_clear_fd(
        ctx: *mut ASYNC_WAIT_CTX,
        key: *const ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_is_capable() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_start_job(
        job: *mut *mut ASYNC_JOB,
        ctx: *mut ASYNC_WAIT_CTX,
        ret: *mut ::aya_ebpf::cty::c_int,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>,
        args: *mut ::aya_ebpf::cty::c_void,
        size: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_pause_job() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASYNC_get_current_job() -> *mut ASYNC_JOB;
}
extern "C" {
    pub fn ASYNC_get_wait_ctx(job: *mut ASYNC_JOB) -> *mut ASYNC_WAIT_CTX;
}
extern "C" {
    pub fn ASYNC_block_pause();
}
extern "C" {
    pub fn ASYNC_unblock_pause();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SCT {
    _unused: [u8; 0],
}
pub type sk_SCT_compfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const *const SCT, b: *const *const SCT) -> ::aya_ebpf::cty::c_int>;
pub type sk_SCT_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut SCT)>;
pub type sk_SCT_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const SCT) -> *mut SCT>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CTLOG {
    _unused: [u8; 0],
}
pub type sk_CTLOG_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const CTLOG, b: *const *const CTLOG) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_CTLOG_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut CTLOG)>;
pub type sk_CTLOG_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const CTLOG) -> *mut CTLOG>;
pub const ct_log_entry_type_t_CT_LOG_ENTRY_TYPE_NOT_SET: ct_log_entry_type_t = -1;
pub const ct_log_entry_type_t_CT_LOG_ENTRY_TYPE_X509: ct_log_entry_type_t = 0;
pub const ct_log_entry_type_t_CT_LOG_ENTRY_TYPE_PRECERT: ct_log_entry_type_t = 1;
pub type ct_log_entry_type_t = ::aya_ebpf::cty::c_int;
pub const sct_version_t_SCT_VERSION_NOT_SET: sct_version_t = -1;
pub const sct_version_t_SCT_VERSION_V1: sct_version_t = 0;
pub type sct_version_t = ::aya_ebpf::cty::c_int;
pub const sct_source_t_SCT_SOURCE_UNKNOWN: sct_source_t = 0;
pub const sct_source_t_SCT_SOURCE_TLS_EXTENSION: sct_source_t = 1;
pub const sct_source_t_SCT_SOURCE_X509V3_EXTENSION: sct_source_t = 2;
pub const sct_source_t_SCT_SOURCE_OCSP_STAPLED_RESPONSE: sct_source_t = 3;
pub type sct_source_t = ::aya_ebpf::cty::c_uint;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_NOT_SET: sct_validation_status_t = 0;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_UNKNOWN_LOG: sct_validation_status_t = 1;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_VALID: sct_validation_status_t = 2;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_INVALID: sct_validation_status_t = 3;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_UNVERIFIED: sct_validation_status_t = 4;
pub const sct_validation_status_t_SCT_VALIDATION_STATUS_UNKNOWN_VERSION: sct_validation_status_t = 5;
pub type sct_validation_status_t = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_new_ex(
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut CT_POLICY_EVAL_CTX;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_new() -> *mut CT_POLICY_EVAL_CTX;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_free(ctx: *mut CT_POLICY_EVAL_CTX);
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get0_cert(ctx: *const CT_POLICY_EVAL_CTX) -> *mut X509;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set1_cert(ctx: *mut CT_POLICY_EVAL_CTX, cert: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get0_issuer(ctx: *const CT_POLICY_EVAL_CTX) -> *mut X509;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set1_issuer(ctx: *mut CT_POLICY_EVAL_CTX, issuer: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get0_log_store(ctx: *const CT_POLICY_EVAL_CTX) -> *const CTLOG_STORE;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(ctx: *mut CT_POLICY_EVAL_CTX, log_store: *mut CTLOG_STORE);
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_get_time(ctx: *const CT_POLICY_EVAL_CTX) -> u64;
}
extern "C" {
    pub fn CT_POLICY_EVAL_CTX_set_time(ctx: *mut CT_POLICY_EVAL_CTX, time_in_ms: u64);
}
extern "C" {
    pub fn SCT_new() -> *mut SCT;
}
extern "C" {
    pub fn SCT_new_from_base64(
        version: ::aya_ebpf::cty::c_uchar,
        logid_base64: *const ::aya_ebpf::cty::c_char,
        entry_type: ct_log_entry_type_t,
        timestamp: u64,
        extensions_base64: *const ::aya_ebpf::cty::c_char,
        signature_base64: *const ::aya_ebpf::cty::c_char,
    ) -> *mut SCT;
}
extern "C" {
    pub fn SCT_free(sct: *mut SCT);
}
extern "C" {
    pub fn SCT_LIST_free(a: *mut stack_st_SCT);
}
extern "C" {
    pub fn SCT_get_version(sct: *const SCT) -> sct_version_t;
}
extern "C" {
    pub fn SCT_set_version(sct: *mut SCT, version: sct_version_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_get_log_entry_type(sct: *const SCT) -> ct_log_entry_type_t;
}
extern "C" {
    pub fn SCT_set_log_entry_type(sct: *mut SCT, entry_type: ct_log_entry_type_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_get0_log_id(sct: *const SCT, log_id: *mut *mut ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SCT_set0_log_id(
        sct: *mut SCT,
        log_id: *mut ::aya_ebpf::cty::c_uchar,
        log_id_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_set1_log_id(
        sct: *mut SCT,
        log_id: *const ::aya_ebpf::cty::c_uchar,
        log_id_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_get_timestamp(sct: *const SCT) -> u64;
}
extern "C" {
    pub fn SCT_set_timestamp(sct: *mut SCT, timestamp: u64);
}
extern "C" {
    pub fn SCT_get_signature_nid(sct: *const SCT) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_set_signature_nid(sct: *mut SCT, nid: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_get0_extensions(sct: *const SCT, ext: *mut *mut ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SCT_set0_extensions(sct: *mut SCT, ext: *mut ::aya_ebpf::cty::c_uchar, ext_len: usize);
}
extern "C" {
    pub fn SCT_set1_extensions(
        sct: *mut SCT,
        ext: *const ::aya_ebpf::cty::c_uchar,
        ext_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_get0_signature(sct: *const SCT, sig: *mut *mut ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SCT_set0_signature(sct: *mut SCT, sig: *mut ::aya_ebpf::cty::c_uchar, sig_len: usize);
}
extern "C" {
    pub fn SCT_set1_signature(
        sct: *mut SCT,
        sig: *const ::aya_ebpf::cty::c_uchar,
        sig_len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_get_source(sct: *const SCT) -> sct_source_t;
}
extern "C" {
    pub fn SCT_set_source(sct: *mut SCT, source: sct_source_t) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_validation_status_string(sct: *const SCT) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SCT_print(sct: *const SCT, out: *mut BIO, indent: ::aya_ebpf::cty::c_int, logs: *const CTLOG_STORE);
}
extern "C" {
    pub fn SCT_LIST_print(
        sct_list: *const stack_st_SCT,
        out: *mut BIO,
        indent: ::aya_ebpf::cty::c_int,
        separator: *const ::aya_ebpf::cty::c_char,
        logs: *const CTLOG_STORE,
    );
}
extern "C" {
    pub fn SCT_get_validation_status(sct: *const SCT) -> sct_validation_status_t;
}
extern "C" {
    pub fn SCT_validate(sct: *mut SCT, ctx: *const CT_POLICY_EVAL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SCT_LIST_validate(scts: *const stack_st_SCT, ctx: *mut CT_POLICY_EVAL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2o_SCT_LIST(a: *const stack_st_SCT, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn o2i_SCT_LIST(
        a: *mut *mut stack_st_SCT,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> *mut stack_st_SCT;
}
extern "C" {
    pub fn i2d_SCT_LIST(a: *const stack_st_SCT, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_SCT_LIST(
        a: *mut *mut stack_st_SCT,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut stack_st_SCT;
}
extern "C" {
    pub fn i2o_SCT(sct: *const SCT, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn o2i_SCT(psct: *mut *mut SCT, in_: *mut *const ::aya_ebpf::cty::c_uchar, len: usize) -> *mut SCT;
}
extern "C" {
    pub fn CTLOG_new_ex(
        public_key: *mut EVP_PKEY,
        name: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut CTLOG;
}
extern "C" {
    pub fn CTLOG_new(public_key: *mut EVP_PKEY, name: *const ::aya_ebpf::cty::c_char) -> *mut CTLOG;
}
extern "C" {
    pub fn CTLOG_new_from_base64_ex(
        ct_log: *mut *mut CTLOG,
        pkey_base64: *const ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CTLOG_new_from_base64(
        ct_log: *mut *mut CTLOG,
        pkey_base64: *const ::aya_ebpf::cty::c_char,
        name: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CTLOG_free(log: *mut CTLOG);
}
extern "C" {
    pub fn CTLOG_get0_name(log: *const CTLOG) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn CTLOG_get0_log_id(log: *const CTLOG, log_id: *mut *const u8, log_id_len: *mut usize);
}
extern "C" {
    pub fn CTLOG_get0_public_key(log: *const CTLOG) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn CTLOG_STORE_new_ex(libctx: *mut OSSL_LIB_CTX, propq: *const ::aya_ebpf::cty::c_char) -> *mut CTLOG_STORE;
}
extern "C" {
    pub fn CTLOG_STORE_new() -> *mut CTLOG_STORE;
}
extern "C" {
    pub fn CTLOG_STORE_free(store: *mut CTLOG_STORE);
}
extern "C" {
    pub fn CTLOG_STORE_get0_log_by_id(store: *const CTLOG_STORE, log_id: *const u8, log_id_len: usize) -> *const CTLOG;
}
extern "C" {
    pub fn CTLOG_STORE_load_file(store: *mut CTLOG_STORE, file: *const ::aya_ebpf::cty::c_char)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CTLOG_STORE_load_default_file(store: *mut CTLOG_STORE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_SSL_strings() -> ::aya_ebpf::cty::c_int;
}
pub type ssl_crock_st = *mut ssl_st;
pub type TLS_SESSION_TICKET_EXT = tls_session_ticket_ext_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_method_st {
    _unused: [u8; 0],
}
pub type SSL_METHOD = ssl_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_cipher_st {
    _unused: [u8; 0],
}
pub type SSL_CIPHER = ssl_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_session_st {
    _unused: [u8; 0],
}
pub type SSL_SESSION = ssl_session_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_sigalgs_st {
    _unused: [u8; 0],
}
pub type TLS_SIGALGS = tls_sigalgs_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_conf_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CONF_CTX = ssl_conf_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_comp_st {
    _unused: [u8; 0],
}
pub type SSL_COMP = ssl_comp_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_CIPHER {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_COMP {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_protection_profile_st {
    pub name: *const ::aya_ebpf::cty::c_char,
    pub id: ::aya_ebpf::cty::c_ulong,
}
pub type SRTP_PROTECTION_PROFILE = srtp_protection_profile_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SRTP_PROTECTION_PROFILE {
    _unused: [u8; 0],
}
pub type sk_SRTP_PROTECTION_PROFILE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const SRTP_PROTECTION_PROFILE,
        b: *const *const SRTP_PROTECTION_PROFILE,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_SRTP_PROTECTION_PROFILE_freefunc =
    ::core::option::Option<unsafe extern "C" fn(a: *mut SRTP_PROTECTION_PROFILE)>;
pub type sk_SRTP_PROTECTION_PROFILE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const SRTP_PROTECTION_PROFILE) -> *mut SRTP_PROTECTION_PROFILE>;
pub type tls_session_ticket_ext_cb_fn = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        data: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type tls_session_secret_cb_fn = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        secret: *mut ::aya_ebpf::cty::c_void,
        secret_len: *mut ::aya_ebpf::cty::c_int,
        peer_ciphers: *mut stack_st_SSL_CIPHER,
        cipher: *mut *const SSL_CIPHER,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type custom_ext_add_cb = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::aya_ebpf::cty::c_uint,
        out: *mut *const ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        al: *mut ::aya_ebpf::cty::c_int,
        add_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type custom_ext_free_cb = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::aya_ebpf::cty::c_uint,
        out: *const ::aya_ebpf::cty::c_uchar,
        add_arg: *mut ::aya_ebpf::cty::c_void,
    ),
>;
pub type custom_ext_parse_cb = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::aya_ebpf::cty::c_uint,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
        al: *mut ::aya_ebpf::cty::c_int,
        parse_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type SSL_custom_ext_add_cb_ex = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::aya_ebpf::cty::c_uint,
        context: ::aya_ebpf::cty::c_uint,
        out: *mut *const ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
        x: *mut X509,
        chainidx: usize,
        al: *mut ::aya_ebpf::cty::c_int,
        add_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type SSL_custom_ext_free_cb_ex = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::aya_ebpf::cty::c_uint,
        context: ::aya_ebpf::cty::c_uint,
        out: *const ::aya_ebpf::cty::c_uchar,
        add_arg: *mut ::aya_ebpf::cty::c_void,
    ),
>;
pub type SSL_custom_ext_parse_cb_ex = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ext_type: ::aya_ebpf::cty::c_uint,
        context: ::aya_ebpf::cty::c_uint,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: usize,
        x: *mut X509,
        chainidx: usize,
        al: *mut ::aya_ebpf::cty::c_int,
        parse_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type SSL_verify_cb = ::core::option::Option<
    unsafe extern "C" fn(preverify_ok: ::aya_ebpf::cty::c_int, x509_ctx: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int,
>;
pub type SSL_async_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(s: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
extern "C" {
    pub fn SSL_CTX_get_options(ctx: *const SSL_CTX) -> u64;
}
extern "C" {
    pub fn SSL_get_options(s: *const SSL) -> u64;
}
extern "C" {
    pub fn SSL_CTX_clear_options(ctx: *mut SSL_CTX, op: u64) -> u64;
}
extern "C" {
    pub fn SSL_clear_options(s: *mut SSL, op: u64) -> u64;
}
extern "C" {
    pub fn SSL_CTX_set_options(ctx: *mut SSL_CTX, op: u64) -> u64;
}
extern "C" {
    pub fn SSL_set_options(s: *mut SSL, op: u64) -> u64;
}
extern "C" {
    pub fn SSL_CTX_set_msg_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                write_p: ::aya_ebpf::cty::c_int,
                version: ::aya_ebpf::cty::c_int,
                content_type: ::aya_ebpf::cty::c_int,
                buf: *const ::aya_ebpf::cty::c_void,
                len: usize,
                ssl: *mut SSL,
                arg: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_set_msg_callback(
        ssl: *mut SSL,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                write_p: ::aya_ebpf::cty::c_int,
                version: ::aya_ebpf::cty::c_int,
                content_type: ::aya_ebpf::cty::c_int,
                buf: *const ::aya_ebpf::cty::c_void,
                len: usize,
                ssl: *mut SSL,
                arg: *mut ::aya_ebpf::cty::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_SRP_CTX_init(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_SRP_CTX_init(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SRP_CTX_free(ctx: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_SRP_CTX_free(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_srp_server_param_with_username(s: *mut SSL, ad: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SRP_Calc_A_param(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
pub type GEN_SESSION_CB = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        id: *mut ::aya_ebpf::cty::c_uchar,
        id_len: *mut ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st_SSL_SESSION {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SSL_CTX_sessions(ctx: *mut SSL_CTX) -> *mut lhash_st_SSL_SESSION;
}
extern "C" {
    pub fn SSL_CTX_sess_set_new_cb(
        ctx: *mut SSL_CTX,
        new_session_cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *mut ssl_st, sess: *mut SSL_SESSION) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_new_cb(
        ctx: *mut SSL_CTX,
    ) -> ::core::option::Option<unsafe extern "C" fn(ctx: *mut ssl_st, arg1: *mut SSL_SESSION) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn SSL_CTX_sess_set_remove_cb(
        ctx: *mut SSL_CTX,
        remove_session_cb: ::core::option::Option<unsafe extern "C" fn(ctx: *mut ssl_ctx_st, sess: *mut SSL_SESSION)>,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_remove_cb(
        ctx: *mut SSL_CTX,
    ) -> ::core::option::Option<unsafe extern "C" fn(ctx: *mut ssl_ctx_st, arg1: *mut SSL_SESSION)>;
}
extern "C" {
    pub fn SSL_CTX_sess_set_get_cb(
        ctx: *mut SSL_CTX,
        get_session_cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut ssl_st,
                data: *const ::aya_ebpf::cty::c_uchar,
                len: ::aya_ebpf::cty::c_int,
                copy: *mut ::aya_ebpf::cty::c_int,
            ) -> *mut SSL_SESSION,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_get_cb(
        ctx: *mut SSL_CTX,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ssl_st,
            arg1: *const ::aya_ebpf::cty::c_uchar,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: *mut ::aya_ebpf::cty::c_int,
        ) -> *mut SSL_SESSION,
    >;
}
extern "C" {
    pub fn SSL_CTX_set_info_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *const SSL, type_: ::aya_ebpf::cty::c_int, val: ::aya_ebpf::cty::c_int),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_info_callback(
        ctx: *mut SSL_CTX,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(ctx: *const SSL, arg1: ::aya_ebpf::cty::c_int, arg2: ::aya_ebpf::cty::c_int),
    >;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_cb(
        ctx: *mut SSL_CTX,
        client_cert_cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                x509: *mut *mut X509,
                pkey: *mut *mut EVP_PKEY,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_client_cert_cb(
        ctx: *mut SSL_CTX,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut SSL, arg1: *mut *mut X509, arg2: *mut *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_engine(ctx: *mut SSL_CTX, e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cookie_generate_cb(
        ctx: *mut SSL_CTX,
        app_gen_cookie_cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *mut ::aya_ebpf::cty::c_uchar,
                cookie_len: *mut ::aya_ebpf::cty::c_uint,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_cookie_verify_cb(
        ctx: *mut SSL_CTX,
        app_verify_cookie_cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *const ::aya_ebpf::cty::c_uchar,
                cookie_len: ::aya_ebpf::cty::c_uint,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_stateless_cookie_generate_cb(
        ctx: *mut SSL_CTX,
        gen_stateless_cookie_cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *mut ::aya_ebpf::cty::c_uchar,
                cookie_len: *mut usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_stateless_cookie_verify_cb(
        ctx: *mut SSL_CTX,
        verify_stateless_cookie_cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                cookie: *const ::aya_ebpf::cty::c_uchar,
                cookie_len: usize,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
pub type SSL_CTX_npn_advertised_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        out: *mut *const ::aya_ebpf::cty::c_uchar,
        outlen: *mut ::aya_ebpf::cty::c_uint,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_next_protos_advertised_cb(
        s: *mut SSL_CTX,
        cb: SSL_CTX_npn_advertised_cb_func,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
pub type SSL_CTX_npn_select_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut ::aya_ebpf::cty::c_uchar,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: ::aya_ebpf::cty::c_uint,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_next_proto_select_cb(
        s: *mut SSL_CTX,
        cb: SSL_CTX_npn_select_cb_func,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_next_proto_negotiated(
        s: *const SSL,
        data: *mut *const ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    );
}
extern "C" {
    pub fn SSL_select_next_proto(
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
        outlen: *mut ::aya_ebpf::cty::c_uchar,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: ::aya_ebpf::cty::c_uint,
        client: *const ::aya_ebpf::cty::c_uchar,
        client_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_alpn_protos(
        ctx: *mut SSL_CTX,
        protos: *const ::aya_ebpf::cty::c_uchar,
        protos_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_alpn_protos(
        ssl: *mut SSL,
        protos: *const ::aya_ebpf::cty::c_uchar,
        protos_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type SSL_CTX_alpn_select_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        out: *mut *const ::aya_ebpf::cty::c_uchar,
        outlen: *mut ::aya_ebpf::cty::c_uchar,
        in_: *const ::aya_ebpf::cty::c_uchar,
        inlen: ::aya_ebpf::cty::c_uint,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_alpn_select_cb(
        ctx: *mut SSL_CTX,
        cb: SSL_CTX_alpn_select_cb_func,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_alpn_selected(
        ssl: *const SSL,
        data: *mut *const ::aya_ebpf::cty::c_uchar,
        len: *mut ::aya_ebpf::cty::c_uint,
    );
}
pub type SSL_psk_client_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        hint: *const ::aya_ebpf::cty::c_char,
        identity: *mut ::aya_ebpf::cty::c_char,
        max_identity_len: ::aya_ebpf::cty::c_uint,
        psk: *mut ::aya_ebpf::cty::c_uchar,
        max_psk_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_uint,
>;
extern "C" {
    pub fn SSL_CTX_set_psk_client_callback(ctx: *mut SSL_CTX, cb: SSL_psk_client_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_client_callback(ssl: *mut SSL, cb: SSL_psk_client_cb_func);
}
pub type SSL_psk_server_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        identity: *const ::aya_ebpf::cty::c_char,
        psk: *mut ::aya_ebpf::cty::c_uchar,
        max_psk_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_uint,
>;
extern "C" {
    pub fn SSL_CTX_set_psk_server_callback(ctx: *mut SSL_CTX, cb: SSL_psk_server_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_server_callback(ssl: *mut SSL, cb: SSL_psk_server_cb_func);
}
extern "C" {
    pub fn SSL_CTX_use_psk_identity_hint(
        ctx: *mut SSL_CTX,
        identity_hint: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_psk_identity_hint(
        s: *mut SSL,
        identity_hint: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_psk_identity_hint(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_get_psk_identity(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
pub type SSL_psk_find_session_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        identity: *const ::aya_ebpf::cty::c_uchar,
        identity_len: usize,
        sess: *mut *mut SSL_SESSION,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type SSL_psk_use_session_cb_func = ::core::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        md: *const EVP_MD,
        id: *mut *const ::aya_ebpf::cty::c_uchar,
        idlen: *mut usize,
        sess: *mut *mut SSL_SESSION,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn SSL_set_psk_find_session_callback(s: *mut SSL, cb: SSL_psk_find_session_cb_func);
}
extern "C" {
    pub fn SSL_CTX_set_psk_find_session_callback(ctx: *mut SSL_CTX, cb: SSL_psk_find_session_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_use_session_callback(s: *mut SSL, cb: SSL_psk_use_session_cb_func);
}
extern "C" {
    pub fn SSL_CTX_set_psk_use_session_callback(ctx: *mut SSL_CTX, cb: SSL_psk_use_session_cb_func);
}
extern "C" {
    pub fn SSL_CTX_has_client_custom_ext(
        ctx: *const SSL_CTX,
        ext_type: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::aya_ebpf::cty::c_uint,
        add_cb: custom_ext_add_cb,
        free_cb: custom_ext_free_cb,
        add_arg: *mut ::aya_ebpf::cty::c_void,
        parse_cb: custom_ext_parse_cb,
        parse_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_server_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::aya_ebpf::cty::c_uint,
        add_cb: custom_ext_add_cb,
        free_cb: custom_ext_free_cb,
        add_arg: *mut ::aya_ebpf::cty::c_void,
        parse_cb: custom_ext_parse_cb,
        parse_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_custom_ext(
        ctx: *mut SSL_CTX,
        ext_type: ::aya_ebpf::cty::c_uint,
        context: ::aya_ebpf::cty::c_uint,
        add_cb: SSL_custom_ext_add_cb_ex,
        free_cb: SSL_custom_ext_free_cb_ex,
        add_arg: *mut ::aya_ebpf::cty::c_void,
        parse_cb: SSL_custom_ext_parse_cb_ex,
        parse_arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_extension_supported(ext_type: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
pub type SSL_CTX_keylog_cb_func =
    ::core::option::Option<unsafe extern "C" fn(ssl: *const SSL, line: *const ::aya_ebpf::cty::c_char)>;
extern "C" {
    pub fn SSL_CTX_set_keylog_callback(ctx: *mut SSL_CTX, cb: SSL_CTX_keylog_cb_func);
}
extern "C" {
    pub fn SSL_CTX_get_keylog_callback(ctx: *const SSL_CTX) -> SSL_CTX_keylog_cb_func;
}
extern "C" {
    pub fn SSL_CTX_set_max_early_data(ctx: *mut SSL_CTX, max_early_data: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_max_early_data(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_set_max_early_data(s: *mut SSL, max_early_data: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_max_early_data(s: *const SSL) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_recv_max_early_data(ctx: *mut SSL_CTX, recv_max_early_data: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_recv_max_early_data(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_set_recv_max_early_data(s: *mut SSL, recv_max_early_data: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_recv_max_early_data(s: *const SSL) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_max_fragment_length(ctx: *mut SSL_CTX, mode: u8) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_max_fragment_length(ssl: *mut SSL, mode: u8) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_servername(s: *const SSL, type_: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_get_servername_type(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_export_keying_material(
        s: *mut SSL,
        out: *mut ::aya_ebpf::cty::c_uchar,
        olen: usize,
        label: *const ::aya_ebpf::cty::c_char,
        llen: usize,
        context: *const ::aya_ebpf::cty::c_uchar,
        contextlen: usize,
        use_context: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_export_keying_material_early(
        s: *mut SSL,
        out: *mut ::aya_ebpf::cty::c_uchar,
        olen: usize,
        label: *const ::aya_ebpf::cty::c_char,
        llen: usize,
        context: *const ::aya_ebpf::cty::c_uchar,
        contextlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_peer_signature_type_nid(s: *const SSL, pnid: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_signature_type_nid(s: *const SSL, pnid: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_sigalgs(
        s: *mut SSL,
        idx: ::aya_ebpf::cty::c_int,
        psign: *mut ::aya_ebpf::cty::c_int,
        phash: *mut ::aya_ebpf::cty::c_int,
        psignandhash: *mut ::aya_ebpf::cty::c_int,
        rsig: *mut ::aya_ebpf::cty::c_uchar,
        rhash: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_shared_sigalgs(
        s: *mut SSL,
        idx: ::aya_ebpf::cty::c_int,
        psign: *mut ::aya_ebpf::cty::c_int,
        phash: *mut ::aya_ebpf::cty::c_int,
        psignandhash: *mut ::aya_ebpf::cty::c_int,
        rsig: *mut ::aya_ebpf::cty::c_uchar,
        rhash: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_check_chain(
        s: *mut SSL,
        x: *mut X509,
        pk: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_ticket_key_evp_cb(
        ctx: *mut SSL_CTX,
        fp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::aya_ebpf::cty::c_uchar,
                arg3: *mut ::aya_ebpf::cty::c_uchar,
                arg4: *mut EVP_CIPHER_CTX,
                arg5: *mut EVP_MAC_CTX,
                arg6: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tls_session_ticket_ext_st {
    pub length: ::aya_ebpf::cty::c_ushort,
    pub data: *mut ::aya_ebpf::cty::c_void,
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_use_srtp(
        ctx: *mut SSL_CTX,
        profiles: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_use_srtp(ssl: *mut SSL, profiles: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_srtp_profiles(ssl: *mut SSL) -> *mut stack_st_SRTP_PROTECTION_PROFILE;
}
extern "C" {
    pub fn SSL_get_selected_srtp_profile(s: *mut SSL) -> *mut SRTP_PROTECTION_PROFILE;
}
pub type sk_SSL_CIPHER_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const SSL_CIPHER, b: *const *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_SSL_CIPHER_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut SSL_CIPHER)>;
pub type sk_SSL_CIPHER_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const SSL_CIPHER) -> *mut SSL_CIPHER>;
pub type sk_SSL_COMP_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const SSL_COMP, b: *const *const SSL_COMP) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_SSL_COMP_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut SSL_COMP)>;
pub type sk_SSL_COMP_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const SSL_COMP) -> *mut SSL_COMP>;
extern "C" {
    pub fn SSL_set_debug(s: *mut SSL, debug: ::aya_ebpf::cty::c_int);
}
pub const OSSL_HANDSHAKE_STATE_TLS_ST_BEFORE: OSSL_HANDSHAKE_STATE = 0;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_OK: OSSL_HANDSHAKE_STATE = 1;
pub const OSSL_HANDSHAKE_STATE_DTLS_ST_CR_HELLO_VERIFY_REQUEST: OSSL_HANDSHAKE_STATE = 2;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_SRVR_HELLO: OSSL_HANDSHAKE_STATE = 3;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT: OSSL_HANDSHAKE_STATE = 4;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT_STATUS: OSSL_HANDSHAKE_STATE = 5;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_KEY_EXCH: OSSL_HANDSHAKE_STATE = 6;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT_REQ: OSSL_HANDSHAKE_STATE = 7;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_SRVR_DONE: OSSL_HANDSHAKE_STATE = 8;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_SESSION_TICKET: OSSL_HANDSHAKE_STATE = 9;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CHANGE: OSSL_HANDSHAKE_STATE = 10;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_FINISHED: OSSL_HANDSHAKE_STATE = 11;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CLNT_HELLO: OSSL_HANDSHAKE_STATE = 12;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CERT: OSSL_HANDSHAKE_STATE = 13;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_KEY_EXCH: OSSL_HANDSHAKE_STATE = 14;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CERT_VRFY: OSSL_HANDSHAKE_STATE = 15;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_CHANGE: OSSL_HANDSHAKE_STATE = 16;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_NEXT_PROTO: OSSL_HANDSHAKE_STATE = 17;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_FINISHED: OSSL_HANDSHAKE_STATE = 18;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_HELLO_REQ: OSSL_HANDSHAKE_STATE = 19;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CLNT_HELLO: OSSL_HANDSHAKE_STATE = 20;
pub const OSSL_HANDSHAKE_STATE_DTLS_ST_SW_HELLO_VERIFY_REQUEST: OSSL_HANDSHAKE_STATE = 21;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_SRVR_HELLO: OSSL_HANDSHAKE_STATE = 22;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT: OSSL_HANDSHAKE_STATE = 23;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_KEY_EXCH: OSSL_HANDSHAKE_STATE = 24;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT_REQ: OSSL_HANDSHAKE_STATE = 25;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_SRVR_DONE: OSSL_HANDSHAKE_STATE = 26;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CERT: OSSL_HANDSHAKE_STATE = 27;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_KEY_EXCH: OSSL_HANDSHAKE_STATE = 28;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CERT_VRFY: OSSL_HANDSHAKE_STATE = 29;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_NEXT_PROTO: OSSL_HANDSHAKE_STATE = 30;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_CHANGE: OSSL_HANDSHAKE_STATE = 31;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_FINISHED: OSSL_HANDSHAKE_STATE = 32;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_SESSION_TICKET: OSSL_HANDSHAKE_STATE = 33;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT_STATUS: OSSL_HANDSHAKE_STATE = 34;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CHANGE: OSSL_HANDSHAKE_STATE = 35;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_FINISHED: OSSL_HANDSHAKE_STATE = 36;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_ENCRYPTED_EXTENSIONS: OSSL_HANDSHAKE_STATE = 37;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_ENCRYPTED_EXTENSIONS: OSSL_HANDSHAKE_STATE = 38;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_CERT_VRFY: OSSL_HANDSHAKE_STATE = 39;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_CERT_VRFY: OSSL_HANDSHAKE_STATE = 40;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_HELLO_REQ: OSSL_HANDSHAKE_STATE = 41;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SW_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 42;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 43;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 44;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CR_KEY_UPDATE: OSSL_HANDSHAKE_STATE = 45;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_EARLY_DATA: OSSL_HANDSHAKE_STATE = 46;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_PENDING_EARLY_DATA_END: OSSL_HANDSHAKE_STATE = 47;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_CW_END_OF_EARLY_DATA: OSSL_HANDSHAKE_STATE = 48;
pub const OSSL_HANDSHAKE_STATE_TLS_ST_SR_END_OF_EARLY_DATA: OSSL_HANDSHAKE_STATE = 49;
pub type OSSL_HANDSHAKE_STATE = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn SSL_in_init(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_in_before(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_is_init_finished(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_finished(s: *const SSL, buf: *mut ::aya_ebpf::cty::c_void, count: usize) -> usize;
}
extern "C" {
    pub fn SSL_get_peer_finished(s: *const SSL, buf: *mut ::aya_ebpf::cty::c_void, count: usize) -> usize;
}
extern "C" {
    pub fn PEM_read_bio_SSL_SESSION(
        out: *mut BIO,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_read_SSL_SESSION(
        out: *mut FILE,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_write_bio_SSL_SESSION(out: *mut BIO, x: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PEM_write_SSL_SESSION(out: *mut FILE, x: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_group_to_name(s: *mut SSL, id: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_set0_tmp_dh_pkey(s: *mut SSL, dhpkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set0_tmp_dh_pkey(ctx: *mut SSL_CTX, dhpkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_f_ssl() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_ssl(ctx: *mut SSL_CTX, client: ::aya_ebpf::cty::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_ssl_connect(ctx: *mut SSL_CTX) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_buffer_ssl_connect(ctx: *mut SSL_CTX) -> *mut BIO;
}
extern "C" {
    pub fn BIO_ssl_copy_session_id(to: *mut BIO, from: *mut BIO) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BIO_ssl_shutdown(ssl_bio: *mut BIO);
}
extern "C" {
    pub fn SSL_CTX_set_cipher_list(arg1: *mut SSL_CTX, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_new(meth: *const SSL_METHOD) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_CTX_new_ex(
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
        meth: *const SSL_METHOD,
    ) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_CTX_up_ref(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_free(arg1: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CTX_set_timeout(ctx: *mut SSL_CTX, t: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_timeout(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_cert_store(arg1: *const SSL_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn SSL_CTX_set_cert_store(arg1: *mut SSL_CTX, arg2: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_CTX_set1_cert_store(arg1: *mut SSL_CTX, arg2: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_want(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_clear(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_flush_sessions(ctx: *mut SSL_CTX, tm: ::aya_ebpf::cty::c_long);
}
extern "C" {
    pub fn SSL_get_current_cipher(s: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get_pending_cipher(s: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_get_bits(c: *const SSL_CIPHER, alg_bits: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_version(c: *const SSL_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_name(c: *const SSL_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_standard_name(c: *const SSL_CIPHER) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OPENSSL_cipher_name(rfc_name: *const ::aya_ebpf::cty::c_char) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_id(c: *const SSL_CIPHER) -> u32;
}
extern "C" {
    pub fn SSL_CIPHER_get_protocol_id(c: *const SSL_CIPHER) -> u16;
}
extern "C" {
    pub fn SSL_CIPHER_get_kx_nid(c: *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_auth_nid(c: *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_handshake_digest(c: *const SSL_CIPHER) -> *const EVP_MD;
}
extern "C" {
    pub fn SSL_CIPHER_is_aead(c: *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_fd(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_rfd(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_wfd(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_cipher_list(s: *const SSL, n: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_get_shared_ciphers(
        s: *const SSL,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_get_read_ahead(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_pending(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_has_pending(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_fd(s: *mut SSL, fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_rfd(s: *mut SSL, fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_wfd(s: *mut SSL, fd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set0_rbio(s: *mut SSL, rbio: *mut BIO);
}
extern "C" {
    pub fn SSL_set0_wbio(s: *mut SSL, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_set_bio(s: *mut SSL, rbio: *mut BIO, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_get_rbio(s: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_get_wbio(s: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_set_cipher_list(s: *mut SSL, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ciphersuites(ctx: *mut SSL_CTX, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_ciphersuites(s: *mut SSL, str_: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_read_ahead(s: *mut SSL, yes: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_get_verify_mode(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_verify_depth(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_verify_callback(s: *const SSL) -> SSL_verify_cb;
}
extern "C" {
    pub fn SSL_set_verify(s: *mut SSL, mode: ::aya_ebpf::cty::c_int, callback: SSL_verify_cb);
}
extern "C" {
    pub fn SSL_set_verify_depth(s: *mut SSL, depth: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_set_cert_cb(
        s: *mut SSL,
        cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int,
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey(ssl: *mut SSL, rsa: *mut RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_ASN1(
        ssl: *mut SSL,
        d: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey(ssl: *mut SSL, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_ASN1(
        pk: ::aya_ebpf::cty::c_int,
        ssl: *mut SSL,
        d: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_certificate(ssl: *mut SSL, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_ASN1(
        ssl: *mut SSL,
        d: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_cert_and_key(
        ssl: *mut SSL,
        x509: *mut X509,
        privatekey: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
        override_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo(
        ctx: *mut SSL_CTX,
        serverinfo: *const ::aya_ebpf::cty::c_uchar,
        serverinfo_length: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo_ex(
        ctx: *mut SSL_CTX,
        version: ::aya_ebpf::cty::c_uint,
        serverinfo: *const ::aya_ebpf::cty::c_uchar,
        serverinfo_length: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_serverinfo_file(ctx: *mut SSL_CTX, file: *const ::aya_ebpf::cty::c_char)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_file(
        ssl: *mut SSL,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_file(
        ssl: *mut SSL,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_file(
        ssl: *mut SSL,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_file(
        ctx: *mut SSL_CTX,
        file: *const ::aya_ebpf::cty::c_char,
        type_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_chain_file(
        ctx: *mut SSL_CTX,
        file: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_chain_file(ssl: *mut SSL, file: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_load_client_CA_file(file: *const ::aya_ebpf::cty::c_char) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_load_client_CA_file_ex(
        file: *const ::aya_ebpf::cty::c_char,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_file_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        file: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_add_dir_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        dir: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_add_store_cert_subjects_to_stack(
        stackCAs: *mut stack_st_X509_NAME,
        uri: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_state_string(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_rstate_string(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_state_string_long(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_rstate_string_long(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_SESSION_get_time(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_SESSION_set_time(s: *mut SSL_SESSION, t: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_SESSION_get_timeout(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_SESSION_set_timeout(s: *mut SSL_SESSION, t: ::aya_ebpf::cty::c_long) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_SESSION_get_protocol_version(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set_protocol_version(
        s: *mut SSL_SESSION,
        version: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_hostname(s: *const SSL_SESSION) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_SESSION_set1_hostname(
        s: *mut SSL_SESSION,
        hostname: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_alpn_selected(
        s: *const SSL_SESSION,
        alpn: *mut *const ::aya_ebpf::cty::c_uchar,
        len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_SESSION_set1_alpn_selected(
        s: *mut SSL_SESSION,
        alpn: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_cipher(s: *const SSL_SESSION) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_SESSION_set_cipher(s: *mut SSL_SESSION, cipher: *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_has_ticket(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ticket_lifetime_hint(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn SSL_SESSION_get0_ticket(s: *const SSL_SESSION, tick: *mut *const ::aya_ebpf::cty::c_uchar, len: *mut usize);
}
extern "C" {
    pub fn SSL_SESSION_get_max_early_data(s: *const SSL_SESSION) -> u32;
}
extern "C" {
    pub fn SSL_SESSION_set_max_early_data(s: *mut SSL_SESSION, max_early_data: u32) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_copy_session_id(to: *mut SSL, from: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_peer(s: *mut SSL_SESSION) -> *mut X509;
}
extern "C" {
    pub fn SSL_SESSION_set1_id_context(
        s: *mut SSL_SESSION,
        sid_ctx: *const ::aya_ebpf::cty::c_uchar,
        sid_ctx_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set1_id(
        s: *mut SSL_SESSION,
        sid: *const ::aya_ebpf::cty::c_uchar,
        sid_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_is_resumable(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_new() -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_dup(src: *const SSL_SESSION) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_get_id(
        s: *const SSL_SESSION,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn SSL_SESSION_get0_id_context(
        s: *const SSL_SESSION,
        len: *mut ::aya_ebpf::cty::c_uint,
    ) -> *const ::aya_ebpf::cty::c_uchar;
}
extern "C" {
    pub fn SSL_SESSION_get_compress_id(s: *const SSL_SESSION) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn SSL_SESSION_print_fp(fp: *mut FILE, ses: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_print(fp: *mut BIO, ses: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_print_keylog(bp: *mut BIO, x: *const SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_up_ref(ses: *mut SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_free(ses: *mut SSL_SESSION);
}
extern "C" {
    pub fn i2d_SSL_SESSION(in_: *const SSL_SESSION, pp: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_session(to: *mut SSL, session: *mut SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_session(ctx: *mut SSL_CTX, session: *mut SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_remove_session(ctx: *mut SSL_CTX, session: *mut SSL_SESSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_generate_session_id(ctx: *mut SSL_CTX, cb: GEN_SESSION_CB) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_generate_session_id(s: *mut SSL, cb: GEN_SESSION_CB) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_has_matching_session_id(
        s: *const SSL,
        id: *const ::aya_ebpf::cty::c_uchar,
        id_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn d2i_SSL_SESSION(
        a: *mut *mut SSL_SESSION,
        pp: *mut *const ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_long,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get0_peer_certificate(s: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get1_peer_certificate(s: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_peer_cert_chain(s: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_CTX_get_verify_mode(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_depth(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_callback(ctx: *const SSL_CTX) -> SSL_verify_cb;
}
extern "C" {
    pub fn SSL_CTX_set_verify(ctx: *mut SSL_CTX, mode: ::aya_ebpf::cty::c_int, callback: SSL_verify_cb);
}
extern "C" {
    pub fn SSL_CTX_set_verify_depth(ctx: *mut SSL_CTX, depth: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_CTX_set_cert_verify_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut X509_STORE_CTX, arg2: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int,
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_set_cert_cb(
        c: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int,
        >,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey(ctx: *mut SSL_CTX, rsa: *mut RSA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_ASN1(
        ctx: *mut SSL_CTX,
        d: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey(ctx: *mut SSL_CTX, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_ASN1(
        pk: ::aya_ebpf::cty::c_int,
        ctx: *mut SSL_CTX,
        d: *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate(ctx: *mut SSL_CTX, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_ASN1(
        ctx: *mut SSL_CTX,
        len: ::aya_ebpf::cty::c_int,
        d: *const ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_cert_and_key(
        ctx: *mut SSL_CTX,
        x509: *mut X509,
        privatekey: *mut EVP_PKEY,
        chain: *mut stack_st_X509,
        override_: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb(ctx: *mut SSL_CTX, cb: pem_password_cb);
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb_userdata(ctx: *mut SSL_CTX, u: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_CTX_get_default_passwd_cb(ctx: *mut SSL_CTX) -> pem_password_cb;
}
extern "C" {
    pub fn SSL_CTX_get_default_passwd_cb_userdata(ctx: *mut SSL_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_set_default_passwd_cb(s: *mut SSL, cb: pem_password_cb);
}
extern "C" {
    pub fn SSL_set_default_passwd_cb_userdata(s: *mut SSL, u: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_get_default_passwd_cb(s: *mut SSL) -> pem_password_cb;
}
extern "C" {
    pub fn SSL_get_default_passwd_cb_userdata(s: *mut SSL) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_CTX_check_private_key(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_check_private_key(ctx: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_session_id_context(
        ctx: *mut SSL_CTX,
        sid_ctx: *const ::aya_ebpf::cty::c_uchar,
        sid_ctx_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_new(ctx: *mut SSL_CTX) -> *mut SSL;
}
extern "C" {
    pub fn SSL_up_ref(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_is_dtls(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_session_id_context(
        ssl: *mut SSL,
        sid_ctx: *const ::aya_ebpf::cty::c_uchar,
        sid_ctx_len: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_purpose(ctx: *mut SSL_CTX, purpose: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_purpose(ssl: *mut SSL, purpose: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_trust(ctx: *mut SSL_CTX, trust: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_trust(ssl: *mut SSL, trust: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set1_host(s: *mut SSL, hostname: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_add1_host(s: *mut SSL, hostname: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get0_peername(s: *mut SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_set_hostflags(s: *mut SSL, flags: ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn SSL_CTX_dane_enable(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_dane_mtype_set(ctx: *mut SSL_CTX, md: *const EVP_MD, mtype: u8, ord: u8) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_dane_enable(s: *mut SSL, basedomain: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_dane_tlsa_add(
        s: *mut SSL,
        usage: u8,
        selector: u8,
        mtype: u8,
        data: *const ::aya_ebpf::cty::c_uchar,
        dlen: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get0_dane_authority(
        s: *mut SSL,
        mcert: *mut *mut X509,
        mspki: *mut *mut EVP_PKEY,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get0_dane_tlsa(
        s: *mut SSL,
        usage: *mut u8,
        selector: *mut u8,
        mtype: *mut u8,
        data: *mut *const ::aya_ebpf::cty::c_uchar,
        dlen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get0_dane(ssl: *mut SSL) -> *mut SSL_DANE;
}
extern "C" {
    pub fn SSL_CTX_dane_set_flags(ctx: *mut SSL_CTX, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_dane_clear_flags(ctx: *mut SSL_CTX, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn SSL_dane_set_flags(ssl: *mut SSL, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn SSL_dane_clear_flags(ssl: *mut SSL, flags: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_set1_param(ctx: *mut SSL_CTX, vpm: *mut X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set1_param(ssl: *mut SSL, vpm: *mut X509_VERIFY_PARAM) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get0_param(ctx: *mut SSL_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_get0_param(ssl: *mut SSL) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_CTX_set_srp_username(ctx: *mut SSL_CTX, name: *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_password(ctx: *mut SSL_CTX, password: *mut ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_strength(ctx: *mut SSL_CTX, strength: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_client_pwd_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut SSL, arg2: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_char,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_verify_param_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut SSL, arg2: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_username_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::aya_ebpf::cty::c_int,
                arg3: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_srp_cb_arg(ctx: *mut SSL_CTX, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_srp_server_param(
        s: *mut SSL,
        N: *const BIGNUM,
        g: *const BIGNUM,
        sa: *mut BIGNUM,
        v: *mut BIGNUM,
        info: *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_srp_server_param_pw(
        s: *mut SSL,
        user: *const ::aya_ebpf::cty::c_char,
        pass: *const ::aya_ebpf::cty::c_char,
        grp: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_srp_g(s: *mut SSL) -> *mut BIGNUM;
}
extern "C" {
    pub fn SSL_get_srp_N(s: *mut SSL) -> *mut BIGNUM;
}
extern "C" {
    pub fn SSL_get_srp_username(s: *mut SSL) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_get_srp_userinfo(s: *mut SSL) -> *mut ::aya_ebpf::cty::c_char;
}
pub type SSL_client_hello_cb_fn = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        al: *mut ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_client_hello_cb(c: *mut SSL_CTX, cb: SSL_client_hello_cb_fn, arg: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_client_hello_isv2(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_client_hello_get0_legacy_version(s: *mut SSL) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn SSL_client_hello_get0_random(s: *mut SSL, out: *mut *const ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SSL_client_hello_get0_session_id(s: *mut SSL, out: *mut *const ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SSL_client_hello_get0_ciphers(s: *mut SSL, out: *mut *const ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SSL_client_hello_get0_compression_methods(s: *mut SSL, out: *mut *const ::aya_ebpf::cty::c_uchar) -> usize;
}
extern "C" {
    pub fn SSL_client_hello_get1_extensions_present(
        s: *mut SSL,
        out: *mut *mut ::aya_ebpf::cty::c_int,
        outlen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_client_hello_get0_ext(
        s: *mut SSL,
        type_: ::aya_ebpf::cty::c_uint,
        out: *mut *const ::aya_ebpf::cty::c_uchar,
        outlen: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_certs_clear(s: *mut SSL);
}
extern "C" {
    pub fn SSL_free(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_waiting_for_async(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_all_async_fds(
        s: *mut SSL,
        fds: *mut ::aya_ebpf::cty::c_int,
        numfds: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_changed_async_fds(
        s: *mut SSL,
        addfd: *mut ::aya_ebpf::cty::c_int,
        numaddfds: *mut usize,
        delfd: *mut ::aya_ebpf::cty::c_int,
        numdelfds: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_async_callback(ctx: *mut SSL_CTX, callback: SSL_async_callback_fn) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_async_callback_arg(ctx: *mut SSL_CTX, arg: *mut ::aya_ebpf::cty::c_void)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_async_callback(s: *mut SSL, callback: SSL_async_callback_fn) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_async_callback_arg(s: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_async_status(s: *mut SSL, status: *mut ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_accept(ssl: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_stateless(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_connect(ssl: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_read(
        ssl: *mut SSL,
        buf: *mut ::aya_ebpf::cty::c_void,
        num: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_read_ex(
        ssl: *mut SSL,
        buf: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        readbytes: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_read_early_data(
        s: *mut SSL,
        buf: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        readbytes: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_peek(
        ssl: *mut SSL,
        buf: *mut ::aya_ebpf::cty::c_void,
        num: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_peek_ex(
        ssl: *mut SSL,
        buf: *mut ::aya_ebpf::cty::c_void,
        num: usize,
        readbytes: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_sendfile(
        s: *mut SSL,
        fd: ::aya_ebpf::cty::c_int,
        offset: off_t,
        size: usize,
        flags: ::aya_ebpf::cty::c_int,
    ) -> isize;
}
extern "C" {
    pub fn SSL_write(
        ssl: *mut SSL,
        buf: *const ::aya_ebpf::cty::c_void,
        num: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_write_ex(
        s: *mut SSL,
        buf: *const ::aya_ebpf::cty::c_void,
        num: usize,
        written: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_write_early_data(
        s: *mut SSL,
        buf: *const ::aya_ebpf::cty::c_void,
        num: usize,
        written: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_ctrl(
        ssl: *mut SSL,
        cmd: ::aya_ebpf::cty::c_int,
        larg: ::aya_ebpf::cty::c_long,
        parg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_callback_ctrl(
        arg1: *mut SSL,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_CTX_ctrl(
        ctx: *mut SSL_CTX,
        cmd: ::aya_ebpf::cty::c_int,
        larg: ::aya_ebpf::cty::c_long,
        parg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_CTX_callback_ctrl(
        arg1: *mut SSL_CTX,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_get_early_data_status(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_error(s: *const SSL, ret_code: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_version(s: *const SSL) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_CTX_set_ssl_version(ctx: *mut SSL_CTX, meth: *const SSL_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn TLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_get_data_mtu(s: *const SSL) -> usize;
}
extern "C" {
    pub fn SSL_get_ciphers(s: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CTX_get_ciphers(ctx: *const SSL_CTX) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get_client_ciphers(s: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get1_supported_ciphers(s: *mut SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_do_handshake(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_key_update(s: *mut SSL, updatetype: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_key_update_type(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_renegotiate(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_abbreviated(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_pending(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_new_session_ticket(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_shutdown(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_verify_client_post_handshake(s: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_post_handshake_auth(ctx: *mut SSL_CTX, val: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_set_post_handshake_auth(s: *mut SSL, val: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_ssl_method(ctx: *const SSL_CTX) -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_get_ssl_method(s: *const SSL) -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_set_ssl_method(s: *mut SSL, method: *const SSL_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_alert_type_string_long(value: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_alert_type_string(value: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string_long(value: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string(value: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_set0_CA_list(s: *mut SSL, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_CTX_set0_CA_list(ctx: *mut SSL_CTX, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_get0_CA_list(s: *const SSL) -> *const stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_CTX_get0_CA_list(ctx: *const SSL_CTX) -> *const stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add1_to_CA_list(ssl: *mut SSL, x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_add1_to_CA_list(ctx: *mut SSL_CTX, x: *const X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get0_peer_CA_list(s: *const SSL) -> *const stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_set_client_CA_list(s: *mut SSL, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_CTX_set_client_CA_list(ctx: *mut SSL_CTX, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_get_client_CA_list(s: *const SSL) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_CTX_get_client_CA_list(s: *const SSL_CTX) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_client_CA(ssl: *mut SSL, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_CA(ctx: *mut SSL_CTX, x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_connect_state(s: *mut SSL);
}
extern "C" {
    pub fn SSL_set_accept_state(s: *mut SSL);
}
extern "C" {
    pub fn SSL_get_default_timeout(s: *const SSL) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_CIPHER_description(
        arg1: *const SSL_CIPHER,
        buf: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_dup_CA_list(sk: *const stack_st_X509_NAME) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_dup(ssl: *mut SSL) -> *mut SSL;
}
extern "C" {
    pub fn SSL_get_certificate(ssl: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_privatekey(ssl: *const SSL) -> *mut evp_pkey_st;
}
extern "C" {
    pub fn SSL_CTX_get0_certificate(ctx: *const SSL_CTX) -> *mut X509;
}
extern "C" {
    pub fn SSL_CTX_get0_privatekey(ctx: *const SSL_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn SSL_CTX_set_quiet_shutdown(ctx: *mut SSL_CTX, mode: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_quiet_shutdown(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_quiet_shutdown(ssl: *mut SSL, mode: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_get_quiet_shutdown(ssl: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_shutdown(ssl: *mut SSL, mode: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_get_shutdown(ssl: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_version(ssl: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_client_version(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_paths(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_dir(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_file(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_store(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_file(ctx: *mut SSL_CTX, CAfile: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_dir(ctx: *mut SSL_CTX, CApath: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_store(
        ctx: *mut SSL_CTX,
        CAstore: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_locations(
        ctx: *mut SSL_CTX,
        CAfile: *const ::aya_ebpf::cty::c_char,
        CApath: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_session(ssl: *const SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get1_session(ssl: *mut SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get_SSL_CTX(ssl: *const SSL) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_SSL_CTX(ssl: *mut SSL, ctx: *mut SSL_CTX) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_info_callback(
        ssl: *mut SSL,
        cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *const SSL, type_: ::aya_ebpf::cty::c_int, val: ::aya_ebpf::cty::c_int),
        >,
    );
}
extern "C" {
    pub fn SSL_get_info_callback(
        ssl: *const SSL,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(ssl: *const SSL, arg1: ::aya_ebpf::cty::c_int, arg2: ::aya_ebpf::cty::c_int),
    >;
}
extern "C" {
    pub fn SSL_get_state(ssl: *const SSL) -> OSSL_HANDSHAKE_STATE;
}
extern "C" {
    pub fn SSL_set_verify_result(ssl: *mut SSL, v: ::aya_ebpf::cty::c_long);
}
extern "C" {
    pub fn SSL_get_verify_result(ssl: *const SSL) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn SSL_get0_verified_chain(s: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_get_client_random(ssl: *const SSL, out: *mut ::aya_ebpf::cty::c_uchar, outlen: usize) -> usize;
}
extern "C" {
    pub fn SSL_get_server_random(ssl: *const SSL, out: *mut ::aya_ebpf::cty::c_uchar, outlen: usize) -> usize;
}
extern "C" {
    pub fn SSL_SESSION_get_master_key(
        sess: *const SSL_SESSION,
        out: *mut ::aya_ebpf::cty::c_uchar,
        outlen: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_SESSION_set1_master_key(
        sess: *mut SSL_SESSION,
        in_: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_max_fragment_length(sess: *const SSL_SESSION) -> u8;
}
extern "C" {
    pub fn SSL_set_ex_data(
        ssl: *mut SSL,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_ex_data(ssl: *const SSL, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_SESSION_set_ex_data(
        ss: *mut SSL_SESSION,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ex_data(ss: *const SSL_SESSION, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_CTX_set_ex_data(
        ssl: *mut SSL_CTX,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_ex_data(ssl: *const SSL_CTX, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_get_ex_data_X509_STORE_CTX_idx() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_read_buffer_len(ctx: *mut SSL_CTX, len: usize);
}
extern "C" {
    pub fn SSL_set_default_read_buffer_len(s: *mut SSL, len: usize);
}
extern "C" {
    pub fn SSL_CTX_set_tmp_dh_callback(
        ctx: *mut SSL_CTX,
        dh: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::aya_ebpf::cty::c_int,
                keylength: ::aya_ebpf::cty::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_dh_callback(
        ssl: *mut SSL,
        dh: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::aya_ebpf::cty::c_int,
                keylength: ::aya_ebpf::cty::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_get_current_compression(s: *const SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_get_current_expansion(s: *const SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_COMP_get_name(comp: *const COMP_METHOD) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_COMP_get0_name(comp: *const SSL_COMP) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn SSL_COMP_get_id(comp: *const SSL_COMP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_COMP_get_compression_methods() -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_set0_compression_methods(meths: *mut stack_st_SSL_COMP) -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_add_compression_method(id: ::aya_ebpf::cty::c_int, cm: *mut COMP_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_find(ssl: *mut SSL, ptr: *const ::aya_ebpf::cty::c_uchar) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_get_cipher_nid(c: *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_digest_nid(c: *const SSL_CIPHER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_bytes_to_cipher_list(
        s: *mut SSL,
        bytes: *const ::aya_ebpf::cty::c_uchar,
        len: usize,
        isv2format: ::aya_ebpf::cty::c_int,
        sk: *mut *mut stack_st_SSL_CIPHER,
        scsvs: *mut *mut stack_st_SSL_CIPHER,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_session_ticket_ext(
        s: *mut SSL,
        ext_data: *mut ::aya_ebpf::cty::c_void,
        ext_len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_session_ticket_ext_cb(
        s: *mut SSL,
        cb: tls_session_ticket_ext_cb_fn,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_session_secret_cb(
        s: *mut SSL,
        session_secret_cb: tls_session_secret_cb_fn,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_not_resumable_session_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, is_forward_secure: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_set_not_resumable_session_callback(
        ssl: *mut SSL,
        cb: ::core::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, is_forward_secure: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_record_padding_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                type_: ::aya_ebpf::cty::c_int,
                len: usize,
                arg: *mut ::aya_ebpf::cty::c_void,
            ) -> usize,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_record_padding_callback_arg(ctx: *mut SSL_CTX, arg: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_CTX_get_record_padding_callback_arg(ctx: *const SSL_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_CTX_set_block_padding(ctx: *mut SSL_CTX, block_size: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_record_padding_callback(
        ssl: *mut SSL,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                type_: ::aya_ebpf::cty::c_int,
                len: usize,
                arg: *mut ::aya_ebpf::cty::c_void,
            ) -> usize,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_record_padding_callback_arg(ssl: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_get_record_padding_callback_arg(ssl: *const SSL) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_set_block_padding(ssl: *mut SSL, block_size: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_num_tickets(s: *mut SSL, num_tickets: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get_num_tickets(s: *const SSL) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set_num_tickets(ctx: *mut SSL_CTX, num_tickets: usize) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_num_tickets(ctx: *const SSL_CTX) -> usize;
}
extern "C" {
    pub fn SSL_session_reused(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_is_server(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_new() -> *mut SSL_CONF_CTX;
}
extern "C" {
    pub fn SSL_CONF_CTX_finish(cctx: *mut SSL_CONF_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_free(cctx: *mut SSL_CONF_CTX);
}
extern "C" {
    pub fn SSL_CONF_CTX_set_flags(cctx: *mut SSL_CONF_CTX, flags: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn SSL_CONF_CTX_clear_flags(cctx: *mut SSL_CONF_CTX, flags: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn SSL_CONF_CTX_set1_prefix(
        cctx: *mut SSL_CONF_CTX,
        pre: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CONF_CTX_set_ssl(cctx: *mut SSL_CONF_CTX, ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_CONF_CTX_set_ssl_ctx(cctx: *mut SSL_CONF_CTX, ctx: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CONF_cmd(
        cctx: *mut SSL_CONF_CTX,
        cmd: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CONF_cmd_argv(
        cctx: *mut SSL_CONF_CTX,
        pargc: *mut ::aya_ebpf::cty::c_int,
        pargv: *mut *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CONF_cmd_value_type(
        cctx: *mut SSL_CONF_CTX,
        cmd: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_add_ssl_module();
}
extern "C" {
    pub fn SSL_config(s: *mut SSL, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_config(ctx: *mut SSL_CTX, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_trace(
        write_p: ::aya_ebpf::cty::c_int,
        version: ::aya_ebpf::cty::c_int,
        content_type: ::aya_ebpf::cty::c_int,
        buf: *const ::aya_ebpf::cty::c_void,
        len: usize,
        ssl: *mut SSL,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn DTLSv1_listen(s: *mut SSL, client: *mut BIO_ADDR) -> ::aya_ebpf::cty::c_int;
}
pub type ssl_ct_validation_cb = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *const CT_POLICY_EVAL_CTX,
        scts: *const stack_st_SCT,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn SSL_set_ct_validation_callback(
        s: *mut SSL,
        callback: ssl_ct_validation_cb,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ct_validation_callback(
        ctx: *mut SSL_CTX,
        callback: ssl_ct_validation_cb,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
pub const SSL_CT_VALIDATION_PERMISSIVE: _bindgen_ty_40 = 0;
pub const SSL_CT_VALIDATION_STRICT: _bindgen_ty_40 = 1;
pub type _bindgen_ty_40 = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn SSL_enable_ct(s: *mut SSL, validation_mode: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_enable_ct(ctx: *mut SSL_CTX, validation_mode: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_ct_is_enabled(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_ct_is_enabled(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_get0_peer_scts(s: *mut SSL) -> *const stack_st_SCT;
}
extern "C" {
    pub fn SSL_CTX_set_default_ctlog_list_file(ctx: *mut SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ctlog_list_file(ctx: *mut SSL_CTX, path: *const ::aya_ebpf::cty::c_char)
        -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set0_ctlog_store(ctx: *mut SSL_CTX, logs: *mut CTLOG_STORE);
}
extern "C" {
    pub fn SSL_CTX_get0_ctlog_store(ctx: *const SSL_CTX) -> *const CTLOG_STORE;
}
extern "C" {
    pub fn SSL_set_security_level(s: *mut SSL, level: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_get_security_level(s: *const SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_set_security_callback(
        s: *mut SSL,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                s: *const SSL,
                ctx: *const SSL_CTX,
                op: ::aya_ebpf::cty::c_int,
                bits: ::aya_ebpf::cty::c_int,
                nid: ::aya_ebpf::cty::c_int,
                other: *mut ::aya_ebpf::cty::c_void,
                ex: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_get_security_callback(
        s: *const SSL,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            s: *const SSL,
            arg1: *const SSL_CTX,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: ::aya_ebpf::cty::c_int,
            arg4: ::aya_ebpf::cty::c_int,
            arg5: *mut ::aya_ebpf::cty::c_void,
            arg6: *mut ::aya_ebpf::cty::c_void,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn SSL_set0_security_ex_data(s: *mut SSL, ex: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_get0_security_ex_data(s: *const SSL) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn SSL_CTX_set_security_level(ctx: *mut SSL_CTX, level: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_security_level(ctx: *const SSL_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_security_callback(
        ctx: *mut SSL_CTX,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                s: *const SSL,
                ctx: *const SSL_CTX,
                op: ::aya_ebpf::cty::c_int,
                bits: ::aya_ebpf::cty::c_int,
                nid: ::aya_ebpf::cty::c_int,
                other: *mut ::aya_ebpf::cty::c_void,
                ex: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_security_callback(
        ctx: *const SSL_CTX,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const SSL,
            arg1: *const SSL_CTX,
            arg2: ::aya_ebpf::cty::c_int,
            arg3: ::aya_ebpf::cty::c_int,
            arg4: ::aya_ebpf::cty::c_int,
            arg5: *mut ::aya_ebpf::cty::c_void,
            arg6: *mut ::aya_ebpf::cty::c_void,
        ) -> ::aya_ebpf::cty::c_int,
    >;
}
extern "C" {
    pub fn SSL_CTX_set0_security_ex_data(ctx: *mut SSL_CTX, ex: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn SSL_CTX_get0_security_ex_data(ctx: *const SSL_CTX) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OPENSSL_init_ssl(opts: u64, settings: *const OPENSSL_INIT_SETTINGS) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openssl_ssl_test_functions {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SSL_test_functions() -> *const openssl_ssl_test_functions;
}
extern "C" {
    pub fn SSL_free_buffers(ssl: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_alloc_buffers(ssl: *mut SSL) -> ::aya_ebpf::cty::c_int;
}
pub type SSL_TICKET_STATUS = ::aya_ebpf::cty::c_int;
pub type SSL_TICKET_RETURN = ::aya_ebpf::cty::c_int;
pub type SSL_CTX_generate_session_ticket_fn =
    ::core::option::Option<unsafe extern "C" fn(s: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
pub type SSL_CTX_decrypt_session_ticket_fn = ::core::option::Option<
    unsafe extern "C" fn(
        s: *mut SSL,
        ss: *mut SSL_SESSION,
        keyname: *const ::aya_ebpf::cty::c_uchar,
        keyname_length: usize,
        status: SSL_TICKET_STATUS,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> SSL_TICKET_RETURN,
>;
extern "C" {
    pub fn SSL_CTX_set_session_ticket_cb(
        ctx: *mut SSL_CTX,
        gen_cb: SSL_CTX_generate_session_ticket_fn,
        dec_cb: SSL_CTX_decrypt_session_ticket_fn,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set1_ticket_appdata(
        ss: *mut SSL_SESSION,
        data: *const ::aya_ebpf::cty::c_void,
        len: usize,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_ticket_appdata(
        ss: *mut SSL_SESSION,
        data: *mut *mut ::aya_ebpf::cty::c_void,
        len: *mut usize,
    ) -> ::aya_ebpf::cty::c_int;
}
pub type DTLS_timer_cb = ::core::option::Option<
    unsafe extern "C" fn(s: *mut SSL, timer_us: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_uint,
>;
extern "C" {
    pub fn DTLS_set_timer_cb(s: *mut SSL, cb: DTLS_timer_cb);
}
pub type SSL_allow_early_data_cb_fn =
    ::core::option::Option<unsafe extern "C" fn(s: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int>;
extern "C" {
    pub fn SSL_CTX_set_allow_early_data_cb(
        ctx: *mut SSL_CTX,
        cb: SSL_allow_early_data_cb_fn,
        arg: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn SSL_set_allow_early_data_cb(s: *mut SSL, cb: SSL_allow_early_data_cb_fn, arg: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn OSSL_default_cipher_list() -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OSSL_default_ciphersuites() -> *const ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct err_state_st {
    pub err_flags: [::aya_ebpf::cty::c_int; 16usize],
    pub err_marks: [::aya_ebpf::cty::c_int; 16usize],
    pub err_buffer: [::aya_ebpf::cty::c_ulong; 16usize],
    pub err_data: [*mut ::aya_ebpf::cty::c_char; 16usize],
    pub err_data_size: [usize; 16usize],
    pub err_data_flags: [::aya_ebpf::cty::c_int; 16usize],
    pub err_file: [*mut ::aya_ebpf::cty::c_char; 16usize],
    pub err_line: [::aya_ebpf::cty::c_int; 16usize],
    pub err_func: [*mut ::aya_ebpf::cty::c_char; 16usize],
    pub top: ::aya_ebpf::cty::c_int,
    pub bottom: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERR_string_data_st {
    pub error: ::aya_ebpf::cty::c_ulong,
    pub string: *const ::aya_ebpf::cty::c_char,
}
pub type ERR_STRING_DATA = ERR_string_data_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lhash_st_ERR_STRING_DATA {
    pub dummy: lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lhash_st_ERR_STRING_DATA_lh_ERR_STRING_DATA_dummy {
    pub d1: *mut ::aya_ebpf::cty::c_void,
    pub d2: ::aya_ebpf::cty::c_ulong,
    pub d3: ::aya_ebpf::cty::c_int,
}
pub type lh_ERR_STRING_DATA_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const ERR_STRING_DATA, b: *const ERR_STRING_DATA) -> ::aya_ebpf::cty::c_int,
>;
pub type lh_ERR_STRING_DATA_hashfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ERR_STRING_DATA) -> ::aya_ebpf::cty::c_ulong>;
pub type lh_ERR_STRING_DATA_doallfunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ERR_STRING_DATA)>;
extern "C" {
    pub fn ERR_new();
}
extern "C" {
    pub fn ERR_set_debug(
        file: *const ::aya_ebpf::cty::c_char,
        line: ::aya_ebpf::cty::c_int,
        func: *const ::aya_ebpf::cty::c_char,
    );
}
extern "C" {
    pub fn ERR_set_error(
        lib: ::aya_ebpf::cty::c_int,
        reason: ::aya_ebpf::cty::c_int,
        fmt: *const ::aya_ebpf::cty::c_char,
        ...
    );
}
extern "C" {
    pub fn ERR_vset_error(
        lib: ::aya_ebpf::cty::c_int,
        reason: ::aya_ebpf::cty::c_int,
        fmt: *const ::aya_ebpf::cty::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn ERR_set_error_data(data: *mut ::aya_ebpf::cty::c_char, flags: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn ERR_get_error() -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_get_error_all(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
        func: *mut *const ::aya_ebpf::cty::c_char,
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_get_error_line(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_get_error_line_data(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error() -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_line(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_func(func: *mut *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_data(
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_all(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
        func: *mut *const ::aya_ebpf::cty::c_char,
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_error_line_data(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error() -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_line(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_func(func: *mut *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_data(
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_all(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
        func: *mut *const ::aya_ebpf::cty::c_char,
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_peek_last_error_line_data(
        file: *mut *const ::aya_ebpf::cty::c_char,
        line: *mut ::aya_ebpf::cty::c_int,
        data: *mut *const ::aya_ebpf::cty::c_char,
        flags: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_ulong;
}
extern "C" {
    pub fn ERR_clear_error();
}
extern "C" {
    pub fn ERR_error_string(
        e: ::aya_ebpf::cty::c_ulong,
        buf: *mut ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ERR_error_string_n(e: ::aya_ebpf::cty::c_ulong, buf: *mut ::aya_ebpf::cty::c_char, len: usize);
}
extern "C" {
    pub fn ERR_lib_error_string(e: ::aya_ebpf::cty::c_ulong) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ERR_func_error_string(e: ::aya_ebpf::cty::c_ulong) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ERR_reason_error_string(e: ::aya_ebpf::cty::c_ulong) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ERR_print_errors_cb(
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                str_: *const ::aya_ebpf::cty::c_char,
                len: usize,
                u: *mut ::aya_ebpf::cty::c_void,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        u: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn ERR_print_errors_fp(fp: *mut FILE);
}
extern "C" {
    pub fn ERR_print_errors(bp: *mut BIO);
}
extern "C" {
    pub fn ERR_add_error_data(num: ::aya_ebpf::cty::c_int, ...);
}
extern "C" {
    pub fn ERR_add_error_vdata(num: ::aya_ebpf::cty::c_int, args: *mut __va_list_tag);
}
extern "C" {
    pub fn ERR_add_error_txt(sepr: *const ::aya_ebpf::cty::c_char, txt: *const ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn ERR_add_error_mem_bio(sep: *const ::aya_ebpf::cty::c_char, bio: *mut BIO);
}
extern "C" {
    pub fn ERR_load_strings(lib: ::aya_ebpf::cty::c_int, str_: *mut ERR_STRING_DATA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_load_strings_const(str_: *const ERR_STRING_DATA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_unload_strings(lib: ::aya_ebpf::cty::c_int, str_: *mut ERR_STRING_DATA) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_remove_thread_state(arg1: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn ERR_remove_state(pid: ::aya_ebpf::cty::c_ulong);
}
extern "C" {
    pub fn ERR_get_state() -> *mut ERR_STATE;
}
extern "C" {
    pub fn ERR_get_next_error_library() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_set_mark() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_pop_to_mark() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ERR_clear_last_mark() -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_meth_st {
    pub seed: ::core::option::Option<
        unsafe extern "C" fn(buf: *const ::aya_ebpf::cty::c_void, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
    >,
    pub bytes: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut ::aya_ebpf::cty::c_uchar, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
    >,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn()>,
    pub add: ::core::option::Option<
        unsafe extern "C" fn(
            buf: *const ::aya_ebpf::cty::c_void,
            num: ::aya_ebpf::cty::c_int,
            randomness: f64,
        ) -> ::aya_ebpf::cty::c_int,
    >,
    pub pseudorand: ::core::option::Option<
        unsafe extern "C" fn(buf: *mut ::aya_ebpf::cty::c_uchar, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int,
    >,
    pub status: ::core::option::Option<unsafe extern "C" fn() -> ::aya_ebpf::cty::c_int>,
}
extern "C" {
    pub fn RAND_set_rand_method(meth: *const RAND_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_get_rand_method() -> *const RAND_METHOD;
}
extern "C" {
    pub fn RAND_set_rand_engine(engine: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_OpenSSL() -> *mut RAND_METHOD;
}
extern "C" {
    pub fn RAND_bytes(buf: *mut ::aya_ebpf::cty::c_uchar, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_priv_bytes(buf: *mut ::aya_ebpf::cty::c_uchar, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_priv_bytes_ex(
        ctx: *mut OSSL_LIB_CTX,
        buf: *mut ::aya_ebpf::cty::c_uchar,
        num: usize,
        strength: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_bytes_ex(
        ctx: *mut OSSL_LIB_CTX,
        buf: *mut ::aya_ebpf::cty::c_uchar,
        num: usize,
        strength: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_pseudo_bytes(buf: *mut ::aya_ebpf::cty::c_uchar, num: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_get0_primary(ctx: *mut OSSL_LIB_CTX) -> *mut EVP_RAND_CTX;
}
extern "C" {
    pub fn RAND_get0_public(ctx: *mut OSSL_LIB_CTX) -> *mut EVP_RAND_CTX;
}
extern "C" {
    pub fn RAND_get0_private(ctx: *mut OSSL_LIB_CTX) -> *mut EVP_RAND_CTX;
}
extern "C" {
    pub fn RAND_set0_public(ctx: *mut OSSL_LIB_CTX, rand: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_set0_private(ctx: *mut OSSL_LIB_CTX, rand: *mut EVP_RAND_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_set_DRBG_type(
        ctx: *mut OSSL_LIB_CTX,
        drbg: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
        cipher: *const ::aya_ebpf::cty::c_char,
        digest: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_set_seed_source_type(
        ctx: *mut OSSL_LIB_CTX,
        seed: *const ::aya_ebpf::cty::c_char,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_seed(buf: *const ::aya_ebpf::cty::c_void, num: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn RAND_keep_random_devices_open(keep: ::aya_ebpf::cty::c_int);
}
extern "C" {
    pub fn RAND_add(buf: *const ::aya_ebpf::cty::c_void, num: ::aya_ebpf::cty::c_int, randomness: f64);
}
extern "C" {
    pub fn RAND_load_file(
        file: *const ::aya_ebpf::cty::c_char,
        max_bytes: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_write_file(file: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_file_name(file: *mut ::aya_ebpf::cty::c_char, num: usize) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn RAND_status() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn RAND_poll() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_new() -> *mut UI;
}
extern "C" {
    pub fn UI_new_method(method: *const UI_METHOD) -> *mut UI;
}
extern "C" {
    pub fn UI_free(ui: *mut UI);
}
extern "C" {
    pub fn UI_add_input_string(
        ui: *mut UI,
        prompt: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_int,
        result_buf: *mut ::aya_ebpf::cty::c_char,
        minsize: ::aya_ebpf::cty::c_int,
        maxsize: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_dup_input_string(
        ui: *mut UI,
        prompt: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_int,
        result_buf: *mut ::aya_ebpf::cty::c_char,
        minsize: ::aya_ebpf::cty::c_int,
        maxsize: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_add_verify_string(
        ui: *mut UI,
        prompt: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_int,
        result_buf: *mut ::aya_ebpf::cty::c_char,
        minsize: ::aya_ebpf::cty::c_int,
        maxsize: ::aya_ebpf::cty::c_int,
        test_buf: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_dup_verify_string(
        ui: *mut UI,
        prompt: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_int,
        result_buf: *mut ::aya_ebpf::cty::c_char,
        minsize: ::aya_ebpf::cty::c_int,
        maxsize: ::aya_ebpf::cty::c_int,
        test_buf: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_add_input_boolean(
        ui: *mut UI,
        prompt: *const ::aya_ebpf::cty::c_char,
        action_desc: *const ::aya_ebpf::cty::c_char,
        ok_chars: *const ::aya_ebpf::cty::c_char,
        cancel_chars: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_int,
        result_buf: *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_dup_input_boolean(
        ui: *mut UI,
        prompt: *const ::aya_ebpf::cty::c_char,
        action_desc: *const ::aya_ebpf::cty::c_char,
        ok_chars: *const ::aya_ebpf::cty::c_char,
        cancel_chars: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_int,
        result_buf: *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_add_info_string(ui: *mut UI, text: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_dup_info_string(ui: *mut UI, text: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_add_error_string(ui: *mut UI, text: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_dup_error_string(ui: *mut UI, text: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_construct_prompt(
        ui_method: *mut UI,
        phrase_desc: *const ::aya_ebpf::cty::c_char,
        object_name: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn UI_add_user_data(ui: *mut UI, user_data: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn UI_dup_user_data(ui: *mut UI, user_data: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_get0_user_data(ui: *mut UI) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn UI_get0_result(ui: *mut UI, i: ::aya_ebpf::cty::c_int) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn UI_get_result_length(ui: *mut UI, i: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_process(ui: *mut UI) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_ctrl(
        ui: *mut UI,
        cmd: ::aya_ebpf::cty::c_int,
        i: ::aya_ebpf::cty::c_long,
        p: *mut ::aya_ebpf::cty::c_void,
        f: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_set_ex_data(
        r: *mut UI,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_get_ex_data(r: *const UI, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn UI_set_default_method(meth: *const UI_METHOD);
}
extern "C" {
    pub fn UI_get_default_method() -> *const UI_METHOD;
}
extern "C" {
    pub fn UI_get_method(ui: *mut UI) -> *const UI_METHOD;
}
extern "C" {
    pub fn UI_set_method(ui: *mut UI, meth: *const UI_METHOD) -> *const UI_METHOD;
}
extern "C" {
    pub fn UI_OpenSSL() -> *mut UI_METHOD;
}
extern "C" {
    pub fn UI_null() -> *const UI_METHOD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ui_string_st {
    _unused: [u8; 0],
}
pub type UI_STRING = ui_string_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_UI_STRING {
    _unused: [u8; 0],
}
pub type sk_UI_STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const UI_STRING, b: *const *const UI_STRING) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_UI_STRING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut UI_STRING)>;
pub type sk_UI_STRING_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const UI_STRING) -> *mut UI_STRING>;
pub const UI_string_types_UIT_NONE: UI_string_types = 0;
pub const UI_string_types_UIT_PROMPT: UI_string_types = 1;
pub const UI_string_types_UIT_VERIFY: UI_string_types = 2;
pub const UI_string_types_UIT_BOOLEAN: UI_string_types = 3;
pub const UI_string_types_UIT_INFO: UI_string_types = 4;
pub const UI_string_types_UIT_ERROR: UI_string_types = 5;
pub type UI_string_types = ::aya_ebpf::cty::c_uint;
extern "C" {
    pub fn UI_create_method(name: *const ::aya_ebpf::cty::c_char) -> *mut UI_METHOD;
}
extern "C" {
    pub fn UI_destroy_method(ui_method: *mut UI_METHOD);
}
extern "C" {
    pub fn UI_method_set_opener(
        method: *mut UI_METHOD,
        opener: ::core::option::Option<unsafe extern "C" fn(ui: *mut UI) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_writer(
        method: *mut UI_METHOD,
        writer: ::core::option::Option<unsafe extern "C" fn(ui: *mut UI, uis: *mut UI_STRING) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_flusher(
        method: *mut UI_METHOD,
        flusher: ::core::option::Option<unsafe extern "C" fn(ui: *mut UI) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_reader(
        method: *mut UI_METHOD,
        reader: ::core::option::Option<unsafe extern "C" fn(ui: *mut UI, uis: *mut UI_STRING) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_closer(
        method: *mut UI_METHOD,
        closer: ::core::option::Option<unsafe extern "C" fn(ui: *mut UI) -> ::aya_ebpf::cty::c_int>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_data_duplicator(
        method: *mut UI_METHOD,
        duplicator: ::core::option::Option<
            unsafe extern "C" fn(ui: *mut UI, ui_data: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void,
        >,
        destructor: ::core::option::Option<unsafe extern "C" fn(ui: *mut UI, ui_data: *mut ::aya_ebpf::cty::c_void)>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_prompt_constructor(
        method: *mut UI_METHOD,
        prompt_constructor: ::core::option::Option<
            unsafe extern "C" fn(
                ui: *mut UI,
                phrase_desc: *const ::aya_ebpf::cty::c_char,
                object_name: *const ::aya_ebpf::cty::c_char,
            ) -> *mut ::aya_ebpf::cty::c_char,
        >,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_set_ex_data(
        method: *mut UI_METHOD,
        idx: ::aya_ebpf::cty::c_int,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_method_get_opener(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut UI) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn UI_method_get_writer(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut UI, arg1: *mut UI_STRING) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn UI_method_get_flusher(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut UI) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn UI_method_get_reader(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut UI, arg1: *mut UI_STRING) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn UI_method_get_closer(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut UI) -> ::aya_ebpf::cty::c_int>;
}
extern "C" {
    pub fn UI_method_get_prompt_constructor(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            method: *mut UI,
            arg1: *const ::aya_ebpf::cty::c_char,
            arg2: *const ::aya_ebpf::cty::c_char,
        ) -> *mut ::aya_ebpf::cty::c_char,
    >;
}
extern "C" {
    pub fn UI_method_get_data_duplicator(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(method: *mut UI, arg1: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_void,
    >;
}
extern "C" {
    pub fn UI_method_get_data_destructor(
        method: *const UI_METHOD,
    ) -> ::core::option::Option<unsafe extern "C" fn(method: *mut UI, arg1: *mut ::aya_ebpf::cty::c_void)>;
}
extern "C" {
    pub fn UI_method_get_ex_data(method: *const UI_METHOD, idx: ::aya_ebpf::cty::c_int)
        -> *const ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn UI_get_string_type(uis: *mut UI_STRING) -> UI_string_types;
}
extern "C" {
    pub fn UI_get_input_flags(uis: *mut UI_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_get0_output_string(uis: *mut UI_STRING) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn UI_get0_action_string(uis: *mut UI_STRING) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn UI_get0_result_string(uis: *mut UI_STRING) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn UI_get_result_string_length(uis: *mut UI_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_get0_test_string(uis: *mut UI_STRING) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn UI_get_result_minsize(uis: *mut UI_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_get_result_maxsize(uis: *mut UI_STRING) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_set_result(
        ui: *mut UI,
        uis: *mut UI_STRING,
        result: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_set_result_ex(
        ui: *mut UI,
        uis: *mut UI_STRING,
        result: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_UTIL_read_pw_string(
        buf: *mut ::aya_ebpf::cty::c_char,
        length: ::aya_ebpf::cty::c_int,
        prompt: *const ::aya_ebpf::cty::c_char,
        verify: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_UTIL_read_pw(
        buf: *mut ::aya_ebpf::cty::c_char,
        buff: *mut ::aya_ebpf::cty::c_char,
        size: ::aya_ebpf::cty::c_int,
        prompt: *const ::aya_ebpf::cty::c_char,
        verify: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn UI_UTIL_wrap_read_pem_callback(cb: pem_password_cb, rwflag: ::aya_ebpf::cty::c_int) -> *mut UI_METHOD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ENGINE_CMD_DEFN_st {
    pub cmd_num: ::aya_ebpf::cty::c_uint,
    pub cmd_name: *const ::aya_ebpf::cty::c_char,
    pub cmd_desc: *const ::aya_ebpf::cty::c_char,
    pub cmd_flags: ::aya_ebpf::cty::c_uint,
}
pub type ENGINE_CMD_DEFN = ENGINE_CMD_DEFN_st;
pub type ENGINE_GEN_FUNC_PTR = ::core::option::Option<unsafe extern "C" fn() -> ::aya_ebpf::cty::c_int>;
pub type ENGINE_GEN_INT_FUNC_PTR =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ENGINE) -> ::aya_ebpf::cty::c_int>;
pub type ENGINE_CTRL_FUNC_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        arg2: ::aya_ebpf::cty::c_int,
        arg3: ::aya_ebpf::cty::c_long,
        arg4: *mut ::aya_ebpf::cty::c_void,
        f: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type ENGINE_LOAD_KEY_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        arg2: *const ::aya_ebpf::cty::c_char,
        ui_method: *mut UI_METHOD,
        callback_data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY,
>;
pub type ENGINE_SSL_CLIENT_CERT_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        ssl: *mut SSL,
        ca_dn: *mut stack_st_X509_NAME,
        pcert: *mut *mut X509,
        pkey: *mut *mut EVP_PKEY,
        pother: *mut *mut stack_st_X509,
        ui_method: *mut UI_METHOD,
        callback_data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type ENGINE_CIPHERS_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        arg2: *mut *const EVP_CIPHER,
        arg3: *mut *const ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type ENGINE_DIGESTS_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        arg2: *mut *const EVP_MD,
        arg3: *mut *const ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type ENGINE_PKEY_METHS_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        arg2: *mut *mut EVP_PKEY_METHOD,
        arg3: *mut *const ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type ENGINE_PKEY_ASN1_METHS_PTR = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ENGINE,
        arg2: *mut *mut EVP_PKEY_ASN1_METHOD,
        arg3: *mut *const ::aya_ebpf::cty::c_int,
        arg4: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn ENGINE_get_first() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_last() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_next(e: *mut ENGINE) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_prev(e: *mut ENGINE) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_add(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_remove(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_by_id(id: *const ::aya_ebpf::cty::c_char) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_load_builtin_engines();
}
extern "C" {
    pub fn ENGINE_get_table_flags() -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn ENGINE_set_table_flags(flags: ::aya_ebpf::cty::c_uint);
}
extern "C" {
    pub fn ENGINE_register_RSA(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_RSA(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_RSA();
}
extern "C" {
    pub fn ENGINE_register_DSA(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_DSA(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_DSA();
}
extern "C" {
    pub fn ENGINE_register_EC(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_EC(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_EC();
}
extern "C" {
    pub fn ENGINE_register_DH(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_DH(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_DH();
}
extern "C" {
    pub fn ENGINE_register_RAND(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_RAND(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_RAND();
}
extern "C" {
    pub fn ENGINE_register_ciphers(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_ciphers(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_ciphers();
}
extern "C" {
    pub fn ENGINE_register_digests(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_digests(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_digests();
}
extern "C" {
    pub fn ENGINE_register_pkey_meths(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_pkey_meths(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_pkey_meths();
}
extern "C" {
    pub fn ENGINE_register_pkey_asn1_meths(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_unregister_pkey_asn1_meths(e: *mut ENGINE);
}
extern "C" {
    pub fn ENGINE_register_all_pkey_asn1_meths();
}
extern "C" {
    pub fn ENGINE_register_complete(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_register_all_complete() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_ctrl(
        e: *mut ENGINE,
        cmd: ::aya_ebpf::cty::c_int,
        i: ::aya_ebpf::cty::c_long,
        p: *mut ::aya_ebpf::cty::c_void,
        f: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_cmd_is_executable(e: *mut ENGINE, cmd: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_ctrl_cmd(
        e: *mut ENGINE,
        cmd_name: *const ::aya_ebpf::cty::c_char,
        i: ::aya_ebpf::cty::c_long,
        p: *mut ::aya_ebpf::cty::c_void,
        f: ::core::option::Option<unsafe extern "C" fn()>,
        cmd_optional: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_ctrl_cmd_string(
        e: *mut ENGINE,
        cmd_name: *const ::aya_ebpf::cty::c_char,
        arg: *const ::aya_ebpf::cty::c_char,
        cmd_optional: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_new() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_free(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_up_ref(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_id(e: *mut ENGINE, id: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_name(e: *mut ENGINE, name: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_RSA(e: *mut ENGINE, rsa_meth: *const RSA_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_DSA(e: *mut ENGINE, dsa_meth: *const DSA_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_EC(e: *mut ENGINE, ecdsa_meth: *const EC_KEY_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_DH(e: *mut ENGINE, dh_meth: *const DH_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_RAND(e: *mut ENGINE, rand_meth: *const RAND_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_destroy_function(e: *mut ENGINE, destroy_f: ENGINE_GEN_INT_FUNC_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_init_function(e: *mut ENGINE, init_f: ENGINE_GEN_INT_FUNC_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_finish_function(e: *mut ENGINE, finish_f: ENGINE_GEN_INT_FUNC_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_ctrl_function(e: *mut ENGINE, ctrl_f: ENGINE_CTRL_FUNC_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_load_privkey_function(e: *mut ENGINE, loadpriv_f: ENGINE_LOAD_KEY_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_load_pubkey_function(e: *mut ENGINE, loadpub_f: ENGINE_LOAD_KEY_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_load_ssl_client_cert_function(
        e: *mut ENGINE,
        loadssl_f: ENGINE_SSL_CLIENT_CERT_PTR,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_ciphers(e: *mut ENGINE, f: ENGINE_CIPHERS_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_digests(e: *mut ENGINE, f: ENGINE_DIGESTS_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_pkey_meths(e: *mut ENGINE, f: ENGINE_PKEY_METHS_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_pkey_asn1_meths(e: *mut ENGINE, f: ENGINE_PKEY_ASN1_METHS_PTR) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_flags(e: *mut ENGINE, flags: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_cmd_defns(e: *mut ENGINE, defns: *const ENGINE_CMD_DEFN) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_ex_data(
        e: *mut ENGINE,
        idx: ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_get_ex_data(e: *const ENGINE, idx: ::aya_ebpf::cty::c_int) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ENGINE_get_id(e: *const ENGINE) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ENGINE_get_name(e: *const ENGINE) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ENGINE_get_RSA(e: *const ENGINE) -> *const RSA_METHOD;
}
extern "C" {
    pub fn ENGINE_get_DSA(e: *const ENGINE) -> *const DSA_METHOD;
}
extern "C" {
    pub fn ENGINE_get_EC(e: *const ENGINE) -> *const EC_KEY_METHOD;
}
extern "C" {
    pub fn ENGINE_get_DH(e: *const ENGINE) -> *const DH_METHOD;
}
extern "C" {
    pub fn ENGINE_get_RAND(e: *const ENGINE) -> *const RAND_METHOD;
}
extern "C" {
    pub fn ENGINE_get_destroy_function(e: *const ENGINE) -> ENGINE_GEN_INT_FUNC_PTR;
}
extern "C" {
    pub fn ENGINE_get_init_function(e: *const ENGINE) -> ENGINE_GEN_INT_FUNC_PTR;
}
extern "C" {
    pub fn ENGINE_get_finish_function(e: *const ENGINE) -> ENGINE_GEN_INT_FUNC_PTR;
}
extern "C" {
    pub fn ENGINE_get_ctrl_function(e: *const ENGINE) -> ENGINE_CTRL_FUNC_PTR;
}
extern "C" {
    pub fn ENGINE_get_load_privkey_function(e: *const ENGINE) -> ENGINE_LOAD_KEY_PTR;
}
extern "C" {
    pub fn ENGINE_get_load_pubkey_function(e: *const ENGINE) -> ENGINE_LOAD_KEY_PTR;
}
extern "C" {
    pub fn ENGINE_get_ssl_client_cert_function(e: *const ENGINE) -> ENGINE_SSL_CLIENT_CERT_PTR;
}
extern "C" {
    pub fn ENGINE_get_ciphers(e: *const ENGINE) -> ENGINE_CIPHERS_PTR;
}
extern "C" {
    pub fn ENGINE_get_digests(e: *const ENGINE) -> ENGINE_DIGESTS_PTR;
}
extern "C" {
    pub fn ENGINE_get_pkey_meths(e: *const ENGINE) -> ENGINE_PKEY_METHS_PTR;
}
extern "C" {
    pub fn ENGINE_get_pkey_asn1_meths(e: *const ENGINE) -> ENGINE_PKEY_ASN1_METHS_PTR;
}
extern "C" {
    pub fn ENGINE_get_cipher(e: *mut ENGINE, nid: ::aya_ebpf::cty::c_int) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn ENGINE_get_digest(e: *mut ENGINE, nid: ::aya_ebpf::cty::c_int) -> *const EVP_MD;
}
extern "C" {
    pub fn ENGINE_get_pkey_meth(e: *mut ENGINE, nid: ::aya_ebpf::cty::c_int) -> *const EVP_PKEY_METHOD;
}
extern "C" {
    pub fn ENGINE_get_pkey_asn1_meth(e: *mut ENGINE, nid: ::aya_ebpf::cty::c_int) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn ENGINE_get_pkey_asn1_meth_str(
        e: *mut ENGINE,
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn ENGINE_pkey_asn1_find_str(
        pe: *mut *mut ENGINE,
        str_: *const ::aya_ebpf::cty::c_char,
        len: ::aya_ebpf::cty::c_int,
    ) -> *const EVP_PKEY_ASN1_METHOD;
}
extern "C" {
    pub fn ENGINE_get_cmd_defns(e: *const ENGINE) -> *const ENGINE_CMD_DEFN;
}
extern "C" {
    pub fn ENGINE_get_flags(e: *const ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_init(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_finish(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_load_private_key(
        e: *mut ENGINE,
        key_id: *const ::aya_ebpf::cty::c_char,
        ui_method: *mut UI_METHOD,
        callback_data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn ENGINE_load_public_key(
        e: *mut ENGINE,
        key_id: *const ::aya_ebpf::cty::c_char,
        ui_method: *mut UI_METHOD,
        callback_data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn ENGINE_load_ssl_client_cert(
        e: *mut ENGINE,
        s: *mut SSL,
        ca_dn: *mut stack_st_X509_NAME,
        pcert: *mut *mut X509,
        ppkey: *mut *mut EVP_PKEY,
        pother: *mut *mut stack_st_X509,
        ui_method: *mut UI_METHOD,
        callback_data: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_get_default_RSA() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_default_DSA() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_default_EC() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_default_DH() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_default_RAND() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_cipher_engine(nid: ::aya_ebpf::cty::c_int) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_digest_engine(nid: ::aya_ebpf::cty::c_int) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_pkey_meth_engine(nid: ::aya_ebpf::cty::c_int) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_get_pkey_asn1_meth_engine(nid: ::aya_ebpf::cty::c_int) -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_set_default_RSA(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_string(e: *mut ENGINE, def_list: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_DSA(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_EC(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_DH(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_RAND(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_ciphers(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_digests(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_pkey_meths(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default_pkey_asn1_meths(e: *mut ENGINE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_set_default(e: *mut ENGINE, flags: ::aya_ebpf::cty::c_uint) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ENGINE_add_conf_module();
}
pub type dyn_MEM_malloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: usize,
        arg2: *const ::aya_ebpf::cty::c_char,
        arg3: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type dyn_MEM_realloc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_ebpf::cty::c_void,
        arg2: usize,
        arg3: *const ::aya_ebpf::cty::c_char,
        arg4: ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type dyn_MEM_free_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_ebpf::cty::c_void,
        arg2: *const ::aya_ebpf::cty::c_char,
        arg3: ::aya_ebpf::cty::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_dynamic_MEM_fns {
    pub malloc_fn: dyn_MEM_malloc_fn,
    pub realloc_fn: dyn_MEM_realloc_fn,
    pub free_fn: dyn_MEM_free_fn,
}
pub type dynamic_MEM_fns = st_dynamic_MEM_fns;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_dynamic_fns {
    pub static_state: *mut ::aya_ebpf::cty::c_void,
    pub mem_fns: dynamic_MEM_fns,
}
pub type dynamic_fns = st_dynamic_fns;
pub type dynamic_v_check_fn =
    ::core::option::Option<unsafe extern "C" fn(ossl_version: ::aya_ebpf::cty::c_ulong) -> ::aya_ebpf::cty::c_ulong>;
pub type dynamic_bind_engine = ::core::option::Option<
    unsafe extern "C" fn(
        e: *mut ENGINE,
        id: *const ::aya_ebpf::cty::c_char,
        fns: *const dynamic_fns,
    ) -> ::aya_ebpf::cty::c_int,
>;
extern "C" {
    pub fn ENGINE_get_static_state() -> *mut ::aya_ebpf::cty::c_void;
}
pub type X509V3_EXT_NEW = ::core::option::Option<unsafe extern "C" fn() -> *mut ::aya_ebpf::cty::c_void>;
pub type X509V3_EXT_FREE = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::aya_ebpf::cty::c_void)>;
pub type X509V3_EXT_D2I = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::aya_ebpf::cty::c_void,
        arg2: *mut *const ::aya_ebpf::cty::c_uchar,
        arg3: ::aya_ebpf::cty::c_long,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type X509V3_EXT_I2D = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::aya_ebpf::cty::c_void,
        arg2: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509V3_EXT_I2V = ::core::option::Option<
    unsafe extern "C" fn(
        method: *const v3_ext_method,
        ext: *mut ::aya_ebpf::cty::c_void,
        extlist: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE,
>;
pub type X509V3_EXT_V2I = ::core::option::Option<
    unsafe extern "C" fn(
        method: *const v3_ext_method,
        ctx: *mut v3_ext_ctx,
        values: *mut stack_st_CONF_VALUE,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type X509V3_EXT_I2S = ::core::option::Option<
    unsafe extern "C" fn(method: *const v3_ext_method, ext: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_char,
>;
pub type X509V3_EXT_S2I = ::core::option::Option<
    unsafe extern "C" fn(
        method: *const v3_ext_method,
        ctx: *mut v3_ext_ctx,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
pub type X509V3_EXT_I2R = ::core::option::Option<
    unsafe extern "C" fn(
        method: *const v3_ext_method,
        ext: *mut ::aya_ebpf::cty::c_void,
        out: *mut BIO,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type X509V3_EXT_R2I = ::core::option::Option<
    unsafe extern "C" fn(
        method: *const v3_ext_method,
        ctx: *mut v3_ext_ctx,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_method {
    pub ext_nid: ::aya_ebpf::cty::c_int,
    pub ext_flags: ::aya_ebpf::cty::c_int,
    pub it: ASN1_ITEM_EXP,
    pub ext_new: X509V3_EXT_NEW,
    pub ext_free: X509V3_EXT_FREE,
    pub d2i: X509V3_EXT_D2I,
    pub i2d: X509V3_EXT_I2D,
    pub i2s: X509V3_EXT_I2S,
    pub s2i: X509V3_EXT_S2I,
    pub i2v: X509V3_EXT_I2V,
    pub v2i: X509V3_EXT_V2I,
    pub i2r: X509V3_EXT_I2R,
    pub r2i: X509V3_EXT_R2I,
    pub usr_data: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509V3_CONF_METHOD_st {
    pub get_string: ::core::option::Option<
        unsafe extern "C" fn(
            db: *mut ::aya_ebpf::cty::c_void,
            section: *const ::aya_ebpf::cty::c_char,
            value: *const ::aya_ebpf::cty::c_char,
        ) -> *mut ::aya_ebpf::cty::c_char,
    >,
    pub get_section: ::core::option::Option<
        unsafe extern "C" fn(
            db: *mut ::aya_ebpf::cty::c_void,
            section: *const ::aya_ebpf::cty::c_char,
        ) -> *mut stack_st_CONF_VALUE,
    >,
    pub free_string: ::core::option::Option<
        unsafe extern "C" fn(db: *mut ::aya_ebpf::cty::c_void, string: *mut ::aya_ebpf::cty::c_char),
    >,
    pub free_section:
        ::core::option::Option<unsafe extern "C" fn(db: *mut ::aya_ebpf::cty::c_void, section: *mut stack_st_CONF_VALUE)>,
}
pub type X509V3_CONF_METHOD = X509V3_CONF_METHOD_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_ctx {
    pub flags: ::aya_ebpf::cty::c_int,
    pub issuer_cert: *mut X509,
    pub subject_cert: *mut X509,
    pub subject_req: *mut X509_REQ,
    pub crl: *mut X509_CRL,
    pub db_meth: *mut X509V3_CONF_METHOD,
    pub db: *mut ::aya_ebpf::cty::c_void,
    pub issuer_pkey: *mut EVP_PKEY,
}
pub type X509V3_EXT_METHOD = v3_ext_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509V3_EXT_METHOD {
    _unused: [u8; 0],
}
pub type sk_X509V3_EXT_METHOD_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const X509V3_EXT_METHOD,
        b: *const *const X509V3_EXT_METHOD,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509V3_EXT_METHOD_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509V3_EXT_METHOD)>;
pub type sk_X509V3_EXT_METHOD_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509V3_EXT_METHOD) -> *mut X509V3_EXT_METHOD>;
pub type ENUMERATED_NAMES = BIT_STRING_BITNAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASIC_CONSTRAINTS_st {
    pub ca: ::aya_ebpf::cty::c_int,
    pub pathlen: *mut ASN1_INTEGER,
}
pub type BASIC_CONSTRAINTS = BASIC_CONSTRAINTS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PKEY_USAGE_PERIOD_st {
    pub notBefore: *mut ASN1_GENERALIZEDTIME,
    pub notAfter: *mut ASN1_GENERALIZEDTIME,
}
pub type PKEY_USAGE_PERIOD = PKEY_USAGE_PERIOD_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otherName_st {
    pub type_id: *mut ASN1_OBJECT,
    pub value: *mut ASN1_TYPE,
}
pub type OTHERNAME = otherName_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EDIPartyName_st {
    pub nameAssigner: *mut ASN1_STRING,
    pub partyName: *mut ASN1_STRING,
}
pub type EDIPARTYNAME = EDIPartyName_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GENERAL_NAME_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub d: GENERAL_NAME_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GENERAL_NAME_st__bindgen_ty_1 {
    pub ptr: *mut ::aya_ebpf::cty::c_char,
    pub otherName: *mut OTHERNAME,
    pub rfc822Name: *mut ASN1_IA5STRING,
    pub dNSName: *mut ASN1_IA5STRING,
    pub x400Address: *mut ASN1_STRING,
    pub directoryName: *mut X509_NAME,
    pub ediPartyName: *mut EDIPARTYNAME,
    pub uniformResourceIdentifier: *mut ASN1_IA5STRING,
    pub iPAddress: *mut ASN1_OCTET_STRING,
    pub registeredID: *mut ASN1_OBJECT,
    pub ip: *mut ASN1_OCTET_STRING,
    pub dirn: *mut X509_NAME,
    pub ia5: *mut ASN1_IA5STRING,
    pub rid: *mut ASN1_OBJECT,
    pub other: *mut ASN1_TYPE,
}
pub type GENERAL_NAME = GENERAL_NAME_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_DESCRIPTION_st {
    pub method: *mut ASN1_OBJECT,
    pub location: *mut GENERAL_NAME,
}
pub type ACCESS_DESCRIPTION = ACCESS_DESCRIPTION_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ACCESS_DESCRIPTION {
    _unused: [u8; 0],
}
pub type sk_ACCESS_DESCRIPTION_compfunc = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const *const ACCESS_DESCRIPTION,
        b: *const *const ACCESS_DESCRIPTION,
    ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ACCESS_DESCRIPTION_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ACCESS_DESCRIPTION)>;
pub type sk_ACCESS_DESCRIPTION_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ACCESS_DESCRIPTION) -> *mut ACCESS_DESCRIPTION>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_NAME {
    _unused: [u8; 0],
}
pub type sk_GENERAL_NAME_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const GENERAL_NAME, b: *const *const GENERAL_NAME) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_GENERAL_NAME_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut GENERAL_NAME)>;
pub type sk_GENERAL_NAME_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const GENERAL_NAME) -> *mut GENERAL_NAME>;
pub type AUTHORITY_INFO_ACCESS = stack_st_ACCESS_DESCRIPTION;
pub type EXTENDED_KEY_USAGE = stack_st_ASN1_OBJECT;
pub type TLS_FEATURE = stack_st_ASN1_INTEGER;
pub type GENERAL_NAMES = stack_st_GENERAL_NAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_NAMES {
    _unused: [u8; 0],
}
pub type sk_GENERAL_NAMES_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const GENERAL_NAMES, b: *const *const GENERAL_NAMES) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_GENERAL_NAMES_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut GENERAL_NAMES)>;
pub type sk_GENERAL_NAMES_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const GENERAL_NAMES) -> *mut GENERAL_NAMES>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DIST_POINT_NAME_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub name: DIST_POINT_NAME_st__bindgen_ty_1,
    pub dpname: *mut X509_NAME,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DIST_POINT_NAME_st__bindgen_ty_1 {
    pub fullname: *mut GENERAL_NAMES,
    pub relativename: *mut stack_st_X509_NAME_ENTRY,
}
pub type DIST_POINT_NAME = DIST_POINT_NAME_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIST_POINT_st {
    pub distpoint: *mut DIST_POINT_NAME,
    pub reasons: *mut ASN1_BIT_STRING,
    pub CRLissuer: *mut GENERAL_NAMES,
    pub dp_reasons: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_DIST_POINT {
    _unused: [u8; 0],
}
pub type sk_DIST_POINT_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const DIST_POINT, b: *const *const DIST_POINT) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_DIST_POINT_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut DIST_POINT)>;
pub type sk_DIST_POINT_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const DIST_POINT) -> *mut DIST_POINT>;
pub type CRL_DIST_POINTS = stack_st_DIST_POINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUTHORITY_KEYID_st {
    pub keyid: *mut ASN1_OCTET_STRING,
    pub issuer: *mut GENERAL_NAMES,
    pub serial: *mut ASN1_INTEGER,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SXNET_ID_st {
    pub zone: *mut ASN1_INTEGER,
    pub user: *mut ASN1_OCTET_STRING,
}
pub type SXNETID = SXNET_ID_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SXNETID {
    _unused: [u8; 0],
}
pub type sk_SXNETID_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const SXNETID, b: *const *const SXNETID) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_SXNETID_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut SXNETID)>;
pub type sk_SXNETID_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const SXNETID) -> *mut SXNETID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SXNET_st {
    pub version: *mut ASN1_INTEGER,
    pub ids: *mut stack_st_SXNETID,
}
pub type SXNET = SXNET_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISSUER_SIGN_TOOL_st {
    pub signTool: *mut ASN1_UTF8STRING,
    pub cATool: *mut ASN1_UTF8STRING,
    pub signToolCert: *mut ASN1_UTF8STRING,
    pub cAToolCert: *mut ASN1_UTF8STRING,
}
pub type ISSUER_SIGN_TOOL = ISSUER_SIGN_TOOL_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTICEREF_st {
    pub organization: *mut ASN1_STRING,
    pub noticenos: *mut stack_st_ASN1_INTEGER,
}
pub type NOTICEREF = NOTICEREF_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USERNOTICE_st {
    pub noticeref: *mut NOTICEREF,
    pub exptext: *mut ASN1_STRING,
}
pub type USERNOTICE = USERNOTICE_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct POLICYQUALINFO_st {
    pub pqualid: *mut ASN1_OBJECT,
    pub d: POLICYQUALINFO_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union POLICYQUALINFO_st__bindgen_ty_1 {
    pub cpsuri: *mut ASN1_IA5STRING,
    pub usernotice: *mut USERNOTICE,
    pub other: *mut ASN1_TYPE,
}
pub type POLICYQUALINFO = POLICYQUALINFO_st;
pub type sk_POLICYQUALINFO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const POLICYQUALINFO, b: *const *const POLICYQUALINFO) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_POLICYQUALINFO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut POLICYQUALINFO)>;
pub type sk_POLICYQUALINFO_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const POLICYQUALINFO) -> *mut POLICYQUALINFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POLICYINFO_st {
    pub policyid: *mut ASN1_OBJECT,
    pub qualifiers: *mut stack_st_POLICYQUALINFO,
}
pub type POLICYINFO = POLICYINFO_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICYINFO {
    _unused: [u8; 0],
}
pub type sk_POLICYINFO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const POLICYINFO, b: *const *const POLICYINFO) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_POLICYINFO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut POLICYINFO)>;
pub type sk_POLICYINFO_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const POLICYINFO) -> *mut POLICYINFO>;
pub type CERTIFICATEPOLICIES = stack_st_POLICYINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POLICY_MAPPING_st {
    pub issuerDomainPolicy: *mut ASN1_OBJECT,
    pub subjectDomainPolicy: *mut ASN1_OBJECT,
}
pub type POLICY_MAPPING = POLICY_MAPPING_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICY_MAPPING {
    _unused: [u8; 0],
}
pub type sk_POLICY_MAPPING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const POLICY_MAPPING, b: *const *const POLICY_MAPPING) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_POLICY_MAPPING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut POLICY_MAPPING)>;
pub type sk_POLICY_MAPPING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const POLICY_MAPPING) -> *mut POLICY_MAPPING>;
pub type POLICY_MAPPINGS = stack_st_POLICY_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GENERAL_SUBTREE_st {
    pub base: *mut GENERAL_NAME,
    pub minimum: *mut ASN1_INTEGER,
    pub maximum: *mut ASN1_INTEGER,
}
pub type GENERAL_SUBTREE = GENERAL_SUBTREE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_SUBTREE {
    _unused: [u8; 0],
}
pub type sk_GENERAL_SUBTREE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const GENERAL_SUBTREE, b: *const *const GENERAL_SUBTREE) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_GENERAL_SUBTREE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut GENERAL_SUBTREE)>;
pub type sk_GENERAL_SUBTREE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const GENERAL_SUBTREE) -> *mut GENERAL_SUBTREE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAME_CONSTRAINTS_st {
    pub permittedSubtrees: *mut stack_st_GENERAL_SUBTREE,
    pub excludedSubtrees: *mut stack_st_GENERAL_SUBTREE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POLICY_CONSTRAINTS_st {
    pub requireExplicitPolicy: *mut ASN1_INTEGER,
    pub inhibitPolicyMapping: *mut ASN1_INTEGER,
}
pub type POLICY_CONSTRAINTS = POLICY_CONSTRAINTS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROXY_POLICY_st {
    pub policyLanguage: *mut ASN1_OBJECT,
    pub policy: *mut ASN1_OCTET_STRING,
}
pub type PROXY_POLICY = PROXY_POLICY_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROXY_CERT_INFO_EXTENSION_st {
    pub pcPathLengthConstraint: *mut ASN1_INTEGER,
    pub proxyPolicy: *mut PROXY_POLICY,
}
pub type PROXY_CERT_INFO_EXTENSION = PROXY_CERT_INFO_EXTENSION_st;
extern "C" {
    pub fn PROXY_POLICY_new() -> *mut PROXY_POLICY;
}
extern "C" {
    pub fn PROXY_POLICY_free(a: *mut PROXY_POLICY);
}
extern "C" {
    pub fn d2i_PROXY_POLICY(
        a: *mut *mut PROXY_POLICY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PROXY_POLICY;
}
extern "C" {
    pub fn i2d_PROXY_POLICY(a: *const PROXY_POLICY, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PROXY_POLICY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PROXY_CERT_INFO_EXTENSION_new() -> *mut PROXY_CERT_INFO_EXTENSION;
}
extern "C" {
    pub fn PROXY_CERT_INFO_EXTENSION_free(a: *mut PROXY_CERT_INFO_EXTENSION);
}
extern "C" {
    pub fn d2i_PROXY_CERT_INFO_EXTENSION(
        a: *mut *mut PROXY_CERT_INFO_EXTENSION,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PROXY_CERT_INFO_EXTENSION;
}
extern "C" {
    pub fn i2d_PROXY_CERT_INFO_EXTENSION(
        a: *const PROXY_CERT_INFO_EXTENSION,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PROXY_CERT_INFO_EXTENSION_it() -> *const ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISSUING_DIST_POINT_st {
    pub distpoint: *mut DIST_POINT_NAME,
    pub onlyuser: ::aya_ebpf::cty::c_int,
    pub onlyCA: ::aya_ebpf::cty::c_int,
    pub onlysomereasons: *mut ASN1_BIT_STRING,
    pub indirectCRL: ::aya_ebpf::cty::c_int,
    pub onlyattr: ::aya_ebpf::cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_purpose_st {
    pub purpose: ::aya_ebpf::cty::c_int,
    pub trust: ::aya_ebpf::cty::c_int,
    pub flags: ::aya_ebpf::cty::c_int,
    pub check_purpose: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const x509_purpose_st,
            arg2: *const X509,
            arg3: ::aya_ebpf::cty::c_int,
        ) -> ::aya_ebpf::cty::c_int,
    >,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub sname: *mut ::aya_ebpf::cty::c_char,
    pub usr_data: *mut ::aya_ebpf::cty::c_void,
}
pub type X509_PURPOSE = x509_purpose_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_PURPOSE {
    _unused: [u8; 0],
}
pub type sk_X509_PURPOSE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_PURPOSE, b: *const *const X509_PURPOSE) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_PURPOSE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_PURPOSE)>;
pub type sk_X509_PURPOSE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_PURPOSE) -> *mut X509_PURPOSE>;
extern "C" {
    pub fn BASIC_CONSTRAINTS_new() -> *mut BASIC_CONSTRAINTS;
}
extern "C" {
    pub fn BASIC_CONSTRAINTS_free(a: *mut BASIC_CONSTRAINTS);
}
extern "C" {
    pub fn d2i_BASIC_CONSTRAINTS(
        a: *mut *mut BASIC_CONSTRAINTS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut BASIC_CONSTRAINTS;
}
extern "C" {
    pub fn i2d_BASIC_CONSTRAINTS(
        a: *const BASIC_CONSTRAINTS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn BASIC_CONSTRAINTS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn SXNET_new() -> *mut SXNET;
}
extern "C" {
    pub fn SXNET_free(a: *mut SXNET);
}
extern "C" {
    pub fn d2i_SXNET(
        a: *mut *mut SXNET,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut SXNET;
}
extern "C" {
    pub fn i2d_SXNET(a: *const SXNET, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SXNET_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn SXNETID_new() -> *mut SXNETID;
}
extern "C" {
    pub fn SXNETID_free(a: *mut SXNETID);
}
extern "C" {
    pub fn d2i_SXNETID(
        a: *mut *mut SXNETID,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut SXNETID;
}
extern "C" {
    pub fn i2d_SXNETID(a: *const SXNETID, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SXNETID_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ISSUER_SIGN_TOOL_new() -> *mut ISSUER_SIGN_TOOL;
}
extern "C" {
    pub fn ISSUER_SIGN_TOOL_free(a: *mut ISSUER_SIGN_TOOL);
}
extern "C" {
    pub fn d2i_ISSUER_SIGN_TOOL(
        a: *mut *mut ISSUER_SIGN_TOOL,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ISSUER_SIGN_TOOL;
}
extern "C" {
    pub fn i2d_ISSUER_SIGN_TOOL(
        a: *const ISSUER_SIGN_TOOL,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ISSUER_SIGN_TOOL_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn SXNET_add_id_asc(
        psx: *mut *mut SXNET,
        zone: *const ::aya_ebpf::cty::c_char,
        user: *const ::aya_ebpf::cty::c_char,
        userlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SXNET_add_id_ulong(
        psx: *mut *mut SXNET,
        lzone: ::aya_ebpf::cty::c_ulong,
        user: *const ::aya_ebpf::cty::c_char,
        userlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SXNET_add_id_INTEGER(
        psx: *mut *mut SXNET,
        izone: *mut ASN1_INTEGER,
        user: *const ::aya_ebpf::cty::c_char,
        userlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn SXNET_get_id_asc(sx: *mut SXNET, zone: *const ::aya_ebpf::cty::c_char) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn SXNET_get_id_ulong(sx: *mut SXNET, lzone: ::aya_ebpf::cty::c_ulong) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn SXNET_get_id_INTEGER(sx: *mut SXNET, zone: *mut ASN1_INTEGER) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn AUTHORITY_KEYID_new() -> *mut AUTHORITY_KEYID;
}
extern "C" {
    pub fn AUTHORITY_KEYID_free(a: *mut AUTHORITY_KEYID);
}
extern "C" {
    pub fn d2i_AUTHORITY_KEYID(
        a: *mut *mut AUTHORITY_KEYID,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut AUTHORITY_KEYID;
}
extern "C" {
    pub fn i2d_AUTHORITY_KEYID(
        a: *const AUTHORITY_KEYID,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn AUTHORITY_KEYID_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PKEY_USAGE_PERIOD_new() -> *mut PKEY_USAGE_PERIOD;
}
extern "C" {
    pub fn PKEY_USAGE_PERIOD_free(a: *mut PKEY_USAGE_PERIOD);
}
extern "C" {
    pub fn d2i_PKEY_USAGE_PERIOD(
        a: *mut *mut PKEY_USAGE_PERIOD,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PKEY_USAGE_PERIOD;
}
extern "C" {
    pub fn i2d_PKEY_USAGE_PERIOD(
        a: *const PKEY_USAGE_PERIOD,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PKEY_USAGE_PERIOD_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn GENERAL_NAME_new() -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn GENERAL_NAME_free(a: *mut GENERAL_NAME);
}
extern "C" {
    pub fn d2i_GENERAL_NAME(
        a: *mut *mut GENERAL_NAME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn i2d_GENERAL_NAME(a: *const GENERAL_NAME, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn GENERAL_NAME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn GENERAL_NAME_dup(a: *const GENERAL_NAME) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn GENERAL_NAME_cmp(a: *mut GENERAL_NAME, b: *mut GENERAL_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn v2i_ASN1_BIT_STRING(
        method: *mut X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        nval: *mut stack_st_CONF_VALUE,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2v_ASN1_BIT_STRING(
        method: *mut X509V3_EXT_METHOD,
        bits: *mut ASN1_BIT_STRING,
        extlist: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn i2s_ASN1_IA5STRING(method: *mut X509V3_EXT_METHOD, ia5: *mut ASN1_IA5STRING) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn s2i_ASN1_IA5STRING(
        method: *mut X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn i2s_ASN1_UTF8STRING(
        method: *mut X509V3_EXT_METHOD,
        utf8: *mut ASN1_UTF8STRING,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn s2i_ASN1_UTF8STRING(
        method: *mut X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn i2v_GENERAL_NAME(
        method: *mut X509V3_EXT_METHOD,
        gen: *mut GENERAL_NAME,
        ret: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn GENERAL_NAME_print(out: *mut BIO, gen: *mut GENERAL_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn GENERAL_NAMES_new() -> *mut GENERAL_NAMES;
}
extern "C" {
    pub fn GENERAL_NAMES_free(a: *mut GENERAL_NAMES);
}
extern "C" {
    pub fn d2i_GENERAL_NAMES(
        a: *mut *mut GENERAL_NAMES,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut GENERAL_NAMES;
}
extern "C" {
    pub fn i2d_GENERAL_NAMES(a: *const GENERAL_NAMES, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn GENERAL_NAMES_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn i2v_GENERAL_NAMES(
        method: *mut X509V3_EXT_METHOD,
        gen: *mut GENERAL_NAMES,
        extlist: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn v2i_GENERAL_NAMES(
        method: *const X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        nval: *mut stack_st_CONF_VALUE,
    ) -> *mut GENERAL_NAMES;
}
extern "C" {
    pub fn OTHERNAME_new() -> *mut OTHERNAME;
}
extern "C" {
    pub fn OTHERNAME_free(a: *mut OTHERNAME);
}
extern "C" {
    pub fn d2i_OTHERNAME(
        a: *mut *mut OTHERNAME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OTHERNAME;
}
extern "C" {
    pub fn i2d_OTHERNAME(a: *const OTHERNAME, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OTHERNAME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn EDIPARTYNAME_new() -> *mut EDIPARTYNAME;
}
extern "C" {
    pub fn EDIPARTYNAME_free(a: *mut EDIPARTYNAME);
}
extern "C" {
    pub fn d2i_EDIPARTYNAME(
        a: *mut *mut EDIPARTYNAME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EDIPARTYNAME;
}
extern "C" {
    pub fn i2d_EDIPARTYNAME(a: *const EDIPARTYNAME, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EDIPARTYNAME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OTHERNAME_cmp(a: *mut OTHERNAME, b: *mut OTHERNAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn GENERAL_NAME_set0_value(
        a: *mut GENERAL_NAME,
        type_: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
    );
}
extern "C" {
    pub fn GENERAL_NAME_get0_value(
        a: *const GENERAL_NAME,
        ptype: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn GENERAL_NAME_set0_othername(
        gen: *mut GENERAL_NAME,
        oid: *mut ASN1_OBJECT,
        value: *mut ASN1_TYPE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn GENERAL_NAME_get0_otherName(
        gen: *const GENERAL_NAME,
        poid: *mut *mut ASN1_OBJECT,
        pvalue: *mut *mut ASN1_TYPE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2s_ASN1_OCTET_STRING(
        method: *mut X509V3_EXT_METHOD,
        ia5: *const ASN1_OCTET_STRING,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn s2i_ASN1_OCTET_STRING(
        method: *mut X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        str_: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn EXTENDED_KEY_USAGE_new() -> *mut EXTENDED_KEY_USAGE;
}
extern "C" {
    pub fn EXTENDED_KEY_USAGE_free(a: *mut EXTENDED_KEY_USAGE);
}
extern "C" {
    pub fn d2i_EXTENDED_KEY_USAGE(
        a: *mut *mut EXTENDED_KEY_USAGE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut EXTENDED_KEY_USAGE;
}
extern "C" {
    pub fn i2d_EXTENDED_KEY_USAGE(
        a: *const EXTENDED_KEY_USAGE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn EXTENDED_KEY_USAGE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn i2a_ACCESS_DESCRIPTION(bp: *mut BIO, a: *const ACCESS_DESCRIPTION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn TLS_FEATURE_new() -> *mut TLS_FEATURE;
}
extern "C" {
    pub fn TLS_FEATURE_free(a: *mut TLS_FEATURE);
}
extern "C" {
    pub fn CERTIFICATEPOLICIES_new() -> *mut CERTIFICATEPOLICIES;
}
extern "C" {
    pub fn CERTIFICATEPOLICIES_free(a: *mut CERTIFICATEPOLICIES);
}
extern "C" {
    pub fn d2i_CERTIFICATEPOLICIES(
        a: *mut *mut CERTIFICATEPOLICIES,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut CERTIFICATEPOLICIES;
}
extern "C" {
    pub fn i2d_CERTIFICATEPOLICIES(
        a: *const CERTIFICATEPOLICIES,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CERTIFICATEPOLICIES_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn POLICYINFO_new() -> *mut POLICYINFO;
}
extern "C" {
    pub fn POLICYINFO_free(a: *mut POLICYINFO);
}
extern "C" {
    pub fn d2i_POLICYINFO(
        a: *mut *mut POLICYINFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut POLICYINFO;
}
extern "C" {
    pub fn i2d_POLICYINFO(a: *const POLICYINFO, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn POLICYINFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn POLICYQUALINFO_new() -> *mut POLICYQUALINFO;
}
extern "C" {
    pub fn POLICYQUALINFO_free(a: *mut POLICYQUALINFO);
}
extern "C" {
    pub fn d2i_POLICYQUALINFO(
        a: *mut *mut POLICYQUALINFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut POLICYQUALINFO;
}
extern "C" {
    pub fn i2d_POLICYQUALINFO(
        a: *const POLICYQUALINFO,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn POLICYQUALINFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn USERNOTICE_new() -> *mut USERNOTICE;
}
extern "C" {
    pub fn USERNOTICE_free(a: *mut USERNOTICE);
}
extern "C" {
    pub fn d2i_USERNOTICE(
        a: *mut *mut USERNOTICE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut USERNOTICE;
}
extern "C" {
    pub fn i2d_USERNOTICE(a: *const USERNOTICE, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn USERNOTICE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn NOTICEREF_new() -> *mut NOTICEREF;
}
extern "C" {
    pub fn NOTICEREF_free(a: *mut NOTICEREF);
}
extern "C" {
    pub fn d2i_NOTICEREF(
        a: *mut *mut NOTICEREF,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut NOTICEREF;
}
extern "C" {
    pub fn i2d_NOTICEREF(a: *const NOTICEREF, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NOTICEREF_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn CRL_DIST_POINTS_new() -> *mut CRL_DIST_POINTS;
}
extern "C" {
    pub fn CRL_DIST_POINTS_free(a: *mut CRL_DIST_POINTS);
}
extern "C" {
    pub fn d2i_CRL_DIST_POINTS(
        a: *mut *mut CRL_DIST_POINTS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut CRL_DIST_POINTS;
}
extern "C" {
    pub fn i2d_CRL_DIST_POINTS(
        a: *const CRL_DIST_POINTS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn CRL_DIST_POINTS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn DIST_POINT_new() -> *mut DIST_POINT;
}
extern "C" {
    pub fn DIST_POINT_free(a: *mut DIST_POINT);
}
extern "C" {
    pub fn d2i_DIST_POINT(
        a: *mut *mut DIST_POINT,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DIST_POINT;
}
extern "C" {
    pub fn i2d_DIST_POINT(a: *const DIST_POINT, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DIST_POINT_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn DIST_POINT_NAME_new() -> *mut DIST_POINT_NAME;
}
extern "C" {
    pub fn DIST_POINT_NAME_free(a: *mut DIST_POINT_NAME);
}
extern "C" {
    pub fn d2i_DIST_POINT_NAME(
        a: *mut *mut DIST_POINT_NAME,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut DIST_POINT_NAME;
}
extern "C" {
    pub fn i2d_DIST_POINT_NAME(
        a: *const DIST_POINT_NAME,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn DIST_POINT_NAME_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ISSUING_DIST_POINT_new() -> *mut ISSUING_DIST_POINT;
}
extern "C" {
    pub fn ISSUING_DIST_POINT_free(a: *mut ISSUING_DIST_POINT);
}
extern "C" {
    pub fn d2i_ISSUING_DIST_POINT(
        a: *mut *mut ISSUING_DIST_POINT,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ISSUING_DIST_POINT;
}
extern "C" {
    pub fn i2d_ISSUING_DIST_POINT(
        a: *const ISSUING_DIST_POINT,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ISSUING_DIST_POINT_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn DIST_POINT_set_dpname(dpn: *mut DIST_POINT_NAME, iname: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_check(x: *mut X509, nc: *mut NAME_CONSTRAINTS) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_check_CN(x: *mut X509, nc: *mut NAME_CONSTRAINTS) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ACCESS_DESCRIPTION_new() -> *mut ACCESS_DESCRIPTION;
}
extern "C" {
    pub fn ACCESS_DESCRIPTION_free(a: *mut ACCESS_DESCRIPTION);
}
extern "C" {
    pub fn d2i_ACCESS_DESCRIPTION(
        a: *mut *mut ACCESS_DESCRIPTION,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ACCESS_DESCRIPTION;
}
extern "C" {
    pub fn i2d_ACCESS_DESCRIPTION(
        a: *const ACCESS_DESCRIPTION,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ACCESS_DESCRIPTION_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn AUTHORITY_INFO_ACCESS_new() -> *mut AUTHORITY_INFO_ACCESS;
}
extern "C" {
    pub fn AUTHORITY_INFO_ACCESS_free(a: *mut AUTHORITY_INFO_ACCESS);
}
extern "C" {
    pub fn d2i_AUTHORITY_INFO_ACCESS(
        a: *mut *mut AUTHORITY_INFO_ACCESS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut AUTHORITY_INFO_ACCESS;
}
extern "C" {
    pub fn i2d_AUTHORITY_INFO_ACCESS(
        a: *const AUTHORITY_INFO_ACCESS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn AUTHORITY_INFO_ACCESS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn POLICY_MAPPING_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn POLICY_MAPPING_new() -> *mut POLICY_MAPPING;
}
extern "C" {
    pub fn POLICY_MAPPING_free(a: *mut POLICY_MAPPING);
}
extern "C" {
    pub fn POLICY_MAPPINGS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn GENERAL_SUBTREE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn GENERAL_SUBTREE_new() -> *mut GENERAL_SUBTREE;
}
extern "C" {
    pub fn GENERAL_SUBTREE_free(a: *mut GENERAL_SUBTREE);
}
extern "C" {
    pub fn NAME_CONSTRAINTS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_new() -> *mut NAME_CONSTRAINTS;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_free(a: *mut NAME_CONSTRAINTS);
}
extern "C" {
    pub fn POLICY_CONSTRAINTS_new() -> *mut POLICY_CONSTRAINTS;
}
extern "C" {
    pub fn POLICY_CONSTRAINTS_free(a: *mut POLICY_CONSTRAINTS);
}
extern "C" {
    pub fn POLICY_CONSTRAINTS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn a2i_GENERAL_NAME(
        out: *mut GENERAL_NAME,
        method: *const X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        gen_type: ::aya_ebpf::cty::c_int,
        value: *const ::aya_ebpf::cty::c_char,
        is_nc: ::aya_ebpf::cty::c_int,
    ) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn v2i_GENERAL_NAME(
        method: *const X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        cnf: *mut CONF_VALUE,
    ) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn v2i_GENERAL_NAME_ex(
        out: *mut GENERAL_NAME,
        method: *const X509V3_EXT_METHOD,
        ctx: *mut X509V3_CTX,
        cnf: *mut CONF_VALUE,
        is_nc: ::aya_ebpf::cty::c_int,
    ) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn X509V3_conf_free(val: *mut CONF_VALUE);
}
extern "C" {
    pub fn X509V3_EXT_nconf_nid(
        conf: *mut CONF,
        ctx: *mut X509V3_CTX,
        ext_nid: ::aya_ebpf::cty::c_int,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_nconf(
        conf: *mut CONF,
        ctx: *mut X509V3_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_add_nconf_sk(
        conf: *mut CONF,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        sk: *mut *mut stack_st_X509_EXTENSION,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_add_nconf(
        conf: *mut CONF,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        cert: *mut X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_REQ_add_nconf(
        conf: *mut CONF,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        req: *mut X509_REQ,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_CRL_add_nconf(
        conf: *mut CONF,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        crl: *mut X509_CRL,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_conf_nid(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *mut X509V3_CTX,
        ext_nid: ::aya_ebpf::cty::c_int,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_conf(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *mut X509V3_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_add_conf(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        cert: *mut X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_REQ_add_conf(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        req: *mut X509_REQ,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_CRL_add_conf(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *mut X509V3_CTX,
        section: *const ::aya_ebpf::cty::c_char,
        crl: *mut X509_CRL,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_add_value_bool_nf(
        name: *const ::aya_ebpf::cty::c_char,
        asn1_bool: ::aya_ebpf::cty::c_int,
        extlist: *mut *mut stack_st_CONF_VALUE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_get_value_bool(
        value: *const CONF_VALUE,
        asn1_bool: *mut ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_get_value_int(value: *const CONF_VALUE, aint: *mut *mut ASN1_INTEGER) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_set_nconf(ctx: *mut X509V3_CTX, conf: *mut CONF);
}
extern "C" {
    pub fn X509V3_set_conf_lhash(ctx: *mut X509V3_CTX, lhash: *mut lhash_st_CONF_VALUE);
}
extern "C" {
    pub fn X509V3_get_string(
        ctx: *mut X509V3_CTX,
        name: *const ::aya_ebpf::cty::c_char,
        section: *const ::aya_ebpf::cty::c_char,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509V3_get_section(ctx: *mut X509V3_CTX, section: *const ::aya_ebpf::cty::c_char)
        -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn X509V3_string_free(ctx: *mut X509V3_CTX, str_: *mut ::aya_ebpf::cty::c_char);
}
extern "C" {
    pub fn X509V3_section_free(ctx: *mut X509V3_CTX, section: *mut stack_st_CONF_VALUE);
}
extern "C" {
    pub fn X509V3_set_ctx(
        ctx: *mut X509V3_CTX,
        issuer: *mut X509,
        subject: *mut X509,
        req: *mut X509_REQ,
        crl: *mut X509_CRL,
        flags: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn X509V3_set_issuer_pkey(ctx: *mut X509V3_CTX, pkey: *mut EVP_PKEY) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_add_value(
        name: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_char,
        extlist: *mut *mut stack_st_CONF_VALUE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_add_value_uchar(
        name: *const ::aya_ebpf::cty::c_char,
        value: *const ::aya_ebpf::cty::c_uchar,
        extlist: *mut *mut stack_st_CONF_VALUE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_add_value_bool(
        name: *const ::aya_ebpf::cty::c_char,
        asn1_bool: ::aya_ebpf::cty::c_int,
        extlist: *mut *mut stack_st_CONF_VALUE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_add_value_int(
        name: *const ::aya_ebpf::cty::c_char,
        aint: *const ASN1_INTEGER,
        extlist: *mut *mut stack_st_CONF_VALUE,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn i2s_ASN1_INTEGER(meth: *mut X509V3_EXT_METHOD, aint: *const ASN1_INTEGER) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn s2i_ASN1_INTEGER(meth: *mut X509V3_EXT_METHOD, value: *const ::aya_ebpf::cty::c_char) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2s_ASN1_ENUMERATED(
        meth: *mut X509V3_EXT_METHOD,
        aint: *const ASN1_ENUMERATED,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn i2s_ASN1_ENUMERATED_TABLE(
        meth: *mut X509V3_EXT_METHOD,
        aint: *const ASN1_ENUMERATED,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509V3_EXT_add(ext: *mut X509V3_EXT_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_add_list(extlist: *mut X509V3_EXT_METHOD) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_add_alias(
        nid_to: ::aya_ebpf::cty::c_int,
        nid_from: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_cleanup();
}
extern "C" {
    pub fn X509V3_EXT_get(ext: *mut X509_EXTENSION) -> *const X509V3_EXT_METHOD;
}
extern "C" {
    pub fn X509V3_EXT_get_nid(nid: ::aya_ebpf::cty::c_int) -> *const X509V3_EXT_METHOD;
}
extern "C" {
    pub fn X509V3_add_standard_extensions() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_parse_list(line: *const ::aya_ebpf::cty::c_char) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn X509V3_EXT_d2i(ext: *mut X509_EXTENSION) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509V3_get_d2i(
        x: *const stack_st_X509_EXTENSION,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn X509V3_EXT_i2d(
        ext_nid: ::aya_ebpf::cty::c_int,
        crit: ::aya_ebpf::cty::c_int,
        ext_struc: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_add1_i2d(
        x: *mut *mut stack_st_X509_EXTENSION,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_val_prn(
        out: *mut BIO,
        val: *mut stack_st_CONF_VALUE,
        indent: ::aya_ebpf::cty::c_int,
        ml: ::aya_ebpf::cty::c_int,
    );
}
extern "C" {
    pub fn X509V3_EXT_print(
        out: *mut BIO,
        ext: *mut X509_EXTENSION,
        flag: ::aya_ebpf::cty::c_ulong,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_EXT_print_fp(
        out: *mut FILE,
        ext: *mut X509_EXTENSION,
        flag: ::aya_ebpf::cty::c_int,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509V3_extensions_print(
        out: *mut BIO,
        title: *const ::aya_ebpf::cty::c_char,
        exts: *const stack_st_X509_EXTENSION,
        flag: ::aya_ebpf::cty::c_ulong,
        indent: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_ca(x: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_purpose(
        x: *mut X509,
        id: ::aya_ebpf::cty::c_int,
        ca: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_supported_extension(ex: *mut X509_EXTENSION) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_set(p: *mut ::aya_ebpf::cty::c_int, purpose: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_issued(issuer: *mut X509, subject: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_akid(issuer: *const X509, akid: *const AUTHORITY_KEYID) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_set_proxy_flag(x: *mut X509);
}
extern "C" {
    pub fn X509_set_proxy_pathlen(x: *mut X509, l: ::aya_ebpf::cty::c_long);
}
extern "C" {
    pub fn X509_get_proxy_pathlen(x: *mut X509) -> ::aya_ebpf::cty::c_long;
}
extern "C" {
    pub fn X509_get_extension_flags(x: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get_key_usage(x: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get_extended_key_usage(x: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get0_subject_key_id(x: *mut X509) -> *const ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_get0_authority_key_id(x: *mut X509) -> *const ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_get0_authority_issuer(x: *mut X509) -> *const GENERAL_NAMES;
}
extern "C" {
    pub fn X509_get0_authority_serial(x: *mut X509) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_PURPOSE_get_count() -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get0(idx: ::aya_ebpf::cty::c_int) -> *mut X509_PURPOSE;
}
extern "C" {
    pub fn X509_PURPOSE_get_by_sname(sname: *const ::aya_ebpf::cty::c_char) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get_by_id(id: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_add(
        id: ::aya_ebpf::cty::c_int,
        trust: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_int,
        ck: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const X509_PURPOSE,
                arg2: *const X509,
                arg3: ::aya_ebpf::cty::c_int,
            ) -> ::aya_ebpf::cty::c_int,
        >,
        name: *const ::aya_ebpf::cty::c_char,
        sname: *const ::aya_ebpf::cty::c_char,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get0_name(xp: *const X509_PURPOSE) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_PURPOSE_get0_sname(xp: *const X509_PURPOSE) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn X509_PURPOSE_get_trust(xp: *const X509_PURPOSE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_cleanup();
}
extern "C" {
    pub fn X509_PURPOSE_get_id(arg1: *const X509_PURPOSE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_get1_email(x: *mut X509) -> *mut stack_st_OPENSSL_STRING;
}
extern "C" {
    pub fn X509_REQ_get1_email(x: *mut X509_REQ) -> *mut stack_st_OPENSSL_STRING;
}
extern "C" {
    pub fn X509_email_free(sk: *mut stack_st_OPENSSL_STRING);
}
extern "C" {
    pub fn X509_get1_ocsp(x: *mut X509) -> *mut stack_st_OPENSSL_STRING;
}
extern "C" {
    pub fn X509_check_host(
        x: *mut X509,
        chk: *const ::aya_ebpf::cty::c_char,
        chklen: usize,
        flags: ::aya_ebpf::cty::c_uint,
        peername: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_email(
        x: *mut X509,
        chk: *const ::aya_ebpf::cty::c_char,
        chklen: usize,
        flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_ip(
        x: *mut X509,
        chk: *const ::aya_ebpf::cty::c_uchar,
        chklen: usize,
        flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_check_ip_asc(
        x: *mut X509,
        ipasc: *const ::aya_ebpf::cty::c_char,
        flags: ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn a2i_IPADDRESS(ipasc: *const ::aya_ebpf::cty::c_char) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn a2i_IPADDRESS_NC(ipasc: *const ::aya_ebpf::cty::c_char) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509V3_NAME_from_section(
        nm: *mut X509_NAME,
        dn_sk: *mut stack_st_CONF_VALUE,
        chtype: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509_POLICY_NODE_print(out: *mut BIO, node: *mut X509_POLICY_NODE, indent: ::aya_ebpf::cty::c_int);
}
pub type sk_X509_POLICY_NODE_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const X509_POLICY_NODE, b: *const *const X509_POLICY_NODE) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_X509_POLICY_NODE_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut X509_POLICY_NODE)>;
pub type sk_X509_POLICY_NODE_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const X509_POLICY_NODE) -> *mut X509_POLICY_NODE>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASRange_st {
    pub min: *mut ASN1_INTEGER,
    pub max: *mut ASN1_INTEGER,
}
pub type ASRange = ASRange_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIdOrRange_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub u: ASIdOrRange_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASIdOrRange_st__bindgen_ty_1 {
    pub id: *mut ASN1_INTEGER,
    pub range: *mut ASRange,
}
pub type ASIdOrRange = ASIdOrRange_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASIdOrRange {
    _unused: [u8; 0],
}
pub type sk_ASIdOrRange_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ASIdOrRange, b: *const *const ASIdOrRange) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASIdOrRange_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASIdOrRange)>;
pub type sk_ASIdOrRange_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASIdOrRange) -> *mut ASIdOrRange>;
pub type ASIdOrRanges = stack_st_ASIdOrRange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ASIdentifierChoice_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub u: ASIdentifierChoice_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ASIdentifierChoice_st__bindgen_ty_1 {
    pub inherit: *mut ASN1_NULL,
    pub asIdsOrRanges: *mut ASIdOrRanges,
}
pub type ASIdentifierChoice = ASIdentifierChoice_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASIdentifiers_st {
    pub asnum: *mut ASIdentifierChoice,
    pub rdi: *mut ASIdentifierChoice,
}
pub type ASIdentifiers = ASIdentifiers_st;
extern "C" {
    pub fn ASRange_new() -> *mut ASRange;
}
extern "C" {
    pub fn ASRange_free(a: *mut ASRange);
}
extern "C" {
    pub fn d2i_ASRange(
        a: *mut *mut ASRange,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASRange;
}
extern "C" {
    pub fn i2d_ASRange(a: *const ASRange, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASRange_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASIdOrRange_new() -> *mut ASIdOrRange;
}
extern "C" {
    pub fn ASIdOrRange_free(a: *mut ASIdOrRange);
}
extern "C" {
    pub fn d2i_ASIdOrRange(
        a: *mut *mut ASIdOrRange,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASIdOrRange;
}
extern "C" {
    pub fn i2d_ASIdOrRange(a: *const ASIdOrRange, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASIdOrRange_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASIdentifierChoice_new() -> *mut ASIdentifierChoice;
}
extern "C" {
    pub fn ASIdentifierChoice_free(a: *mut ASIdentifierChoice);
}
extern "C" {
    pub fn d2i_ASIdentifierChoice(
        a: *mut *mut ASIdentifierChoice,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASIdentifierChoice;
}
extern "C" {
    pub fn i2d_ASIdentifierChoice(
        a: *const ASIdentifierChoice,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASIdentifierChoice_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ASIdentifiers_new() -> *mut ASIdentifiers;
}
extern "C" {
    pub fn ASIdentifiers_free(a: *mut ASIdentifiers);
}
extern "C" {
    pub fn d2i_ASIdentifiers(
        a: *mut *mut ASIdentifiers,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ASIdentifiers;
}
extern "C" {
    pub fn i2d_ASIdentifiers(a: *const ASIdentifiers, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ASIdentifiers_it() -> *const ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPAddressRange_st {
    pub min: *mut ASN1_BIT_STRING,
    pub max: *mut ASN1_BIT_STRING,
}
pub type IPAddressRange = IPAddressRange_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IPAddressOrRange_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub u: IPAddressOrRange_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPAddressOrRange_st__bindgen_ty_1 {
    pub addressPrefix: *mut ASN1_BIT_STRING,
    pub addressRange: *mut IPAddressRange,
}
pub type IPAddressOrRange = IPAddressOrRange_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_IPAddressOrRange {
    _unused: [u8; 0],
}
pub type sk_IPAddressOrRange_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const IPAddressOrRange, b: *const *const IPAddressOrRange) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_IPAddressOrRange_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut IPAddressOrRange)>;
pub type sk_IPAddressOrRange_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const IPAddressOrRange) -> *mut IPAddressOrRange>;
pub type IPAddressOrRanges = stack_st_IPAddressOrRange;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IPAddressChoice_st {
    pub type_: ::aya_ebpf::cty::c_int,
    pub u: IPAddressChoice_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPAddressChoice_st__bindgen_ty_1 {
    pub inherit: *mut ASN1_NULL,
    pub addressesOrRanges: *mut IPAddressOrRanges,
}
pub type IPAddressChoice = IPAddressChoice_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPAddressFamily_st {
    pub addressFamily: *mut ASN1_OCTET_STRING,
    pub ipAddressChoice: *mut IPAddressChoice,
}
pub type IPAddressFamily = IPAddressFamily_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_IPAddressFamily {
    _unused: [u8; 0],
}
pub type sk_IPAddressFamily_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const IPAddressFamily, b: *const *const IPAddressFamily) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_IPAddressFamily_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut IPAddressFamily)>;
pub type sk_IPAddressFamily_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const IPAddressFamily) -> *mut IPAddressFamily>;
pub type IPAddrBlocks = stack_st_IPAddressFamily;
extern "C" {
    pub fn IPAddressRange_new() -> *mut IPAddressRange;
}
extern "C" {
    pub fn IPAddressRange_free(a: *mut IPAddressRange);
}
extern "C" {
    pub fn d2i_IPAddressRange(
        a: *mut *mut IPAddressRange,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut IPAddressRange;
}
extern "C" {
    pub fn i2d_IPAddressRange(
        a: *const IPAddressRange,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn IPAddressRange_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn IPAddressOrRange_new() -> *mut IPAddressOrRange;
}
extern "C" {
    pub fn IPAddressOrRange_free(a: *mut IPAddressOrRange);
}
extern "C" {
    pub fn d2i_IPAddressOrRange(
        a: *mut *mut IPAddressOrRange,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut IPAddressOrRange;
}
extern "C" {
    pub fn i2d_IPAddressOrRange(
        a: *const IPAddressOrRange,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn IPAddressOrRange_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn IPAddressChoice_new() -> *mut IPAddressChoice;
}
extern "C" {
    pub fn IPAddressChoice_free(a: *mut IPAddressChoice);
}
extern "C" {
    pub fn d2i_IPAddressChoice(
        a: *mut *mut IPAddressChoice,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut IPAddressChoice;
}
extern "C" {
    pub fn i2d_IPAddressChoice(
        a: *const IPAddressChoice,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn IPAddressChoice_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn IPAddressFamily_new() -> *mut IPAddressFamily;
}
extern "C" {
    pub fn IPAddressFamily_free(a: *mut IPAddressFamily);
}
extern "C" {
    pub fn d2i_IPAddressFamily(
        a: *mut *mut IPAddressFamily,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut IPAddressFamily;
}
extern "C" {
    pub fn i2d_IPAddressFamily(
        a: *const IPAddressFamily,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn IPAddressFamily_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn X509v3_asid_add_inherit(asid: *mut ASIdentifiers, which: ::aya_ebpf::cty::c_int) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_add_id_or_range(
        asid: *mut ASIdentifiers,
        which: ::aya_ebpf::cty::c_int,
        min: *mut ASN1_INTEGER,
        max: *mut ASN1_INTEGER,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_add_inherit(
        addr: *mut IPAddrBlocks,
        afi: ::aya_ebpf::cty::c_uint,
        safi: *const ::aya_ebpf::cty::c_uint,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_add_prefix(
        addr: *mut IPAddrBlocks,
        afi: ::aya_ebpf::cty::c_uint,
        safi: *const ::aya_ebpf::cty::c_uint,
        a: *mut ::aya_ebpf::cty::c_uchar,
        prefixlen: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_add_range(
        addr: *mut IPAddrBlocks,
        afi: ::aya_ebpf::cty::c_uint,
        safi: *const ::aya_ebpf::cty::c_uint,
        min: *mut ::aya_ebpf::cty::c_uchar,
        max: *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_get_afi(f: *const IPAddressFamily) -> ::aya_ebpf::cty::c_uint;
}
extern "C" {
    pub fn X509v3_addr_get_range(
        aor: *mut IPAddressOrRange,
        afi: ::aya_ebpf::cty::c_uint,
        min: *mut ::aya_ebpf::cty::c_uchar,
        max: *mut ::aya_ebpf::cty::c_uchar,
        length: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_is_canonical(asid: *mut ASIdentifiers) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_is_canonical(addr: *mut IPAddrBlocks) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_canonize(asid: *mut ASIdentifiers) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_canonize(addr: *mut IPAddrBlocks) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_inherits(asid: *mut ASIdentifiers) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_inherits(addr: *mut IPAddrBlocks) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_subset(a: *mut ASIdentifiers, b: *mut ASIdentifiers) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_subset(a: *mut IPAddrBlocks, b: *mut IPAddrBlocks) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_validate_path(arg1: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_validate_path(arg1: *mut X509_STORE_CTX) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_asid_validate_resource_set(
        chain: *mut stack_st_X509,
        ext: *mut ASIdentifiers,
        allow_inheritance: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn X509v3_addr_validate_resource_set(
        chain: *mut stack_st_X509,
        ext: *mut IPAddrBlocks,
        allow_inheritance: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_STRING {
    _unused: [u8; 0],
}
pub type sk_ASN1_STRING_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ASN1_STRING, b: *const *const ASN1_STRING) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ASN1_STRING_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ASN1_STRING)>;
pub type sk_ASN1_STRING_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const ASN1_STRING) -> *mut ASN1_STRING>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamingAuthority_st {
    _unused: [u8; 0],
}
pub type NAMING_AUTHORITY = NamingAuthority_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProfessionInfo_st {
    _unused: [u8; 0],
}
pub type PROFESSION_INFO = ProfessionInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Admissions_st {
    _unused: [u8; 0],
}
pub type ADMISSIONS = Admissions_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdmissionSyntax_st {
    _unused: [u8; 0],
}
pub type ADMISSION_SYNTAX = AdmissionSyntax_st;
extern "C" {
    pub fn NAMING_AUTHORITY_new() -> *mut NAMING_AUTHORITY;
}
extern "C" {
    pub fn NAMING_AUTHORITY_free(a: *mut NAMING_AUTHORITY);
}
extern "C" {
    pub fn d2i_NAMING_AUTHORITY(
        a: *mut *mut NAMING_AUTHORITY,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut NAMING_AUTHORITY;
}
extern "C" {
    pub fn i2d_NAMING_AUTHORITY(
        a: *const NAMING_AUTHORITY,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn NAMING_AUTHORITY_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn PROFESSION_INFO_new() -> *mut PROFESSION_INFO;
}
extern "C" {
    pub fn PROFESSION_INFO_free(a: *mut PROFESSION_INFO);
}
extern "C" {
    pub fn d2i_PROFESSION_INFO(
        a: *mut *mut PROFESSION_INFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut PROFESSION_INFO;
}
extern "C" {
    pub fn i2d_PROFESSION_INFO(
        a: *const PROFESSION_INFO,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn PROFESSION_INFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ADMISSIONS_new() -> *mut ADMISSIONS;
}
extern "C" {
    pub fn ADMISSIONS_free(a: *mut ADMISSIONS);
}
extern "C" {
    pub fn d2i_ADMISSIONS(
        a: *mut *mut ADMISSIONS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ADMISSIONS;
}
extern "C" {
    pub fn i2d_ADMISSIONS(a: *const ADMISSIONS, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ADMISSIONS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn ADMISSION_SYNTAX_new() -> *mut ADMISSION_SYNTAX;
}
extern "C" {
    pub fn ADMISSION_SYNTAX_free(a: *mut ADMISSION_SYNTAX);
}
extern "C" {
    pub fn d2i_ADMISSION_SYNTAX(
        a: *mut *mut ADMISSION_SYNTAX,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut ADMISSION_SYNTAX;
}
extern "C" {
    pub fn i2d_ADMISSION_SYNTAX(
        a: *const ADMISSION_SYNTAX,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ADMISSION_SYNTAX_it() -> *const ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_PROFESSION_INFO {
    _unused: [u8; 0],
}
pub type sk_PROFESSION_INFO_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const PROFESSION_INFO, b: *const *const PROFESSION_INFO) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_PROFESSION_INFO_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut PROFESSION_INFO)>;
pub type sk_PROFESSION_INFO_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const PROFESSION_INFO) -> *mut PROFESSION_INFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ADMISSIONS {
    _unused: [u8; 0],
}
pub type sk_ADMISSIONS_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const ADMISSIONS, b: *const *const ADMISSIONS) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_ADMISSIONS_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut ADMISSIONS)>;
pub type sk_ADMISSIONS_copyfunc = ::core::option::Option<unsafe extern "C" fn(a: *const ADMISSIONS) -> *mut ADMISSIONS>;
pub type PROFESSION_INFOS = stack_st_PROFESSION_INFO;
extern "C" {
    pub fn NAMING_AUTHORITY_get0_authorityId(n: *const NAMING_AUTHORITY) -> *const ASN1_OBJECT;
}
extern "C" {
    pub fn NAMING_AUTHORITY_get0_authorityURL(n: *const NAMING_AUTHORITY) -> *const ASN1_IA5STRING;
}
extern "C" {
    pub fn NAMING_AUTHORITY_get0_authorityText(n: *const NAMING_AUTHORITY) -> *const ASN1_STRING;
}
extern "C" {
    pub fn NAMING_AUTHORITY_set0_authorityId(n: *mut NAMING_AUTHORITY, namingAuthorityId: *mut ASN1_OBJECT);
}
extern "C" {
    pub fn NAMING_AUTHORITY_set0_authorityURL(n: *mut NAMING_AUTHORITY, namingAuthorityUrl: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn NAMING_AUTHORITY_set0_authorityText(n: *mut NAMING_AUTHORITY, namingAuthorityText: *mut ASN1_STRING);
}
extern "C" {
    pub fn ADMISSION_SYNTAX_get0_admissionAuthority(as_: *const ADMISSION_SYNTAX) -> *const GENERAL_NAME;
}
extern "C" {
    pub fn ADMISSION_SYNTAX_set0_admissionAuthority(as_: *mut ADMISSION_SYNTAX, aa: *mut GENERAL_NAME);
}
extern "C" {
    pub fn ADMISSION_SYNTAX_get0_contentsOfAdmissions(as_: *const ADMISSION_SYNTAX) -> *const stack_st_ADMISSIONS;
}
extern "C" {
    pub fn ADMISSION_SYNTAX_set0_contentsOfAdmissions(as_: *mut ADMISSION_SYNTAX, a: *mut stack_st_ADMISSIONS);
}
extern "C" {
    pub fn ADMISSIONS_get0_admissionAuthority(a: *const ADMISSIONS) -> *const GENERAL_NAME;
}
extern "C" {
    pub fn ADMISSIONS_set0_admissionAuthority(a: *mut ADMISSIONS, aa: *mut GENERAL_NAME);
}
extern "C" {
    pub fn ADMISSIONS_get0_namingAuthority(a: *const ADMISSIONS) -> *const NAMING_AUTHORITY;
}
extern "C" {
    pub fn ADMISSIONS_set0_namingAuthority(a: *mut ADMISSIONS, na: *mut NAMING_AUTHORITY);
}
extern "C" {
    pub fn ADMISSIONS_get0_professionInfos(a: *const ADMISSIONS) -> *const PROFESSION_INFOS;
}
extern "C" {
    pub fn ADMISSIONS_set0_professionInfos(a: *mut ADMISSIONS, pi: *mut PROFESSION_INFOS);
}
extern "C" {
    pub fn PROFESSION_INFO_get0_addProfessionInfo(pi: *const PROFESSION_INFO) -> *const ASN1_OCTET_STRING;
}
extern "C" {
    pub fn PROFESSION_INFO_set0_addProfessionInfo(pi: *mut PROFESSION_INFO, aos: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn PROFESSION_INFO_get0_namingAuthority(pi: *const PROFESSION_INFO) -> *const NAMING_AUTHORITY;
}
extern "C" {
    pub fn PROFESSION_INFO_set0_namingAuthority(pi: *mut PROFESSION_INFO, na: *mut NAMING_AUTHORITY);
}
extern "C" {
    pub fn PROFESSION_INFO_get0_professionItems(pi: *const PROFESSION_INFO) -> *const stack_st_ASN1_STRING;
}
extern "C" {
    pub fn PROFESSION_INFO_set0_professionItems(pi: *mut PROFESSION_INFO, as_: *mut stack_st_ASN1_STRING);
}
extern "C" {
    pub fn PROFESSION_INFO_get0_professionOIDs(pi: *const PROFESSION_INFO) -> *const stack_st_ASN1_OBJECT;
}
extern "C" {
    pub fn PROFESSION_INFO_set0_professionOIDs(pi: *mut PROFESSION_INFO, po: *mut stack_st_ASN1_OBJECT);
}
extern "C" {
    pub fn PROFESSION_INFO_get0_registrationNumber(pi: *const PROFESSION_INFO) -> *const ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn PROFESSION_INFO_set0_registrationNumber(pi: *mut PROFESSION_INFO, rn: *mut ASN1_PRINTABLESTRING);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_cert_id_st {
    _unused: [u8; 0],
}
pub type OCSP_CERTID = ocsp_cert_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_one_request_st {
    _unused: [u8; 0],
}
pub type OCSP_ONEREQ = ocsp_one_request_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_req_info_st {
    _unused: [u8; 0],
}
pub type OCSP_REQINFO = ocsp_req_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_signature_st {
    _unused: [u8; 0],
}
pub type OCSP_SIGNATURE = ocsp_signature_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_request_st {
    _unused: [u8; 0],
}
pub type OCSP_REQUEST = ocsp_request_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_CERTID {
    _unused: [u8; 0],
}
pub type sk_OCSP_CERTID_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const OCSP_CERTID, b: *const *const OCSP_CERTID) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OCSP_CERTID_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut OCSP_CERTID)>;
pub type sk_OCSP_CERTID_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const OCSP_CERTID) -> *mut OCSP_CERTID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_ONEREQ {
    _unused: [u8; 0],
}
pub type sk_OCSP_ONEREQ_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const OCSP_ONEREQ, b: *const *const OCSP_ONEREQ) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OCSP_ONEREQ_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut OCSP_ONEREQ)>;
pub type sk_OCSP_ONEREQ_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const OCSP_ONEREQ) -> *mut OCSP_ONEREQ>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_resp_bytes_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPBYTES = ocsp_resp_bytes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_RESPID {
    _unused: [u8; 0],
}
pub type sk_OCSP_RESPID_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const OCSP_RESPID, b: *const *const OCSP_RESPID) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OCSP_RESPID_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut OCSP_RESPID)>;
pub type sk_OCSP_RESPID_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const OCSP_RESPID) -> *mut OCSP_RESPID>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_revoked_info_st {
    _unused: [u8; 0],
}
pub type OCSP_REVOKEDINFO = ocsp_revoked_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_cert_status_st {
    _unused: [u8; 0],
}
pub type OCSP_CERTSTATUS = ocsp_cert_status_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_single_response_st {
    _unused: [u8; 0],
}
pub type OCSP_SINGLERESP = ocsp_single_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_SINGLERESP {
    _unused: [u8; 0],
}
pub type sk_OCSP_SINGLERESP_compfunc = ::core::option::Option<
    unsafe extern "C" fn(a: *const *const OCSP_SINGLERESP, b: *const *const OCSP_SINGLERESP) -> ::aya_ebpf::cty::c_int,
>;
pub type sk_OCSP_SINGLERESP_freefunc = ::core::option::Option<unsafe extern "C" fn(a: *mut OCSP_SINGLERESP)>;
pub type sk_OCSP_SINGLERESP_copyfunc =
    ::core::option::Option<unsafe extern "C" fn(a: *const OCSP_SINGLERESP) -> *mut OCSP_SINGLERESP>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_data_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPDATA = ocsp_response_data_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_basic_response_st {
    _unused: [u8; 0],
}
pub type OCSP_BASICRESP = ocsp_basic_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_crl_id_st {
    _unused: [u8; 0],
}
pub type OCSP_CRLID = ocsp_crl_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_service_locator_st {
    _unused: [u8; 0],
}
pub type OCSP_SERVICELOC = ocsp_service_locator_st;
extern "C" {
    pub fn OCSP_CERTID_dup(a: *const OCSP_CERTID) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_sendreq_new(
        io: *mut BIO,
        path: *const ::aya_ebpf::cty::c_char,
        req: *const OCSP_REQUEST,
        buf_size: ::aya_ebpf::cty::c_int,
    ) -> *mut OSSL_HTTP_REQ_CTX;
}
extern "C" {
    pub fn OCSP_sendreq_bio(
        b: *mut BIO,
        path: *const ::aya_ebpf::cty::c_char,
        req: *mut OCSP_REQUEST,
    ) -> *mut OCSP_RESPONSE;
}
pub type OCSP_REQ_CTX = OSSL_HTTP_REQ_CTX;
extern "C" {
    pub fn OCSP_cert_to_id(dgst: *const EVP_MD, subject: *const X509, issuer: *const X509) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_cert_id_new(
        dgst: *const EVP_MD,
        issuerName: *const X509_NAME,
        issuerKey: *const ASN1_BIT_STRING,
        serialNumber: *const ASN1_INTEGER,
    ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_request_add0_id(req: *mut OCSP_REQUEST, cid: *mut OCSP_CERTID) -> *mut OCSP_ONEREQ;
}
extern "C" {
    pub fn OCSP_request_add1_nonce(
        req: *mut OCSP_REQUEST,
        val: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_basic_add1_nonce(
        resp: *mut OCSP_BASICRESP,
        val: *mut ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_check_nonce(req: *mut OCSP_REQUEST, bs: *mut OCSP_BASICRESP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_copy_nonce(resp: *mut OCSP_BASICRESP, req: *mut OCSP_REQUEST) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_set1_name(req: *mut OCSP_REQUEST, nm: *const X509_NAME) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_add1_cert(req: *mut OCSP_REQUEST, cert: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_sign(
        req: *mut OCSP_REQUEST,
        signer: *mut X509,
        key: *mut EVP_PKEY,
        dgst: *const EVP_MD,
        certs: *mut stack_st_X509,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_response_status(resp: *mut OCSP_RESPONSE) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_response_get1_basic(resp: *mut OCSP_RESPONSE) -> *mut OCSP_BASICRESP;
}
extern "C" {
    pub fn OCSP_resp_get0_signature(bs: *const OCSP_BASICRESP) -> *const ASN1_OCTET_STRING;
}
extern "C" {
    pub fn OCSP_resp_get0_tbs_sigalg(bs: *const OCSP_BASICRESP) -> *const X509_ALGOR;
}
extern "C" {
    pub fn OCSP_resp_get0_respdata(bs: *const OCSP_BASICRESP) -> *const OCSP_RESPDATA;
}
extern "C" {
    pub fn OCSP_resp_get0_signer(
        bs: *mut OCSP_BASICRESP,
        signer: *mut *mut X509,
        extra_certs: *mut stack_st_X509,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_resp_count(bs: *mut OCSP_BASICRESP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_resp_get0(bs: *mut OCSP_BASICRESP, idx: ::aya_ebpf::cty::c_int) -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn OCSP_resp_get0_produced_at(bs: *const OCSP_BASICRESP) -> *const ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn OCSP_resp_get0_certs(bs: *const OCSP_BASICRESP) -> *const stack_st_X509;
}
extern "C" {
    pub fn OCSP_resp_get0_id(
        bs: *const OCSP_BASICRESP,
        pid: *mut *const ASN1_OCTET_STRING,
        pname: *mut *const X509_NAME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_resp_get1_id(
        bs: *const OCSP_BASICRESP,
        pid: *mut *mut ASN1_OCTET_STRING,
        pname: *mut *mut X509_NAME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_resp_find(
        bs: *mut OCSP_BASICRESP,
        id: *mut OCSP_CERTID,
        last: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_single_get0_status(
        single: *mut OCSP_SINGLERESP,
        reason: *mut ::aya_ebpf::cty::c_int,
        revtime: *mut *mut ASN1_GENERALIZEDTIME,
        thisupd: *mut *mut ASN1_GENERALIZEDTIME,
        nextupd: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_resp_find_status(
        bs: *mut OCSP_BASICRESP,
        id: *mut OCSP_CERTID,
        status: *mut ::aya_ebpf::cty::c_int,
        reason: *mut ::aya_ebpf::cty::c_int,
        revtime: *mut *mut ASN1_GENERALIZEDTIME,
        thisupd: *mut *mut ASN1_GENERALIZEDTIME,
        nextupd: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_check_validity(
        thisupd: *mut ASN1_GENERALIZEDTIME,
        nextupd: *mut ASN1_GENERALIZEDTIME,
        sec: ::aya_ebpf::cty::c_long,
        maxsec: ::aya_ebpf::cty::c_long,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_verify(
        req: *mut OCSP_REQUEST,
        certs: *mut stack_st_X509,
        store: *mut X509_STORE,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_id_issuer_cmp(a: *const OCSP_CERTID, b: *const OCSP_CERTID) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_id_cmp(a: *const OCSP_CERTID, b: *const OCSP_CERTID) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_onereq_count(req: *mut OCSP_REQUEST) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_onereq_get0(req: *mut OCSP_REQUEST, i: ::aya_ebpf::cty::c_int) -> *mut OCSP_ONEREQ;
}
extern "C" {
    pub fn OCSP_onereq_get0_id(one: *mut OCSP_ONEREQ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_id_get0_info(
        piNameHash: *mut *mut ASN1_OCTET_STRING,
        pmd: *mut *mut ASN1_OBJECT,
        pikeyHash: *mut *mut ASN1_OCTET_STRING,
        pserial: *mut *mut ASN1_INTEGER,
        cid: *mut OCSP_CERTID,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_request_is_signed(req: *mut OCSP_REQUEST) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_response_create(status: ::aya_ebpf::cty::c_int, bs: *mut OCSP_BASICRESP) -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn OCSP_basic_add1_status(
        rsp: *mut OCSP_BASICRESP,
        cid: *mut OCSP_CERTID,
        status: ::aya_ebpf::cty::c_int,
        reason: ::aya_ebpf::cty::c_int,
        revtime: *mut ASN1_TIME,
        thisupd: *mut ASN1_TIME,
        nextupd: *mut ASN1_TIME,
    ) -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn OCSP_basic_add1_cert(resp: *mut OCSP_BASICRESP, cert: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_basic_sign(
        brsp: *mut OCSP_BASICRESP,
        signer: *mut X509,
        key: *mut EVP_PKEY,
        dgst: *const EVP_MD,
        certs: *mut stack_st_X509,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_basic_sign_ctx(
        brsp: *mut OCSP_BASICRESP,
        signer: *mut X509,
        ctx: *mut EVP_MD_CTX,
        certs: *mut stack_st_X509,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPID_set_by_name(respid: *mut OCSP_RESPID, cert: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPID_set_by_key_ex(
        respid: *mut OCSP_RESPID,
        cert: *mut X509,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPID_set_by_key(respid: *mut OCSP_RESPID, cert: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPID_match_ex(
        respid: *mut OCSP_RESPID,
        cert: *mut X509,
        libctx: *mut OSSL_LIB_CTX,
        propq: *const ::aya_ebpf::cty::c_char,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPID_match(respid: *mut OCSP_RESPID, cert: *mut X509) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_crlID_new(
        url: *const ::aya_ebpf::cty::c_char,
        n: *mut ::aya_ebpf::cty::c_long,
        tim: *mut ::aya_ebpf::cty::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_accept_responses_new(oids: *mut *mut ::aya_ebpf::cty::c_char) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_archive_cutoff_new(tim: *mut ::aya_ebpf::cty::c_char) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_url_svcloc_new(
        issuer: *const X509_NAME,
        urls: *mut *const ::aya_ebpf::cty::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_REQUEST_get_ext_count(x: *mut OCSP_REQUEST) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQUEST_get_ext_by_NID(
        x: *mut OCSP_REQUEST,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQUEST_get_ext_by_OBJ(
        x: *mut OCSP_REQUEST,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQUEST_get_ext_by_critical(
        x: *mut OCSP_REQUEST,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQUEST_get_ext(x: *mut OCSP_REQUEST, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_REQUEST_delete_ext(x: *mut OCSP_REQUEST, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_REQUEST_get1_ext_d2i(
        x: *mut OCSP_REQUEST,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OCSP_REQUEST_add1_ext_i2d(
        x: *mut OCSP_REQUEST,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQUEST_add_ext(
        x: *mut OCSP_REQUEST,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_get_ext_count(x: *mut OCSP_ONEREQ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_get_ext_by_NID(
        x: *mut OCSP_ONEREQ,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_get_ext_by_OBJ(
        x: *mut OCSP_ONEREQ,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_get_ext_by_critical(
        x: *mut OCSP_ONEREQ,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_get_ext(x: *mut OCSP_ONEREQ, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_ONEREQ_delete_ext(x: *mut OCSP_ONEREQ, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_ONEREQ_get1_ext_d2i(
        x: *mut OCSP_ONEREQ,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OCSP_ONEREQ_add1_ext_i2d(
        x: *mut OCSP_ONEREQ,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_add_ext(
        x: *mut OCSP_ONEREQ,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext_count(x: *mut OCSP_BASICRESP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext_by_NID(
        x: *mut OCSP_BASICRESP,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext_by_OBJ(
        x: *mut OCSP_BASICRESP,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext_by_critical(
        x: *mut OCSP_BASICRESP,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext(x: *mut OCSP_BASICRESP, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_BASICRESP_delete_ext(x: *mut OCSP_BASICRESP, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_BASICRESP_get1_ext_d2i(
        x: *mut OCSP_BASICRESP,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OCSP_BASICRESP_add1_ext_i2d(
        x: *mut OCSP_BASICRESP,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_add_ext(
        x: *mut OCSP_BASICRESP,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext_count(x: *mut OCSP_SINGLERESP) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext_by_NID(
        x: *mut OCSP_SINGLERESP,
        nid: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext_by_OBJ(
        x: *mut OCSP_SINGLERESP,
        obj: *const ASN1_OBJECT,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext_by_critical(
        x: *mut OCSP_SINGLERESP,
        crit: ::aya_ebpf::cty::c_int,
        lastpos: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext(x: *mut OCSP_SINGLERESP, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_SINGLERESP_delete_ext(x: *mut OCSP_SINGLERESP, loc: ::aya_ebpf::cty::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get1_ext_d2i(
        x: *mut OCSP_SINGLERESP,
        nid: ::aya_ebpf::cty::c_int,
        crit: *mut ::aya_ebpf::cty::c_int,
        idx: *mut ::aya_ebpf::cty::c_int,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn OCSP_SINGLERESP_add1_ext_i2d(
        x: *mut OCSP_SINGLERESP,
        nid: ::aya_ebpf::cty::c_int,
        value: *mut ::aya_ebpf::cty::c_void,
        crit: ::aya_ebpf::cty::c_int,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_add_ext(
        x: *mut OCSP_SINGLERESP,
        ex: *mut X509_EXTENSION,
        loc: ::aya_ebpf::cty::c_int,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get0_id(x: *const OCSP_SINGLERESP) -> *const OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_SINGLERESP_new() -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn OCSP_SINGLERESP_free(a: *mut OCSP_SINGLERESP);
}
extern "C" {
    pub fn d2i_OCSP_SINGLERESP(
        a: *mut *mut OCSP_SINGLERESP,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn i2d_OCSP_SINGLERESP(
        a: *const OCSP_SINGLERESP,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_CERTSTATUS_new() -> *mut OCSP_CERTSTATUS;
}
extern "C" {
    pub fn OCSP_CERTSTATUS_free(a: *mut OCSP_CERTSTATUS);
}
extern "C" {
    pub fn d2i_OCSP_CERTSTATUS(
        a: *mut *mut OCSP_CERTSTATUS,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_CERTSTATUS;
}
extern "C" {
    pub fn i2d_OCSP_CERTSTATUS(
        a: *const OCSP_CERTSTATUS,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_CERTSTATUS_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_REVOKEDINFO_new() -> *mut OCSP_REVOKEDINFO;
}
extern "C" {
    pub fn OCSP_REVOKEDINFO_free(a: *mut OCSP_REVOKEDINFO);
}
extern "C" {
    pub fn d2i_OCSP_REVOKEDINFO(
        a: *mut *mut OCSP_REVOKEDINFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_REVOKEDINFO;
}
extern "C" {
    pub fn i2d_OCSP_REVOKEDINFO(
        a: *const OCSP_REVOKEDINFO,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REVOKEDINFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_BASICRESP_new() -> *mut OCSP_BASICRESP;
}
extern "C" {
    pub fn OCSP_BASICRESP_free(a: *mut OCSP_BASICRESP);
}
extern "C" {
    pub fn d2i_OCSP_BASICRESP(
        a: *mut *mut OCSP_BASICRESP,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_BASICRESP;
}
extern "C" {
    pub fn i2d_OCSP_BASICRESP(
        a: *const OCSP_BASICRESP,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_RESPDATA_new() -> *mut OCSP_RESPDATA;
}
extern "C" {
    pub fn OCSP_RESPDATA_free(a: *mut OCSP_RESPDATA);
}
extern "C" {
    pub fn d2i_OCSP_RESPDATA(
        a: *mut *mut OCSP_RESPDATA,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_RESPDATA;
}
extern "C" {
    pub fn i2d_OCSP_RESPDATA(a: *const OCSP_RESPDATA, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPDATA_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_RESPID_new() -> *mut OCSP_RESPID;
}
extern "C" {
    pub fn OCSP_RESPID_free(a: *mut OCSP_RESPID);
}
extern "C" {
    pub fn d2i_OCSP_RESPID(
        a: *mut *mut OCSP_RESPID,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_RESPID;
}
extern "C" {
    pub fn i2d_OCSP_RESPID(a: *const OCSP_RESPID, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPID_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_RESPONSE_new() -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn OCSP_RESPONSE_free(a: *mut OCSP_RESPONSE);
}
extern "C" {
    pub fn d2i_OCSP_RESPONSE(
        a: *mut *mut OCSP_RESPONSE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn i2d_OCSP_RESPONSE(a: *const OCSP_RESPONSE, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPONSE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_RESPBYTES_new() -> *mut OCSP_RESPBYTES;
}
extern "C" {
    pub fn OCSP_RESPBYTES_free(a: *mut OCSP_RESPBYTES);
}
extern "C" {
    pub fn d2i_OCSP_RESPBYTES(
        a: *mut *mut OCSP_RESPBYTES,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_RESPBYTES;
}
extern "C" {
    pub fn i2d_OCSP_RESPBYTES(
        a: *const OCSP_RESPBYTES,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPBYTES_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_ONEREQ_new() -> *mut OCSP_ONEREQ;
}
extern "C" {
    pub fn OCSP_ONEREQ_free(a: *mut OCSP_ONEREQ);
}
extern "C" {
    pub fn d2i_OCSP_ONEREQ(
        a: *mut *mut OCSP_ONEREQ,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_ONEREQ;
}
extern "C" {
    pub fn i2d_OCSP_ONEREQ(a: *const OCSP_ONEREQ, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_ONEREQ_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_CERTID_new() -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_CERTID_free(a: *mut OCSP_CERTID);
}
extern "C" {
    pub fn d2i_OCSP_CERTID(
        a: *mut *mut OCSP_CERTID,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn i2d_OCSP_CERTID(a: *const OCSP_CERTID, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_CERTID_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_REQUEST_new() -> *mut OCSP_REQUEST;
}
extern "C" {
    pub fn OCSP_REQUEST_free(a: *mut OCSP_REQUEST);
}
extern "C" {
    pub fn d2i_OCSP_REQUEST(
        a: *mut *mut OCSP_REQUEST,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_REQUEST;
}
extern "C" {
    pub fn i2d_OCSP_REQUEST(a: *const OCSP_REQUEST, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQUEST_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_SIGNATURE_new() -> *mut OCSP_SIGNATURE;
}
extern "C" {
    pub fn OCSP_SIGNATURE_free(a: *mut OCSP_SIGNATURE);
}
extern "C" {
    pub fn d2i_OCSP_SIGNATURE(
        a: *mut *mut OCSP_SIGNATURE,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_SIGNATURE;
}
extern "C" {
    pub fn i2d_OCSP_SIGNATURE(
        a: *const OCSP_SIGNATURE,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SIGNATURE_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_REQINFO_new() -> *mut OCSP_REQINFO;
}
extern "C" {
    pub fn OCSP_REQINFO_free(a: *mut OCSP_REQINFO);
}
extern "C" {
    pub fn d2i_OCSP_REQINFO(
        a: *mut *mut OCSP_REQINFO,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_REQINFO;
}
extern "C" {
    pub fn i2d_OCSP_REQINFO(a: *const OCSP_REQINFO, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_REQINFO_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_CRLID_new() -> *mut OCSP_CRLID;
}
extern "C" {
    pub fn OCSP_CRLID_free(a: *mut OCSP_CRLID);
}
extern "C" {
    pub fn d2i_OCSP_CRLID(
        a: *mut *mut OCSP_CRLID,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_CRLID;
}
extern "C" {
    pub fn i2d_OCSP_CRLID(a: *const OCSP_CRLID, out: *mut *mut ::aya_ebpf::cty::c_uchar) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_CRLID_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_SERVICELOC_new() -> *mut OCSP_SERVICELOC;
}
extern "C" {
    pub fn OCSP_SERVICELOC_free(a: *mut OCSP_SERVICELOC);
}
extern "C" {
    pub fn d2i_OCSP_SERVICELOC(
        a: *mut *mut OCSP_SERVICELOC,
        in_: *mut *const ::aya_ebpf::cty::c_uchar,
        len: ::aya_ebpf::cty::c_long,
    ) -> *mut OCSP_SERVICELOC;
}
extern "C" {
    pub fn i2d_OCSP_SERVICELOC(
        a: *const OCSP_SERVICELOC,
        out: *mut *mut ::aya_ebpf::cty::c_uchar,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_SERVICELOC_it() -> *const ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_response_status_str(s: ::aya_ebpf::cty::c_long) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OCSP_cert_status_str(s: ::aya_ebpf::cty::c_long) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OCSP_crl_reason_str(s: ::aya_ebpf::cty::c_long) -> *const ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn OCSP_REQUEST_print(
        bp: *mut BIO,
        a: *mut OCSP_REQUEST,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_RESPONSE_print(
        bp: *mut BIO,
        o: *mut OCSP_RESPONSE,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn OCSP_basic_verify(
        bs: *mut OCSP_BASICRESP,
        certs: *mut stack_st_X509,
        st: *mut X509_STORE,
        flags: ::aya_ebpf::cty::c_ulong,
    ) -> ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_ocsp_s {
    _unused: [u8; 0],
}
pub type ngx_ssl_ocsp_t = ngx_ssl_ocsp_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_s {
    pub ctx: *mut SSL_CTX,
    pub log: *mut ngx_log_t,
    pub buffer_size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_connection_s {
    pub connection: *mut SSL,
    pub session_ctx: *mut SSL_CTX,
    pub last: ngx_int_t,
    pub buf: *mut ngx_buf_t,
    pub buffer_size: usize,
    pub handler: ngx_connection_handler_pt,
    pub session: *mut SSL_SESSION,
    pub save_session: ngx_connection_handler_pt,
    pub saved_read_handler: ngx_event_handler_pt,
    pub saved_write_handler: ngx_event_handler_pt,
    pub ocsp: *mut ngx_ssl_ocsp_t,
    pub early_buf: u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl ngx_ssl_connection_s {
    #[inline]
    pub fn handshaked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_handshaked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn handshake_rejected(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_handshake_rejected(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn renegotiation(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_renegotiation(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn buffer(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_buffer(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sendfile(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_wait_shutdown(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_wait_shutdown(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_send_shutdown(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_send_shutdown(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shutdown_without_free(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shutdown_without_free(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn handshake_buffer_set(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_handshake_buffer_set(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn try_early_data(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_try_early_data(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_early(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_early(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_ocsp(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_ocsp(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_preread(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_early_preread(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        handshaked: ::aya_ebpf::cty::c_uint,
        handshake_rejected: ::aya_ebpf::cty::c_uint,
        renegotiation: ::aya_ebpf::cty::c_uint,
        buffer: ::aya_ebpf::cty::c_uint,
        sendfile: ::aya_ebpf::cty::c_uint,
        no_wait_shutdown: ::aya_ebpf::cty::c_uint,
        no_send_shutdown: ::aya_ebpf::cty::c_uint,
        shutdown_without_free: ::aya_ebpf::cty::c_uint,
        handshake_buffer_set: ::aya_ebpf::cty::c_uint,
        try_early_data: ::aya_ebpf::cty::c_uint,
        in_early: ::aya_ebpf::cty::c_uint,
        in_ocsp: ::aya_ebpf::cty::c_uint,
        early_preread: ::aya_ebpf::cty::c_uint,
        write_blocked: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let handshaked: u32 = unsafe { ::core::mem::transmute(handshaked) };
            handshaked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let handshake_rejected: u32 = unsafe { ::core::mem::transmute(handshake_rejected) };
            handshake_rejected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let renegotiation: u32 = unsafe { ::core::mem::transmute(renegotiation) };
            renegotiation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let buffer: u32 = unsafe { ::core::mem::transmute(buffer) };
            buffer as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sendfile: u32 = unsafe { ::core::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let no_wait_shutdown: u32 = unsafe { ::core::mem::transmute(no_wait_shutdown) };
            no_wait_shutdown as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_send_shutdown: u32 = unsafe { ::core::mem::transmute(no_send_shutdown) };
            no_send_shutdown as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let shutdown_without_free: u32 = unsafe { ::core::mem::transmute(shutdown_without_free) };
            shutdown_without_free as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let handshake_buffer_set: u32 = unsafe { ::core::mem::transmute(handshake_buffer_set) };
            handshake_buffer_set as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let try_early_data: u32 = unsafe { ::core::mem::transmute(try_early_data) };
            try_early_data as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let in_early: u32 = unsafe { ::core::mem::transmute(in_early) };
            in_early as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let in_ocsp: u32 = unsafe { ::core::mem::transmute(in_ocsp) };
            in_ocsp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let early_preread: u32 = unsafe { ::core::mem::transmute(early_preread) };
            early_preread as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let write_blocked: u32 = unsafe { ::core::mem::transmute(write_blocked) };
            write_blocked as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_ssl_sess_id_t = ngx_ssl_sess_id_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_sess_id_s {
    pub node: ngx_rbtree_node_t,
    pub id: *mut u_char,
    pub len: usize,
    pub session: *mut u_char,
    pub queue: ngx_queue_t,
    pub expire: time_t,
    pub stub: *mut ::aya_ebpf::cty::c_void,
    pub sess_id: [u_char; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_session_cache_t {
    pub session_rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub expire_queue: ngx_queue_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_ssl_session_ticket_key_t {
    pub size: usize,
    pub name: [u_char; 16usize],
    pub hmac_key: [u_char; 32usize],
    pub aes_key: [u_char; 32usize],
}
extern "C" {
    pub fn ngx_ssl_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_create(ssl: *mut ngx_ssl_t, protocols: ngx_uint_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_certificates(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        certs: *mut ngx_array_t,
        keys: *mut ngx_array_t,
        passwords: *mut ngx_array_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_certificate(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        cert: *mut ngx_str_t,
        key: *mut ngx_str_t,
        passwords: *mut ngx_array_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_connection_certificate(
        c: *mut ngx_connection_t,
        pool: *mut ngx_pool_t,
        cert: *mut ngx_str_t,
        key: *mut ngx_str_t,
        passwords: *mut ngx_array_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ciphers(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        ciphers: *mut ngx_str_t,
        prefer_server_ciphers: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_client_certificate(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        cert: *mut ngx_str_t,
        depth: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_trusted_certificate(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        cert: *mut ngx_str_t,
        depth: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_crl(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, crl: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_stapling(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        file: *mut ngx_str_t,
        responder: *mut ngx_str_t,
        verify: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_stapling_resolver(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        resolver: *mut ngx_resolver_t,
        resolver_timeout: ngx_msec_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ocsp(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        responder: *mut ngx_str_t,
        depth: ngx_uint_t,
        shm_zone: *mut ngx_shm_zone_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ocsp_resolver(
        cf: *mut ngx_conf_t,
        ssl: *mut ngx_ssl_t,
        resolver: *mut ngx_resolver_t,
        resolver_timeout: ngx_msec_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ocsp_validate(c: *mut ngx_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ocsp_get_status(c: *mut ngx_connection_t, s: *mut *const ::aya_ebpf::cty::c_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ocsp_cleanup(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_ssl_ocsp_cache_init(shm_zone: *mut ngx_shm_zone_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_read_password_file(cf: *mut ngx_conf_t, file: *mut ngx_str_t) -> *mut ngx_array_t;
}
extern "C" {
    pub fn ngx_ssl_preserve_passwords(cf: *mut ngx_conf_t, passwords: *mut ngx_array_t) -> *mut ngx_array_t;
}
extern "C" {
    pub fn ngx_ssl_dhparam(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, file: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_ecdh_curve(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_early_data(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, enable: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_conf_commands(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, commands: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_client_session_cache(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, enable: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_session_cache(
        ssl: *mut ngx_ssl_t,
        sess_ctx: *mut ngx_str_t,
        certificates: *mut ngx_array_t,
        builtin_session_cache: isize,
        shm_zone: *mut ngx_shm_zone_t,
        timeout: time_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_session_ticket_keys(cf: *mut ngx_conf_t, ssl: *mut ngx_ssl_t, paths: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_session_cache_init(shm_zone: *mut ngx_shm_zone_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_create_connection(ssl: *mut ngx_ssl_t, c: *mut ngx_connection_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_remove_cached_session(ssl: *mut SSL_CTX, sess: *mut SSL_SESSION);
}
extern "C" {
    pub fn ngx_ssl_set_session(c: *mut ngx_connection_t, session: *mut SSL_SESSION) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_session(c: *mut ngx_connection_t) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn ngx_ssl_get0_session(c: *mut ngx_connection_t) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn ngx_ssl_check_host(c: *mut ngx_connection_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_protocol(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_cipher_name(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_ciphers(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_curves(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_session_id(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_session_reused(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_early_data(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_server_name(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_alpn_protocol(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_raw_certificate(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_certificate(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_escaped_certificate(
        c: *mut ngx_connection_t,
        pool: *mut ngx_pool_t,
        s: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_subject_dn(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_issuer_dn(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_subject_dn_legacy(
        c: *mut ngx_connection_t,
        pool: *mut ngx_pool_t,
        s: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_issuer_dn_legacy(
        c: *mut ngx_connection_t,
        pool: *mut ngx_pool_t,
        s: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_serial_number(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_fingerprint(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_client_verify(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_client_v_start(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_client_v_end(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_get_client_v_remain(c: *mut ngx_connection_t, pool: *mut ngx_pool_t, s: *mut ngx_str_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_handshake(c: *mut ngx_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize;
}
extern "C" {
    pub fn ngx_ssl_write(c: *mut ngx_connection_t, data: *mut u_char, size: usize) -> isize;
}
extern "C" {
    pub fn ngx_ssl_recv_chain(c: *mut ngx_connection_t, cl: *mut ngx_chain_t, limit: off_t) -> isize;
}
extern "C" {
    pub fn ngx_ssl_send_chain(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_ssl_free_buffer(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_ssl_shutdown(c: *mut ngx_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_ssl_error(level: ngx_uint_t, log: *mut ngx_log_t, err: ngx_err_t, fmt: *mut ::aya_ebpf::cty::c_char, ...);
}
extern "C" {
    pub fn ngx_ssl_cleanup_ctx(data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub static mut ngx_ssl_connection_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_server_conf_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_session_cache_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_session_ticket_keys_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_ocsp_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_certificate_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_next_certificate_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_certificate_name_index: ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub static mut ngx_ssl_stapling_index: ::aya_ebpf::cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_cache_manager_ctx_t {
    pub handler: ngx_event_handler_pt,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub delay: ngx_msec_t,
}
extern "C" {
    pub fn ngx_master_process_cycle(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_single_process_cycle(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_process: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_worker: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_new_binary: ngx_pid_t;
}
extern "C" {
    pub static mut ngx_inherited: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_daemonized: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_exiting: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_is_privileged_agent: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_reap: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_sigio: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_sigalrm: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_quit: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_debug_quit: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_terminate: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_noaccept: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_reconfigure: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_reopen: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_change_binary: sig_atomic_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_command_s {
    pub name: ngx_str_t,
    pub type_: ngx_uint_t,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            cmd: *mut ngx_command_t,
            conf: *mut ::aya_ebpf::cty::c_void,
        ) -> *mut ::aya_ebpf::cty::c_char,
    >,
    pub conf: ngx_uint_t,
    pub offset: ngx_uint_t,
    pub post: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_s {
    pub fd: ngx_fd_t,
    pub name: ngx_str_t,
    pub flush: ::core::option::Option<unsafe extern "C" fn(file: *mut ngx_open_file_t, log: *mut ngx_log_t)>,
    pub data: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_file_t {
    pub file: ngx_file_t,
    pub buffer: *mut ngx_buf_t,
    pub dump: *mut ngx_buf_t,
    pub line: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_dump_t {
    pub name: ngx_str_t,
    pub buffer: *mut ngx_buf_t,
}
pub type ngx_conf_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        cf: *mut ngx_conf_t,
        dummy: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_s {
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub args: *mut ngx_array_t,
    pub cycle: *mut ngx_cycle_t,
    pub pool: *mut ngx_pool_t,
    pub temp_pool: *mut ngx_pool_t,
    pub conf_file: *mut ngx_conf_file_t,
    pub log: *mut ngx_log_t,
    pub ctx: *mut ::aya_ebpf::cty::c_void,
    pub module_type: ngx_uint_t,
    pub cmd_type: ngx_uint_t,
    pub handler: ngx_conf_handler_pt,
    pub handler_conf: *mut ::aya_ebpf::cty::c_void,
}
pub type ngx_conf_post_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        cf: *mut ngx_conf_t,
        data: *mut ::aya_ebpf::cty::c_void,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_post_t {
    pub post_handler: ngx_conf_post_handler_pt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_deprecated_t {
    pub post_handler: ngx_conf_post_handler_pt,
    pub old_name: *mut ::aya_ebpf::cty::c_char,
    pub new_name: *mut ::aya_ebpf::cty::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_num_bounds_t {
    pub post_handler: ngx_conf_post_handler_pt,
    pub low: ngx_int_t,
    pub high: ngx_int_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_enum_t {
    pub name: ngx_str_t,
    pub value: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_conf_bitmask_t {
    pub name: ngx_str_t,
    pub mask: ngx_uint_t,
}
extern "C" {
    pub fn ngx_conf_deprecated(
        cf: *mut ngx_conf_t,
        post: *mut ::aya_ebpf::cty::c_void,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_check_num_bounds(
        cf: *mut ngx_conf_t,
        post: *mut ::aya_ebpf::cty::c_void,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_param(cf: *mut ngx_conf_t) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_parse(cf: *mut ngx_conf_t, filename: *mut ngx_str_t) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_include(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_full_name(cycle: *mut ngx_cycle_t, name: *mut ngx_str_t, conf_prefix: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_conf_open_file(cycle: *mut ngx_cycle_t, name: *mut ngx_str_t) -> *mut ngx_open_file_t;
}
extern "C" {
    pub fn ngx_conf_log_error(
        level: ngx_uint_t,
        cf: *mut ngx_conf_t,
        err: ngx_err_t,
        fmt: *const ::aya_ebpf::cty::c_char,
        ...
    );
}
extern "C" {
    pub fn ngx_conf_set_flag_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_str_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_str_array_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_keyval_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_num_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_size_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_off_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_msec_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_sec_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_bufs_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_enum_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_conf_set_bitmask_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_module_s {
    pub ctx_index: ngx_uint_t,
    pub index: ngx_uint_t,
    pub name: *mut ::aya_ebpf::cty::c_char,
    pub spare0: ngx_uint_t,
    pub spare1: ngx_uint_t,
    pub version: ngx_uint_t,
    pub signature: *const ::aya_ebpf::cty::c_char,
    pub ctx: *mut ::aya_ebpf::cty::c_void,
    pub commands: *mut ngx_command_t,
    pub type_: ngx_uint_t,
    pub init_master: ::core::option::Option<unsafe extern "C" fn(log: *mut ngx_log_t) -> ngx_int_t>,
    pub init_module: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub init_process: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub init_thread: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> ngx_int_t>,
    pub exit_thread: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub exit_process: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub exit_master: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    pub spare_hook0: usize,
    pub spare_hook1: usize,
    pub spare_hook2: usize,
    pub spare_hook3: usize,
    pub spare_hook4: usize,
    pub spare_hook5: usize,
    pub spare_hook6: usize,
    pub spare_hook7: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_core_module_t {
    pub name: ngx_str_t,
    pub create_conf:
        ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> *mut ::aya_ebpf::cty::c_void>,
    pub init_conf: ::core::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, conf: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_char,
    >,
}
extern "C" {
    pub fn ngx_preinit_modules() -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cycle_modules(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_init_modules(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_count_modules(cycle: *mut ngx_cycle_t, type_: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_add_module(
        cf: *mut ngx_conf_t,
        file: *mut ngx_str_t,
        module: *mut ngx_module_t,
        order: *mut *mut ::aya_ebpf::cty::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_modules: [*mut ngx_module_t; 0usize];
}
extern "C" {
    pub static mut ngx_max_module: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_module_names: [*mut ::aya_ebpf::cty::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_info_t {
    pub fd: ngx_fd_t,
    pub uniq: ngx_file_uniq_t,
    pub mtime: time_t,
    pub size: off_t,
    pub fs_size: off_t,
    pub directio: off_t,
    pub read_ahead: usize,
    pub err: ngx_err_t,
    pub failed: *mut ::aya_ebpf::cty::c_char,
    pub valid: time_t,
    pub min_uses: ngx_uint_t,
    pub disable_symlinks_from: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_open_file_info_t {
    #[inline]
    pub fn disable_symlinks(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_disable_symlinks(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn test_dir(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test_dir(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test_only(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test_only(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errors(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_errors(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn events(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_events(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dir(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dir(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_link(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_link(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_exec(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_exec(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_directio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_directio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_symlinks: ::aya_ebpf::cty::c_uint,
        test_dir: ::aya_ebpf::cty::c_uint,
        test_only: ::aya_ebpf::cty::c_uint,
        log: ::aya_ebpf::cty::c_uint,
        errors: ::aya_ebpf::cty::c_uint,
        events: ::aya_ebpf::cty::c_uint,
        is_dir: ::aya_ebpf::cty::c_uint,
        is_file: ::aya_ebpf::cty::c_uint,
        is_link: ::aya_ebpf::cty::c_uint,
        is_exec: ::aya_ebpf::cty::c_uint,
        is_directio: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let disable_symlinks: u32 = unsafe { ::core::mem::transmute(disable_symlinks) };
            disable_symlinks as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test_dir: u32 = unsafe { ::core::mem::transmute(test_dir) };
            test_dir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let test_only: u32 = unsafe { ::core::mem::transmute(test_only) };
            test_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let log: u32 = unsafe { ::core::mem::transmute(log) };
            log as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let errors: u32 = unsafe { ::core::mem::transmute(errors) };
            errors as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let events: u32 = unsafe { ::core::mem::transmute(events) };
            events as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_dir: u32 = unsafe { ::core::mem::transmute(is_dir) };
            is_dir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let is_file: u32 = unsafe { ::core::mem::transmute(is_file) };
            is_file as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let is_link: u32 = unsafe { ::core::mem::transmute(is_link) };
            is_link as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let is_exec: u32 = unsafe { ::core::mem::transmute(is_exec) };
            is_exec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let is_directio: u32 = unsafe { ::core::mem::transmute(is_directio) };
            is_directio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_cached_open_file_t = ngx_cached_open_file_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_cached_open_file_s {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub name: *mut u_char,
    pub created: time_t,
    pub accessed: time_t,
    pub fd: ngx_fd_t,
    pub uniq: ngx_file_uniq_t,
    pub mtime: time_t,
    pub size: off_t,
    pub err: ngx_err_t,
    pub uses: u32,
    pub disable_symlinks_from: usize,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
    pub event: *mut ngx_event_t,
}
impl ngx_cached_open_file_s {
    #[inline]
    pub fn disable_symlinks(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_disable_symlinks(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn count(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn close(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_event(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_event(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_dir(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_dir(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_link(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_link(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_exec(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_exec(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_directio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_directio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_symlinks: ::aya_ebpf::cty::c_uint,
        count: ::aya_ebpf::cty::c_uint,
        close: ::aya_ebpf::cty::c_uint,
        use_event: ::aya_ebpf::cty::c_uint,
        is_dir: ::aya_ebpf::cty::c_uint,
        is_file: ::aya_ebpf::cty::c_uint,
        is_link: ::aya_ebpf::cty::c_uint,
        is_exec: ::aya_ebpf::cty::c_uint,
        is_directio: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let disable_symlinks: u32 = unsafe { ::core::mem::transmute(disable_symlinks) };
            disable_symlinks as u64
        });
        __bindgen_bitfield_unit.set(2usize, 24u8, {
            let count: u32 = unsafe { ::core::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let close: u32 = unsafe { ::core::mem::transmute(close) };
            close as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let use_event: u32 = unsafe { ::core::mem::transmute(use_event) };
            use_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let is_dir: u32 = unsafe { ::core::mem::transmute(is_dir) };
            is_dir as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let is_file: u32 = unsafe { ::core::mem::transmute(is_file) };
            is_file as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let is_link: u32 = unsafe { ::core::mem::transmute(is_link) };
            is_link as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_exec: u32 = unsafe { ::core::mem::transmute(is_exec) };
            is_exec as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let is_directio: u32 = unsafe { ::core::mem::transmute(is_directio) };
            is_directio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_t {
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub expire_queue: ngx_queue_t,
    pub current: ngx_uint_t,
    pub max: ngx_uint_t,
    pub inactive: time_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_cleanup_t {
    pub cache: *mut ngx_open_file_cache_t,
    pub file: *mut ngx_cached_open_file_t,
    pub min_uses: ngx_uint_t,
    pub log: *mut ngx_log_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_open_file_cache_event_t {
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub read: *mut ngx_event_t,
    pub write: *mut ngx_event_t,
    pub fd: ngx_fd_t,
    pub file: *mut ngx_cached_open_file_t,
    pub cache: *mut ngx_open_file_cache_t,
}
extern "C" {
    pub fn ngx_open_file_cache_init(
        pool: *mut ngx_pool_t,
        max: ngx_uint_t,
        inactive: time_t,
    ) -> *mut ngx_open_file_cache_t;
}
extern "C" {
    pub fn ngx_open_cached_file(
        cache: *mut ngx_open_file_cache_t,
        name: *mut ngx_str_t,
        of: *mut ngx_open_file_info_t,
        pool: *mut ngx_pool_t,
    ) -> ngx_int_t;
}
pub type ngx_recv_pt =
    ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize>;
pub type ngx_recv_chain_pt =
    ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> isize>;
pub type ngx_send_pt =
    ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize>;
pub type ngx_send_chain_pt = ::core::option::Option<
    unsafe extern "C" fn(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> *mut ngx_chain_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_os_io_t {
    pub recv: ngx_recv_pt,
    pub recv_chain: ngx_recv_chain_pt,
    pub udp_recv: ngx_recv_pt,
    pub send: ngx_send_pt,
    pub udp_send: ngx_send_pt,
    pub udp_send_chain: ngx_send_chain_pt,
    pub send_chain: ngx_send_chain_pt,
    pub flags: ngx_uint_t,
}
extern "C" {
    pub fn ngx_os_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_status(log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_os_specific_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_specific_status(log: *mut ngx_log_t);
}
extern "C" {
    pub fn ngx_daemon(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_os_signal_process(
        cycle: *mut ngx_cycle_t,
        sig: *mut ::aya_ebpf::cty::c_char,
        pid: ngx_pid_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_unix_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize;
}
extern "C" {
    pub fn ngx_readv_chain(c: *mut ngx_connection_t, entry: *mut ngx_chain_t, limit: off_t) -> isize;
}
extern "C" {
    pub fn ngx_udp_unix_recv(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize;
}
extern "C" {
    pub fn ngx_unix_send(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize;
}
extern "C" {
    pub fn ngx_writev_chain(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_udp_unix_send(c: *mut ngx_connection_t, buf: *mut u_char, size: usize) -> isize;
}
extern "C" {
    pub fn ngx_udp_unix_sendmsg_chain(
        c: *mut ngx_connection_t,
        in_: *mut ngx_chain_t,
        limit: off_t,
    ) -> *mut ngx_chain_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_iovec_t {
    pub iovs: *mut iovec,
    pub count: ngx_uint_t,
    pub size: usize,
    pub nalloc: ngx_uint_t,
}
extern "C" {
    pub fn ngx_output_chain_to_iovec(
        vec: *mut ngx_iovec_t,
        in_: *mut ngx_chain_t,
        limit: usize,
        log: *mut ngx_log_t,
    ) -> *mut ngx_chain_t;
}
extern "C" {
    pub fn ngx_writev(c: *mut ngx_connection_t, vec: *mut ngx_iovec_t) -> isize;
}
extern "C" {
    pub static mut ngx_os_io: ngx_os_io_t;
}
extern "C" {
    pub static mut ngx_ncpu: ngx_int_t;
}
extern "C" {
    pub static mut ngx_max_sockets: ngx_int_t;
}
extern "C" {
    pub static mut ngx_inherited_nonblocking: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_tcp_nodelay_and_tcp_nopush: ngx_uint_t;
}
extern "C" {
    pub fn ngx_linux_sendfile_chain(c: *mut ngx_connection_t, in_: *mut ngx_chain_t, limit: off_t) -> *mut ngx_chain_t;
}
pub type __kernel_sa_family_t = ::aya_ebpf::cty::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [::aya_ebpf::cty::c_char; 126usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_flowlabel_req {
    pub flr_dst: in6_addr,
    pub flr_label: __be32,
    pub flr_action: __u8,
    pub flr_share: __u8,
    pub flr_flags: __u16,
    pub flr_expires: __u16,
    pub flr_linger: __u16,
    pub __flr_pad: __u32,
}
pub const nf_inet_hooks_NF_INET_PRE_ROUTING: nf_inet_hooks = 0;
pub const nf_inet_hooks_NF_INET_LOCAL_IN: nf_inet_hooks = 1;
pub const nf_inet_hooks_NF_INET_FORWARD: nf_inet_hooks = 2;
pub const nf_inet_hooks_NF_INET_LOCAL_OUT: nf_inet_hooks = 3;
pub const nf_inet_hooks_NF_INET_POST_ROUTING: nf_inet_hooks = 4;
pub const nf_inet_hooks_NF_INET_NUMHOOKS: nf_inet_hooks = 5;
pub const nf_inet_hooks_NF_INET_INGRESS: nf_inet_hooks = 5;
pub type nf_inet_hooks = ::aya_ebpf::cty::c_uint;
pub const nf_dev_hooks_NF_NETDEV_INGRESS: nf_dev_hooks = 0;
pub const nf_dev_hooks_NF_NETDEV_EGRESS: nf_dev_hooks = 1;
pub const nf_dev_hooks_NF_NETDEV_NUMHOOKS: nf_dev_hooks = 2;
pub type nf_dev_hooks = ::aya_ebpf::cty::c_uint;
pub const NFPROTO_UNSPEC: _bindgen_ty_41 = 0;
pub const NFPROTO_INET: _bindgen_ty_41 = 1;
pub const NFPROTO_IPV4: _bindgen_ty_41 = 2;
pub const NFPROTO_ARP: _bindgen_ty_41 = 3;
pub const NFPROTO_NETDEV: _bindgen_ty_41 = 5;
pub const NFPROTO_BRIDGE: _bindgen_ty_41 = 7;
pub const NFPROTO_IPV6: _bindgen_ty_41 = 10;
pub const NFPROTO_DECNET: _bindgen_ty_41 = 12;
pub const NFPROTO_NUMPROTO: _bindgen_ty_41 = 13;
pub type _bindgen_ty_41 = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
}
pub const nf_ip_hook_priorities_NF_IP_PRI_FIRST: nf_ip_hook_priorities = -2147483648;
pub const nf_ip_hook_priorities_NF_IP_PRI_RAW_BEFORE_DEFRAG: nf_ip_hook_priorities = -450;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_DEFRAG: nf_ip_hook_priorities = -400;
pub const nf_ip_hook_priorities_NF_IP_PRI_RAW: nf_ip_hook_priorities = -300;
pub const nf_ip_hook_priorities_NF_IP_PRI_SELINUX_FIRST: nf_ip_hook_priorities = -225;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK: nf_ip_hook_priorities = -200;
pub const nf_ip_hook_priorities_NF_IP_PRI_MANGLE: nf_ip_hook_priorities = -150;
pub const nf_ip_hook_priorities_NF_IP_PRI_NAT_DST: nf_ip_hook_priorities = -100;
pub const nf_ip_hook_priorities_NF_IP_PRI_FILTER: nf_ip_hook_priorities = 0;
pub const nf_ip_hook_priorities_NF_IP_PRI_SECURITY: nf_ip_hook_priorities = 50;
pub const nf_ip_hook_priorities_NF_IP_PRI_NAT_SRC: nf_ip_hook_priorities = 100;
pub const nf_ip_hook_priorities_NF_IP_PRI_SELINUX_LAST: nf_ip_hook_priorities = 225;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_HELPER: nf_ip_hook_priorities = 300;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_CONFIRM: nf_ip_hook_priorities = 2147483647;
pub const nf_ip_hook_priorities_NF_IP_PRI_LAST: nf_ip_hook_priorities = 2147483647;
pub type nf_ip_hook_priorities = ::aya_ebpf::cty::c_int;
pub const ssl_module_srv_cfg_name_local_cert_chain: ssl_module_srv_cfg_name = 0;
pub const ssl_module_srv_cfg_name_ignore_cert_validity: ssl_module_srv_cfg_name = 1;
pub const ssl_module_srv_cfg_name_ignore_cert_validity_tolerance_secs: ssl_module_srv_cfg_name = 2;
pub const ssl_module_srv_cfg_name_close_if_verify_failed: ssl_module_srv_cfg_name = 3;
pub const ssl_module_srv_cfg_name_crl_ocsp_before_cache: ssl_module_srv_cfg_name = 4;
pub const ssl_module_srv_cfg_name_crl_ocsp_treat_unknown_status_as_revoked: ssl_module_srv_cfg_name = 5;
pub const ssl_module_srv_cfg_name_verify_mode: ssl_module_srv_cfg_name = 6;
pub const ssl_module_srv_cfg_name_handshake_timeout: ssl_module_srv_cfg_name = 7;
pub type ssl_module_srv_cfg_name = ::aya_ebpf::cty::c_uint;
pub type ngx_get_ssl_module_srv_cfg_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        c: *mut ngx_connection_t,
        cfg_name: ssl_module_srv_cfg_name,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ngx_int_t,
>;
pub type ngx_listening_t = ngx_listening_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_listening_s {
    pub fd: ngx_socket_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text_max_len: usize,
    pub addr_text: ngx_str_t,
    pub type_: ::aya_ebpf::cty::c_int,
    pub backlog: ::aya_ebpf::cty::c_int,
    pub rcvbuf: ::aya_ebpf::cty::c_int,
    pub sndbuf: ::aya_ebpf::cty::c_int,
    pub keepidle: ::aya_ebpf::cty::c_int,
    pub keepintvl: ::aya_ebpf::cty::c_int,
    pub keepcnt: ::aya_ebpf::cty::c_int,
    pub handler: ngx_connection_handler_pt,
    pub servers: *mut ::aya_ebpf::cty::c_void,
    pub log: ngx_log_t,
    pub logp: *mut ngx_log_t,
    pub pool_size: usize,
    pub post_accept_buffer_size: usize,
    pub previous: *mut ngx_listening_t,
    pub connection: *mut ngx_connection_t,
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub worker: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub fastopen: ::aya_ebpf::cty::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_listening_s {
    #[inline]
    pub fn open(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_open(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remain(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remain(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bound(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bound(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inherited(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inherited(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonblocking_accept(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonblocking_accept(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn listen(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonblocking(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonblocking(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn addr_ntop(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_addr_ntop(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6only(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6only(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_reuseport(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_reuseport(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delete_deferred(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delete_deferred(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_deferred(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_deferred(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        open: ::aya_ebpf::cty::c_uint,
        remain: ::aya_ebpf::cty::c_uint,
        ignore: ::aya_ebpf::cty::c_uint,
        bound: ::aya_ebpf::cty::c_uint,
        inherited: ::aya_ebpf::cty::c_uint,
        nonblocking_accept: ::aya_ebpf::cty::c_uint,
        listen: ::aya_ebpf::cty::c_uint,
        nonblocking: ::aya_ebpf::cty::c_uint,
        shared: ::aya_ebpf::cty::c_uint,
        addr_ntop: ::aya_ebpf::cty::c_uint,
        wildcard: ::aya_ebpf::cty::c_uint,
        ipv6only: ::aya_ebpf::cty::c_uint,
        reuseport: ::aya_ebpf::cty::c_uint,
        add_reuseport: ::aya_ebpf::cty::c_uint,
        keepalive: ::aya_ebpf::cty::c_uint,
        deferred_accept: ::aya_ebpf::cty::c_uint,
        delete_deferred: ::aya_ebpf::cty::c_uint,
        add_deferred: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let open: u32 = unsafe { ::core::mem::transmute(open) };
            open as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let remain: u32 = unsafe { ::core::mem::transmute(remain) };
            remain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ignore: u32 = unsafe { ::core::mem::transmute(ignore) };
            ignore as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bound: u32 = unsafe { ::core::mem::transmute(bound) };
            bound as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let inherited: u32 = unsafe { ::core::mem::transmute(inherited) };
            inherited as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nonblocking_accept: u32 = unsafe { ::core::mem::transmute(nonblocking_accept) };
            nonblocking_accept as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let listen: u32 = unsafe { ::core::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nonblocking: u32 = unsafe { ::core::mem::transmute(nonblocking) };
            nonblocking as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let shared: u32 = unsafe { ::core::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let addr_ntop: u32 = unsafe { ::core::mem::transmute(addr_ntop) };
            addr_ntop as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wildcard: u32 = unsafe { ::core::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ipv6only: u32 = unsafe { ::core::mem::transmute(ipv6only) };
            ipv6only as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reuseport: u32 = unsafe { ::core::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let add_reuseport: u32 = unsafe { ::core::mem::transmute(add_reuseport) };
            add_reuseport as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let keepalive: u32 = unsafe { ::core::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::core::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let delete_deferred: u32 = unsafe { ::core::mem::transmute(delete_deferred) };
            delete_deferred as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let add_deferred: u32 = unsafe { ::core::mem::transmute(add_deferred) };
            add_deferred as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn no_stat_stub(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_stat_stub(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(no_stat_stub: ::aya_ebpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let no_stat_stub: u32 = unsafe { ::core::mem::transmute(no_stat_stub) };
            no_stat_stub as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ngx_connection_log_error_e_NGX_ERROR_ALERT: ngx_connection_log_error_e = 0;
pub const ngx_connection_log_error_e_NGX_ERROR_ERR: ngx_connection_log_error_e = 1;
pub const ngx_connection_log_error_e_NGX_ERROR_INFO: ngx_connection_log_error_e = 2;
pub const ngx_connection_log_error_e_NGX_ERROR_IGNORE_ECONNRESET: ngx_connection_log_error_e = 3;
pub const ngx_connection_log_error_e_NGX_ERROR_IGNORE_EINVAL: ngx_connection_log_error_e = 4;
pub type ngx_connection_log_error_e = ::aya_ebpf::cty::c_uint;
pub const ngx_connection_tcp_nodelay_e_NGX_TCP_NODELAY_UNSET: ngx_connection_tcp_nodelay_e = 0;
pub const ngx_connection_tcp_nodelay_e_NGX_TCP_NODELAY_SET: ngx_connection_tcp_nodelay_e = 1;
pub const ngx_connection_tcp_nodelay_e_NGX_TCP_NODELAY_DISABLED: ngx_connection_tcp_nodelay_e = 2;
pub type ngx_connection_tcp_nodelay_e = ::aya_ebpf::cty::c_uint;
pub const ngx_connection_tcp_nopush_e_NGX_TCP_NOPUSH_UNSET: ngx_connection_tcp_nopush_e = 0;
pub const ngx_connection_tcp_nopush_e_NGX_TCP_NOPUSH_SET: ngx_connection_tcp_nopush_e = 1;
pub const ngx_connection_tcp_nopush_e_NGX_TCP_NOPUSH_DISABLED: ngx_connection_tcp_nopush_e = 2;
pub type ngx_connection_tcp_nopush_e = ::aya_ebpf::cty::c_uint;
pub const ngx_connection_used_module_type_e_NGX_HTTP_MODULE_TYPE: ngx_connection_used_module_type_e = 0;
pub const ngx_connection_used_module_type_e_NGX_STREAM_MODULE_TYPE: ngx_connection_used_module_type_e = 1;
pub const ngx_connection_used_module_type_e_NGX_MAIL_MODULE_TYPE: ngx_connection_used_module_type_e = 2;
pub type ngx_connection_used_module_type_e = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_connection_s {
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub read: *mut ngx_event_t,
    pub write: *mut ngx_event_t,
    pub fd: ngx_socket_t,
    pub recv: ngx_recv_pt,
    pub send: ngx_send_pt,
    pub recv_chain: ngx_recv_chain_pt,
    pub send_chain: ngx_send_chain_pt,
    pub listening: *mut ngx_listening_t,
    pub sent: off_t,
    pub log: *mut ngx_log_t,
    pub pool: *mut ngx_pool_t,
    pub type_: ::aya_ebpf::cty::c_int,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text: ngx_str_t,
    pub proxy_protocol: *mut ngx_proxy_protocol_t,
    pub ssl: *mut ngx_ssl_connection_t,
    #[doc = "  KLNE 0057 ASYNC_SSL\n\n  支持异步SSL"]
    pub async_: *mut ngx_event_t,
    pub async_fd: ngx_socket_t,
    pub asynch: ngx_flag_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub udp: *mut ngx_udp_connection_t,
    pub local_sockaddr: *mut sockaddr,
    pub local_socklen: socklen_t,
    pub buffer: *mut ngx_buf_t,
    pub queue: ngx_queue_t,
    pub number: ngx_atomic_uint_t,
    pub start_time: ngx_msec_t,
    pub requests: ngx_uint_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub sts_temp_pool: *mut ngx_pool_t,
    pub sendfile_task: *mut ngx_thread_task_t,
    #[doc = " KLNE 0034 SUPPORT_LUA_PER_CONNECTION_CONTEXT_VARIABLES\n\n 支持lua设置per-connection变量"]
    pub lua_connection_ctx_ref: ::aya_ebpf::cty::c_int,
    #[doc = " KLNE 0039 FORWARD_PROXY_WITH_DNAT\n\n 支持结合DNAT实现正向代理"]
    pub origin_backend_addr: ngx_str_t,
    pub origin_backend_port: in_port_t,
    #[doc = " KLNE 0048 UPSTREAM_EVENT_CERTIFICATE\n\n 支持后端事件证书"]
    pub app_session: ngx_str_t,
    #[doc = " KLNE 0059 VALID_FOR_LUA_PER_CONNECTION_CONTEXT_VARIABLES\n\n LUA连接上下文变量支持指定有效期"]
    pub start_sec: time_t,
    pub start_msec: ngx_msec_t,
    #[doc = " KLNE 0072 LOG_SSL_HANDSHAKE_FAILURES\n\n 支持记录各类握手失败的访问日志"]
    pub ssl_handshake_code: ngx_uint_t,
    pub ngx_get_ssl_module_srv_cfg_handler: ngx_get_ssl_module_srv_cfg_handler_pt,
}
impl ngx_connection_s {
    #[inline]
    pub fn num_async_fds(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_num_async_fds(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(num_async_fds: ::aya_ebpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let num_async_fds: u32 = unsafe { ::core::mem::transmute(num_async_fds) };
            num_async_fds as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn buffered(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_buffered(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn log_error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_log_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn timedout(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timedout(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn destroyed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_destroyed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idle(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reusable(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reusable(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shared(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sendfile(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sendfile(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sndlowat(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sndlowat(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp_nodelay(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_nodelay(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tcp_nopush(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_nopush(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn need_last_buf(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_need_last_buf(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn busy_count(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_busy_count(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn used_module_type(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(27usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_used_module_type(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sts_flag(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sts_flag(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        buffered: ::aya_ebpf::cty::c_uint,
        log_error: ::aya_ebpf::cty::c_uint,
        timedout: ::aya_ebpf::cty::c_uint,
        error: ::aya_ebpf::cty::c_uint,
        destroyed: ::aya_ebpf::cty::c_uint,
        idle: ::aya_ebpf::cty::c_uint,
        reusable: ::aya_ebpf::cty::c_uint,
        close: ::aya_ebpf::cty::c_uint,
        shared: ::aya_ebpf::cty::c_uint,
        sendfile: ::aya_ebpf::cty::c_uint,
        sndlowat: ::aya_ebpf::cty::c_uint,
        tcp_nodelay: ::aya_ebpf::cty::c_uint,
        tcp_nopush: ::aya_ebpf::cty::c_uint,
        need_last_buf: ::aya_ebpf::cty::c_uint,
        busy_count: ::aya_ebpf::cty::c_uint,
        used_module_type: ::aya_ebpf::cty::c_uint,
        sts_flag: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let buffered: u32 = unsafe { ::core::mem::transmute(buffered) };
            buffered as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let log_error: u32 = unsafe { ::core::mem::transmute(log_error) };
            log_error as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timedout: u32 = unsafe { ::core::mem::transmute(timedout) };
            timedout as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let destroyed: u32 = unsafe { ::core::mem::transmute(destroyed) };
            destroyed as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let idle: u32 = unsafe { ::core::mem::transmute(idle) };
            idle as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reusable: u32 = unsafe { ::core::mem::transmute(reusable) };
            reusable as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let close: u32 = unsafe { ::core::mem::transmute(close) };
            close as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let shared: u32 = unsafe { ::core::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let sendfile: u32 = unsafe { ::core::mem::transmute(sendfile) };
            sendfile as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let sndlowat: u32 = unsafe { ::core::mem::transmute(sndlowat) };
            sndlowat as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let tcp_nodelay: u32 = unsafe { ::core::mem::transmute(tcp_nodelay) };
            tcp_nodelay as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let tcp_nopush: u32 = unsafe { ::core::mem::transmute(tcp_nopush) };
            tcp_nopush as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let need_last_buf: u32 = unsafe { ::core::mem::transmute(need_last_buf) };
            need_last_buf as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let busy_count: u32 = unsafe { ::core::mem::transmute(busy_count) };
            busy_count as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let used_module_type: u32 = unsafe { ::core::mem::transmute(used_module_type) };
            used_module_type as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let sts_flag: u32 = unsafe { ::core::mem::transmute(sts_flag) };
            sts_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_create_listening(
        cf: *mut ngx_conf_t,
        sockaddr: *mut sockaddr,
        socklen: socklen_t,
    ) -> *mut ngx_listening_t;
}
extern "C" {
    pub fn ngx_clone_listening(cycle: *mut ngx_cycle_t, ls: *mut ngx_listening_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_set_inherited_sockets(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_open_listening_sockets(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_configure_listening_sockets(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_close_listening_sockets(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_close_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_close_idle_connections(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_connection_local_sockaddr(c: *mut ngx_connection_t, s: *mut ngx_str_t, port: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_tcp_nodelay(c: *mut ngx_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_connection_error(
        c: *mut ngx_connection_t,
        err: ngx_err_t,
        text: *mut ::aya_ebpf::cty::c_char,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_get_connection(s: ngx_socket_t, log: *mut ngx_log_t) -> *mut ngx_connection_t;
}
extern "C" {
    pub fn ngx_free_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_reusable_connection(c: *mut ngx_connection_t, reusable: ngx_uint_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_syslog_peer_t {
    pub facility: ngx_uint_t,
    pub severity: ngx_uint_t,
    pub tag: ngx_str_t,
    pub server: ngx_addr_t,
    pub conn: ngx_connection_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " KLNE 0056 SYSLOG_WARNING_WITH_SPECIFY_STATUS\n\n 访问日志以WARNING级别记录状态码为4xx/5xx的请求"]
    pub warning_status: *mut ngx_array_t,
    pub warning_status_exclude_mode: ngx_flag_t,
}
impl ngx_syslog_peer_t {
    #[inline]
    pub fn busy(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_busy(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohostname(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nohostname(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        busy: ::aya_ebpf::cty::c_uint,
        nohostname: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let busy: u32 = unsafe { ::core::mem::transmute(busy) };
            busy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohostname: u32 = unsafe { ::core::mem::transmute(nohostname) };
            nohostname as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_syslog_process_conf(cf: *mut ngx_conf_t, peer: *mut ngx_syslog_peer_t) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    #[doc = " KLNE 0056 SYSLOG_WARNING_WITH_SPECIFY_STATUS\n\n 访问日志以WARNING级别记录状态码为4xx/5xx的请求"]
    pub fn ngx_syslog_add_header(
        peer: *mut ngx_syslog_peer_t,
        buf: *mut u_char,
        is_need_warning: ngx_flag_t,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_syslog_writer(log: *mut ngx_log_t, level: ngx_uint_t, buf: *mut u_char, len: usize);
}
extern "C" {
    pub fn ngx_syslog_send(peer: *mut ngx_syslog_peer_t, buf: *mut u_char, len: usize) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_proxy_protocol_s {
    pub src_addr: ngx_str_t,
    pub dst_addr: ngx_str_t,
    pub src_port: in_port_t,
    pub dst_port: in_port_t,
    #[doc = " KLNE 0185 NGX_PROXY_PROTOCOL_TLV\n\n 支持proxy_protocol_tlv_name变量"]
    pub tlvs: ngx_str_t,
}
extern "C" {
    pub fn ngx_proxy_protocol_read(c: *mut ngx_connection_t, buf: *mut u_char, last: *mut u_char) -> *mut u_char;
}
extern "C" {
    pub fn ngx_proxy_protocol_write(c: *mut ngx_connection_t, buf: *mut u_char, last: *mut u_char) -> *mut u_char;
}
extern "C" {
    #[doc = " KLNE 0185 NGX_PROXY_PROTOCOL_TLV\n\n 支持proxy_protocol_tlv_name变量"]
    pub fn ngx_proxy_protocol_get_tlv(
        c: *mut ngx_connection_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_cpuinfo();
}
extern "C" {
    pub static mut saved_init_cycle_pool: *mut ngx_pool_t;
}
pub type ngx_http_request_t = ngx_http_request_s;
pub type ngx_http_upstream_t = ngx_http_upstream_s;
pub type ngx_http_cache_t = ngx_http_cache_s;
pub type ngx_http_file_cache_t = ngx_http_file_cache_s;
pub type ngx_http_log_ctx_t = ngx_http_log_ctx_s;
pub type ngx_http_chunked_t = ngx_http_chunked_s;
pub type ngx_http_v2_stream_t = ngx_http_v2_stream_s;
pub type ngx_http_header_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, h: *mut ngx_table_elt_t, offset: ngx_uint_t) -> ngx_int_t,
>;
pub type ngx_http_log_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        sr: *mut ngx_http_request_t,
        buf: *mut u_char,
        len: usize,
    ) -> *mut u_char,
>;
pub type ngx_http_variable_value_t = ngx_variable_value_t;
pub type ngx_http_variable_t = ngx_http_variable_s;
pub type ngx_http_set_variable_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, v: *mut ngx_http_variable_value_t, data: usize),
>;
pub type ngx_http_get_variable_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, v: *mut ngx_http_variable_value_t, data: usize) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_variable_s {
    pub name: ngx_str_t,
    pub set_handler: ngx_http_set_variable_pt,
    pub get_handler: ngx_http_get_variable_pt,
    pub data: usize,
    pub flags: ngx_uint_t,
    pub index: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_add_variable(
        cf: *mut ngx_conf_t,
        name: *mut ngx_str_t,
        flags: ngx_uint_t,
    ) -> *mut ngx_http_variable_t;
}
extern "C" {
    pub fn ngx_http_get_variable_index(cf: *mut ngx_conf_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_get_indexed_variable(
        r: *mut ngx_http_request_t,
        index: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_get_flushed_variable(
        r: *mut ngx_http_request_t,
        index: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_get_variable(
        r: *mut ngx_http_request_t,
        name: *mut ngx_str_t,
        key: ngx_uint_t,
    ) -> *mut ngx_http_variable_value_t;
}
extern "C" {
    pub fn ngx_http_variable_unknown_header(
        v: *mut ngx_http_variable_value_t,
        var: *mut ngx_str_t,
        part: *mut ngx_list_part_t,
        prefix: usize,
    ) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_regex_variable_t {
    pub capture: ngx_uint_t,
    pub index: ngx_int_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_regex_t {
    pub regex: *mut ngx_regex_t,
    pub ncaptures: ngx_uint_t,
    pub variables: *mut ngx_http_regex_variable_t,
    pub nvariables: ngx_uint_t,
    pub name: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_map_regex_t {
    pub regex: *mut ngx_http_regex_t,
    pub value: *mut ::aya_ebpf::cty::c_void,
}
extern "C" {
    pub fn ngx_http_regex_compile(cf: *mut ngx_conf_t, rc: *mut ngx_regex_compile_t) -> *mut ngx_http_regex_t;
}
extern "C" {
    pub fn ngx_http_regex_exec(r: *mut ngx_http_request_t, re: *mut ngx_http_regex_t, s: *mut ngx_str_t) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_map_t {
    pub hash: ngx_hash_combined_t,
    pub regex: *mut ngx_http_map_regex_t,
    pub nregex: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_map_find(
        r: *mut ngx_http_request_t,
        map: *mut ngx_http_map_t,
        match_: *mut ngx_str_t,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_variables_add_core_vars(cf: *mut ngx_conf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_variables_init_vars(cf: *mut ngx_conf_t) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_variable_null_value: ngx_http_variable_value_t;
}
extern "C" {
    pub static mut ngx_http_variable_true_value: ngx_http_variable_value_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_conf_ctx_t {
    pub main_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub srv_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub loc_conf: *mut *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_module_t {
    pub preconfiguration: ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> ngx_int_t>,
    pub postconfiguration: ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> ngx_int_t>,
    pub create_main_conf:
        ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut ::aya_ebpf::cty::c_void>,
    pub init_main_conf: ::core::option::Option<
        unsafe extern "C" fn(cf: *mut ngx_conf_t, conf: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_char,
    >,
    pub create_srv_conf:
        ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut ::aya_ebpf::cty::c_void>,
    pub merge_srv_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            prev: *mut ::aya_ebpf::cty::c_void,
            conf: *mut ::aya_ebpf::cty::c_void,
        ) -> *mut ::aya_ebpf::cty::c_char,
    >,
    pub create_loc_conf:
        ::core::option::Option<unsafe extern "C" fn(cf: *mut ngx_conf_t) -> *mut ::aya_ebpf::cty::c_void>,
    pub merge_loc_conf: ::core::option::Option<
        unsafe extern "C" fn(
            cf: *mut ngx_conf_t,
            prev: *mut ::aya_ebpf::cty::c_void,
            conf: *mut ::aya_ebpf::cty::c_void,
        ) -> *mut ::aya_ebpf::cty::c_char,
    >,
}
pub const ngx_http_state_e_NGX_HTTP_INITING_REQUEST_STATE: ngx_http_state_e = 0;
pub const ngx_http_state_e_NGX_HTTP_READING_REQUEST_STATE: ngx_http_state_e = 1;
pub const ngx_http_state_e_NGX_HTTP_PROCESS_REQUEST_STATE: ngx_http_state_e = 2;
pub const ngx_http_state_e_NGX_HTTP_CONNECT_UPSTREAM_STATE: ngx_http_state_e = 3;
pub const ngx_http_state_e_NGX_HTTP_WRITING_UPSTREAM_STATE: ngx_http_state_e = 4;
pub const ngx_http_state_e_NGX_HTTP_READING_UPSTREAM_STATE: ngx_http_state_e = 5;
pub const ngx_http_state_e_NGX_HTTP_WRITING_REQUEST_STATE: ngx_http_state_e = 6;
pub const ngx_http_state_e_NGX_HTTP_LINGERING_CLOSE_STATE: ngx_http_state_e = 7;
pub const ngx_http_state_e_NGX_HTTP_KEEPALIVE_STATE: ngx_http_state_e = 8;
pub type ngx_http_state_e = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_header_t {
    pub name: ngx_str_t,
    pub offset: ngx_uint_t,
    pub handler: ngx_http_header_handler_pt,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_header_out_t {
    pub name: ngx_str_t,
    pub offset: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_headers_in_t {
    pub headers: ngx_list_t,
    pub host: *mut ngx_table_elt_t,
    pub connection: *mut ngx_table_elt_t,
    pub if_modified_since: *mut ngx_table_elt_t,
    pub if_unmodified_since: *mut ngx_table_elt_t,
    pub if_match: *mut ngx_table_elt_t,
    pub if_none_match: *mut ngx_table_elt_t,
    pub user_agent: *mut ngx_table_elt_t,
    pub referer: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub content_range: *mut ngx_table_elt_t,
    pub content_type: *mut ngx_table_elt_t,
    pub range: *mut ngx_table_elt_t,
    pub if_range: *mut ngx_table_elt_t,
    pub transfer_encoding: *mut ngx_table_elt_t,
    pub te: *mut ngx_table_elt_t,
    pub expect: *mut ngx_table_elt_t,
    pub upgrade: *mut ngx_table_elt_t,
    pub accept_encoding: *mut ngx_table_elt_t,
    pub via: *mut ngx_table_elt_t,
    pub authorization: *mut ngx_table_elt_t,
    pub keep_alive: *mut ngx_table_elt_t,
    pub x_forwarded_for: ngx_array_t,
    pub x_real_ip: *mut ngx_table_elt_t,
    pub accept: *mut ngx_table_elt_t,
    pub accept_language: *mut ngx_table_elt_t,
    pub depth: *mut ngx_table_elt_t,
    pub destination: *mut ngx_table_elt_t,
    pub overwrite: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub user: ngx_str_t,
    pub passwd: ngx_str_t,
    pub cookies: ngx_array_t,
    pub server: ngx_str_t,
    pub content_length_n: off_t,
    pub keep_alive_n: time_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_headers_in_t {
    #[inline]
    pub fn connection_type(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_connection_type(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msie(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msie6(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie6(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opera(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_opera(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gecko(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gecko(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chrome(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chrome(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn safari(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_safari(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn konqueror(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_konqueror(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connection_type: ::aya_ebpf::cty::c_uint,
        chunked: ::aya_ebpf::cty::c_uint,
        msie: ::aya_ebpf::cty::c_uint,
        msie6: ::aya_ebpf::cty::c_uint,
        opera: ::aya_ebpf::cty::c_uint,
        gecko: ::aya_ebpf::cty::c_uint,
        chrome: ::aya_ebpf::cty::c_uint,
        safari: ::aya_ebpf::cty::c_uint,
        konqueror: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let connection_type: u32 = unsafe { ::core::mem::transmute(connection_type) };
            connection_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let chunked: u32 = unsafe { ::core::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let msie: u32 = unsafe { ::core::mem::transmute(msie) };
            msie as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let msie6: u32 = unsafe { ::core::mem::transmute(msie6) };
            msie6 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let opera: u32 = unsafe { ::core::mem::transmute(opera) };
            opera as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let gecko: u32 = unsafe { ::core::mem::transmute(gecko) };
            gecko as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let chrome: u32 = unsafe { ::core::mem::transmute(chrome) };
            chrome as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let safari: u32 = unsafe { ::core::mem::transmute(safari) };
            safari as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let konqueror: u32 = unsafe { ::core::mem::transmute(konqueror) };
            konqueror as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_headers_out_t {
    pub headers: ngx_list_t,
    pub trailers: ngx_list_t,
    pub status: ngx_uint_t,
    pub status_line: ngx_str_t,
    pub server: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub content_encoding: *mut ngx_table_elt_t,
    pub location: *mut ngx_table_elt_t,
    pub refresh: *mut ngx_table_elt_t,
    pub last_modified: *mut ngx_table_elt_t,
    pub content_range: *mut ngx_table_elt_t,
    pub accept_ranges: *mut ngx_table_elt_t,
    pub www_authenticate: *mut ngx_table_elt_t,
    pub expires: *mut ngx_table_elt_t,
    pub etag: *mut ngx_table_elt_t,
    pub override_charset: *mut ngx_str_t,
    pub content_type_len: usize,
    pub content_type: ngx_str_t,
    pub charset: ngx_str_t,
    pub content_type_lowcase: *mut u_char,
    pub content_type_hash: ngx_uint_t,
    pub cache_control: ngx_array_t,
    pub link: ngx_array_t,
    pub content_length_n: off_t,
    pub content_offset: off_t,
    pub date_time: time_t,
    pub last_modified_time: time_t,
}
pub type ngx_http_client_body_handler_pt = ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_request_body_t {
    pub temp_file: *mut ngx_temp_file_t,
    pub bufs: *mut ngx_chain_t,
    pub buf: *mut ngx_buf_t,
    pub rest: off_t,
    pub received: off_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub chunked: *mut ngx_http_chunked_t,
    pub post_handler: ngx_http_client_body_handler_pt,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_request_body_t {
    #[inline]
    pub fn filter_need_buffering(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_buffering(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_sent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_sent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_saved(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_saved(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        filter_need_buffering: ::aya_ebpf::cty::c_uint,
        last_sent: ::aya_ebpf::cty::c_uint,
        last_saved: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let filter_need_buffering: u32 = unsafe { ::core::mem::transmute(filter_need_buffering) };
            filter_need_buffering as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let last_sent: u32 = unsafe { ::core::mem::transmute(last_sent) };
            last_sent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let last_saved: u32 = unsafe { ::core::mem::transmute(last_saved) };
            last_saved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_addr_conf_t = ngx_http_addr_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_connection_t {
    pub addr_conf: *mut ngx_http_addr_conf_t,
    pub conf_ctx: *mut ngx_http_conf_ctx_t,
    pub ssl_servername: *mut ngx_str_t,
    pub ssl_servername_regex: *mut ngx_http_regex_t,
    pub busy: *mut ngx_chain_t,
    pub nbusy: ngx_int_t,
    pub free: *mut ngx_chain_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_connection_t {
    #[inline]
    pub fn ssl(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssl: ::aya_ebpf::cty::c_uint,
        proxy_protocol: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::core::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_cleanup_pt = ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void)>;
pub type ngx_http_cleanup_t = ngx_http_cleanup_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cleanup_s {
    pub handler: ngx_http_cleanup_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub next: *mut ngx_http_cleanup_t,
}
pub type ngx_http_post_subrequest_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, data: *mut ::aya_ebpf::cty::c_void, rc: ngx_int_t) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_post_subrequest_t {
    pub handler: ngx_http_post_subrequest_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
}
pub type ngx_http_postponed_request_t = ngx_http_postponed_request_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_postponed_request_s {
    pub request: *mut ngx_http_request_t,
    pub out: *mut ngx_chain_t,
    pub next: *mut ngx_http_postponed_request_t,
}
pub type ngx_http_posted_request_t = ngx_http_posted_request_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_posted_request_s {
    pub request: *mut ngx_http_request_t,
    pub next: *mut ngx_http_posted_request_t,
}
pub type ngx_http_handler_pt = ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>;
pub type ngx_http_event_handler_pt = ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_request_s {
    pub signature: u32,
    pub connection: *mut ngx_connection_t,
    pub ctx: *mut *mut ::aya_ebpf::cty::c_void,
    pub main_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub srv_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub loc_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub read_event_handler: ngx_http_event_handler_pt,
    pub write_event_handler: ngx_http_event_handler_pt,
    pub cache: *mut ngx_http_cache_t,
    pub upstream: *mut ngx_http_upstream_t,
    pub upstream_states: *mut ngx_array_t,
    pub pool: *mut ngx_pool_t,
    pub header_in: *mut ngx_buf_t,
    pub headers_in: ngx_http_headers_in_t,
    pub headers_out: ngx_http_headers_out_t,
    pub request_body: *mut ngx_http_request_body_t,
    pub lingering_time: time_t,
    pub start_sec: time_t,
    pub start_msec: ngx_msec_t,
    pub method: ngx_uint_t,
    pub http_version: ngx_uint_t,
    pub request_line: ngx_str_t,
    pub uri: ngx_str_t,
    pub args: ngx_str_t,
    pub exten: ngx_str_t,
    pub unparsed_uri: ngx_str_t,
    pub method_name: ngx_str_t,
    pub http_protocol: ngx_str_t,
    pub schema: ngx_str_t,
    pub out: *mut ngx_chain_t,
    pub main: *mut ngx_http_request_t,
    pub parent: *mut ngx_http_request_t,
    pub postponed: *mut ngx_http_postponed_request_t,
    pub post_subrequest: *mut ngx_http_post_subrequest_t,
    pub posted_requests: *mut ngx_http_posted_request_t,
    pub phase_handler: ngx_int_t,
    pub content_handler: ngx_http_handler_pt,
    pub access_code: ngx_uint_t,
    pub variables: *mut ngx_http_variable_value_t,
    pub ncaptures: ngx_uint_t,
    pub captures: *mut ::aya_ebpf::cty::c_int,
    pub captures_data: *mut u_char,
    pub limit_rate: usize,
    pub limit_rate_after: usize,
    pub header_size: usize,
    pub request_length: off_t,
    pub err_status: ngx_uint_t,
    pub http_connection: *mut ngx_http_connection_t,
    pub stream: *mut ngx_http_v2_stream_t,
    pub log_handler: ngx_http_log_handler_pt,
    pub cleanup: *mut ngx_http_cleanup_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 15usize]>,
    pub state: ngx_uint_t,
    pub header_hash: ngx_uint_t,
    pub lowcase_index: ngx_uint_t,
    pub lowcase_header: [u_char; 32usize],
    pub header_name_start: *mut u_char,
    pub header_name_end: *mut u_char,
    pub header_start: *mut u_char,
    pub header_end: *mut u_char,
    pub uri_start: *mut u_char,
    pub uri_end: *mut u_char,
    pub uri_ext: *mut u_char,
    pub args_start: *mut u_char,
    pub request_start: *mut u_char,
    pub request_end: *mut u_char,
    pub method_end: *mut u_char,
    pub schema_start: *mut u_char,
    pub schema_end: *mut u_char,
    pub host_start: *mut u_char,
    pub host_end: *mut u_char,
    pub port_start: *mut u_char,
    pub port_end: *mut u_char,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl ngx_http_request_s {
    #[inline]
    pub fn count(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequests(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_subrequests(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http_state(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_http_state(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn complex_uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complex_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quoted_uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quoted_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn plus_in_uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_plus_in_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn empty_path_in_uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_empty_path_in_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invalid_header(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invalid_header(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_uri_to_alias(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_uri_to_alias(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_location(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_location(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_unparsed_uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_unparsed_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_changed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri_changed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri_changes(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_uri_changes(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_single_buf(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_single_buf(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_file_only(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_file_only(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_persistent_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_persistent_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_in_clean_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_in_clean_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_file_group_access(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_file_group_access(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_file_log_level(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_file_log_level(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_no_buffering(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_no_buffering(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequest_in_memory(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subrequest_in_memory(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waited(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waited(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cached(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_tested(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_tested(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_ok(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_ok(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_vary(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_vary(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn realloc_captures(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_realloc_captures(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bypass_cache(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bypass_cache(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cache(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cache(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_conn_status(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(69usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_limit_conn_status(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(69usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_req_status(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(71usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_limit_req_status(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(71usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_rate_set(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_rate_set(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_rate_after_set(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_rate_after_set(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pipeline(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pipeline(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_only(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_only(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expect_trailers(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expect_trailers(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lingering_close(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lingering_close(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn discard_body(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discard_body(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reading_body(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reading_body(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn internal(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_internal(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_page(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_page(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_finalize(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_finalize(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn post_action(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_post_action(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_complete(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_complete(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_output(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_output(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_sent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_sent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expect_tested(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_expect_tested(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_tested(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(92usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_tested(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(92usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn done(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(93usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_done(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(93usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn logged(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(94usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_logged(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(94usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn buffered(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_buffered(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn main_filter_need_in_memory(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(100usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_main_filter_need_in_memory(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(100usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_need_in_memory(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(101usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_in_memory(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(101usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_need_temporary(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(102usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_need_temporary(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(102usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserve_body(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(103usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_preserve_body(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(103usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_ranges(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(104usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_ranges(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(104usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subrequest_ranges(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(105usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subrequest_ranges(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(105usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_range(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(106usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single_range(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(106usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_not_modified(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(107usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_not_modified(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(107usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_reading(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(108usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_reading(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(108usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_writing(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(109usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_writing(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(109usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stat_processing(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(110usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stat_processing(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(110usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(111usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(111usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn health_check(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(112usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_health_check(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(112usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: ::aya_ebpf::cty::c_uint,
        subrequests: ::aya_ebpf::cty::c_uint,
        blocked: ::aya_ebpf::cty::c_uint,
        aio: ::aya_ebpf::cty::c_uint,
        http_state: ::aya_ebpf::cty::c_uint,
        complex_uri: ::aya_ebpf::cty::c_uint,
        quoted_uri: ::aya_ebpf::cty::c_uint,
        plus_in_uri: ::aya_ebpf::cty::c_uint,
        empty_path_in_uri: ::aya_ebpf::cty::c_uint,
        invalid_header: ::aya_ebpf::cty::c_uint,
        add_uri_to_alias: ::aya_ebpf::cty::c_uint,
        valid_location: ::aya_ebpf::cty::c_uint,
        valid_unparsed_uri: ::aya_ebpf::cty::c_uint,
        uri_changed: ::aya_ebpf::cty::c_uint,
        uri_changes: ::aya_ebpf::cty::c_uint,
        request_body_in_single_buf: ::aya_ebpf::cty::c_uint,
        request_body_in_file_only: ::aya_ebpf::cty::c_uint,
        request_body_in_persistent_file: ::aya_ebpf::cty::c_uint,
        request_body_in_clean_file: ::aya_ebpf::cty::c_uint,
        request_body_file_group_access: ::aya_ebpf::cty::c_uint,
        request_body_file_log_level: ::aya_ebpf::cty::c_uint,
        request_body_no_buffering: ::aya_ebpf::cty::c_uint,
        subrequest_in_memory: ::aya_ebpf::cty::c_uint,
        waited: ::aya_ebpf::cty::c_uint,
        cached: ::aya_ebpf::cty::c_uint,
        gzip_tested: ::aya_ebpf::cty::c_uint,
        gzip_ok: ::aya_ebpf::cty::c_uint,
        gzip_vary: ::aya_ebpf::cty::c_uint,
        realloc_captures: ::aya_ebpf::cty::c_uint,
        proxy: ::aya_ebpf::cty::c_uint,
        bypass_cache: ::aya_ebpf::cty::c_uint,
        no_cache: ::aya_ebpf::cty::c_uint,
        limit_conn_status: ::aya_ebpf::cty::c_uint,
        limit_req_status: ::aya_ebpf::cty::c_uint,
        limit_rate_set: ::aya_ebpf::cty::c_uint,
        limit_rate_after_set: ::aya_ebpf::cty::c_uint,
        pipeline: ::aya_ebpf::cty::c_uint,
        chunked: ::aya_ebpf::cty::c_uint,
        header_only: ::aya_ebpf::cty::c_uint,
        expect_trailers: ::aya_ebpf::cty::c_uint,
        keepalive: ::aya_ebpf::cty::c_uint,
        lingering_close: ::aya_ebpf::cty::c_uint,
        discard_body: ::aya_ebpf::cty::c_uint,
        reading_body: ::aya_ebpf::cty::c_uint,
        internal: ::aya_ebpf::cty::c_uint,
        error_page: ::aya_ebpf::cty::c_uint,
        filter_finalize: ::aya_ebpf::cty::c_uint,
        post_action: ::aya_ebpf::cty::c_uint,
        request_complete: ::aya_ebpf::cty::c_uint,
        request_output: ::aya_ebpf::cty::c_uint,
        header_sent: ::aya_ebpf::cty::c_uint,
        expect_tested: ::aya_ebpf::cty::c_uint,
        root_tested: ::aya_ebpf::cty::c_uint,
        done: ::aya_ebpf::cty::c_uint,
        logged: ::aya_ebpf::cty::c_uint,
        buffered: ::aya_ebpf::cty::c_uint,
        main_filter_need_in_memory: ::aya_ebpf::cty::c_uint,
        filter_need_in_memory: ::aya_ebpf::cty::c_uint,
        filter_need_temporary: ::aya_ebpf::cty::c_uint,
        preserve_body: ::aya_ebpf::cty::c_uint,
        allow_ranges: ::aya_ebpf::cty::c_uint,
        subrequest_ranges: ::aya_ebpf::cty::c_uint,
        single_range: ::aya_ebpf::cty::c_uint,
        disable_not_modified: ::aya_ebpf::cty::c_uint,
        stat_reading: ::aya_ebpf::cty::c_uint,
        stat_writing: ::aya_ebpf::cty::c_uint,
        stat_processing: ::aya_ebpf::cty::c_uint,
        background: ::aya_ebpf::cty::c_uint,
        health_check: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 15usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 15usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let count: u32 = unsafe { ::core::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let subrequests: u32 = unsafe { ::core::mem::transmute(subrequests) };
            subrequests as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let blocked: u32 = unsafe { ::core::mem::transmute(blocked) };
            blocked as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let aio: u32 = unsafe { ::core::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit.set(33usize, 4u8, {
            let http_state: u32 = unsafe { ::core::mem::transmute(http_state) };
            http_state as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let complex_uri: u32 = unsafe { ::core::mem::transmute(complex_uri) };
            complex_uri as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let quoted_uri: u32 = unsafe { ::core::mem::transmute(quoted_uri) };
            quoted_uri as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let plus_in_uri: u32 = unsafe { ::core::mem::transmute(plus_in_uri) };
            plus_in_uri as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let empty_path_in_uri: u32 = unsafe { ::core::mem::transmute(empty_path_in_uri) };
            empty_path_in_uri as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let invalid_header: u32 = unsafe { ::core::mem::transmute(invalid_header) };
            invalid_header as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let add_uri_to_alias: u32 = unsafe { ::core::mem::transmute(add_uri_to_alias) };
            add_uri_to_alias as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let valid_location: u32 = unsafe { ::core::mem::transmute(valid_location) };
            valid_location as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let valid_unparsed_uri: u32 = unsafe { ::core::mem::transmute(valid_unparsed_uri) };
            valid_unparsed_uri as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let uri_changed: u32 = unsafe { ::core::mem::transmute(uri_changed) };
            uri_changed as u64
        });
        __bindgen_bitfield_unit.set(46usize, 4u8, {
            let uri_changes: u32 = unsafe { ::core::mem::transmute(uri_changes) };
            uri_changes as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let request_body_in_single_buf: u32 = unsafe { ::core::mem::transmute(request_body_in_single_buf) };
            request_body_in_single_buf as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let request_body_in_file_only: u32 = unsafe { ::core::mem::transmute(request_body_in_file_only) };
            request_body_in_file_only as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let request_body_in_persistent_file: u32 =
                unsafe { ::core::mem::transmute(request_body_in_persistent_file) };
            request_body_in_persistent_file as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let request_body_in_clean_file: u32 = unsafe { ::core::mem::transmute(request_body_in_clean_file) };
            request_body_in_clean_file as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let request_body_file_group_access: u32 = unsafe { ::core::mem::transmute(request_body_file_group_access) };
            request_body_file_group_access as u64
        });
        __bindgen_bitfield_unit.set(55usize, 3u8, {
            let request_body_file_log_level: u32 = unsafe { ::core::mem::transmute(request_body_file_log_level) };
            request_body_file_log_level as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let request_body_no_buffering: u32 = unsafe { ::core::mem::transmute(request_body_no_buffering) };
            request_body_no_buffering as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let subrequest_in_memory: u32 = unsafe { ::core::mem::transmute(subrequest_in_memory) };
            subrequest_in_memory as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let waited: u32 = unsafe { ::core::mem::transmute(waited) };
            waited as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let cached: u32 = unsafe { ::core::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let gzip_tested: u32 = unsafe { ::core::mem::transmute(gzip_tested) };
            gzip_tested as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let gzip_ok: u32 = unsafe { ::core::mem::transmute(gzip_ok) };
            gzip_ok as u64
        });
        __bindgen_bitfield_unit.set(64usize, 1u8, {
            let gzip_vary: u32 = unsafe { ::core::mem::transmute(gzip_vary) };
            gzip_vary as u64
        });
        __bindgen_bitfield_unit.set(65usize, 1u8, {
            let realloc_captures: u32 = unsafe { ::core::mem::transmute(realloc_captures) };
            realloc_captures as u64
        });
        __bindgen_bitfield_unit.set(66usize, 1u8, {
            let proxy: u32 = unsafe { ::core::mem::transmute(proxy) };
            proxy as u64
        });
        __bindgen_bitfield_unit.set(67usize, 1u8, {
            let bypass_cache: u32 = unsafe { ::core::mem::transmute(bypass_cache) };
            bypass_cache as u64
        });
        __bindgen_bitfield_unit.set(68usize, 1u8, {
            let no_cache: u32 = unsafe { ::core::mem::transmute(no_cache) };
            no_cache as u64
        });
        __bindgen_bitfield_unit.set(69usize, 2u8, {
            let limit_conn_status: u32 = unsafe { ::core::mem::transmute(limit_conn_status) };
            limit_conn_status as u64
        });
        __bindgen_bitfield_unit.set(71usize, 3u8, {
            let limit_req_status: u32 = unsafe { ::core::mem::transmute(limit_req_status) };
            limit_req_status as u64
        });
        __bindgen_bitfield_unit.set(74usize, 1u8, {
            let limit_rate_set: u32 = unsafe { ::core::mem::transmute(limit_rate_set) };
            limit_rate_set as u64
        });
        __bindgen_bitfield_unit.set(75usize, 1u8, {
            let limit_rate_after_set: u32 = unsafe { ::core::mem::transmute(limit_rate_after_set) };
            limit_rate_after_set as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let pipeline: u32 = unsafe { ::core::mem::transmute(pipeline) };
            pipeline as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let chunked: u32 = unsafe { ::core::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit.set(78usize, 1u8, {
            let header_only: u32 = unsafe { ::core::mem::transmute(header_only) };
            header_only as u64
        });
        __bindgen_bitfield_unit.set(79usize, 1u8, {
            let expect_trailers: u32 = unsafe { ::core::mem::transmute(expect_trailers) };
            expect_trailers as u64
        });
        __bindgen_bitfield_unit.set(80usize, 1u8, {
            let keepalive: u32 = unsafe { ::core::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(81usize, 1u8, {
            let lingering_close: u32 = unsafe { ::core::mem::transmute(lingering_close) };
            lingering_close as u64
        });
        __bindgen_bitfield_unit.set(82usize, 1u8, {
            let discard_body: u32 = unsafe { ::core::mem::transmute(discard_body) };
            discard_body as u64
        });
        __bindgen_bitfield_unit.set(83usize, 1u8, {
            let reading_body: u32 = unsafe { ::core::mem::transmute(reading_body) };
            reading_body as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let internal: u32 = unsafe { ::core::mem::transmute(internal) };
            internal as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let error_page: u32 = unsafe { ::core::mem::transmute(error_page) };
            error_page as u64
        });
        __bindgen_bitfield_unit.set(86usize, 1u8, {
            let filter_finalize: u32 = unsafe { ::core::mem::transmute(filter_finalize) };
            filter_finalize as u64
        });
        __bindgen_bitfield_unit.set(87usize, 1u8, {
            let post_action: u32 = unsafe { ::core::mem::transmute(post_action) };
            post_action as u64
        });
        __bindgen_bitfield_unit.set(88usize, 1u8, {
            let request_complete: u32 = unsafe { ::core::mem::transmute(request_complete) };
            request_complete as u64
        });
        __bindgen_bitfield_unit.set(89usize, 1u8, {
            let request_output: u32 = unsafe { ::core::mem::transmute(request_output) };
            request_output as u64
        });
        __bindgen_bitfield_unit.set(90usize, 1u8, {
            let header_sent: u32 = unsafe { ::core::mem::transmute(header_sent) };
            header_sent as u64
        });
        __bindgen_bitfield_unit.set(91usize, 1u8, {
            let expect_tested: u32 = unsafe { ::core::mem::transmute(expect_tested) };
            expect_tested as u64
        });
        __bindgen_bitfield_unit.set(92usize, 1u8, {
            let root_tested: u32 = unsafe { ::core::mem::transmute(root_tested) };
            root_tested as u64
        });
        __bindgen_bitfield_unit.set(93usize, 1u8, {
            let done: u32 = unsafe { ::core::mem::transmute(done) };
            done as u64
        });
        __bindgen_bitfield_unit.set(94usize, 1u8, {
            let logged: u32 = unsafe { ::core::mem::transmute(logged) };
            logged as u64
        });
        __bindgen_bitfield_unit.set(96usize, 4u8, {
            let buffered: u32 = unsafe { ::core::mem::transmute(buffered) };
            buffered as u64
        });
        __bindgen_bitfield_unit.set(100usize, 1u8, {
            let main_filter_need_in_memory: u32 = unsafe { ::core::mem::transmute(main_filter_need_in_memory) };
            main_filter_need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(101usize, 1u8, {
            let filter_need_in_memory: u32 = unsafe { ::core::mem::transmute(filter_need_in_memory) };
            filter_need_in_memory as u64
        });
        __bindgen_bitfield_unit.set(102usize, 1u8, {
            let filter_need_temporary: u32 = unsafe { ::core::mem::transmute(filter_need_temporary) };
            filter_need_temporary as u64
        });
        __bindgen_bitfield_unit.set(103usize, 1u8, {
            let preserve_body: u32 = unsafe { ::core::mem::transmute(preserve_body) };
            preserve_body as u64
        });
        __bindgen_bitfield_unit.set(104usize, 1u8, {
            let allow_ranges: u32 = unsafe { ::core::mem::transmute(allow_ranges) };
            allow_ranges as u64
        });
        __bindgen_bitfield_unit.set(105usize, 1u8, {
            let subrequest_ranges: u32 = unsafe { ::core::mem::transmute(subrequest_ranges) };
            subrequest_ranges as u64
        });
        __bindgen_bitfield_unit.set(106usize, 1u8, {
            let single_range: u32 = unsafe { ::core::mem::transmute(single_range) };
            single_range as u64
        });
        __bindgen_bitfield_unit.set(107usize, 1u8, {
            let disable_not_modified: u32 = unsafe { ::core::mem::transmute(disable_not_modified) };
            disable_not_modified as u64
        });
        __bindgen_bitfield_unit.set(108usize, 1u8, {
            let stat_reading: u32 = unsafe { ::core::mem::transmute(stat_reading) };
            stat_reading as u64
        });
        __bindgen_bitfield_unit.set(109usize, 1u8, {
            let stat_writing: u32 = unsafe { ::core::mem::transmute(stat_writing) };
            stat_writing as u64
        });
        __bindgen_bitfield_unit.set(110usize, 1u8, {
            let stat_processing: u32 = unsafe { ::core::mem::transmute(stat_processing) };
            stat_processing as u64
        });
        __bindgen_bitfield_unit.set(111usize, 1u8, {
            let background: u32 = unsafe { ::core::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(112usize, 1u8, {
            let health_check: u32 = unsafe { ::core::mem::transmute(health_check) };
            health_check as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn http_minor(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_http_minor(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn http_major(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_http_major(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        http_minor: ::aya_ebpf::cty::c_uint,
        http_major: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let http_minor: u32 = unsafe { ::core::mem::transmute(http_minor) };
            http_minor as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let http_major: u32 = unsafe { ::core::mem::transmute(http_major) };
            http_major as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ephemeral_t {
    pub terminal_posted_request: ngx_http_posted_request_t,
}
extern "C" {
    pub static mut ngx_http_headers_in: [ngx_http_header_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_headers_out: [ngx_http_header_out_t; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_engine_t {
    pub ip: *mut u_char,
    pub pos: *mut u_char,
    pub sp: *mut ngx_http_variable_value_t,
    pub buf: ngx_str_t,
    pub line: ngx_str_t,
    pub args: *mut u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub status: ngx_int_t,
    pub request: *mut ngx_http_request_t,
}
impl ngx_http_script_engine_t {
    #[inline]
    pub fn flushed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flushed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quote(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quote(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_log(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flushed: ::aya_ebpf::cty::c_uint,
        skip: ::aya_ebpf::cty::c_uint,
        quote: ::aya_ebpf::cty::c_uint,
        is_args: ::aya_ebpf::cty::c_uint,
        log: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flushed: u32 = unsafe { ::core::mem::transmute(flushed) };
            flushed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip: u32 = unsafe { ::core::mem::transmute(skip) };
            skip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let quote: u32 = unsafe { ::core::mem::transmute(quote) };
            quote as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_args: u32 = unsafe { ::core::mem::transmute(is_args) };
            is_args as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let log: u32 = unsafe { ::core::mem::transmute(log) };
            log as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_compile_t {
    pub cf: *mut ngx_conf_t,
    pub source: *mut ngx_str_t,
    pub flushes: *mut *mut ngx_array_t,
    pub lengths: *mut *mut ngx_array_t,
    pub values: *mut *mut ngx_array_t,
    pub variables: ngx_uint_t,
    pub ncaptures: ngx_uint_t,
    pub captures_mask: ngx_uint_t,
    pub size: ngx_uint_t,
    pub main: *mut ::aya_ebpf::cty::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_script_compile_t {
    #[inline]
    pub fn compile_args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compile_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_lengths(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete_lengths(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_values(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete_values(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conf_prefix(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_conf_prefix(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_prefix(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_prefix(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dup_capture(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dup_capture(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compile_args: ::aya_ebpf::cty::c_uint,
        complete_lengths: ::aya_ebpf::cty::c_uint,
        complete_values: ::aya_ebpf::cty::c_uint,
        zero: ::aya_ebpf::cty::c_uint,
        conf_prefix: ::aya_ebpf::cty::c_uint,
        root_prefix: ::aya_ebpf::cty::c_uint,
        dup_capture: ::aya_ebpf::cty::c_uint,
        args: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compile_args: u32 = unsafe { ::core::mem::transmute(compile_args) };
            compile_args as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let complete_lengths: u32 = unsafe { ::core::mem::transmute(complete_lengths) };
            complete_lengths as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let complete_values: u32 = unsafe { ::core::mem::transmute(complete_values) };
            complete_values as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let zero: u32 = unsafe { ::core::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let conf_prefix: u32 = unsafe { ::core::mem::transmute(conf_prefix) };
            conf_prefix as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let root_prefix: u32 = unsafe { ::core::mem::transmute(root_prefix) };
            root_prefix as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dup_capture: u32 = unsafe { ::core::mem::transmute(dup_capture) };
            dup_capture as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let args: u32 = unsafe { ::core::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_complex_value_t {
    pub value: ngx_str_t,
    pub flushes: *mut ngx_uint_t,
    pub lengths: *mut ::aya_ebpf::cty::c_void,
    pub values: *mut ::aya_ebpf::cty::c_void,
    pub u: ngx_http_complex_value_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ngx_http_complex_value_t__bindgen_ty_1 {
    pub size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_compile_complex_value_t {
    pub cf: *mut ngx_conf_t,
    pub value: *mut ngx_str_t,
    pub complex_value: *mut ngx_http_complex_value_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_compile_complex_value_t {
    #[inline]
    pub fn zero(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conf_prefix(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_conf_prefix(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn root_prefix(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_root_prefix(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        zero: ::aya_ebpf::cty::c_uint,
        conf_prefix: ::aya_ebpf::cty::c_uint,
        root_prefix: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zero: u32 = unsafe { ::core::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let conf_prefix: u32 = unsafe { ::core::mem::transmute(conf_prefix) };
            conf_prefix as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let root_prefix: u32 = unsafe { ::core::mem::transmute(root_prefix) };
            root_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_script_code_pt = ::core::option::Option<unsafe extern "C" fn(e: *mut ngx_http_script_engine_t)>;
pub type ngx_http_script_len_code_pt =
    ::core::option::Option<unsafe extern "C" fn(e: *mut ngx_http_script_engine_t) -> usize>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_copy_code_t {
    pub code: ngx_http_script_code_pt,
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_var_code_t {
    pub code: ngx_http_script_code_pt,
    pub index: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_var_handler_code_t {
    pub code: ngx_http_script_code_pt,
    pub handler: ngx_http_set_variable_pt,
    pub data: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_copy_capture_code_t {
    pub code: ngx_http_script_code_pt,
    pub n: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_regex_code_t {
    pub code: ngx_http_script_code_pt,
    pub regex: *mut ngx_http_regex_t,
    pub lengths: *mut ngx_array_t,
    pub size: usize,
    pub status: usize,
    pub next: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub name: ngx_str_t,
}
impl ngx_http_script_regex_code_t {
    #[inline]
    pub fn test(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn negative_test(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_negative_test(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn break_cycle(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_break_cycle(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        test: ::aya_ebpf::cty::c_uint,
        negative_test: ::aya_ebpf::cty::c_uint,
        uri: ::aya_ebpf::cty::c_uint,
        args: ::aya_ebpf::cty::c_uint,
        add_args: ::aya_ebpf::cty::c_uint,
        redirect: ::aya_ebpf::cty::c_uint,
        break_cycle: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let test: u32 = unsafe { ::core::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let negative_test: u32 = unsafe { ::core::mem::transmute(negative_test) };
            negative_test as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let uri: u32 = unsafe { ::core::mem::transmute(uri) };
            uri as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let args: u32 = unsafe { ::core::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let add_args: u32 = unsafe { ::core::mem::transmute(add_args) };
            add_args as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let redirect: u32 = unsafe { ::core::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let break_cycle: u32 = unsafe { ::core::mem::transmute(break_cycle) };
            break_cycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_regex_end_code_t {
    pub code: ngx_http_script_code_pt,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_script_regex_end_code_t {
    #[inline]
    pub fn uri(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uri(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn add_args(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_add_args(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirect(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redirect(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uri: ::aya_ebpf::cty::c_uint,
        args: ::aya_ebpf::cty::c_uint,
        add_args: ::aya_ebpf::cty::c_uint,
        redirect: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uri: u32 = unsafe { ::core::mem::transmute(uri) };
            uri as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let args: u32 = unsafe { ::core::mem::transmute(args) };
            args as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let add_args: u32 = unsafe { ::core::mem::transmute(add_args) };
            add_args as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let redirect: u32 = unsafe { ::core::mem::transmute(redirect) };
            redirect as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_full_name_code_t {
    pub code: ngx_http_script_code_pt,
    pub conf_prefix: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_script_return_code_t {
    pub code: ngx_http_script_code_pt,
    pub status: usize,
    pub text: ngx_http_complex_value_t,
}
pub const ngx_http_script_file_op_e_ngx_http_script_file_plain: ngx_http_script_file_op_e = 0;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_plain: ngx_http_script_file_op_e = 1;
pub const ngx_http_script_file_op_e_ngx_http_script_file_dir: ngx_http_script_file_op_e = 2;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_dir: ngx_http_script_file_op_e = 3;
pub const ngx_http_script_file_op_e_ngx_http_script_file_exists: ngx_http_script_file_op_e = 4;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_exists: ngx_http_script_file_op_e = 5;
pub const ngx_http_script_file_op_e_ngx_http_script_file_exec: ngx_http_script_file_op_e = 6;
pub const ngx_http_script_file_op_e_ngx_http_script_file_not_exec: ngx_http_script_file_op_e = 7;
pub type ngx_http_script_file_op_e = ::aya_ebpf::cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_file_code_t {
    pub code: ngx_http_script_code_pt,
    pub op: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_if_code_t {
    pub code: ngx_http_script_code_pt,
    pub next: usize,
    pub loc_conf: *mut *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_complex_value_code_t {
    pub code: ngx_http_script_code_pt,
    pub lengths: *mut ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_script_value_code_t {
    pub code: ngx_http_script_code_pt,
    pub value: usize,
    pub text_len: usize,
    pub text_data: usize,
}
extern "C" {
    pub fn ngx_http_script_flush_complex_value(r: *mut ngx_http_request_t, val: *mut ngx_http_complex_value_t);
}
extern "C" {
    pub fn ngx_http_complex_value(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_complex_value_size(
        r: *mut ngx_http_request_t,
        val: *mut ngx_http_complex_value_t,
        default_value: usize,
    ) -> usize;
}
extern "C" {
    pub fn ngx_http_compile_complex_value(ccv: *mut ngx_http_compile_complex_value_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_complex_value_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_set_complex_value_zero_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_set_complex_value_size_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_test_predicates(r: *mut ngx_http_request_t, predicates: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_test_required_predicates(r: *mut ngx_http_request_t, predicates: *mut ngx_array_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_predicate_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_script_variables_count(value: *mut ngx_str_t) -> ngx_uint_t;
}
extern "C" {
    pub fn ngx_http_script_compile(sc: *mut ngx_http_script_compile_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_script_run(
        r: *mut ngx_http_request_t,
        value: *mut ngx_str_t,
        code_lengths: *mut ::aya_ebpf::cty::c_void,
        reserved: usize,
        code_values: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_script_flush_no_cacheable_variables(r: *mut ngx_http_request_t, indices: *mut ngx_array_t);
}
extern "C" {
    pub fn ngx_http_script_start_code(
        pool: *mut ngx_pool_t,
        codes: *mut *mut ngx_array_t,
        size: usize,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_script_add_code(
        codes: *mut ngx_array_t,
        size: usize,
        code: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_script_copy_len_code(e: *mut ngx_http_script_engine_t) -> usize;
}
extern "C" {
    pub fn ngx_http_script_copy_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_copy_var_len_code(e: *mut ngx_http_script_engine_t) -> usize;
}
extern "C" {
    pub fn ngx_http_script_copy_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_copy_capture_len_code(e: *mut ngx_http_script_engine_t) -> usize;
}
extern "C" {
    pub fn ngx_http_script_copy_capture_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_mark_args_code(e: *mut ngx_http_script_engine_t) -> usize;
}
extern "C" {
    pub fn ngx_http_script_start_args_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_regex_start_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_regex_end_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_return_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_break_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_if_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_equal_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_not_equal_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_file_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_complex_value_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_value_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_set_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_var_set_handler_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_var_code(e: *mut ngx_http_script_engine_t);
}
extern "C" {
    pub fn ngx_http_script_nop_code(e: *mut ngx_http_script_engine_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_s {
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub available: ::aya_ebpf::cty::c_int,
    pub handler: ngx_event_handler_pt,
    pub index: ngx_uint_t,
    pub log: *mut ngx_log_t,
    pub timer: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub saved_handler: ngx_event_handler_pt,
}
impl ngx_event_s {
    #[inline]
    pub fn write(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accept(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instance(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_instance(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn active(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_active(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ready(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ready(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oneshot(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oneshot(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn complete(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_complete(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eof(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eof(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timedout(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timedout(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_set(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_set(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delayed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delayed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_eof(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pending_eof(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn posted(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_posted(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn closed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_closed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resolver(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resolver(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_socket_leak_check(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_socket_leak_check(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cancelable(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cancelable(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        write: ::aya_ebpf::cty::c_uint,
        accept: ::aya_ebpf::cty::c_uint,
        instance: ::aya_ebpf::cty::c_uint,
        active: ::aya_ebpf::cty::c_uint,
        disabled: ::aya_ebpf::cty::c_uint,
        ready: ::aya_ebpf::cty::c_uint,
        oneshot: ::aya_ebpf::cty::c_uint,
        complete: ::aya_ebpf::cty::c_uint,
        eof: ::aya_ebpf::cty::c_uint,
        error: ::aya_ebpf::cty::c_uint,
        timedout: ::aya_ebpf::cty::c_uint,
        timer_set: ::aya_ebpf::cty::c_uint,
        delayed: ::aya_ebpf::cty::c_uint,
        deferred_accept: ::aya_ebpf::cty::c_uint,
        pending_eof: ::aya_ebpf::cty::c_uint,
        posted: ::aya_ebpf::cty::c_uint,
        closed: ::aya_ebpf::cty::c_uint,
        channel: ::aya_ebpf::cty::c_uint,
        resolver: ::aya_ebpf::cty::c_uint,
        skip_socket_leak_check: ::aya_ebpf::cty::c_uint,
        cancelable: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let write: u32 = unsafe { ::core::mem::transmute(write) };
            write as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let accept: u32 = unsafe { ::core::mem::transmute(accept) };
            accept as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let instance: u32 = unsafe { ::core::mem::transmute(instance) };
            instance as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let active: u32 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disabled: u32 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ready: u32 = unsafe { ::core::mem::transmute(ready) };
            ready as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let oneshot: u32 = unsafe { ::core::mem::transmute(oneshot) };
            oneshot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let complete: u32 = unsafe { ::core::mem::transmute(complete) };
            complete as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let eof: u32 = unsafe { ::core::mem::transmute(eof) };
            eof as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let timedout: u32 = unsafe { ::core::mem::transmute(timedout) };
            timedout as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let timer_set: u32 = unsafe { ::core::mem::transmute(timer_set) };
            timer_set as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delayed: u32 = unsafe { ::core::mem::transmute(delayed) };
            delayed as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::core::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let pending_eof: u32 = unsafe { ::core::mem::transmute(pending_eof) };
            pending_eof as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let posted: u32 = unsafe { ::core::mem::transmute(posted) };
            posted as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let closed: u32 = unsafe { ::core::mem::transmute(closed) };
            closed as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let channel: u32 = unsafe { ::core::mem::transmute(channel) };
            channel as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let resolver: u32 = unsafe { ::core::mem::transmute(resolver) };
            resolver as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let skip_socket_leak_check: u32 = unsafe { ::core::mem::transmute(skip_socket_leak_check) };
            skip_socket_leak_check as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let cancelable: u32 = unsafe { ::core::mem::transmute(cancelable) };
            cancelable as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn async_(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(async_: ::aya_ebpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let async_: u32 = unsafe { ::core::mem::transmute(async_) };
            async_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_aio_s {
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub handler: ngx_event_handler_pt,
    pub file: *mut ngx_file_t,
    pub fd: ngx_fd_t,
    pub preload_handler: ::core::option::Option<unsafe extern "C" fn(file: *mut ngx_buf_t) -> isize>,
    pub res: i64,
    pub aiocb: ngx_aiocb_t,
    pub event: ngx_event_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_actions_t {
    pub add: ::core::option::Option<
        unsafe extern "C" fn(ev: *mut ngx_event_t, event: ngx_int_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub del: ::core::option::Option<
        unsafe extern "C" fn(ev: *mut ngx_event_t, event: ngx_int_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub enable: ::core::option::Option<
        unsafe extern "C" fn(ev: *mut ngx_event_t, event: ngx_int_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub disable: ::core::option::Option<
        unsafe extern "C" fn(ev: *mut ngx_event_t, event: ngx_int_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub add_conn: ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t) -> ngx_int_t>,
    pub del_conn: ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t, flags: ngx_uint_t) -> ngx_int_t>,
    pub notify: ::core::option::Option<unsafe extern "C" fn(handler: ngx_event_handler_pt) -> ngx_int_t>,
    pub process_events: ::core::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, timer: ngx_msec_t, flags: ngx_uint_t) -> ngx_int_t,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t, timer: ngx_msec_t) -> ngx_int_t>,
    pub done: ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t)>,
    #[doc = "  KLNE 0057 ASYNC_SSL\n\n  支持异步SSL"]
    pub add_async_conn: ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t) -> ngx_int_t>,
    pub del_async_conn:
        ::core::option::Option<unsafe extern "C" fn(c: *mut ngx_connection_t, flags: ngx_uint_t) -> ngx_int_t>,
}
extern "C" {
    pub static mut ngx_event_actions: ngx_event_actions_t;
}
extern "C" {
    pub static mut ngx_use_epoll_rdhup: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_io: ngx_os_io_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_conf_t {
    pub connections: ngx_uint_t,
    pub use_: ngx_uint_t,
    pub multi_accept: ngx_flag_t,
    pub accept_mutex: ngx_flag_t,
    pub accept_mutex_delay: ngx_msec_t,
    pub name: *mut u_char,
    pub debug_connection: ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_module_t {
    pub name: *mut ngx_str_t,
    pub create_conf:
        ::core::option::Option<unsafe extern "C" fn(cycle: *mut ngx_cycle_t) -> *mut ::aya_ebpf::cty::c_void>,
    pub init_conf: ::core::option::Option<
        unsafe extern "C" fn(cycle: *mut ngx_cycle_t, conf: *mut ::aya_ebpf::cty::c_void) -> *mut ::aya_ebpf::cty::c_char,
    >,
    pub actions: ngx_event_actions_t,
}
extern "C" {
    pub static mut ngx_connection_counter: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_ptr: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_accept_mutex: ngx_shmtx_t;
}
extern "C" {
    pub static mut ngx_use_accept_mutex: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_events: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_held: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_accept_mutex_delay: ngx_msec_t;
}
extern "C" {
    pub static mut ngx_accept_disabled: ngx_int_t;
}
extern "C" {
    pub static mut ngx_stat_accepted: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_handled: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_requests: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_active: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_reading: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_writing: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_waiting: *mut ngx_atomic_t;
}
extern "C" {
    #[doc = " KLNE 0027 STATUS_MONITOR\n\n 支持状态监控"]
    pub static mut ngx_stat_upstream_active_connection: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_upstream_cumulative_connection: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_ssl_session_new: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_ssl_session_reused: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_ssl_session_failed: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_ssl_session_non_expired_dropped: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_sni_match_servername_failures: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_sni_mismatch_host_count: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_host_match_servername_failures: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_stat_worker_spawned_since_start_or_reload: *mut ngx_atomic_t;
}
extern "C" {
    pub static mut ngx_event_timer_alarm: sig_atomic_t;
}
extern "C" {
    pub static mut ngx_event_flags: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_events_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_event_core_module: ngx_module_t;
}
extern "C" {
    pub fn ngx_event_accept(ev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_event_recvmsg(ev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_udp_rbtree_insert_value(
        temp: *mut ngx_rbtree_node_t,
        node: *mut ngx_rbtree_node_t,
        sentinel: *mut ngx_rbtree_node_t,
    );
}
extern "C" {
    pub fn ngx_delete_udp_connection(data: *mut ::aya_ebpf::cty::c_void);
}
extern "C" {
    pub fn ngx_trylock_accept_mutex(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_enable_accept_events(cycle: *mut ngx_cycle_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_accept_log_error(log: *mut ngx_log_t, buf: *mut u_char, len: usize) -> *mut u_char;
}
extern "C" {
    pub fn ngx_debug_accepted_connection(ecf: *mut ngx_event_conf_t, c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_process_events_and_timers(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub fn ngx_handle_read_event(rev: *mut ngx_event_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_handle_write_event(wev: *mut ngx_event_t, lowat: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_send_lowat(c: *mut ngx_connection_t, lowat: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_timer_init(log: *mut ngx_log_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_find_timer() -> ngx_msec_t;
}
extern "C" {
    pub fn ngx_event_expire_timers();
}
extern "C" {
    pub fn ngx_event_no_timers_left() -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_event_timer_rbtree: ngx_rbtree_t;
}
extern "C" {
    pub fn ngx_event_process_posted(cycle: *mut ngx_cycle_t, posted: *mut ngx_queue_t);
}
extern "C" {
    pub fn ngx_event_move_posted_next(cycle: *mut ngx_cycle_t);
}
extern "C" {
    pub static mut ngx_posted_accept_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_next_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_events: ngx_queue_t;
}
extern "C" {
    pub static mut ngx_posted_delayed_events: ngx_queue_t;
}
pub type ngx_peer_connection_t = ngx_peer_connection_s;
pub type ngx_event_get_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t,
>;
pub type ngx_event_free_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut ::aya_ebpf::cty::c_void, state: ngx_uint_t),
>;
pub type ngx_event_notify_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut ::aya_ebpf::cty::c_void, type_: ngx_uint_t),
>;
pub type ngx_event_set_peer_session_pt = ::core::option::Option<
    unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t,
>;
pub type ngx_event_save_peer_session_pt =
    ::core::option::Option<unsafe extern "C" fn(pc: *mut ngx_peer_connection_t, data: *mut ::aya_ebpf::cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_peer_connection_s {
    pub connection: *mut ngx_connection_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: *mut ngx_str_t,
    pub tries: ngx_uint_t,
    pub start_time: ngx_msec_t,
    pub get: ngx_event_get_peer_pt,
    pub free: ngx_event_free_peer_pt,
    pub notify: ngx_event_notify_peer_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
    pub set_session: ngx_event_set_peer_session_pt,
    pub save_session: ngx_event_save_peer_session_pt,
    pub local: *mut ngx_addr_t,
    pub type_: ::aya_ebpf::cty::c_int,
    pub rcvbuf: ::aya_ebpf::cty::c_int,
    pub log: *mut ngx_log_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub spare: [u64; 2usize],
}
impl ngx_peer_connection_s {
    #[inline]
    pub fn cached(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cached(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transparent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transparent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn so_keepalive(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_so_keepalive(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn down(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_down(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn backup(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backup(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log_error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_log_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cached: ::aya_ebpf::cty::c_uint,
        transparent: ::aya_ebpf::cty::c_uint,
        so_keepalive: ::aya_ebpf::cty::c_uint,
        down: ::aya_ebpf::cty::c_uint,
        backup: ::aya_ebpf::cty::c_uint,
        log_error: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cached: u32 = unsafe { ::core::mem::transmute(cached) };
            cached as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transparent: u32 = unsafe { ::core::mem::transmute(transparent) };
            transparent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let so_keepalive: u32 = unsafe { ::core::mem::transmute(so_keepalive) };
            so_keepalive as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let down: u32 = unsafe { ::core::mem::transmute(down) };
            down as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let backup: u32 = unsafe { ::core::mem::transmute(backup) };
            backup as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let log_error: u32 = unsafe { ::core::mem::transmute(log_error) };
            log_error as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_event_connect_peer(pc: *mut ngx_peer_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_get_peer(pc: *mut ngx_peer_connection_t, data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t;
}
pub type ngx_event_pipe_t = ngx_event_pipe_s;
pub type ngx_event_pipe_input_filter_pt =
    ::core::option::Option<unsafe extern "C" fn(p: *mut ngx_event_pipe_t, buf: *mut ngx_buf_t) -> ngx_int_t>;
pub type ngx_event_pipe_output_filter_pt = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void, chain: *mut ngx_chain_t) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_event_pipe_s {
    pub upstream: *mut ngx_connection_t,
    pub downstream: *mut ngx_connection_t,
    pub free_raw_bufs: *mut ngx_chain_t,
    pub in_: *mut ngx_chain_t,
    pub last_in: *mut *mut ngx_chain_t,
    pub writing: *mut ngx_chain_t,
    pub out: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub input_filter: ngx_event_pipe_input_filter_pt,
    pub input_ctx: *mut ::aya_ebpf::cty::c_void,
    pub output_filter: ngx_event_pipe_output_filter_pt,
    pub output_ctx: *mut ::aya_ebpf::cty::c_void,
    pub thread_handler:
        ::core::option::Option<unsafe extern "C" fn(task: *mut ngx_thread_task_t, file: *mut ngx_file_t) -> ngx_int_t>,
    pub thread_ctx: *mut ::aya_ebpf::cty::c_void,
    pub thread_task: *mut ngx_thread_task_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub allocated: ngx_int_t,
    pub bufs: ngx_bufs_t,
    pub tag: ngx_buf_tag_t,
    pub busy_size: isize,
    pub read_length: off_t,
    pub length: off_t,
    pub max_temp_file_size: off_t,
    pub temp_file_write_size: isize,
    pub read_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub send_lowat: isize,
    pub pool: *mut ngx_pool_t,
    pub log: *mut ngx_log_t,
    pub preread_bufs: *mut ngx_chain_t,
    pub preread_size: usize,
    pub buf_to_file: *mut ngx_buf_t,
    pub limit_rate: usize,
    pub start_sec: time_t,
    pub temp_file: *mut ngx_temp_file_t,
    pub num: ::aya_ebpf::cty::c_int,
}
impl ngx_event_pipe_s {
    #[inline]
    pub fn read(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cacheable(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cacheable(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn single_buf(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single_buf(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn free_bufs(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_free_bufs(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_done(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_done(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_eof(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_eof(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upstream_blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upstream_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downstream_done(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downstream_done(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn downstream_error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_downstream_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cyclic_temp_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cyclic_temp_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aio(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aio(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read: ::aya_ebpf::cty::c_uint,
        cacheable: ::aya_ebpf::cty::c_uint,
        single_buf: ::aya_ebpf::cty::c_uint,
        free_bufs: ::aya_ebpf::cty::c_uint,
        upstream_done: ::aya_ebpf::cty::c_uint,
        upstream_error: ::aya_ebpf::cty::c_uint,
        upstream_eof: ::aya_ebpf::cty::c_uint,
        upstream_blocked: ::aya_ebpf::cty::c_uint,
        downstream_done: ::aya_ebpf::cty::c_uint,
        downstream_error: ::aya_ebpf::cty::c_uint,
        cyclic_temp_file: ::aya_ebpf::cty::c_uint,
        aio: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read: u32 = unsafe { ::core::mem::transmute(read) };
            read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cacheable: u32 = unsafe { ::core::mem::transmute(cacheable) };
            cacheable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let single_buf: u32 = unsafe { ::core::mem::transmute(single_buf) };
            single_buf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let free_bufs: u32 = unsafe { ::core::mem::transmute(free_bufs) };
            free_bufs as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let upstream_done: u32 = unsafe { ::core::mem::transmute(upstream_done) };
            upstream_done as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let upstream_error: u32 = unsafe { ::core::mem::transmute(upstream_error) };
            upstream_error as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let upstream_eof: u32 = unsafe { ::core::mem::transmute(upstream_eof) };
            upstream_eof as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let upstream_blocked: u32 = unsafe { ::core::mem::transmute(upstream_blocked) };
            upstream_blocked as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let downstream_done: u32 = unsafe { ::core::mem::transmute(downstream_done) };
            downstream_done as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let downstream_error: u32 = unsafe { ::core::mem::transmute(downstream_error) };
            downstream_error as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cyclic_temp_file: u32 = unsafe { ::core::mem::transmute(cyclic_temp_file) };
            cyclic_temp_file as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let aio: u32 = unsafe { ::core::mem::transmute(aio) };
            aio as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_event_pipe(p: *mut ngx_event_pipe_t, do_write: ngx_int_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_pipe_copy_input_filter(p: *mut ngx_event_pipe_t, buf: *mut ngx_buf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_event_pipe_add_free_buf(p: *mut ngx_event_pipe_t, b: *mut ngx_buf_t) -> ngx_int_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_state_t {
    pub status: ngx_uint_t,
    pub response_time: ngx_msec_t,
    pub connect_time: ngx_msec_t,
    pub header_time: ngx_msec_t,
    pub queue_time: ngx_msec_t,
    pub response_length: off_t,
    pub bytes_received: off_t,
    pub bytes_sent: off_t,
    #[doc = " KLNE 0080 UPSTREAM_VARIABLES\n\n 添加upstream变量, 方便在访问日志中确定是否为backup server"]
    pub backup: ngx_uint_t,
    pub peer: *mut ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_main_conf_t {
    pub headers_in_hash: ngx_hash_t,
    pub upstreams: ngx_array_t,
}
pub type ngx_http_upstream_srv_conf_t = ngx_http_upstream_srv_conf_s;
pub type ngx_http_upstream_init_pt = ::core::option::Option<
    unsafe extern "C" fn(cf: *mut ngx_conf_t, us: *mut ngx_http_upstream_srv_conf_t) -> ngx_int_t,
>;
pub type ngx_http_upstream_init_peer_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, us: *mut ngx_http_upstream_srv_conf_t) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_peer_t {
    pub init_upstream: ngx_http_upstream_init_pt,
    pub init: ngx_http_upstream_init_peer_pt,
    pub data: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_server_t {
    pub name: ngx_str_t,
    pub addrs: *mut ngx_addr_t,
    pub naddrs: ngx_uint_t,
    pub weight: ngx_uint_t,
    pub max_conns: ngx_uint_t,
    pub max_fails: ngx_uint_t,
    pub fail_timeout: time_t,
    pub slow_start: ngx_msec_t,
    pub down: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub spare: [u64; 6usize],
}
impl ngx_http_upstream_server_t {
    #[inline]
    pub fn backup(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backup(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(backup: ::aya_ebpf::cty::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let backup: u32 = unsafe { ::core::mem::transmute(backup) };
            backup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_srv_conf_s {
    pub peer: ngx_http_upstream_peer_t,
    pub srv_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub servers: *mut ngx_array_t,
    pub flags: ngx_uint_t,
    pub host: ngx_str_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub port: in_port_t,
    pub no_port: ngx_uint_t,
    pub shm_zone: *mut ngx_shm_zone_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_local_t {
    pub addr: *mut ngx_addr_t,
    pub value: *mut ngx_http_complex_value_t,
    pub transparent: ngx_uint_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_upstream_conf_t {
    pub upstream: *mut ngx_http_upstream_srv_conf_t,
    pub connect_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub read_timeout: ngx_msec_t,
    pub next_upstream_timeout: ngx_msec_t,
    pub send_lowat: usize,
    pub buffer_size: usize,
    pub limit_rate: usize,
    pub busy_buffers_size: usize,
    pub max_temp_file_size: usize,
    pub temp_file_write_size: usize,
    pub busy_buffers_size_conf: usize,
    pub max_temp_file_size_conf: usize,
    pub temp_file_write_size_conf: usize,
    pub bufs: ngx_bufs_t,
    pub ignore_headers: ngx_uint_t,
    pub next_upstream: ngx_uint_t,
    pub store_access: ngx_uint_t,
    pub next_upstream_tries: ngx_uint_t,
    pub buffering: ngx_flag_t,
    pub request_buffering: ngx_flag_t,
    pub pass_request_headers: ngx_flag_t,
    pub pass_request_body: ngx_flag_t,
    pub ignore_client_abort: ngx_flag_t,
    pub intercept_errors: ngx_flag_t,
    pub cyclic_temp_file: ngx_flag_t,
    pub force_ranges: ngx_flag_t,
    pub temp_path: *mut ngx_path_t,
    pub hide_headers_hash: ngx_hash_t,
    pub hide_headers: *mut ngx_array_t,
    pub pass_headers: *mut ngx_array_t,
    pub local: *mut ngx_http_upstream_local_t,
    pub socket_keepalive: ngx_flag_t,
    pub cache_zone: *mut ngx_shm_zone_t,
    pub cache_value: *mut ngx_http_complex_value_t,
    pub cache_min_uses: ngx_uint_t,
    pub cache_use_stale: ngx_uint_t,
    pub cache_methods: ngx_uint_t,
    pub cache_max_range_offset: off_t,
    pub cache_lock: ngx_flag_t,
    pub cache_lock_timeout: ngx_msec_t,
    pub cache_lock_age: ngx_msec_t,
    pub cache_revalidate: ngx_flag_t,
    pub cache_convert_head: ngx_flag_t,
    pub cache_background_update: ngx_flag_t,
    pub cache_valid: *mut ngx_array_t,
    pub cache_bypass: *mut ngx_array_t,
    pub cache_purge: *mut ngx_array_t,
    pub no_cache: *mut ngx_array_t,
    pub store_lengths: *mut ngx_array_t,
    pub store_values: *mut ngx_array_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub ssl: *mut ngx_ssl_t,
    pub ssl_session_reuse: ngx_flag_t,
    pub ssl_name: *mut ngx_http_complex_value_t,
    pub ssl_server_name: ngx_flag_t,
    pub ssl_verify: ngx_flag_t,
    #[doc = " 新增指令proxy_disable_check_ssl_name，不校验服务器证书SAN或CN匹配特定主机名"]
    pub ssl_disable_check_server_name: ngx_flag_t,
    #[doc = " KLNE 0029 DUMP_APPLICATION_DATA\n\n 支持DUMP应用数据"]
    pub dump_application_data: ngx_flag_t,
    #[doc = " KLNE 0048 UPSTREAM_EVENT_CERTIFICATE\n\n 支持后端事件证书"]
    pub extra_key: ngx_http_complex_value_t,
    #[doc = "  KLNE 0057 ASYNC_SSL\n\n  支持异步SSL"]
    pub ssl_asynch: ngx_flag_t,
    #[doc = " KLNE 0068 UPSTREAM_STATUS_NULL_ON_CONNECT_ERROR\n\n 支持重置upstream连接错误状态码"]
    pub upstream_status_null_on_connect_error: ngx_flag_t,
    #[doc = " KLNE 0021 SSL_CERTIFICATE\n\n upstream支持GMVPN双证书"]
    pub ssl_certificates: *mut ngx_array_t,
    pub ssl_certificate_keys: *mut ngx_array_t,
    pub ssl_certificate_values: *mut ngx_array_t,
    pub ssl_certificate_key_values: *mut ngx_array_t,
    pub ssl_certificate: *mut ngx_http_complex_value_t,
    pub ssl_certificate_key: *mut ngx_http_complex_value_t,
    pub ssl_passwords: *mut ngx_array_t,
    pub module: ngx_str_t,
    pub spare: [u64; 2usize],
}
impl ngx_http_upstream_conf_t {
    #[inline]
    pub fn cache(&self) -> ::aya_ebpf::cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cache(&mut self, val: ::aya_ebpf::cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn store(&self) -> ::aya_ebpf::cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: ::aya_ebpf::cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intercept_404(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intercept_404(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn change_buffering(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_change_buffering(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pass_trailers(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pass_trailers(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preserve_output(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_preserve_output(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cache: ::aya_ebpf::cty::c_int,
        store: ::aya_ebpf::cty::c_int,
        intercept_404: ::aya_ebpf::cty::c_uint,
        change_buffering: ::aya_ebpf::cty::c_uint,
        pass_trailers: ::aya_ebpf::cty::c_uint,
        preserve_output: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let cache: u32 = unsafe { ::core::mem::transmute(cache) };
            cache as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let store: u32 = unsafe { ::core::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let intercept_404: u32 = unsafe { ::core::mem::transmute(intercept_404) };
            intercept_404 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let change_buffering: u32 = unsafe { ::core::mem::transmute(change_buffering) };
            change_buffering as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pass_trailers: u32 = unsafe { ::core::mem::transmute(pass_trailers) };
            pass_trailers as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let preserve_output: u32 = unsafe { ::core::mem::transmute(preserve_output) };
            preserve_output as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_header_t {
    pub name: ngx_str_t,
    pub handler: ngx_http_header_handler_pt,
    pub offset: ngx_uint_t,
    pub copy_handler: ngx_http_header_handler_pt,
    pub conf: ngx_uint_t,
    pub redirect: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_headers_in_t {
    pub headers: ngx_list_t,
    pub trailers: ngx_list_t,
    pub status_n: ngx_uint_t,
    pub status_line: ngx_str_t,
    pub status: *mut ngx_table_elt_t,
    pub date: *mut ngx_table_elt_t,
    pub server: *mut ngx_table_elt_t,
    pub connection: *mut ngx_table_elt_t,
    pub expires: *mut ngx_table_elt_t,
    pub etag: *mut ngx_table_elt_t,
    pub x_accel_expires: *mut ngx_table_elt_t,
    pub x_accel_redirect: *mut ngx_table_elt_t,
    pub x_accel_limit_rate: *mut ngx_table_elt_t,
    pub content_type: *mut ngx_table_elt_t,
    pub content_length: *mut ngx_table_elt_t,
    pub last_modified: *mut ngx_table_elt_t,
    pub location: *mut ngx_table_elt_t,
    pub accept_ranges: *mut ngx_table_elt_t,
    pub www_authenticate: *mut ngx_table_elt_t,
    pub transfer_encoding: *mut ngx_table_elt_t,
    pub vary: *mut ngx_table_elt_t,
    pub content_encoding: *mut ngx_table_elt_t,
    pub cache_control: ngx_array_t,
    pub cookies: ngx_array_t,
    pub content_length_n: off_t,
    pub last_modified_time: time_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_upstream_headers_in_t {
    #[inline]
    pub fn connection_close(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_connection_close(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chunked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_chunked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        connection_close: ::aya_ebpf::cty::c_uint,
        chunked: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let connection_close: u32 = unsafe { ::core::mem::transmute(connection_close) };
            connection_close as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let chunked: u32 = unsafe { ::core::mem::transmute(chunked) };
            chunked as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_resolved_t {
    pub host: ngx_str_t,
    pub port: in_port_t,
    pub no_port: ngx_uint_t,
    pub naddrs: ngx_uint_t,
    pub addrs: *mut ngx_resolver_addr_t,
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub ctx: *mut ngx_resolver_ctx_t,
}
pub type ngx_http_upstream_handler_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, u: *mut ngx_http_upstream_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_s {
    pub read_event_handler: ngx_http_upstream_handler_pt,
    pub write_event_handler: ngx_http_upstream_handler_pt,
    pub peer: ngx_peer_connection_t,
    pub pipe: *mut ngx_event_pipe_t,
    pub request_bufs: *mut ngx_chain_t,
    pub output: ngx_output_chain_ctx_t,
    pub writer: ngx_chain_writer_ctx_t,
    pub conf: *mut ngx_http_upstream_conf_t,
    pub upstream: *mut ngx_http_upstream_srv_conf_t,
    pub caches: *mut ngx_array_t,
    pub connect_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub read_timeout: ngx_msec_t,
    pub headers_in: ngx_http_upstream_headers_in_t,
    pub resolved: *mut ngx_http_upstream_resolved_t,
    pub from_client: ngx_buf_t,
    pub buffer: ngx_buf_t,
    pub length: off_t,
    pub out_bufs: *mut ngx_chain_t,
    pub busy_bufs: *mut ngx_chain_t,
    pub free_bufs: *mut ngx_chain_t,
    pub input_filter_init: ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t>,
    pub input_filter:
        ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void, bytes: isize) -> ngx_int_t>,
    pub input_filter_ctx: *mut ::aya_ebpf::cty::c_void,
    pub create_key: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub create_request: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub reinit_request: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub process_header: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>,
    pub abort_request: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t)>,
    pub finalize_request: ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, rc: ngx_int_t)>,
    pub rewrite_redirect: ::core::option::Option<
        unsafe extern "C" fn(r: *mut ngx_http_request_t, h: *mut ngx_table_elt_t, prefix: usize) -> ngx_int_t,
    >,
    pub rewrite_cookie:
        ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, h: *mut ngx_table_elt_t) -> ngx_int_t>,
    pub start_time: ngx_msec_t,
    pub state: *mut ngx_http_upstream_state_t,
    pub method: ngx_str_t,
    pub schema: ngx_str_t,
    pub uri: ngx_str_t,
    pub ssl_name: ngx_str_t,
    pub cleanup: *mut ngx_http_cleanup_pt,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_upstream_s {
    #[inline]
    pub fn store(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cacheable(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cacheable(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accel(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accel(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssl(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_status(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_cache_status(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn buffering(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_buffering(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keepalive(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keepalive(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upgrade(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_upgrade(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_sent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_sent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_sent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_sent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_body_blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_body_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn header_sent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_header_sent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        store: ::aya_ebpf::cty::c_uint,
        cacheable: ::aya_ebpf::cty::c_uint,
        accel: ::aya_ebpf::cty::c_uint,
        ssl: ::aya_ebpf::cty::c_uint,
        cache_status: ::aya_ebpf::cty::c_uint,
        buffering: ::aya_ebpf::cty::c_uint,
        keepalive: ::aya_ebpf::cty::c_uint,
        upgrade: ::aya_ebpf::cty::c_uint,
        error: ::aya_ebpf::cty::c_uint,
        request_sent: ::aya_ebpf::cty::c_uint,
        request_body_sent: ::aya_ebpf::cty::c_uint,
        request_body_blocked: ::aya_ebpf::cty::c_uint,
        header_sent: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let store: u32 = unsafe { ::core::mem::transmute(store) };
            store as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cacheable: u32 = unsafe { ::core::mem::transmute(cacheable) };
            cacheable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let accel: u32 = unsafe { ::core::mem::transmute(accel) };
            accel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let cache_status: u32 = unsafe { ::core::mem::transmute(cache_status) };
            cache_status as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let buffering: u32 = unsafe { ::core::mem::transmute(buffering) };
            buffering as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let keepalive: u32 = unsafe { ::core::mem::transmute(keepalive) };
            keepalive as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let upgrade: u32 = unsafe { ::core::mem::transmute(upgrade) };
            upgrade as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let request_sent: u32 = unsafe { ::core::mem::transmute(request_sent) };
            request_sent as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let request_body_sent: u32 = unsafe { ::core::mem::transmute(request_body_sent) };
            request_body_sent as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let request_body_blocked: u32 = unsafe { ::core::mem::transmute(request_body_blocked) };
            request_body_blocked as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let header_sent: u32 = unsafe { ::core::mem::transmute(header_sent) };
            header_sent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_next_t {
    pub status: ngx_uint_t,
    pub mask: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_param_t {
    pub key: ngx_str_t,
    pub value: ngx_str_t,
    pub skip_empty: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_upstream_create(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_init(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_upstream_non_buffered_filter_init(data: *mut ::aya_ebpf::cty::c_void) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_non_buffered_filter(data: *mut ::aya_ebpf::cty::c_void, bytes: isize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_add(
        cf: *mut ngx_conf_t,
        u: *mut ngx_url_t,
        flags: ngx_uint_t,
    ) -> *mut ngx_http_upstream_srv_conf_t;
}
extern "C" {
    pub fn ngx_http_upstream_bind_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_upstream_param_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_upstream_hide_headers_hash(
        cf: *mut ngx_conf_t,
        conf: *mut ngx_http_upstream_conf_t,
        prev: *mut ngx_http_upstream_conf_t,
        default_hide_headers: *mut ngx_str_t,
        hash: *mut ngx_hash_init_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_upstream_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_upstream_cache_method_mask: [ngx_conf_bitmask_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_upstream_ignore_headers_masks: [ngx_conf_bitmask_t; 0usize];
}
pub type ngx_http_upstream_rr_peer_t = ngx_http_upstream_rr_peer_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_rr_peer_s {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub name: ngx_str_t,
    pub server: ngx_str_t,
    pub current_weight: ngx_int_t,
    pub effective_weight: ngx_int_t,
    pub weight: ngx_int_t,
    pub conns: ngx_uint_t,
    pub max_conns: ngx_uint_t,
    pub fails: ngx_uint_t,
    pub accessed: time_t,
    pub checked: time_t,
    pub max_fails: ngx_uint_t,
    pub fail_timeout: time_t,
    pub slow_start: ngx_msec_t,
    pub start_time: ngx_msec_t,
    pub down: ngx_uint_t,
    #[doc = " KLNE 0080 UPSTREAM_VARIABLES\n\n 添加upstream变量, 方便在访问日志中确定是否为backup server"]
    pub backup: ngx_uint_t,
    pub ssl_session: *mut ::aya_ebpf::cty::c_void,
    pub ssl_session_len: ::aya_ebpf::cty::c_int,
    pub lock: ngx_atomic_t,
    pub next: *mut ngx_http_upstream_rr_peer_t,
    pub spare: [u64; 32usize],
}
pub type ngx_http_upstream_rr_peers_t = ngx_http_upstream_rr_peers_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_rr_peers_s {
    pub number: ngx_uint_t,
    pub shpool: *mut ngx_slab_pool_t,
    pub rwlock: ngx_atomic_t,
    pub zone_next: *mut ngx_http_upstream_rr_peers_t,
    pub total_weight: ngx_uint_t,
    pub tries: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub name: *mut ngx_str_t,
    pub next: *mut ngx_http_upstream_rr_peers_t,
    pub peer: *mut ngx_http_upstream_rr_peer_t,
}
impl ngx_http_upstream_rr_peers_s {
    #[inline]
    pub fn single(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_single(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        single: ::aya_ebpf::cty::c_uint,
        weighted: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single: u32 = unsafe { ::core::mem::transmute(single) };
            single as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let weighted: u32 = unsafe { ::core::mem::transmute(weighted) };
            weighted as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_upstream_rr_peer_data_t {
    pub config: ngx_uint_t,
    pub peers: *mut ngx_http_upstream_rr_peers_t,
    pub current: *mut ngx_http_upstream_rr_peer_t,
    pub tried: *mut usize,
    pub data: usize,
    #[doc = " KLNE 0048 UPSTREAM_EVENT_CERTIFICATE\n\n 支持后端事件证书"]
    pub ssl_session_reuse_with_extra_key: ngx_flag_t,
    pub extra_key: ngx_str_t,
}
extern "C" {
    pub fn ngx_http_upstream_init_round_robin(cf: *mut ngx_conf_t, us: *mut ngx_http_upstream_srv_conf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_init_round_robin_peer(
        r: *mut ngx_http_request_t,
        us: *mut ngx_http_upstream_srv_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_create_round_robin_peer(
        r: *mut ngx_http_request_t,
        ur: *mut ngx_http_upstream_resolved_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_get_round_robin_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_free_round_robin_peer(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_ebpf::cty::c_void,
        state: ngx_uint_t,
    );
}
extern "C" {
    pub fn ngx_http_upstream_set_round_robin_peer_session(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_ebpf::cty::c_void,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_upstream_save_round_robin_peer_session(
        pc: *mut ngx_peer_connection_t,
        data: *mut ::aya_ebpf::cty::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_thread_task_s {
    pub next: *mut ngx_thread_task_t,
    pub id: ngx_uint_t,
    pub ctx: *mut ::aya_ebpf::cty::c_void,
    pub handler: ::core::option::Option<unsafe extern "C" fn(data: *mut ::aya_ebpf::cty::c_void, log: *mut ngx_log_t)>,
    pub event: ngx_event_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_thread_pool_s {
    _unused: [u8; 0],
}
pub type ngx_thread_pool_t = ngx_thread_pool_s;
extern "C" {
    pub fn ngx_thread_pool_add(cf: *mut ngx_conf_t, name: *mut ngx_str_t) -> *mut ngx_thread_pool_t;
}
extern "C" {
    pub fn ngx_thread_pool_get(cycle: *mut ngx_cycle_t, name: *mut ngx_str_t) -> *mut ngx_thread_pool_t;
}
extern "C" {
    pub fn ngx_thread_task_alloc(pool: *mut ngx_pool_t, size: usize) -> *mut ngx_thread_task_t;
}
extern "C" {
    pub fn ngx_thread_task_post(tp: *mut ngx_thread_pool_t, task: *mut ngx_thread_task_t) -> ngx_int_t;
}
pub type ngx_http_location_tree_node_t = ngx_http_location_tree_node_s;
pub type ngx_http_core_loc_conf_t = ngx_http_core_loc_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_listen_opt_t {
    pub sockaddr: *mut sockaddr,
    pub socklen: socklen_t,
    pub addr_text: ngx_str_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub backlog: ::aya_ebpf::cty::c_int,
    pub rcvbuf: ::aya_ebpf::cty::c_int,
    pub sndbuf: ::aya_ebpf::cty::c_int,
    pub fastopen: ::aya_ebpf::cty::c_int,
    pub tcp_keepidle: ::aya_ebpf::cty::c_int,
    pub tcp_keepintvl: ::aya_ebpf::cty::c_int,
    pub tcp_keepcnt: ::aya_ebpf::cty::c_int,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_listen_opt_t {
    #[inline]
    pub fn set(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_set(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_server(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_default_server(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bind(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bind(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wildcard(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wildcard(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ssl(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http2(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http2(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6only(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6only(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_accept(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_accept(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reuseport(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reuseport(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn so_keepalive(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_so_keepalive(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        set: ::aya_ebpf::cty::c_uint,
        default_server: ::aya_ebpf::cty::c_uint,
        bind: ::aya_ebpf::cty::c_uint,
        wildcard: ::aya_ebpf::cty::c_uint,
        ssl: ::aya_ebpf::cty::c_uint,
        http2: ::aya_ebpf::cty::c_uint,
        ipv6only: ::aya_ebpf::cty::c_uint,
        deferred_accept: ::aya_ebpf::cty::c_uint,
        reuseport: ::aya_ebpf::cty::c_uint,
        so_keepalive: ::aya_ebpf::cty::c_uint,
        proxy_protocol: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let set: u32 = unsafe { ::core::mem::transmute(set) };
            set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let default_server: u32 = unsafe { ::core::mem::transmute(default_server) };
            default_server as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bind: u32 = unsafe { ::core::mem::transmute(bind) };
            bind as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wildcard: u32 = unsafe { ::core::mem::transmute(wildcard) };
            wildcard as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let http2: u32 = unsafe { ::core::mem::transmute(http2) };
            http2 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ipv6only: u32 = unsafe { ::core::mem::transmute(ipv6only) };
            ipv6only as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let deferred_accept: u32 = unsafe { ::core::mem::transmute(deferred_accept) };
            deferred_accept as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let reuseport: u32 = unsafe { ::core::mem::transmute(reuseport) };
            reuseport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let so_keepalive: u32 = unsafe { ::core::mem::transmute(so_keepalive) };
            so_keepalive as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::core::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn close_if_sni_match_servername_failed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_if_sni_match_servername_failed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_stat_stub(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_stat_stub(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        close_if_sni_match_servername_failed: ::aya_ebpf::cty::c_uint,
        no_stat_stub: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let close_if_sni_match_servername_failed: u32 =
                unsafe { ::core::mem::transmute(close_if_sni_match_servername_failed) };
            close_if_sni_match_servername_failed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_stat_stub: u32 = unsafe { ::core::mem::transmute(no_stat_stub) };
            no_stat_stub as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const ngx_http_phases_NGX_HTTP_POST_READ_PHASE: ngx_http_phases = 0;
pub const ngx_http_phases_NGX_HTTP_SERVER_REWRITE_PHASE: ngx_http_phases = 1;
pub const ngx_http_phases_NGX_HTTP_FIND_CONFIG_PHASE: ngx_http_phases = 2;
pub const ngx_http_phases_NGX_HTTP_REWRITE_PHASE: ngx_http_phases = 3;
pub const ngx_http_phases_NGX_HTTP_POST_REWRITE_PHASE: ngx_http_phases = 4;
pub const ngx_http_phases_NGX_HTTP_PREACCESS_PHASE: ngx_http_phases = 5;
pub const ngx_http_phases_NGX_HTTP_ACCESS_PHASE: ngx_http_phases = 6;
pub const ngx_http_phases_NGX_HTTP_POST_ACCESS_PHASE: ngx_http_phases = 7;
pub const ngx_http_phases_NGX_HTTP_PRECONTENT_PHASE: ngx_http_phases = 8;
pub const ngx_http_phases_NGX_HTTP_CONTENT_PHASE: ngx_http_phases = 9;
pub const ngx_http_phases_NGX_HTTP_LOG_PHASE: ngx_http_phases = 10;
pub type ngx_http_phases = ::aya_ebpf::cty::c_uint;
pub type ngx_http_phase_handler_t = ngx_http_phase_handler_s;
pub type ngx_http_phase_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_phase_handler_s {
    pub checker: ngx_http_phase_handler_pt,
    pub handler: ngx_http_handler_pt,
    pub next: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_phase_engine_t {
    pub handlers: *mut ngx_http_phase_handler_t,
    pub server_rewrite_index: ngx_uint_t,
    pub location_rewrite_index: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_phase_t {
    pub handlers: ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_core_main_conf_t {
    pub servers: ngx_array_t,
    pub phase_engine: ngx_http_phase_engine_t,
    pub headers_in_hash: ngx_hash_t,
    pub variables_hash: ngx_hash_t,
    pub variables: ngx_array_t,
    pub prefix_variables: ngx_array_t,
    pub ncaptures: ngx_uint_t,
    pub server_names_hash_max_size: ngx_uint_t,
    pub server_names_hash_bucket_size: ngx_uint_t,
    pub variables_hash_max_size: ngx_uint_t,
    pub variables_hash_bucket_size: ngx_uint_t,
    pub variables_keys: *mut ngx_hash_keys_arrays_t,
    pub ports: *mut ngx_array_t,
    pub phases: [ngx_http_phase_t; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_core_srv_conf_t {
    pub server_names: ngx_array_t,
    pub ctx: *mut ngx_http_conf_ctx_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub server_name: ngx_str_t,
    #[doc = " KLNE 4043 server_description\n 在server中添加server_description配置项，用来做服务唯一标识，以供监控使用"]
    pub server_description: ngx_str_t,
    #[doc = " KLNE 0100 NETWORKS_FOR_POLICY_ROUTE_LOCATION\n\n 使用策略路由时location支持networks匹配"]
    pub net_locations: ngx_array_t,
    pub connection_pool_size: usize,
    pub request_pool_size: usize,
    pub client_header_buffer_size: usize,
    pub large_client_header_buffers: ngx_bufs_t,
    pub client_header_timeout: ngx_msec_t,
    pub ignore_invalid_headers: ngx_flag_t,
    pub merge_slashes: ngx_flag_t,
    pub underscores_in_headers: ngx_flag_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub named_locations: *mut *mut ngx_http_core_loc_conf_t,
}
impl ngx_http_core_srv_conf_t {
    #[inline]
    pub fn listen(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_listen(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn captures(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_captures(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        listen: ::aya_ebpf::cty::c_uint,
        captures: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let listen: u32 = unsafe { ::core::mem::transmute(listen) };
            listen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let captures: u32 = unsafe { ::core::mem::transmute(captures) };
            captures as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_server_name_t {
    pub regex: *mut ngx_http_regex_t,
    pub server: *mut ngx_http_core_srv_conf_t,
    pub name: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_virtual_names_t {
    pub names: ngx_hash_combined_t,
    pub nregex: ngx_uint_t,
    pub regex: *mut ngx_http_server_name_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_addr_conf_s {
    pub default_server: *mut ngx_http_core_srv_conf_t,
    pub virtual_names: *mut ngx_http_virtual_names_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_addr_conf_s {
    #[inline]
    pub fn ssl(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ssl(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn http2(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_http2(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn proxy_protocol(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_proxy_protocol(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_if_sni_match_servername_failed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_if_sni_match_servername_failed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ssl: ::aya_ebpf::cty::c_uint,
        http2: ::aya_ebpf::cty::c_uint,
        proxy_protocol: ::aya_ebpf::cty::c_uint,
        close_if_sni_match_servername_failed: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssl: u32 = unsafe { ::core::mem::transmute(ssl) };
            ssl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let http2: u32 = unsafe { ::core::mem::transmute(http2) };
            http2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let proxy_protocol: u32 = unsafe { ::core::mem::transmute(proxy_protocol) };
            proxy_protocol as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let close_if_sni_match_servername_failed: u32 =
                unsafe { ::core::mem::transmute(close_if_sni_match_servername_failed) };
            close_if_sni_match_servername_failed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_in_addr_t {
    pub addr: in_addr_t,
    pub conf: ngx_http_addr_conf_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_in6_addr_t {
    pub addr6: in6_addr,
    pub conf: ngx_http_addr_conf_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_port_t {
    pub addrs: *mut ::aya_ebpf::cty::c_void,
    pub naddrs: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_conf_port_t {
    pub family: ngx_int_t,
    pub port: in_port_t,
    pub addrs: ngx_array_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_conf_addr_t {
    pub opt: ngx_http_listen_opt_t,
    pub hash: ngx_hash_t,
    pub wc_head: *mut ngx_hash_wildcard_t,
    pub wc_tail: *mut ngx_hash_wildcard_t,
    pub nregex: ngx_uint_t,
    pub regex: *mut ngx_http_server_name_t,
    pub default_server: *mut ngx_http_core_srv_conf_t,
    pub servers: ngx_array_t,
}
#[doc = " KLNE 0100 NETWORKS_FOR_POLICY_ROUTE_LOCATION\n\n 使用策略路由时location支持networks匹配"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_network_t {
    pub cidr: ngx_cidr_t,
    pub cidr_text: ngx_str_t,
    pub port_start: in_port_t,
    pub port_end: in_port_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ngx_http_err_page_t {
    pub status: ngx_int_t,
    pub overwrite: ngx_int_t,
    pub value: ngx_http_complex_value_t,
    pub args: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_core_loc_conf_s {
    pub name: ngx_str_t,
    pub escaped_name: ngx_str_t,
    pub regex: *mut ngx_http_regex_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub static_locations: *mut ngx_http_location_tree_node_t,
    pub regex_locations: *mut *mut ngx_http_core_loc_conf_t,
    pub loc_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub limit_except: u32,
    pub limit_except_loc_conf: *mut *mut ::aya_ebpf::cty::c_void,
    pub handler: ngx_http_handler_pt,
    pub alias: usize,
    pub root: ngx_str_t,
    pub post_action: ngx_str_t,
    pub root_lengths: *mut ngx_array_t,
    pub root_values: *mut ngx_array_t,
    pub types: *mut ngx_array_t,
    pub types_hash: ngx_hash_t,
    pub default_type: ngx_str_t,
    pub client_max_body_size: off_t,
    pub directio: off_t,
    pub directio_alignment: off_t,
    pub client_body_buffer_size: usize,
    pub send_lowat: usize,
    pub postpone_output: usize,
    pub sendfile_max_chunk: usize,
    pub read_ahead: usize,
    pub subrequest_output_buffer_size: usize,
    pub limit_rate: *mut ngx_http_complex_value_t,
    pub limit_rate_after: *mut ngx_http_complex_value_t,
    pub client_body_timeout: ngx_msec_t,
    pub send_timeout: ngx_msec_t,
    pub keepalive_time: ngx_msec_t,
    pub keepalive_timeout: ngx_msec_t,
    pub lingering_time: ngx_msec_t,
    pub lingering_timeout: ngx_msec_t,
    pub resolver_timeout: ngx_msec_t,
    pub auth_delay: ngx_msec_t,
    pub resolver: *mut ngx_resolver_t,
    pub keepalive_header: time_t,
    pub keepalive_requests: ngx_uint_t,
    pub keepalive_disable: ngx_uint_t,
    pub satisfy: ngx_uint_t,
    pub lingering_close: ngx_uint_t,
    pub if_modified_since: ngx_uint_t,
    pub max_ranges: ngx_uint_t,
    pub client_body_in_file_only: ngx_uint_t,
    pub client_body_in_single_buffer: ngx_flag_t,
    pub internal: ngx_flag_t,
    pub sendfile: ngx_flag_t,
    pub aio: ngx_flag_t,
    pub aio_write: ngx_flag_t,
    pub tcp_nopush: ngx_flag_t,
    pub tcp_nodelay: ngx_flag_t,
    pub reset_timedout_connection: ngx_flag_t,
    pub absolute_redirect: ngx_flag_t,
    pub server_name_in_redirect: ngx_flag_t,
    pub port_in_redirect: ngx_flag_t,
    pub msie_padding: ngx_flag_t,
    pub msie_refresh: ngx_flag_t,
    pub log_not_found: ngx_flag_t,
    pub log_subrequest: ngx_flag_t,
    pub recursive_error_pages: ngx_flag_t,
    pub server_tokens: ngx_uint_t,
    pub chunked_transfer_encoding: ngx_flag_t,
    pub etag: ngx_flag_t,
    pub gzip_vary: ngx_flag_t,
    pub gzip_http_version: ngx_uint_t,
    pub gzip_proxied: ngx_uint_t,
    pub gzip_disable: *mut ngx_array_t,
    pub thread_pool: *mut ngx_thread_pool_t,
    pub thread_pool_value: *mut ngx_http_complex_value_t,
    pub disable_symlinks: ngx_uint_t,
    pub disable_symlinks_from: *mut ngx_http_complex_value_t,
    pub error_pages: *mut ngx_array_t,
    pub client_body_temp_path: *mut ngx_path_t,
    pub open_file_cache: *mut ngx_open_file_cache_t,
    pub open_file_cache_valid: time_t,
    pub open_file_cache_min_uses: ngx_uint_t,
    pub open_file_cache_errors: ngx_flag_t,
    pub open_file_cache_events: ngx_flag_t,
    pub error_log: *mut ngx_log_t,
    pub types_hash_max_size: ngx_uint_t,
    pub types_hash_bucket_size: ngx_uint_t,
    pub locations: *mut ngx_queue_t,
    #[doc = " KLNE 0010 TIME_FORMAT\n\n 时间变量支持以毫秒为单位"]
    pub time_variables_with_millisecond: ngx_flag_t,
    #[doc = " KLNE 0029 DUMP_APPLICATION_DATA\n\n 支持DUMP应用数据"]
    pub dump_application_data: ngx_flag_t,
    #[doc = " KLNE 0035 POLICY_ROUTE_FOR_LOCATION\n\n 支持策略路由"]
    pub variable: *mut ngx_http_complex_value_t,
    #[doc = " KLNE 0100 NETWORKS_FOR_POLICY_ROUTE_LOCATION\n\n 使用策略路由时location支持networks匹配"]
    pub net: *mut ngx_http_network_t,
    #[doc = " KLNE 0050 REJECT_REQUEST_WITHOUT_HOST_HEADER\n\n 支持拒绝不带Host请求头的请求"]
    pub reject_request_without_host_header: ngx_flag_t,
    #[doc = " KLNE 0059 VALID_FOR_LUA_PER_CONNECTION_CONTEXT_VARIABLES\n\n LUA连接上下文变量支持指定有效期"]
    pub lua_connection_ctx_valid: ngx_msec_t,
    #[doc = " KLNE 0069 REPLACE_DASH_WITH_CHAR_IN_VARIABLES\n\n 使用特定字符替换变量中的中划线"]
    pub replace_dash_with_char_in_variables: ngx_str_t,
}
impl ngx_http_core_loc_conf_s {
    #[inline]
    pub fn noname(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noname(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lmt_excpt(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lmt_excpt(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn named(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_named(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exact_match(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noregex(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noregex(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn net_match(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_net_match(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_redirect(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_redirect(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_disable_msie6(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_disable_msie6(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn gzip_disable_degradation(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_gzip_disable_degradation(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        noname: ::aya_ebpf::cty::c_uint,
        lmt_excpt: ::aya_ebpf::cty::c_uint,
        named: ::aya_ebpf::cty::c_uint,
        exact_match: ::aya_ebpf::cty::c_uint,
        noregex: ::aya_ebpf::cty::c_uint,
        net_match: ::aya_ebpf::cty::c_uint,
        auto_redirect: ::aya_ebpf::cty::c_uint,
        gzip_disable_msie6: ::aya_ebpf::cty::c_uint,
        gzip_disable_degradation: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let noname: u32 = unsafe { ::core::mem::transmute(noname) };
            noname as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lmt_excpt: u32 = unsafe { ::core::mem::transmute(lmt_excpt) };
            lmt_excpt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let named: u32 = unsafe { ::core::mem::transmute(named) };
            named as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exact_match: u32 = unsafe { ::core::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let noregex: u32 = unsafe { ::core::mem::transmute(noregex) };
            noregex as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let net_match: u32 = unsafe { ::core::mem::transmute(net_match) };
            net_match as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let auto_redirect: u32 = unsafe { ::core::mem::transmute(auto_redirect) };
            auto_redirect as u64
        });
        __bindgen_bitfield_unit.set(7usize, 2u8, {
            let gzip_disable_msie6: u32 = unsafe { ::core::mem::transmute(gzip_disable_msie6) };
            gzip_disable_msie6 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let gzip_disable_degradation: u32 = unsafe { ::core::mem::transmute(gzip_disable_degradation) };
            gzip_disable_degradation as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_location_queue_t {
    pub queue: ngx_queue_t,
    pub exact: *mut ngx_http_core_loc_conf_t,
    pub inclusive: *mut ngx_http_core_loc_conf_t,
    pub name: *mut ngx_str_t,
    pub file_name: *mut u_char,
    pub line: ngx_uint_t,
    pub list: ngx_queue_t,
    #[doc = " KLNE 0035 POLICY_ROUTE_FOR_LOCATION\n\n 支持策略路由"]
    pub variable: *mut ngx_http_complex_value_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_location_tree_node_s {
    pub left: *mut ngx_http_location_tree_node_t,
    pub right: *mut ngx_http_location_tree_node_t,
    pub tree: *mut ngx_http_location_tree_node_t,
    pub exact: *mut ngx_http_core_loc_conf_t,
    pub inclusive: *mut ngx_http_core_loc_conf_t,
    #[doc = " KLNE 0035 POLICY_ROUTE_FOR_LOCATION\n\n 支持策略路由"]
    pub variable: *mut ngx_http_complex_value_t,
    pub auto_redirect: u_char,
    pub len: u_char,
    pub name: [u_char; 1usize],
}
extern "C" {
    pub fn ngx_http_core_run_phases(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_core_generic_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_rewrite_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_find_config_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_post_rewrite_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t)
        -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_access_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_post_access_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_core_content_phase(r: *mut ngx_http_request_t, ph: *mut ngx_http_phase_handler_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_test_content_type(
        r: *mut ngx_http_request_t,
        types_hash: *mut ngx_hash_t,
    ) -> *mut ::aya_ebpf::cty::c_void;
}
extern "C" {
    pub fn ngx_http_set_content_type(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_exten(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_set_etag(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_weak_etag(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_send_response(
        r: *mut ngx_http_request_t,
        status: ngx_uint_t,
        ct: *mut ngx_str_t,
        cv: *mut ngx_http_complex_value_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_map_uri_to_path(
        r: *mut ngx_http_request_t,
        name: *mut ngx_str_t,
        root_length: *mut usize,
        reserved: usize,
    ) -> *mut u_char;
}
extern "C" {
    pub fn ngx_http_auth_basic_user(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_gzip_ok(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_subrequest(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
        psr: *mut *mut ngx_http_request_t,
        ps: *mut ngx_http_post_subrequest_t,
        flags: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_internal_redirect(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_named_location(r: *mut ngx_http_request_t, name: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_cleanup_add(r: *mut ngx_http_request_t, size: usize) -> *mut ngx_http_cleanup_t;
}
pub type ngx_http_output_header_filter_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t) -> ngx_int_t>;
pub type ngx_http_output_body_filter_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t>;
pub type ngx_http_request_body_filter_pt =
    ::core::option::Option<unsafe extern "C" fn(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t>;
extern "C" {
    pub fn ngx_http_output_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_write_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_request_body_save_filter(r: *mut ngx_http_request_t, chain: *mut ngx_chain_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_set_disable_symlinks(
        r: *mut ngx_http_request_t,
        clcf: *mut ngx_http_core_loc_conf_t,
        path: *mut ngx_str_t,
        of: *mut ngx_open_file_info_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_get_forwarded_addr(
        r: *mut ngx_http_request_t,
        addr: *mut ngx_addr_t,
        headers: *mut ngx_array_t,
        value: *mut ngx_str_t,
        proxies: *mut ngx_array_t,
        recursive: ::aya_ebpf::cty::c_int,
    ) -> ngx_int_t;
}
extern "C" {
    #[doc = " KLNE 0010 TIME_FORMAT\n\n 时间变量支持以毫秒为单位"]
    pub fn ngx_http_get_core_module_time_variables_with_millisecond(
        c: *mut ngx_connection_t,
        flag: *mut ngx_flag_t,
    ) -> ngx_int_t;
}
extern "C" {
    #[doc = " KLNE 0029 DUMP_APPLICATION_DATA\n\n 支持DUMP应用数据"]
    pub fn ngx_http_get_core_module_dump_application_data(c: *mut ngx_connection_t, flag: *mut ngx_flag_t)
        -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_core_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_max_module: ngx_uint_t;
}
extern "C" {
    pub static mut ngx_http_core_get_method: ngx_str_t;
}
pub type ngx_http_v2_connection_t = ngx_http_v2_connection_s;
pub type ngx_http_v2_node_t = ngx_http_v2_node_s;
pub type ngx_http_v2_out_frame_t = ngx_http_v2_out_frame_s;
pub type ngx_http_v2_handler_pt = ::core::option::Option<
    unsafe extern "C" fn(h2c: *mut ngx_http_v2_connection_t, pos: *mut u_char, end: *mut u_char) -> *mut u_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_header_t {
    pub name: ngx_str_t,
    pub value: ngx_str_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_state_t {
    pub sid: ngx_uint_t,
    pub length: usize,
    pub padding: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub header: ngx_http_v2_header_t,
    pub header_limit: usize,
    pub field_state: u_char,
    pub field_start: *mut u_char,
    pub field_end: *mut u_char,
    pub field_rest: usize,
    pub pool: *mut ngx_pool_t,
    pub stream: *mut ngx_http_v2_stream_t,
    pub buffer: [u_char; 16usize],
    pub buffer_used: usize,
    pub handler: ngx_http_v2_handler_pt,
}
impl ngx_http_v2_state_t {
    #[inline]
    pub fn flags(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn incomplete(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_incomplete(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_pool(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_pool(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parse_name(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parse_name(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parse_value(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parse_value(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn index(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::aya_ebpf::cty::c_uint,
        incomplete: ::aya_ebpf::cty::c_uint,
        keep_pool: ::aya_ebpf::cty::c_uint,
        parse_name: ::aya_ebpf::cty::c_uint,
        parse_value: ::aya_ebpf::cty::c_uint,
        index: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let incomplete: u32 = unsafe { ::core::mem::transmute(incomplete) };
            incomplete as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let keep_pool: u32 = unsafe { ::core::mem::transmute(keep_pool) };
            keep_pool as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let parse_name: u32 = unsafe { ::core::mem::transmute(parse_name) };
            parse_name as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let parse_value: u32 = unsafe { ::core::mem::transmute(parse_value) };
            parse_value as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let index: u32 = unsafe { ::core::mem::transmute(index) };
            index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_hpack_t {
    pub entries: *mut *mut ngx_http_v2_header_t,
    pub added: ngx_uint_t,
    pub deleted: ngx_uint_t,
    pub reused: ngx_uint_t,
    pub allocated: ngx_uint_t,
    pub size: usize,
    pub free: usize,
    pub storage: *mut u_char,
    pub pos: *mut u_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_connection_s {
    pub connection: *mut ngx_connection_t,
    pub http_connection: *mut ngx_http_connection_t,
    pub total_bytes: off_t,
    pub payload_bytes: off_t,
    pub processing: ngx_uint_t,
    pub frames: ngx_uint_t,
    pub idle: ngx_uint_t,
    pub priority_limit: ngx_uint_t,
    pub pushing: ngx_uint_t,
    pub concurrent_pushes: ngx_uint_t,
    pub send_window: usize,
    pub recv_window: usize,
    pub init_window: usize,
    pub frame_size: usize,
    pub waiting: ngx_queue_t,
    pub state: ngx_http_v2_state_t,
    pub hpack: ngx_http_v2_hpack_t,
    pub pool: *mut ngx_pool_t,
    pub free_frames: *mut ngx_http_v2_out_frame_t,
    pub free_fake_connections: *mut ngx_connection_t,
    pub streams_index: *mut *mut ngx_http_v2_node_t,
    pub last_out: *mut ngx_http_v2_out_frame_t,
    pub dependencies: ngx_queue_t,
    pub closed: ngx_queue_t,
    pub last_sid: ngx_uint_t,
    pub last_push: ngx_uint_t,
    pub lingering_time: time_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_v2_connection_s {
    #[inline]
    pub fn closed_nodes(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_closed_nodes(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn settings_ack(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_settings_ack(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn table_update(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_table_update(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn goaway(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_goaway(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn push_disabled(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_push_disabled(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        closed_nodes: ::aya_ebpf::cty::c_uint,
        settings_ack: ::aya_ebpf::cty::c_uint,
        table_update: ::aya_ebpf::cty::c_uint,
        blocked: ::aya_ebpf::cty::c_uint,
        goaway: ::aya_ebpf::cty::c_uint,
        push_disabled: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let closed_nodes: u32 = unsafe { ::core::mem::transmute(closed_nodes) };
            closed_nodes as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let settings_ack: u32 = unsafe { ::core::mem::transmute(settings_ack) };
            settings_ack as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let table_update: u32 = unsafe { ::core::mem::transmute(table_update) };
            table_update as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let blocked: u32 = unsafe { ::core::mem::transmute(blocked) };
            blocked as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let goaway: u32 = unsafe { ::core::mem::transmute(goaway) };
            goaway as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let push_disabled: u32 = unsafe { ::core::mem::transmute(push_disabled) };
            push_disabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_node_s {
    pub id: ngx_uint_t,
    pub index: *mut ngx_http_v2_node_t,
    pub parent: *mut ngx_http_v2_node_t,
    pub queue: ngx_queue_t,
    pub children: ngx_queue_t,
    pub reuse: ngx_queue_t,
    pub rank: ngx_uint_t,
    pub weight: ngx_uint_t,
    pub rel_weight: f64,
    pub stream: *mut ngx_http_v2_stream_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_stream_s {
    pub request: *mut ngx_http_request_t,
    pub connection: *mut ngx_http_v2_connection_t,
    pub node: *mut ngx_http_v2_node_t,
    pub queued: ngx_uint_t,
    pub send_window: isize,
    pub recv_window: usize,
    pub preread: *mut ngx_buf_t,
    pub frames: ngx_uint_t,
    pub free_frames: *mut ngx_http_v2_out_frame_t,
    pub free_frame_headers: *mut ngx_chain_t,
    pub free_bufs: *mut ngx_chain_t,
    pub queue: ngx_queue_t,
    pub cookies: *mut ngx_array_t,
    pub pool: *mut ngx_pool_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_v2_stream_s {
    #[inline]
    pub fn waiting(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waiting(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exhausted(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exhausted(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_closed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_closed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_closed(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_out_closed(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst_sent(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rst_sent(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_flow_control(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_flow_control(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_data(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_data(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        waiting: ::aya_ebpf::cty::c_uint,
        blocked: ::aya_ebpf::cty::c_uint,
        exhausted: ::aya_ebpf::cty::c_uint,
        in_closed: ::aya_ebpf::cty::c_uint,
        out_closed: ::aya_ebpf::cty::c_uint,
        rst_sent: ::aya_ebpf::cty::c_uint,
        no_flow_control: ::aya_ebpf::cty::c_uint,
        skip_data: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let waiting: u32 = unsafe { ::core::mem::transmute(waiting) };
            waiting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let blocked: u32 = unsafe { ::core::mem::transmute(blocked) };
            blocked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let exhausted: u32 = unsafe { ::core::mem::transmute(exhausted) };
            exhausted as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_closed: u32 = unsafe { ::core::mem::transmute(in_closed) };
            in_closed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let out_closed: u32 = unsafe { ::core::mem::transmute(out_closed) };
            out_closed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rst_sent: u32 = unsafe { ::core::mem::transmute(rst_sent) };
            rst_sent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_flow_control: u32 = unsafe { ::core::mem::transmute(no_flow_control) };
            no_flow_control as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let skip_data: u32 = unsafe { ::core::mem::transmute(skip_data) };
            skip_data as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_v2_out_frame_s {
    pub next: *mut ngx_http_v2_out_frame_t,
    pub first: *mut ngx_chain_t,
    pub last: *mut ngx_chain_t,
    pub handler: ::core::option::Option<
        unsafe extern "C" fn(h2c: *mut ngx_http_v2_connection_t, frame: *mut ngx_http_v2_out_frame_t) -> ngx_int_t,
    >,
    pub stream: *mut ngx_http_v2_stream_t,
    pub length: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_v2_out_frame_s {
    #[inline]
    pub fn blocked(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blocked(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        blocked: ::aya_ebpf::cty::c_uint,
        fin: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let blocked: u32 = unsafe { ::core::mem::transmute(blocked) };
            blocked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fin: u32 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ngx_http_v2_init(rev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_http_v2_read_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_read_unbuffered_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_push_stream(
        parent: *mut ngx_http_v2_stream_t,
        path: *mut ngx_str_t,
    ) -> *mut ngx_http_v2_stream_t;
}
extern "C" {
    pub fn ngx_http_v2_close_stream(stream: *mut ngx_http_v2_stream_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_v2_send_output_queue(h2c: *mut ngx_http_v2_connection_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_get_static_name(index: ngx_uint_t) -> *mut ngx_str_t;
}
extern "C" {
    pub fn ngx_http_v2_get_static_value(index: ngx_uint_t) -> *mut ngx_str_t;
}
extern "C" {
    pub fn ngx_http_v2_get_indexed_header(
        h2c: *mut ngx_http_v2_connection_t,
        index: ngx_uint_t,
        name_only: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_add_header(h2c: *mut ngx_http_v2_connection_t, header: *mut ngx_http_v2_header_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_table_size(h2c: *mut ngx_http_v2_connection_t, size: usize) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_huff_decode(
        state: *mut u_char,
        src: *mut u_char,
        len: usize,
        dst: *mut *mut u_char,
        last: ngx_uint_t,
        log: *mut ngx_log_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_v2_huff_encode(src: *mut u_char, len: usize, dst: *mut u_char, lower: ngx_uint_t) -> usize;
}
extern "C" {
    pub fn ngx_http_v2_string_encode(
        dst: *mut u_char,
        src: *mut u_char,
        len: usize,
        tmp: *mut u_char,
        lower: ngx_uint_t,
    ) -> *mut u_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cache_valid_t {
    pub status: ngx_uint_t,
    pub valid: time_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_node_t {
    pub node: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub key: [u_char; 8usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub uniq: ngx_file_uniq_t,
    pub expire: time_t,
    pub valid_sec: time_t,
    pub body_start: usize,
    pub fs_size: off_t,
    pub lock_time: ngx_msec_t,
}
impl ngx_http_file_cache_node_t {
    #[inline]
    pub fn count(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_count(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn uses(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_uses(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_msec(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_valid_msec(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn exists(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updating(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updating(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deleting(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deleting(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn purged(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_purged(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        count: ::aya_ebpf::cty::c_uint,
        uses: ::aya_ebpf::cty::c_uint,
        valid_msec: ::aya_ebpf::cty::c_uint,
        error: ::aya_ebpf::cty::c_uint,
        exists: ::aya_ebpf::cty::c_uint,
        updating: ::aya_ebpf::cty::c_uint,
        deleting: ::aya_ebpf::cty::c_uint,
        purged: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let count: u32 = unsafe { ::core::mem::transmute(count) };
            count as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let uses: u32 = unsafe { ::core::mem::transmute(uses) };
            uses as u64
        });
        __bindgen_bitfield_unit.set(32usize, 10u8, {
            let valid_msec: u32 = unsafe { ::core::mem::transmute(valid_msec) };
            valid_msec as u64
        });
        __bindgen_bitfield_unit.set(42usize, 10u8, {
            let error: u32 = unsafe { ::core::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let exists: u32 = unsafe { ::core::mem::transmute(exists) };
            exists as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let updating: u32 = unsafe { ::core::mem::transmute(updating) };
            updating as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let deleting: u32 = unsafe { ::core::mem::transmute(deleting) };
            deleting as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let purged: u32 = unsafe { ::core::mem::transmute(purged) };
            purged as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_cache_s {
    pub file: ngx_file_t,
    pub keys: ngx_array_t,
    pub crc32: u32,
    pub key: [u_char; 16usize],
    pub main: [u_char; 16usize],
    pub uniq: ngx_file_uniq_t,
    pub valid_sec: time_t,
    pub updating_sec: time_t,
    pub error_sec: time_t,
    pub last_modified: time_t,
    pub date: time_t,
    pub etag: ngx_str_t,
    pub vary: ngx_str_t,
    pub variant: [u_char; 16usize],
    pub buffer_size: usize,
    pub header_start: usize,
    pub body_start: usize,
    pub length: off_t,
    pub fs_size: off_t,
    pub min_uses: ngx_uint_t,
    pub error: ngx_uint_t,
    pub valid_msec: ngx_uint_t,
    pub vary_tag: ngx_uint_t,
    pub buf: *mut ngx_buf_t,
    pub file_cache: *mut ngx_http_file_cache_t,
    pub node: *mut ngx_http_file_cache_node_t,
    pub thread_task: *mut ngx_thread_task_t,
    pub lock_timeout: ngx_msec_t,
    pub lock_age: ngx_msec_t,
    pub lock_time: ngx_msec_t,
    pub wait_time: ngx_msec_t,
    pub wait_event: ngx_event_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl ngx_http_cache_s {
    #[inline]
    pub fn lock(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lock(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn waiting(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_waiting(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updated(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updated(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn updating(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_updating(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exists(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exists(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temp_file(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_temp_file(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn purged(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_purged(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reading(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reading(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secondary(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secondary(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_variant(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_variant(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn background(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_background(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stale_updating(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stale_updating(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stale_error(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stale_error(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lock: ::aya_ebpf::cty::c_uint,
        waiting: ::aya_ebpf::cty::c_uint,
        updated: ::aya_ebpf::cty::c_uint,
        updating: ::aya_ebpf::cty::c_uint,
        exists: ::aya_ebpf::cty::c_uint,
        temp_file: ::aya_ebpf::cty::c_uint,
        purged: ::aya_ebpf::cty::c_uint,
        reading: ::aya_ebpf::cty::c_uint,
        secondary: ::aya_ebpf::cty::c_uint,
        update_variant: ::aya_ebpf::cty::c_uint,
        background: ::aya_ebpf::cty::c_uint,
        stale_updating: ::aya_ebpf::cty::c_uint,
        stale_error: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lock: u32 = unsafe { ::core::mem::transmute(lock) };
            lock as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let waiting: u32 = unsafe { ::core::mem::transmute(waiting) };
            waiting as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let updated: u32 = unsafe { ::core::mem::transmute(updated) };
            updated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let updating: u32 = unsafe { ::core::mem::transmute(updating) };
            updating as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exists: u32 = unsafe { ::core::mem::transmute(exists) };
            exists as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let temp_file: u32 = unsafe { ::core::mem::transmute(temp_file) };
            temp_file as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let purged: u32 = unsafe { ::core::mem::transmute(purged) };
            purged as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reading: u32 = unsafe { ::core::mem::transmute(reading) };
            reading as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let secondary: u32 = unsafe { ::core::mem::transmute(secondary) };
            secondary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let update_variant: u32 = unsafe { ::core::mem::transmute(update_variant) };
            update_variant as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let background: u32 = unsafe { ::core::mem::transmute(background) };
            background as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let stale_updating: u32 = unsafe { ::core::mem::transmute(stale_updating) };
            stale_updating as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let stale_error: u32 = unsafe { ::core::mem::transmute(stale_error) };
            stale_error as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_header_t {
    pub version: ngx_uint_t,
    pub valid_sec: time_t,
    pub updating_sec: time_t,
    pub error_sec: time_t,
    pub last_modified: time_t,
    pub date: time_t,
    pub crc32: u32,
    pub valid_msec: u_short,
    pub header_start: u_short,
    pub body_start: u_short,
    pub etag_len: u_char,
    pub etag: [u_char; 128usize],
    pub vary_len: u_char,
    pub vary: [u_char; 128usize],
    pub variant: [u_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_sh_t {
    pub rbtree: ngx_rbtree_t,
    pub sentinel: ngx_rbtree_node_t,
    pub queue: ngx_queue_t,
    pub cold: ngx_atomic_t,
    pub loading: ngx_atomic_t,
    pub size: off_t,
    pub count: ngx_uint_t,
    pub watermark: ngx_uint_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_file_cache_s {
    pub sh: *mut ngx_http_file_cache_sh_t,
    pub shpool: *mut ngx_slab_pool_t,
    pub path: *mut ngx_path_t,
    pub min_free: off_t,
    pub max_size: off_t,
    pub bsize: usize,
    pub inactive: time_t,
    pub fail_time: time_t,
    pub files: ngx_uint_t,
    pub loader_files: ngx_uint_t,
    pub last: ngx_msec_t,
    pub loader_sleep: ngx_msec_t,
    pub loader_threshold: ngx_msec_t,
    pub manager_files: ngx_uint_t,
    pub manager_sleep: ngx_msec_t,
    pub manager_threshold: ngx_msec_t,
    pub shm_zone: *mut ngx_shm_zone_t,
    pub use_temp_path: ngx_uint_t,
}
extern "C" {
    pub fn ngx_http_file_cache_new(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_create(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_create_key(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_file_cache_open(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_set_header(r: *mut ngx_http_request_t, buf: *mut u_char) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_update(r: *mut ngx_http_request_t, tf: *mut ngx_temp_file_t);
}
extern "C" {
    pub fn ngx_http_file_cache_update_header(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_cache_send(arg1: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_file_cache_free(c: *mut ngx_http_cache_t, tf: *mut ngx_temp_file_t);
}
extern "C" {
    pub fn ngx_http_file_cache_valid(cache_valid: *mut ngx_array_t, status: ngx_uint_t) -> time_t;
}
extern "C" {
    pub fn ngx_http_file_cache_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_file_cache_valid_set_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub static mut ngx_http_cache_status: [ngx_str_t; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_main_conf_t {
    pub hash: ngx_hash_t,
    pub commands: ngx_hash_keys_arrays_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_ctx_t {
    pub buf: *mut ngx_buf_t,
    pub pos: *mut u_char,
    pub copy_start: *mut u_char,
    pub copy_end: *mut u_char,
    pub key: ngx_uint_t,
    pub command: ngx_str_t,
    pub params: ngx_array_t,
    pub param: *mut ngx_table_elt_t,
    pub params_array: [ngx_table_elt_t; 4usize],
    pub in_: *mut ngx_chain_t,
    pub out: *mut ngx_chain_t,
    pub last_out: *mut *mut ngx_chain_t,
    pub busy: *mut ngx_chain_t,
    pub free: *mut ngx_chain_t,
    pub state: ngx_uint_t,
    pub saved_state: ngx_uint_t,
    pub saved: usize,
    pub looked: usize,
    pub value_len: usize,
    pub variables: *mut ngx_list_t,
    pub blocks: *mut ngx_array_t,
    pub ncaptures: ngx_uint_t,
    pub captures: *mut ::aya_ebpf::cty::c_int,
    pub captures_data: *mut u_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub wait: *mut ngx_http_request_t,
    pub value_buf: *mut ::aya_ebpf::cty::c_void,
    pub timefmt: ngx_str_t,
    pub errmsg: ngx_str_t,
}
impl ngx_http_ssi_ctx_t {
    #[inline]
    pub fn shared(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conditional(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_conditional(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn encoding(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_encoding(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn output_chosen(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_output_chosen(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shared: ::aya_ebpf::cty::c_uint,
        conditional: ::aya_ebpf::cty::c_uint,
        encoding: ::aya_ebpf::cty::c_uint,
        block: ::aya_ebpf::cty::c_uint,
        output: ::aya_ebpf::cty::c_uint,
        output_chosen: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shared: u32 = unsafe { ::core::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let conditional: u32 = unsafe { ::core::mem::transmute(conditional) };
            conditional as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let encoding: u32 = unsafe { ::core::mem::transmute(encoding) };
            encoding as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let block: u32 = unsafe { ::core::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let output: u32 = unsafe { ::core::mem::transmute(output) };
            output as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let output_chosen: u32 = unsafe { ::core::mem::transmute(output_chosen) };
            output_chosen as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ngx_http_ssi_command_pt = ::core::option::Option<
    unsafe extern "C" fn(
        r: *mut ngx_http_request_t,
        ctx: *mut ngx_http_ssi_ctx_t,
        arg1: *mut *mut ngx_str_t,
    ) -> ngx_int_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_param_t {
    pub name: ngx_str_t,
    pub index: ngx_uint_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_ssi_param_t {
    #[inline]
    pub fn mandatory(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mandatory(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multiple(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multiple(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mandatory: ::aya_ebpf::cty::c_uint,
        multiple: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mandatory: u32 = unsafe { ::core::mem::transmute(mandatory) };
            mandatory as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let multiple: u32 = unsafe { ::core::mem::transmute(multiple) };
            multiple as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssi_command_t {
    pub name: ngx_str_t,
    pub handler: ngx_http_ssi_command_pt,
    pub params: *mut ngx_http_ssi_param_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl ngx_http_ssi_command_t {
    #[inline]
    pub fn conditional(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_conditional(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn block(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> ::aya_ebpf::cty::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: ::aya_ebpf::cty::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        conditional: ::aya_ebpf::cty::c_uint,
        block: ::aya_ebpf::cty::c_uint,
        flush: ::aya_ebpf::cty::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let conditional: u32 = unsafe { ::core::mem::transmute(conditional) };
            conditional as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let block: u32 = unsafe { ::core::mem::transmute(block) };
            block as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flush: u32 = unsafe { ::core::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut ngx_http_ssi_filter_module: ngx_module_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_ssl_srv_conf_t {
    pub enable: ngx_flag_t,
    pub ssl: ngx_ssl_t,
    pub prefer_server_ciphers: ngx_flag_t,
    pub early_data: ngx_flag_t,
    pub reject_handshake: ngx_flag_t,
    pub protocols: ngx_uint_t,
    pub verify: ngx_uint_t,
    pub verify_depth: ngx_uint_t,
    pub buffer_size: usize,
    pub builtin_session_cache: isize,
    pub session_timeout: time_t,
    pub certificates: *mut ngx_array_t,
    pub certificate_keys: *mut ngx_array_t,
    pub certificate_values: *mut ngx_array_t,
    pub certificate_key_values: *mut ngx_array_t,
    pub dhparam: ngx_str_t,
    pub ecdh_curve: ngx_str_t,
    pub client_certificate: ngx_str_t,
    pub trusted_certificate: ngx_str_t,
    pub crl: ngx_str_t,
    pub ciphers: ngx_str_t,
    pub passwords: *mut ngx_array_t,
    pub conf_commands: *mut ngx_array_t,
    pub shm_zone: *mut ngx_shm_zone_t,
    pub session_tickets: ngx_flag_t,
    pub session_ticket_keys: *mut ngx_array_t,
    #[doc = " KLNE 0028 SSL_CRL_OCSP\n\n 证书黑名单验证支持使用CRL OCSP方式"]
    pub crl_ocsp: ngx_uint_t,
    pub crl_ocsp_cache_zone: *mut ngx_shm_zone_t,
    pub crl_ocsp_responder: ngx_str_t,
    pub crl_ocsp_file: ngx_str_t,
    pub crl_ocsp_verify_response: ngx_flag_t,
    pub crl_ocsp_treat_unknown_status_as_revoked: ngx_flag_t,
    pub crl_ocsp_before_cache: ngx_flag_t,
    pub crl_ocsp_request_method: ngx_uint_t,
    pub crl_ocsp_response_probe_interval: ngx_msec_t,
    pub stapling: ngx_flag_t,
    pub stapling_verify: ngx_flag_t,
    pub stapling_file: ngx_str_t,
    pub stapling_responder: ngx_str_t,
    pub file: *mut u_char,
    pub line: ngx_uint_t,
    #[doc = " KLNE 0009 SSL_DUMP_HANDSHAKE_DATA\n\n 支持DUMP SSL握手数据"]
    pub dump_handshake_data: ngx_flag_t,
    #[doc = " KLNE 0011 SSL_MODE\n\n 支持自定义SSL MODE"]
    pub ssl_mode: ngx_uint_t,
    #[doc = " KLNE 0012 SSL_OPTIONS\n\n 支持自定义SSL OPTIONS"]
    pub ssl_options: ngx_uint_t,
    #[doc = " KLNE 0013 SSL_CIPHERS\n\n 支持指定SSL握手时允许客户端使用的签名算法列表"]
    pub client_sigalgs_list: ngx_str_t,
    #[doc = " KLNE 0013 SSL_CIPHERS\n\n 支持指定SSL握手时服务端使用的签名算法列表"]
    pub server_sigalgs_list: ngx_str_t,
    #[doc = " KLNE 0014 SSL_VERIFY_CLIENT\n\n 增强ssl_verify_client功能: 支持仅本地证书链/未提交证书时断开连接/忽略证书有效期/握手失败时断开连接"]
    pub verify_with_local_cert_chain: ngx_flag_t,
    pub verify_with_close_if_nocert: ngx_flag_t,
    pub verify_with_close_if_verify_failed: ngx_flag_t,
    pub verify_with_ignore_cert_validity: ngx_flag_t,
    pub verify_with_ignore_cert_validity_tolerance_secs: time_t,
    #[doc = " KLNE 0017 SSL_CLIENT_CERTIFICATE_ENCODING\n\n 支持指定客户端证书字符编码"]
    pub client_certificate_encoding: ngx_uint_t,
    #[doc = " KLNE 0023 SSL_CRL_CACHE\n\n 证书黑名单验证支持使用CRL CACHE方式"]
    pub crl_cache: ngx_flag_t,
    pub crl_zone: *mut ngx_shm_zone_t,
    pub crl_cache_file: ngx_str_t,
    pub crl_cache_max_entry: u_long,
    #[doc = " KLNE 0031 SSL_GMVPN_SPEEDUP_BY_PRECOMPUTE_MULT\n\n 支持通过EC_KEY_precompute_mult加速GMVPN"]
    pub gmvpn_speedup_by_precompute_mult: ngx_flag_t,
    #[doc = " KLNE 0032 SSL_DEFER_CHECK_IF_CLIENT_NOCERT\n\n 双向验证客户端未提交证书且后端无法连接时支持向前端返回502响应"]
    pub defer_check_if_client_nocert: ngx_flag_t,
    #[doc = " KLNE 0051 SSL_SESSION_TICKET_SET_SID_CTX\n\n 支持配置session_ticket中的sid_ctx"]
    pub session_ticket_sid: ngx_str_t,
    #[doc = " KLNE 0052 SSL_SESSION_TICKET_SET_SESSION_ID\n\n 支持配置在tls1.3协议下session_ticket中的session_id是否\n 与之前的session_id保持一致"]
    pub session_ticket_keep_session_id: ngx_flag_t,
    #[doc = "  KLNE 0057 ASYNC_SSL\n\n  支持异步SSL"]
    pub enable_asynch: ngx_flag_t,
    #[doc = " KLNE 0070 SSL_SECURITY_LEVEL\n\n SSL安全等级可配置，以支持MD5签名的证书"]
    pub security_level: ngx_uint_t,
    #[doc = " KLNE 0072 LOG_SSL_HANDSHAKE_FAILURES\n\n 支持记录各类握手失败的访问日志"]
    pub handshake_failed_access_log: ngx_flag_t,
    #[doc = " KLNE 0075 SSL_STAPLING_REQUEST_METHOD\n\n SSL STAPLING支持指定OCSP请求方法"]
    pub stapling_request_method: ngx_uint_t,
    #[doc = " KLNE 0077 SSL_SPA\n\n 支持简单认证服务SPA"]
    pub spa: ngx_flag_t,
    pub spa_key_file: ngx_str_t,
    #[doc = " KLNE 0078 CLIENT_HELLO_CUSTOM_EXTENSION\n\n 支持注册ClientHello自定义扩展项"]
    pub client_hello_custom_exts: *mut ngx_array_t,
}
extern "C" {
    pub static mut ngx_http_ssl_module: ngx_module_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_log_ctx_s {
    pub connection: *mut ngx_connection_t,
    pub request: *mut ngx_http_request_t,
    pub current_request: *mut ngx_http_request_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_chunked_s {
    pub state: ngx_uint_t,
    pub size: off_t,
    pub length: off_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngx_http_status_t {
    pub http_version: ngx_uint_t,
    pub code: ngx_uint_t,
    pub count: ngx_uint_t,
    pub start: *mut u_char,
    pub end: *mut u_char,
}
extern "C" {
    pub fn ngx_http_add_location(
        cf: *mut ngx_conf_t,
        locations: *mut *mut ngx_queue_t,
        clcf: *mut ngx_http_core_loc_conf_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_add_listen(
        cf: *mut ngx_conf_t,
        cscf: *mut ngx_http_core_srv_conf_t,
        lsopt: *mut ngx_http_listen_opt_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_init_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_close_connection(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_ssl_servername(
        ssl_conn: *mut SSL,
        ad: *mut ::aya_ebpf::cty::c_int,
        arg: *mut ::aya_ebpf::cty::c_void,
    ) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ngx_http_ssl_certificate(ssl_conn: *mut SSL, arg: *mut ::aya_ebpf::cty::c_void) -> ::aya_ebpf::cty::c_int;
}
extern "C" {
    pub fn ngx_http_parse_request_line(r: *mut ngx_http_request_t, b: *mut ngx_buf_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_uri(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_complex_uri(r: *mut ngx_http_request_t, merge_slashes: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_status_line(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        status: *mut ngx_http_status_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_unsafe_uri(
        r: *mut ngx_http_request_t,
        uri: *mut ngx_str_t,
        args: *mut ngx_str_t,
        flags: *mut ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_header_line(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        allow_underscores: ngx_uint_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_multi_header_lines(
        headers: *mut ngx_array_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_parse_set_cookie_lines(
        headers: *mut ngx_array_t,
        name: *mut ngx_str_t,
        value: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_arg(r: *mut ngx_http_request_t, name: *mut u_char, len: usize, value: *mut ngx_str_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_split_args(r: *mut ngx_http_request_t, uri: *mut ngx_str_t, args: *mut ngx_str_t);
}
extern "C" {
    pub fn ngx_http_parse_chunked(
        r: *mut ngx_http_request_t,
        b: *mut ngx_buf_t,
        ctx: *mut ngx_http_chunked_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_create_request(c: *mut ngx_connection_t) -> *mut ngx_http_request_t;
}
extern "C" {
    pub fn ngx_http_process_request_uri(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_process_request_header(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_process_request(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_update_location_config(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_run_posted_requests(c: *mut ngx_connection_t);
}
extern "C" {
    pub fn ngx_http_post_request(r: *mut ngx_http_request_t, pr: *mut ngx_http_posted_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_finalize_request(r: *mut ngx_http_request_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_free_request(r: *mut ngx_http_request_t, rc: ngx_int_t);
}
extern "C" {
    pub fn ngx_http_empty_handler(wev: *mut ngx_event_t);
}
extern "C" {
    pub fn ngx_http_request_empty_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_send_special(r: *mut ngx_http_request_t, flags: ngx_uint_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_read_client_request_body(
        r: *mut ngx_http_request_t,
        post_handler: ngx_http_client_body_handler_pt,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_read_unbuffered_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_send_header(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_special_response_handler(r: *mut ngx_http_request_t, error: ngx_int_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_filter_finalize_request(
        r: *mut ngx_http_request_t,
        m: *mut ngx_module_t,
        error: ngx_int_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_clean_header(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_discard_request_body(r: *mut ngx_http_request_t) -> ngx_int_t;
}
extern "C" {
    pub fn ngx_http_discarded_request_body_handler(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_block_reading(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_test_reading(r: *mut ngx_http_request_t);
}
extern "C" {
    pub fn ngx_http_types_slot(
        cf: *mut ngx_conf_t,
        cmd: *mut ngx_command_t,
        conf: *mut ::aya_ebpf::cty::c_void,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_merge_types(
        cf: *mut ngx_conf_t,
        keys: *mut *mut ngx_array_t,
        types_hash: *mut ngx_hash_t,
        prev_keys: *mut *mut ngx_array_t,
        prev_types_hash: *mut ngx_hash_t,
        default_types: *mut ngx_str_t,
    ) -> *mut ::aya_ebpf::cty::c_char;
}
extern "C" {
    pub fn ngx_http_set_default_types(
        cf: *mut ngx_conf_t,
        types: *mut *mut ngx_array_t,
        default_type: *mut ngx_str_t,
    ) -> ngx_int_t;
}
extern "C" {
    pub static mut ngx_http_module: ngx_module_t;
}
extern "C" {
    pub static mut ngx_http_html_default_types: [ngx_str_t; 0usize];
}
extern "C" {
    pub static mut ngx_http_top_header_filter: ngx_http_output_header_filter_pt;
}
extern "C" {
    pub static mut ngx_http_top_body_filter: ngx_http_output_body_filter_pt;
}
extern "C" {
    pub static mut ngx_http_top_request_body_filter: ngx_http_request_body_filter_pt;
}
pub const NGX_RS_HTTP_MAIN_CONF_OFFSET: usize = 0;
pub const NGX_RS_HTTP_SRV_CONF_OFFSET: usize = 8;
pub const NGX_RS_HTTP_LOC_CONF_OFFSET: usize = 16;
pub const NGX_RS_MODULE_SIGNATURE: &[u8; 41] = b"8,4,8,0011111111010111001111111111111111\0";
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::aya_ebpf::cty::c_uint,
    pub fp_offset: ::aya_ebpf::cty::c_uint,
    pub overflow_arg_area: *mut ::aya_ebpf::cty::c_void,
    pub reg_save_area: *mut ::aya_ebpf::cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_at {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ax25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_dl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_eon {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_inarp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ipx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_iso {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ns {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_x25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct link_map {
    pub _address: u8,
}
